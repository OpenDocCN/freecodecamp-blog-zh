# 严苛、自由或保姆状态:Java、C#、C、C++、Go 和 Rust 中的并发意识形态

> 原文：<https://www.freecodecamp.org/news/concurrency-ideologies-of-programming-languages-java-c-c-c-go-and-rust-bd4671d943f/>

### 为什么我们需要并发

曾经，有一段美好的时光，时钟速度每 18 个月翻一番。这种现象被称为摩尔定律。如果一个程序员的程序不够快，他们可以等待，很快计算机就会赶上来。

这太好了，不能持久，但事实并非如此。CPU 设计者仍然通过给计算机增加更多的核心来跟上摩尔定律。

这给程序员带来了一个问题。在新的世界中，我们的程序每 18 个月将运行两倍的速度，但前提是它是一个使用更多内核的并行程序。

因此，对于程序员来说，在并行环境中编写代码的能力是一项关键技能。这篇文章探讨了不同的编程语言如何支持并行和并发程序。

### 经典并发原语

几乎所有的操作系统都支持多线程执行。然而，并发程序员需要帮助来解决另外两个问题。

*   共享数据—如果并发访问共享数据，可能会产生意外的结果。
*   线程间的信号传递——一些用例需要程序员控制线程的执行顺序。其他的例子是希望线程在某一点等待，等待另一个线程，以特定的顺序运行，永远不要超过另一个线程，并且在临界区域中不超过 N 个线程。

编程语言提供不同的原语来帮助程序员控制上述情况。让我们来看看那些经典的原始人:

1.  锁(也称为互斥)——确保在代码的选定区域中只执行一个线程
2.  监视器——它们做同样的事情，但是比锁好一点，因为它们强迫你开锁
3.  (计数)信号量——强大的抽象，可以支持广泛的协调场景
4.  等待并通知—做同样的事情，但是比信号量弱。程序员必须在等待之前处理错过的通知触发器
5.  条件变量——当给定的条件发生时，让线程休眠和唤醒
6.  有条件等待的通道和缓冲区—如果没有要接收的线程，则侦听并收集消息(有可选的有界缓冲区)
7.  非阻塞数据结构(比如非阻塞队列、原子计数器)——这些是聪明的数据结构，允许许多线程访问，而不使用锁或最少量的锁。

这些原语在它们的功能上有所重叠。任何编程语言都可以通过少量的代码获得并发的全部能力。例如，锁和信号量可以处理你能想到的所有并发用例。

### 原语的语言支持

选择并发原语不仅仅是因为它的能力。不同的原语有不同的编程模型。这需要用不同的方式来思考这个问题。不同的编程语言选择了与它们的语言模型最匹配的不同子集。选择取决于设计者的品味以及语言的哲学。

让我们探索其中的几个选择。

#### Java 和 C#

Java 和 C#都选择了完全不选。两者都支持所有原语。

Java 最初只支持监视器( **synchronized** 关键字)和等待通知。跨线程发送信号简直是一场噩梦。我记得我花了几个小时在“错过的信号”上，但仍然出错。

很快，Java 设计者意识到了他们的错误。他们添加了一个并发包，其中包含了包括非阻塞数据结构在内的所有东西。

唯一不受纯形式支持的原语是通道和缓冲区。然而，如果你想要它们，用队列和缓冲区来模仿通道是很容易的。尽管您的实现在性能上永远比不上 Go 或 Erlang。

C#，来晚了，从 Java 学的。它几乎什么都有。C#也有一些 Java 没有的高级助手构造。这解决了障碍等常见问题。有关更多详细信息，请查看 [C#线程包](https://msdn.microsoft.com/en-us/library/system.threading%28v=vs.110%29.aspx)。

### C 和 C++

c 最初依靠操作系统调用来执行多线程。那时代码是不可移植的。相反，第三方并发库提供了这一功能。不幸的是，由于这种语言没有限制 API，所以有很多可用的库。

由于 C 和 C++是最接近操作系统的语言，前沿线程研究通常是用这两种语言完成的。例如，快速搜索显示了 [22 个 C++并发库](https://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries)和 [6 个 C 并发库](https://stackoverflow.com/questions/5613646/threading-in-c-cross-platform)。不缺动力。

这些库提供了广泛的前沿技术。然而，由于 API 的多样性，没有多少程序员像他那样精通一个给定的 API。

### 占线小时

Erlang 是为并发性而从头开始设计的。Erlang 将线程间交互的完全控制权交给了程序员。程序员通过消息传递进行所有的交流。这就是 Erlang 在多核电脑上传奇性能的来源。

然而，这是要付出代价的。Erlang 不支持线程间共享状态。这不是错误。共享状态触发线程间的同步，这将不受程序员的直接控制。这种同步通常会降低性能。

因此，Erlang 编程体验对于大多数程序员来说是陌生的。它的全功能性质也没有帮助。

Erlang 中的主要并发结构是通道。它内置了缓冲区和对条件等待的支持。例如，您可以要求通道等待，直到它接收到满足给定条件的消息。每个进程都有一个通道，它只能从该通道接收数据。

实际上，由于 Erlang 是一种函数式编程语言，所以很少需要共享内存锁。不幸的是，这样的用例是存在的。由于 Erlang 没有共享内存，所以不能锁定某些东西。但是，您可以创建一个进程来表示锁。您通过向锁发送消息来获取和释放锁，就像在分布式系统中一样。

除非您是编程语言专家，非常了解函数式编程，否则生成的程序通常会很复杂，很难调试。通过选择 Erlang，程序员权衡了并发支持和熟悉程度。

如果您想了解更多，请阅读这些文章:[Erlang for Concurrent Programming](https://queue.acm.org/detail.cfm?id=1454463)和[The hickhelper ' s Guide to Concurrency](http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency)。

### 去

围棋很像二郎。其主要的并发模式是通过通道和缓冲区，并支持条件等待。它对于并发的核心理念是:[不要通过共享内存进行通信；而是通过通信](https://golang.org/doc/effective_go.html#sharing)共享内存。

然而，有一个根本的区别。Go 相信你会做正确的事情。Go 让你可以在线程间共享数据，并且支持[互斥](https://gobyexample.com/mutexes)和[信号量](https://github.com/golang/sync/blob/master/semaphore/semaphore.go)。此外，他们放宽了 Erlang 限制，即每个通道被永久分配给一个线程。你可以创建一个渠道，并传递它。

综上所述，Go 希望我们像 Erlang 一样进行并发编程。然而，尽管 Erlang 强制执行，但 Go 相信您会做正确的事情。如果说 Erlang 是严苛的，那么 Go 就是自由的状态。

### 锈

Rust 也很像 Erlang 和 Go。它使用具有缓冲区和条件等待的通道进行通信。就像 Go 一样，它放宽了 Erlang [的限制，允许您共享内存](https://doc.rust-lang.org/book/second-edition/ch16-03-shared-state.html)，支持原子引用计数和锁，允许您在线程间传递通道。

然而，Rust 更进一步。虽然 Go 相信你会做正确的事情，但 Rust 会指派一名导师陪你坐在一起，如果你试图做错事，他会抱怨。Rust 的导师是编译器。它进行复杂的分析，以确定在线程间传递的值的所有权，并在存在潜在问题时提供编译错误。

以下是 Rust docs 中的一段引文。

> 所有权规则在消息发送中起着至关重要的作用，因为它们帮助我们编写安全的并发代码。防止并发编程中的错误是我们通过权衡必须在整个 Rust 程序中考虑所有权而获得的优势。— [使用值](https://doc.rust-lang.org/book/second-edition/ch16-02-message-passing.html)的所有权传递消息。

如果说 Erlang 是严厉的，Go 是自由的状态，那么 Rust 就是保姆状态。

调试并发程序是一场噩梦。在糟糕的一天，可能需要几天。所以我很欣赏 Rust 试图通过编译器级分析所做的事情。

但是，如果你对并发没有经验，试图写一个并发的 Rust 程序，会让你很烦。无论你做什么，它都会用隐晦的语言抱怨并发性。当你改变的时候，它会说别的，然后再说。在您详细了解并发性之前，这并不容易。

相比之下，围棋给程序员提供了虚假的安全感，他们认为自己的任务已经完成，这种想法往往是错误的。他们以后可能会为此付出代价。然而，只有当代码进入生产阶段，用户遇到这个场景，并且错误被发现时，他们才会付钱。这是一大堆的“如果”。虽然这不公平，但程序员可能会侥幸逃脱。无论如何，人类并不擅长延迟满足和 T2 的长远眼光。所以程序员通常更喜欢检查 Rust。

Rust 试图提供帮助，但很少有人会感激这种帮助。没有人喜欢保姆国家。

> Rust 没有得到应有的普及，因为太多目光短浅的开发人员对 Rust 的严格感到恼火，而不是欣赏他们从这种严格中获得的巨大力量。“—[rjc 2013](https://www.reddit.com/r/rust/comments/8x1myq/concurrency_ideologies_of_programming_languages/e21xwqy/)

更多信息，请阅读[Rust 中的并发原语与 Go](https://news.ycombinator.com/item?id=7851274.) 中的并发原语相比如何？

### 结论

当谈到并发意识形态时，编程语言会给你一个选择:自由状态(Go)、严格状态(Erlang)或保姆状态(Rust)。

如果你想了解更多，我推荐两个资源。

首先，读一下[信号量小书](http://greenteapress.com/wp/semaphores/)，里面教你关于锁和信号量的一切。

第二，如果你想了解通道和 Erlang 模型，[请查看 MPI](http://mpitutorial.com/) 。你可能会认为 MPI 是一种死语言。它不是。迄今为止，大多数科学模拟都是使用 MPI 完成的。天气是用它预测的，交通工具是用它设计的，药物是用它发现的。使用 MPI，科学真的进步了。MPI 以我们无法想象的方式使用并发。为了体验它，请查看 [MPI 通信原语](http://www.mathcs.emory.edu/~cheung/Courses/355/Syllabus/92-MPI/group-comm.html)。

如果你遵循以上两个建议，你将会对复杂性和并发性的可能性有所了解。这是一个需要一生去掌握的话题。

我希望这篇文章是有用的。我一边研究这些语言，一边思考芭蕾舞演员的并发模型。Ballerina 是一种新的编程语言，专为分布式环境编写微服务和集成 API 而设计。它包括新的并发特性，比如自适应锁定。它分析代码并试图尽可能短时间地保持锁定。请访问 [https://ballerina.io.](https://ballerina.io.) 查看