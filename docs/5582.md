# 订购外卖:如何吃一块可怕的巨石

> 原文：<https://www.freecodecamp.org/news/ordering-take-out-how-to-eat-a-scary-monolith-805e471a613f/>

艾伦·里德霍弗

# 订购外卖:如何吃一块可怕的巨石

![ZNMnkrUgDk5amTOEnsfejUd6N6N12FihIr0u](img/3aa74c047f3e83b5fae2898140a03aa8.png)

马丁·福勒[说](https://www.martinfowler.com/bliki/MonolithFirst.html):

> 几乎所有成功的微服务故事都始于一个变得太大而破碎的整体。

你可以把我们的故事添加到列表中。

我和我的团队刚刚建立了一个新的消息服务。它取代了我们主要应用程序中老化的子系统。我们根据现实生活中的概念来设计新的服务。这极大地简化了数据模型，释放了在旧数据模型中难以构建的新特性。

一路上，我们学到了一些东西，希望与大家分享…

![MaXabuxVfnzuqOetILf5NhS1fmlts8AbyCLo](img/e94a4a06d87c08dd7870e52b4248f889.png)

### 我们最坏、最悲观的估计也过于乐观了

我们对完成这项工程所需时间最保守的猜测是三个月。花了 10 分钟。

公平地说，我们估计整个团队需要三个月的时间来完成这项工作。但是，实际上，我们同时接手了几个项目。我们继续对遗留子系统进行维护，甚至增加了新的功能。因此，考虑到不到一半的资源，最初的估计应该更长。

也就是说，我们确实低估了这项工作。我们低估了将子系统从整体中分离出来的工作。我们开始搜索子系统所拥有的类的引用。我们最终看到了引用底层数据库表的 SQL 查询。这就是子系统与应用程序其余部分的紧密耦合程度。

**经验教训:**注意*所有的*整合点。可能比你想象的要多。

![jcZnblemwjZBQ2trF9dpJWd5haPFYbphLrow](img/f599b3bf633a1d3bd78ae3846f3c5db9.png)

### 围绕整体结构中的子系统建立一条护城河

在*域驱动设计中，* Eric Evans 描述了一种称为反腐败层的模式。这一层是两个子系统之间的一堵墙。两个子系统都不直接与对方对话。他们都对着墙说话。遵循这种模式可以防止子系统之间的冲突。

对我们来说，其他子系统已经转移到我们的。我们需要一种方法在不修改其功能的情况下断开它们的连接。我们从反腐败层寻找灵感。

我们的解决方案:我们在整体结构中的子系统周围包裹了一个外观层。这在子系统周围设置了一条护城河，防止除了通过定义的接口之外的访问。它还允许我们集成测试对外观的调用。即使在切换到新的服务之后，我们也始终保持着那些测试的通过。

如上所述，这是提取服务最困难的部分。将原始 SQL 查询的一半放在外观后面是一项艰巨的工作:

首先，您必须理解整个查询，其中一些长达数百行。接下来，提取访问旧子系统的查询片段。然后，将它们转换成新的数据模型。您可以扩展新服务来支持这个新查询。最后，将结果与原始 SQL 查询的剩余部分集成在一起。如果你做得对，调用代码永远不会知道区别。

**经验教训:**构建应用程序时，保持界限很重要。封装很重要。这一点在巨石之外是显而易见的。但是，更重要的是*内部的*那块巨石。这是保持系统灵活性的唯一方法，这样你就可以通过重构为新特性腾出空间。

![rAlpgJ4-e13zDCzGJAFxfRsqwjneOWivEEuN](img/306da7c325e74eb864a074a010251da2.png)

### 并行运行两个系统

我们并行运行了两个系统几个月，同时努力实现功能对等。我们可以这样做，因为我们创造了上面提到的外观。我们通过遗留子系统和新服务向外观发送请求。比较结果使我们能够发现(并修复)数据的不一致性。它还给我们提供了一个针对实际生产数据的真实压力测试。

吸取的教训:我们用这种方法发现了大部分的 bug。生产工作负载无可替代。我们承认这增加了开发成本。但是，在我们将系统投入生产之前找到漏洞是值得的。

![oBKskiY3Cni6yDQfCtAj50HcvrzKg7riCrdz](img/392070b496a0210ad304648a0d569527.png)

### 使用功能标志来展示卷展栏

功能标志是一个布尔值，它在开启时启用某个功能，在关闭时禁用该功能。典型的功能标志系统允许您为用户子集打开标志。这允许您逐步推出功能，而不是一次全部推出。

我们的实现使用了四个独立的标志:

*   一个标志控制是否写入新系统。这使得我们可以并行运行这些系统。我们在过程的早期就打开了这个标志，给我们带来了上面描述的好处。
*   另一个标志控制是否从新服务中读取数据。这样，我们可以在全局启用之前测试功能。
*   最后两个标志控制哪个系统可以访问我们的第三方电子邮件提供商。一个标志关闭了遗留子系统。另一个打开了新服务。我们将这些标志分开，以便在出现重大问题时可以同时关闭两个系统。(我们最终没有实现这个功能。但是我们仍然很高兴我们建造了它。)

最后，使用特性标志允许我们一次向一个客户推出新服务。这降低了风险，防止了对业务的不当干扰。

**经验教训:**使用单独的特性标志来读写服务。这允许您开始与遗留系统并行运行服务。在我们的例子中，添加额外的标志来防止重复的电子邮件被发送是至关重要的。

![z5ciHTnv-lW9AORCgzx9pdiHcubvX9EAsiNV](img/8b66048699f56d05f10c8bd6eb54c825.png)

### 尽早添加日志记录、异常处理和监控

我们在新服务中构建的第一个东西是一个记录器。接下来，我们添加了异常处理。这在调试系统时变得至关重要。我们发现它在跨越服务边界时特别有用。

我们后来添加了监控，为我们的数据导入过程提供了一个窗口。添加它很容易，因为我们的集中记录器。

**经验教训:**集中日志记录和异常处理，并尽早构建。你以后会感谢自己的。

![HZWJyhA6TsmtkdSHRcIoVRO6vnzzIxSLwG6V](img/f5cd48081efee6a32a28d5802fc6dd91.png)

### 预计迁移数据时会出现问题

我们决定将我们的数据移植到新的服务中，这样就会有一个记录系统。我们通过向新服务发送消息来做到这一点，从而在高负载下测试接口。

绝大多数数据都正确迁移了。但是有许多有效的边缘案例。每次我们找出一个边缘案例，我们都会调整迁移并再次运行它。

最终，我们有大约 700 条记录(总共 120 万条)无法解释。绝大多数是几岁的孩子。这些数据不符合我们已经确定并解决的任何一个关键案例。在花了几天时间之后，我们决定将记录标记为“失败”,然后继续前进。

**吸取的教训:**生产数据草率。大部分看起来都是正确的。有些人不会。数据越旧，迁移就越困难。记录将会丢失。外键将不存在。随它去吧。尽可能做出最好、最方便用户的决定。

![4etUQXX-ktD33z-PoW3dgJgYmjwibMCn2ZAP](img/4fddd86b3f5b6db2e08c4c59d769fe35.png)

### 使用确定性 UUIDs 和幂等迁移

当您有两个不同的系统并行运行时，您需要一个共享的 id 空间。任何 UUID 都可以。但是我们选择使用确定性 UUIDs 来支持幂等迁移。为了生成确定性的 UUID，需要提供一个名称空间和一些唯一的属性。给定相同的数据，算法总是产生相同的 UUID。

在我们的例子中，主应用程序中的外观生成确定性的 UUIDs。然后，它将 UUID 发送给服务进行存储。在服务内部，我们对该字段进行了索引以防止重复。这使得幂等性成为可能。

**经验教训:**您的生产数据将无法预测。当您解决棘手问题时，您需要一遍又一遍地运行您的迁移。使用确定性 UUIDs 使这成为可能。

![RaN-4SHUcVD7X8ohmabLvlA933hVU6J6mBvB](img/5cd726c0c42c54c5b9b489c4bb28e9e0.png)

### 使用队列

引入新服务意味着引入另一个故障点。我们希望保护自己免受小规模服务中断的影响。因此，我们决定通过队列与服务进行通信。通过使用一个健壮的队列，我们实现了一定程度的容错，以防服务中断。我们还选择了一个 FIFO 队列来保证操作的顺序。这可以防止在创建之前或删除之后进行更新。这也让我们能够通过横向扩展来加快数据导入过程。

**经验教训:**使用健壮的队列有几个好处。容错让你安心。此外，横向扩展使您能够跟上需求。

![3PnX0cTLctAh7DBHQoyxPycmOExnNxZga7zq](img/cc6a7f2b6c0e9d01d07aca77b91a73ec.png)

### 使用断路器

通过队列异步读取数据要求调用者理解异步回调。当然，JavaScript 在这方面非常擅长。但是，露比不是。在这种情况下，是 monolith 通过队列调用服务。

考虑来自前端的获取一些数据的请求。monolith 将接收该请求，并将一条消息和一个相关 id 放在一个队列中。然后，服务将使用结果和相同的相关 id 进行回复(在不同的队列上)。但是，处理响应的工作者没有请求的句柄。因此，现在您需要将数据推送到前端(很可能使用套接字)。

换句话说，我们将不得不重写我们的前端来通过套接字接收数据。不幸的是，我们没有时间来重建我们的应用程序的前端，以这种方式工作。因此，我们选择使用 HTTP 进行读取操作。这种方法一直很有效，直到它失效。

在测试过程中，部署过程中的一个错误导致新服务停止运行。这使得 monolith 无法加载到我们的暂存环境中。为什么？因为当我们加载第一个页面时，我们正在从服务中引导数据。由于服务中断，所有请求都超时了。解决方案是使用断路器模式。

断路器将呼叫打包到外部服务。如果调用成功，什么也不会发生。但是，如果由于某些异常(如超时或服务器错误)呼叫失败，断路器就会跳闸。跳闸时，断路器不会呼叫服务。相反，它在冷却期间返回硬编码的返回值，如“nil”或“[]”或“{}”。一旦冷却期满，断路器开始再次调用服务。如果恢复了，太好了！否则，断路器会再次跳闸。

**经验教训:**如果您必须使用 HTTP，请保护更广泛的系统免受服务中断的影响。断路器是做到这一点的一种机制。

![mTAX0RC7RdFhjIeyJmJoAROtssQliybEWTll](img/77569690556aae35d38869eff277987a.png)

### 高管赞助

长期项目的成功往往归结于管理层的支持。我们很幸运，我们的产品副总裁和工程副总裁都支持我们的计划。他们非常信任我们。当这个项目看起来比我们计划的要大时，他们支持我们。没有他们的支持，我们不可能完成我们的工作。

为什么我们的执行赞助商愿意为我们出头？几个原因。但最重要的一点是，我们在与他们的沟通中是开放和诚实的。他们知道项目在哪里，也知道我们需要做什么。

经验教训:当着手一个长期、高风险的项目时，确保你得到了领导的支持。确保他们了解好处和风险。并且，不断沟通。它能建立信任，这是你成功所需要的。

### 我们会有哪些不同的做法？

我们认为在提出这个项目之前，我们已经做了尽职调查。我们找到了子系统中使用的模型的所有参考资料。但是我们没有在原始 SQL 语句中搜索对底层表名的直接引用。那是一个疏忽。我们下次一定会这样做。

如果我们能回到过去，我们会将旧的子系统*隔离在*整体中。封装子系统将简化提取过程。事实上，它甚至可能使它变得不必要，因为我们本来可以就地重构。

### 那么，我们会再做一次吗？

毫无疑问，这是一次长途旅行。由于一些真正史诗般的耦合，将我们的子系统从整体中解救出来比我们预测的更困难。我们出于需要做了解耦工作。它不是令人愉快的。这感觉像是一件苦差事。

但是，使用新服务是一个梦想。代码分解得非常好。我们有超高的测试覆盖率。此外，我们已经定义好了与特定用例相对应的领域逻辑。因此，我们可以通过查看单个类来判断应用程序做了什么。这意味着扩展服务就像添加另一个域类并对其进行测试一样简单。

但是，我们会再做一次吗？

作为工程师？我们一定会再做一次。该项目大大提高了开发人员的生产力和幸福感。仅从工作满意度来看，这种交换对我们来说是值得的。事实上，我们已经看到了提取一些小型服务的机会。

作为一个组织？我们对取得的成绩非常满意。客户很高兴我们推出了之前无法推出的长期需求功能。管理层很高兴没有出现生产问题。而且，团队很高兴能摆脱巨石柱。

也就是说，在我们所处的阶段，这个项目是一项重大投资。我们需要看到强劲的回报，然后再大规模押注于服务提取。

这篇文章的一个版本最初发表在我们关于招聘行业工程学的博客 [SourceCode](https://sourcecode.entelo.com/) 上。

我要感谢[菲托·冯·扎斯特罗](https://www.freecodecamp.org/news/ordering-take-out-how-to-eat-a-scary-monolith-805e471a613f/undefined)、[杰森·罗森戴尔](https://www.freecodecamp.org/news/ordering-take-out-how-to-eat-a-scary-monolith-805e471a613f/undefined)、[瑞安·A·布斯](https://www.freecodecamp.org/news/ordering-take-out-how-to-eat-a-scary-monolith-805e471a613f/undefined)和[科尔·格平格尔](https://www.freecodecamp.org/news/ordering-take-out-how-to-eat-a-scary-monolith-805e471a613f/undefined)，他们都对本文做出了宝贵的贡献。

谢谢你！你读到这里就获奖了。向我推荐这篇文章，我会给你一张免费的贴纸！