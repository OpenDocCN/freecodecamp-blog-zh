# 用 Python 学习面向对象编程

> 原文：<https://www.freecodecamp.org/news/learn-object-oriented-programming-with-python/>

面向对象编程是软件开发中的一个重要概念。

面向对象编程(OOP)是一种依赖于类和对象概念的编程范式。您可以使用这种方法在许多编程语言中编写程序，包括 Python

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个完整的 Python 面向对象编程课程。

JimShapedCoding 的 Jim 开发了这个课程。吉姆创造了许多受欢迎的课程，是一个伟大的老师。

在这个完整的教程中，你将会学到关于 OOP 的所有知识，以及如何使用 Python 来实现它。

以下是本课程涵盖的部分:

*   课程入门
*   构造函数，__init__
*   类与静态方法
*   遗产
*   Getters 和 Setters
*   OOP 原则

观看以下全部课程或在 freeCodeCamp.org YouTube 频道观看(2 小时观看)。

[https://www.youtube.com/embed/Ej_02ICOIgs?feature=oembed](https://www.youtube.com/embed/Ej_02ICOIgs?feature=oembed)

## 副本

(自动生成)

对于软件开发人员来说，理解面向对象编程是很重要的。

在本课程中，来自 JimShapeCoding 的 Jim 将教你所有关于面向对象编程和 Python 面向对象编程的知识，它可能是阻碍你成为一名伟大的 Python 开发人员的因素。

除了借出你作为软件工程师的第一份工作之外，欢迎大家参加 Python 面向对象编程课程。

现在，如果你在过去努力理解面向对象编程的概念，那么你完全没问题。

你会得到很好的照顾。

因为在这门课中，我要确保这将是你们最后一次看关于类和面向对象编程的复杂概念的教程。

我们将通过开发一个真正的 Python 应用程序来做到这一点，这个应用程序写起来会非常酷。

我们会一步一步增加它的复杂性。

在整个过程中，我们将理解我们需要知道的关于面向对象编程的一切。

这门课会有一些要求，我希望每个人至少了解函数，变量，if 语句，以及 for 循环。

如果你知道其他编程语言中的这些东西，那么这也很好。

话虽如此，我们还是开始吧。

现在为了解释为什么你应该写面向对象的程序，我将解释基于一个商店管理系统的概念，我们将开始一起开发这个系统。

因此，开始考虑如何解决这样的问题时，我们可以首先考虑跟踪我们商店中现有的商品。

因此，我们可以开始的一个方法是，我们可以创建这四个变量来开始跟踪我们的项目。

如你所见，我们有了第一个变量，等于 phone。

然后我们有三个以上的变量，故意以第一项的前缀开始，这样我们可以通过遵循正确的命名约定来描述这四个变量之间的关系。

现在，你可能会认为这四个变量之所以相互关联，只是因为它们使用了与第一项相同的前缀。

对于 Python 来说，这只是四个不同数据类型的变量。

因此，如果我们要打印这四个变量的类型，现在，我们将毫无意外地收到它们的类型，对，我们将收到价格、数量和总价的字符串和整数。

现在我想把重点放在这些具体的输出上，因为正如你所看到的，对于每一种类型，我们还看到了关键字 class。

这意味着这些数据类型实际上是字符串或整数的实例。

所以在 Python 编程语言中，每种数据类型都是某个类先前实例化的对象。

对于 item，是一个从 string 类型的类实例化的变量。

对于 price quantity 和 price total，它们是由一个名为 Iand 的类实例化的，意为 integer。

所以本来可以更好的。

如果我们调用我们想要创建自己的数据类型的 tail Python，它将允许我们编写一个代码，如果需要的话，我们可以在将来轻松地重用它。

现在，每个实例都可以有描述相关信息的属性。

我们至少可以为我们的项目数据类型考虑一些好的候选属性，比如名称、价格或数量。

好了，让我们开始创建我们的第一个类。

所以我会清理这里的一切，然后我们继续。

所以它将被分成两部分，第一部分是类的创建。

第二部分，我将实例化这个类的一些对象。

现在，当我说创建一个实例，或创建一个对象，基本上我指的是同一件事，所以你可能会听到我说其中之一。

好吧，那我们继续上课吧。

然后这需要跟随着你想要创建的类的名字。

所以我们想把它命名为 item。

在这门课里，将来，我们会写一些对我们非常有用的代码。

所以我们不会每次都重复自己喜欢采取类似的行动。

但是现在，暂时地，我要在这里说一遍，这样我们就不会在这个类定义中收到任何箭头。

好了，现在我们已经创建了我们的类，那么我们可以创建这个类的一些实例了。

所以我们继续说，第一项等于第二项。

这个动作相当于创建一个类的实例，就像你要创建一个随机的字符串，然后你会像下面这样说。

这也相当于这个。

所以理解 Python 中的类是如何工作的非常重要。

所以我会删除这一行，因为这只是一个例子。

现在我说了，我们可以给一个类的实例分配一些属性。

所以让我们开始创建属性。

这可以通过在类的实例后面使用点号来实现。

在这里你可以说你想给它一个属性，比如一个名字，它等于 phone，而第一项，价格可能等于 100。

例如，我认为一个点的数量可以等于五个。

在那个阶段，你可能会问自己，我们创造的这四条线的随机变量有什么不同？这里，我们实际上在这四行之间有一个关系，因为每一个属性都被分配给类的一个实例。

我可能会继续这样做，并尝试打印 item one nil 的类型，以及 name、price 和 quantity 属性的类型。

现在有了名称、价格和数量，我们就不会有任何惊喜了，因为我们给 item 对象分配了 string 类型的属性。

但是如果我们要打印它，然后检查结果，如果我要运行这个程序，所以你可以看到现在我们有一个数据类型的项目。

这就是我们之前看到的与我们刚刚创建的东西之间的巨大差异。

所以现在我们明白了如何创建我们自己的数据类型。

现在让我们来看看使用面向对象编程还有哪些好处。

好了，到目前为止，我们了解了如何给实例分配属性，我们现在还应该了解如何创建一些方法，并在实例上执行它们。

现在，如果我们以 string 的构建类为例，那么你知道我们有一些方法，我们可以对每个字符串执行。

在这个例子中，你可以看到我抓取了一个字符串的实例，我把它命名为 random str，然后我继续下一行，执行 opera 方法，如果你记得的话，它可以抓取所有的字母，并把它们变成大写。

现在这里最大的问题是，我们如何继续下去，设计一些方法，允许在我们的实例上执行，答案就在我们的类里面。

所以我们可以在类里面写一些方法，这些方法可以从我们的实例中访问。

所以我们可以继续说，给我们的方法起个名字。

现在，我们想要创造的金属的一个很好的候选，实际上是计算总价格，因为据我们所知，它本来可以很好。

如果我们有一个方法可以继续计算结果，用一个点的价格乘以一个点的数量，那么我们就可以得到这个特定项目的总价格。

现在，在我们继续并完成这个函数之前，我将通过删除这两行来创建该项目的另一个实例，因为我们已经理解了这个示例。

所以我要把它们改成第二项，就像这样。

而且我准备用笔记本电脑之类的东西，把价格改成 1000。

说我们有三个。

现在快速补充一下，当你听到我说方法时，我基本上是指类中的两个函数。

因为就 Python 而言，或者在任何编程语言中，当你用这个关键字隔离定义时，那么那些就被认为是被调用的函数。

但是当你在类中创建这些函数时，这些就叫做方法。

所以这是你应该理解的重要一点，因为从现在开始我要调用这些方法。

好的，现在如果我继续打开和关闭这些括号，那么你会看到一个自动生成的参数，Python 希望我们有意接收它。

发生这种情况的原因是，当你继续调用这些方法时，Python 将对象本身作为第一个参数传递。

现在，如果我到这里，说第一项计算总价，那么我们现在做的动作就是调用这个方法。

但是当你从一个实例调用一个方法时，Python 每次都会把对象本身作为第一个参数传递。

这就是为什么不允许我们创建永远不会接收参数的方法。

如果我去掉第一个参数，你会看到这个，比如说 pass。

如果我现在执行这个程序，你会看到类型 0，计算总价没有位置参数，但是给了一个。

简而言之，这个异常的意思是 Python 试图传递一个参数，而你没有收到任何参数，所以这很成问题。

这就是为什么当你继续创建你的方法时，你必须至少接收一个参数。

既然我们总是收到这个参数，那么这只是一个调用这个自我的普通方法。

如果我把它叫做类似于我的烫发的东西，或者我不知道别的什么东西，那是没问题的。

但是您绝不会想弄乱不同 Python 开发人员之间的通用约定。

所以这就是为什么每次你都要确保让它保持自我。

现在，如果我继续运行这个程序，你会看到我们不会收到任何错误。

所以这意味着这个方法被正确地实现了。

现在让我们看看我们将如何从创建这个方法中受益，因为它应该继续为我们创建一个使用价格和数量的计算。

所以我会特意在这里多接收两个参数，我们可以暂时命名为 x&y。

我们可以说返回 x 乘以 y。

现在我会继续传递，两个额外的论点。

这将是一个点的价格。

第二个是数量。

这是可行的，因为当你在后台调用这个方法时，Python 会把它作为参数传递。

然后它传递第二个参数。

这是作为第三个参数传递的。

所以这是完美的。

如果我要运行它，并实际打印它，请原谅我在打印之前运行它，所以我将用这个内置的打印函数包围这个表达式。

我将运行它，您将会看到 500，正如预期的那样，现在我可以做完全相同的事情来计算我们的第二个项目的总价格。

所以如果我拿着这个，把这个粘贴进去，在这一行，实际上把这个换成第二项，把这个换成第二项，还有这个，那么我会得到预期的 3000。

这就是你如何创造一种金属。

好的，在那之前，我们知道我们可以分配属性，也可以创建一些方法，我们可以直接在实例中使用它们，就像那一行中的两个例子，还有那一行。

现在，在那一集里，我们将解决一些我们在面向对象编程的最佳实践方面遇到的更多问题，以及你将在基于 Opie 的每个项目中看到的东西。

好吧，那我们开始吧。

现在，我们在这里遇到的第一个问题是，我们没有一套规则来处理属性，这些属性是为了成功地实例化一个实例而需要传递的。

这意味着，对于我想要继续创建的每个项目，我需要像这里一样硬编码属性名。

如果我们以某种方式调用这个类，声明为了成功实例化一个实例，必须传递 name、price 和 quantity，否则，就不能成功地创建实例，那就更好了。

这意味着，如果我们能在后台执行一些东西，这将是一个很好的选择。

第二，我们实例化一个实例，有一种方法，你可以达到这样的行为。

那就是创建一个特殊的方法，它有一个非常独特的名字，叫做双下划线 init 双下划线。

现在你可能会听到这个术语，就像听到构造函数一样冰冷。

基本上，这是一个具有唯一名称的方法，你需要有意地这样称呼它，以便使用它的特殊未来。

现在，它的工作方式是通过以下方式创建它。

所以它是双下划线。

如你所见，我已经为一些非常特殊的方法提供了自动完成功能，这些方法以双下划线开始和结束。

现在这些方法的集合被称为魔术方法。

我们将会学到很多你们在 Opie 中拥有的神奇方法，但是我们首先要学习的是 init 双下划线，就像这样。

好了，现在我们已经创建了这个方法，那么让我们来看看这个金属在背景中做了什么。

所以当你创建一个类的实例时，Python 会自动执行这个双下划线 init 函数。

这意味着什么，这意味着现在我们已经声明了我们的类，Python 将运行这一行。

因为已经创建了一个实例，并且设计了双下划线 init 方法，所以它将调用这个双下划线 init 双下划线方法中的操作。

为了证明这一点，我将从一个非常基本的观点开始，即我生来如此。

现在我们到了这里，一个例子。

这里还有一个。

所以我们应该看到我被创造了两次。

为了避免混淆，我将从这里删除这些打印行，这样我们可以看到更清晰的图片。

好，如果我们运行我们的程序，我们可以看到我被创造了两次。

这是因为 Python 调用了这个双下划线 init 双下划线方法两次，这要感谢我们已经评分的那两个实例。

好了，现在我们在这个类中使用了双下划线 init 函数，我们应该从中受益并解决更多的问题，以实现 Opie 最佳实践。

现在，如果你还记得在本教程的开始，我说过我们到目前为止的一个问题是，我们仍然以那种方式硬编码属性，说点名称，点价格，点数量。

这是我们肯定可以避免的。

现在让我们看看如何开始避免为这里的每个实例创建那些硬编码的属性。

因此，我们实际上可以从我们设计的双下划线 init 方法中受益。

让我们看看现在我们如何理解，对于我们将要创建的每个实例，它将自动调用这个双下划线 init 方法。

这意味着，我们不仅可以接收 self 参数，因为这是我们必须做的事情，因为 Python 在后台将实例本身作为第一个参数传递，此外，我们还可以接收更多的参数，然后对它们做一些事情。

因此，作为一个焊料，让我们说，我们希望收到一个参数，我们可以命名为名称。

如你所见，Python 会自动抱怨这里没有填写名称参数。

所以现在，我可以继续传递这个关于电话的论点。

对于第二个问题，我可以继续讨论笔记本电脑。

现在，一旦我创建了这个，那么我就可以实际上继续下去，改变我的打印线一点点。

因此，这将是一个独特的打印行，我可以识别每个打印行来自哪里。

我可以继续说，创建了一个实例，并在这里使用了一个列，然后像这样引用它的名称。

既然我们已经创建了这个，那么如果我们运行我们的程序，那么你会看到独特的句子，一个为手机和笔记本电脑创建的实例。

好了，现在我们已经完成了，接下来还有一些不太完美的地方，因为我们仍然在这里和这里传入 name 属性。

所以现在注意 init 方法如何接收 self 作为参数。

我们已经知道了原因。

我们在这里将 self 作为一个参数，这实际上允许我们从 init 方法中分配属性，这样我们就不必为我们创建的每个实例分配 name 属性。

这意味着什么，这意味着我可以从这个神奇的方法中，动态地给一个实例分配一个属性，这个方法在这里叫做双下划线。

所以如果我说，self，点 name，那么我把 name 属性赋给每个实例，它将被创建或者已经被创建，我让它等于从这里传入的 name。

这意味着什么，意味着现在我可以允许自己删除这一行。

然后这一行。

如您所见，现在我有了一个动态属性赋值，这要感谢我们在这里编写的 self 点名称等于名称，以测试属性赋值世界，然后我可以在这里再使用两行，如下所示。

因此，我将打印它的一个点的名称，我也将打印该名称的项目。

为了避免混淆，我要去掉这条线。

所以我们只能从这里看到印刷线。

现在，如果我运行它，您会看到我们收到了一部手机和一台笔记本电脑。

这意味着我们能够动态地分配属性。

这是完美的。

既然我们有了这样的想法，那么我们也应该为我们想要得到的其他属性做同样的事情。

所以我们也要考虑价格和数量。

所以我要去我的 init 方法，我要再次接收，价格和数量。

我也要做同样的事情。

所以我要赋予价格这个属性。

这就等于价格。

而且数量会和数量相等。

你也可以看到 Python 再次抱怨价格和数量没有在这里传递。

所以我可以说 100，然后 5，然后我可以删除这些。

然后我可以在这里做同样的事情。

我可以传入 1000 个，然后 3 个，删除它们，为了证明这是可行的，我要复制自己几次，然后把它变成数量，我是说价格，这个也是价格。

这个是数量，这个也是。

如果我运行它，你会看到结果和预期的一样。

所以这是你应该使用双下划线 init 方法的一种方式，你应该总是注意你想要分配给双下划线 init 方法中的对象的属性，意思是在构造函数中。

现在，当我们和类一起工作时，需要记住几个非常重要的标志。

现在，当我们继续使用 Ws 坐标方法时，这并不意味着我们不能区分强制参数和非强制参数。

假设您目前不知道某个特定商品的数量，那么您可以继续，默认情况下，收到的数量参数为零，因为现实情况是您目前不知道您的商店中有多少部手机。

因此，我们可以直接使用默认值，例如，零，这意味着您不必在这里传递这五个和三个。

现在为了向你们展示结果，如果我运行我们的程序，你们可以看到我们在这里两次得到零。

所以这是你想要记住的事情。

还有一点很重要，我现在想说的是，你可以单独给特定的实例分配属性。

所以说，你想知道笔记本电脑是否有数字小键盘，因为有些笔记本电脑的键盘右侧没有数字小键盘。

但这并不是你想赋予手机的真实属性。

这就是为什么你可以继续，顺便让我删除这些打印行。

这就是为什么你可以继续说，比如第二项，它的 numpad 等于 false。

这是你要记住的，因为你在构造函数中使用一些属性赋值的事实并不意味着你不能在实例化你想要的实例后，添加更多你想要的属性。

好了，现在我们明白了这一点，那么还有一个小问题需要解决。

现在注意计算总价是如何接收 x 和 y 作为参数的。

我们现在问的问题是为什么它仍然接收这些参数。

嗯，我们现在可以肯定没有收到这些参数。

因为正如我们所知，对于我们在类中设计的每一种金属，对象本身是通过参数传递的。

我知道我重复了几次。

但这就是我没能理解类的地方。

这就是为什么理解这种行为非常重要。

我们已经知道对象本身是作为参数传递的。

这就是我们接受自我的原因。

这意味着现在我们可以返回自己的点价格乘以自己的点数量。

这将意味着我们实际上不需要接收那些参数，因为一旦实例被分级，我们就分配那些属性。

这意味着我们可以访问这些属性，通过我们将来要在这个类中添加的方法。

为了测试这是否可行，我现在要删除这个例子。

我说打印一个点，计算总价。

所以我们可以在这里返回结果。

我也会为第二项做同样的事，抱歉，只有这一项。

现在来展示一些除了零以外的实数，然后我会把数量传入这里。

例如，我会说一和三，因为我不想乘以一个等于零的大数。

这可能来自这里。

所以我会去查。

你会看到我们收到了预期的结果。

所以现在我们完全理解了全局，如何在类中使用构造函数，以及您应该继续执行的最佳实践是什么。

好了，现在我们明白了这一点，那么我们可能会认为我们已经完美地完成了所有的事情。

但实际上我想告诉你们，如果我们在这里除了传递一个整数，还传递一个字符串，然后运行我们的程序，会发生什么。

所以如果我们运行它，你会发现我们把事情搞砸了。

因为这个函数，例如，他选择打印字符串三次，因为你会看到我们有 1000 乘以 3，在这里被返回。

所以它一次显示 1000，两次显示 1000，然后再显示一次。

这意味着，我们必须验证我们传入的值的数据类型。

因此，有几种方法可以实现这一点。

一种方法是在你在这里声明的参数中输入，所以一个很好的开始，比如说，声明一个名字必须是一个字符串。

现在，让我先把这个拿回去，把它们改成整数，然后到这里来设计这些参数。

因此，为了指定类型，您应该继续创建一个冒号，后面跟着您希望在这里接收的数据类型的类型。

所以如果我在这里传入的，只是对 str 类的对象引用，那就意味着它只能接受字符串。

我可以通过把它变成一个整数来证明。

你会看到我们这里有一个抱怨，说期望类型 str God int。

这是完美的。

既然我们已经完成了，那么我要对价格本身做同样的事情。

价格，我们可以通过传递 float 来做同样的事情。

当我们传递 float 时，也可以传递整数。

这对于浮点数和整数来说是非常独特的。

所以使用 float 类型是没问题的。

对于数量，我们不需要指定一个类型，因为我们传递了一个缺省的整型值，这个事实已经将这些参数标记为总是整型。

这就是为什么，举例来说，如果我让它保持原样，把数量改成一个字符串，你会看到它会抱怨，因为默认值已经是一个整数了。

所以它需要一个整数。

好了，这些东西实际上是很好的设置，让我们的 init 函数更强大。

但是我们可能仍然希望以下面的方式验证接收到的值。

所以说，你永远不想收到一个负数的数量。

你永远也不想收到负数的价格。

所以这是你不能通过在这里打字来实现的。

但是实际上有一个很好的方法来解决这个问题。

那就是使用断言语句。

assert 是一个语句关键字，用于检查发生的事情是否与您的预期相符。

让我们看看如何使用 assert。

所以我要把它从这里删掉。

我要组织一下我们的 init 方法，我要在这里说一个注释，我要说赋值给 self 对象。

我还会对收到的参数进行验证。

好了，现在验证价格和数量都大于或等于零是个好主意，因为当它们是负数时，我们可能不想处理它们，我们想让问题崩溃。

所以我们可以说 assert，注意我把它当作一个语句，而不是内置函数，或者类似的东西。

我可以说，价格大于或等于零。

一旦我说了这个，那么我也可以对数量做同样的事情。

所以让我快速地做一下。

这样，一旦我们有了这个，我就可以运行我们的程序了。

你会看到我不会收到任何箭。

但是当我把这个量变成负 1，比如说，这个量是负 3，那么我会看到一些箭头，表示断言错误。

现在你可以看到，我们在这里看到的事实，断言错误是一个相当普遍的异常，这并不意味着什么。

第三个参数如此美妙，你可以在它附近添加你自己的异常消息作为第二个参数。

让我们从这里开始，回到那两条线。

所以传递给语句的第一个参数是我们想要检查的语句。

但是如果我们在这里用逗号，用一个字符串来表示，实际上是格式化的字符串，我可以说 price，然后引用它的值不大于零。

他们可以在这里加一个解释标记，也可以用同样的东西。

用逗号把它抄下来，粘贴到这里。

改变这个量，然后参考它的值，说它不等于，我的意思是大于等于零。

所以我们实际上需要改成大于等于，就像这样。

这里也一样，我这里有一些空格，将被删除。

好的，现在如果我执行我们的程序，你可以看到，我们收到的断言错误量减一不大于或等于零。

所以我应该删除这个，然后这里的那个，现在它是完美的。

现在我们明白了，使用 assert 语句可以让我们验证收到的参数。

此外，它还允许我们在继续进行我们希望在该程序中采取的其他操作之前，尽快发现错误。

让我把它们变回这样的有效值。

这是完美的。

好了，到目前为止，我们已经学习了如何使用构造函数。

我们还了解了如何为实例分配不同的属性，使每个实例都是唯一的，这意味着您可以继续创建任意数量的实例，并且您可以控制传递名称、价格和数量的任意值。

现在考虑一种情况，您想要利用一个属性，该属性将是全局的，或者跨所有实例，现在是一个很好的候选，例如，这可能是您想要在您的商店中应用销售的情况。

所以这意味着你想继续下去，并控制应用一些折扣的每一个项目。

这是创建所有实例共享的属性的一个很好的选择。

现在我们称这些种类的属性，类属性，以及我们已经学到的种类的属性，直到这一点，实际上是在一个完整的名称中被称为实例属性。

关于实例属性，我们什么都知道，我们也学会了如何使用它，但我们没有使用另一种属性，我们将在本教程中使用，也就是所谓的类属性。

所以类属性是属于类本身的属性。

但是，您也可以从实例级别访问该属性。

让我们来看看您想要创建的类属性的一个很好的候选对象。

所以这将会出现在我们的课堂上。

在我们类的第一行，我可以创建一个类属性。

因此，让我们继续创建一个属性，如工资率等于 0.8。

我这样做的原因是因为我说过会有 20%的折扣。

所以我可能想存储一个描述我还需要付多少钱的属性。

所以我在这里会说，像这样打八折后的工资档次。

好了，现在我们已经创建了这个属性，接下来让我们看看有哪些方法可以访问这个属性。

现在，如果我真的删除其中一个，在这一行中说一些类似下面的话。

所以我将尝试访问类本身的引用。

所以我不会创建一个这样的实例，除此之外，我只是引入对类级别本身的引用。

我将尝试通过 PE 下划线 rate 来访问该属性。

现在，如果我运行它，你将会看到预期的结果，我们会看到这个类属性，因为这是你访问这些类属性的一种方式。

这可能会令人困惑，但是我一分钟前说过，您也可以从实例级访问这些类属性。

好吧，让我们看看这是不是真的。

如果我要复制这两行两次，用快捷键 Ctrl，D，那么让我们继续，把它们改成第一项，把这一行改成第二项。

现在看看我如何尝试从实例中访问 pay rate 属性，尽管我们没有这样的实例属性。

现在，如果我运行它，您将会看到我们仍然可以访问该类属性。

嗯，这可能会令人困惑。

这可能很难理解为什么会发生这种情况。

当我们在 Python 中使用实例时，实际上有一些事情我们需要理解。

因此，当我们手头有一个实例时，首先这个实例试图在第一阶段从实例级别引入属性，但是如果它没有在那里找到它，那么它将试图从类级别引入该属性。

这意味着，第一项在这里做了一些事情，然后对自己说，好的，这里没有这个属性，因为这不是分配给我的属性。

因此，我将尝试从实例级别搜索它，然后找到它，如果冲刺回来。

这就是这里正在发生的事情。

项目一和项目二是在例程层找不到支付费率属性的例程。

所以他们两个都继续尝试从类的层面引入这个属性。

因为它确实存在于类级别，所以我们能够访问它们。

现在为了让你更好地了解这里发生了什么。

然后我要做另外一件事。

现在我将删除这些第一个打印行。

我也将从这里删除这些属性。

现在有一个内置的魔法属性，而不是魔法方法，您可以继续查看属于该特定对象的所有属性。

这可以通过使用双下划线来实现。

因此，这将继续，并尝试为您提供属于您应用此属性的对象的所有属性，并希望查看其内容。

因此，我将继续复制这个，并将其粘贴到实例级别。

这样我就能得到职业等级的所有属性。

第二行将为实例级执行此操作。

好的，如果我要运行它，那么让我们来看看结果。

现在我们可以看到，在第一行，我们看到了这个工资率属性。

但是在第二行，我们从来看不到它，我们看到的是名称、价格和数量。

你还可以注意到，这个神奇的属性实际上负责获取所有的属性，并将其转换为一个字典。

这就是 dict 关键字的来源，它只是一个字典的简化版本。

因此，这是一个非常有用的神奇属性，如果您只是出于调试的原因想暂时查看属于某个对象的所有属性，您可以继续使用它。

好了，现在我们明白了这一点，那么让我们来看一个真实的例子，并想出一个方法来对我们的商品价格应用折扣。

这将通过创建一个方法，我们将属于我们的每个实例，这意味着我们可以继续前进，并提出一个方法，我们可以命名为应用折扣。

所以让我们继续并开始工作吧。

所以我要说 def apply，discount，注意我在一个类中使用了一个新方法。

所以在这里，首先我们需要弄清楚如何覆盖一个属于实例的属性。

我们已经知道，我们可以用 self 关键字做到这一点。

因此，它将是自我点价格。

这将等于 self 点价格，意味着该属性的旧值乘以支付率。

现在你可能认为我们可以像这样直接访问它。

但如果你记得的话，那其实是属于物品类本身的。

这可能会令人困惑，因为这个方法已经在这个类中了。

所以你可能已经想到，你可以通过说 pay rate 来直接访问它，因为它已经在类里面了。

但这实际上是行不通的。

因为正如我们之前所理解的，您可以从类级别或实例级别访问它。

所以我们可以继续这样说。

这样你就有了一种金属，它基本上可以覆盖你的一件物品的价格属性。

现在为了向您展示这是可行的，我现在只能使用一个实例。

我可以通过调用 apply discount 来调用这个方法。

我现在还可以尝试打印这一项的价格属性，我们应该会看到 ad right。

所以如果我们运行它，你会看到，我们会在零点收到预期的信号。

现在，我们不应该忘记您可能还希望对某个特定商品有不同的折扣金额。

假设有一天你有 20 件商品，或者只有笔记本电脑，你会想要 30%的折扣。

但是将 class 属性改为 0.7 并不是一个好主意，因为这会影响你手头上所有的物品。

因此，您可以将该属性直接分配给您希望获得不同折扣金额的实例之一，接下来我们来看一个例子。

因此，我将允许自己带回该物品或笔记本电脑，然后我可以对该物品应用 30%的折扣，方法是将完全相同的属性分配给该实例。

所以我可以用一个项目来表示，得分率等于 0.7。

现在，对于第二项，它将在实例级别找到工资率属性。

因此，它实际上不必前进到类级别并带回工资率的值，因为 Add first look 将在实例级别找到它。

但对于第一项，情况不同，它仍将从项级别读取，这将是 0.8。

那么现在，如果我们尝试使用第二个点应用折扣，并且现在打印价格，那么让我们看看会发生什么。

因此，我将取消对该行的注释，暂时不显示该屏幕。

我会继续执行我们的程序。

现在你可以看到我们仍然收到 800 美元。

这意味着已经应用的折扣仍然是 20%。

这是从哪里来的，嗯，这是从这种方法来的，无论我们怎么努力，从阶级水平上拉工资率。

因此，这里的最佳实践是改变这两个单元。

这样，如果我们覆盖实例级别的工资率，它将从实例级别读取。

但是对于第一项，如果我们尝试从实例级别访问工资率，那么这仍然很好，因为我们没有为第一项分配特定的工资率。

因此，它将从类级别中提取。

现在，如果我们尝试运行它，你会看到我们已经得到了预期的结果。

如果我们取消第一项的第一行注释，然后重新运行我们的程序，那么你可以看到第一项，我们有 20%的折扣。

第二项，我们有 30%的折扣。

所以当谈到访问类属性时，当你想出一些方法时，你可能要重新考虑你想如何访问它们。

特别是对于创建像 apply discount 这样的方法，从实例级别访问它是一个很好的主意。

因此，您还可以选择使用指定给实例级别的支付费率。

好了，现在我们已经完全理解了类和实例属性之间的区别，让我们跳到下一个主题。

现在你会看到我已经删除了下面的那些打印行。

我在这里创造了五个例子。

因此，您可能还想立即创建这五个实例。

这就是为什么我会推荐你到我的仓库，访问这些类属性目录，然后是代码片段，然后从这五个下划线 items.py 文件中复制代码。

好的，那么考虑一种情况，你的商店将来会更大，意味着你会有更多的商品，那么你会有更多的商品，就像你将来想做的事情一样。

但我们的类目前的问题是，我们没有任何资源可以访问我们商店中的所有项目。

现在，如果我们能以某种方式拥有一个包含到目前为止已经创建的所有项目实例的列表，那就更好了。

但是目前，还没有一种方法可以给我们一个包含五个元素的列表，其中每个元素代表一个类的实例。

所以为了提出这样一个设计，这里有一个很好的候选对象来创建一个我们可以命名为 all 的类属性。

一旦我们做到了这一点，我们将会看到如何将我们的实例添加到列表中。

因此，我将从这里开始，在所有属性中使用。

所以它将等于一个空列表。

现在，我们需要弄清楚，每次创建实例时，我们将如何添加实例。

如果你还记得的话，一旦实例被评分，双下划线 init 方法就会被立即调用。

因此，在这个双下划线 init 方法中使用一个负责在每次创建实例时添加到列表中的代码，这可能是一个很好的主意，就像下面这样简单。

首先，你可以注意到我实际上在这个双下划线 init 函数中写了一些命令，比如运行验证和分配保存对象。

因此，在这里以一个注释开始可能是一个好主意，这个注释会说要执行的操作只是为了在我们正在做的不同事情之间有一个很大的区别。

现在在这里我可以说 item dot all，你可以看到我首先使用了 class 对象，然后是一个 list，所以我可以使用 dot append，然后我只添加 self 对象。

现在我们知道，自我实际上是每次被创造时的实例本身。

因此，一旦我们在单元内部启动这样一个命令，那么对于将要创建的每个实例，这个 all 列表将被我们的实例填充。

现在向您展示，在我们创建实例之后，我可以跳转行，我们可以说打印项目。

现在如果我运行我们的程序，你会看到我们有一个包含五个实例的列表。

如果我向右滚动一点，你会看到我正好有五个元素。

这是完美的。

如果你想用实例的一个属性做一些事情，这将会非常有用。

假设您想要打印所有实例的所有名称，那么您可以轻松地使用 for 循环来完成这样的任务。

因此，我们可以继续说，例如，在项目点所有，你可以说打印实例，点名称。

一旦我们想出了这个，那么你可以看到我们已经评分的所有实例的所有名称。

因此，这在某些地方会很有用，特别是如果你知道如何使用过滤功能，例如，在一些符合你的标准的实例上应用一些特殊的东西。

好了，现在我们明白了这一点，那么让我们也来看看我们之前看到的一个问题。

现在，如果我用 Ctrl，D 键几次，仍然使用这个打印项目点，你可以看到，这个对象的表示方式不太友好。

现在，如果我们能以某种方式改变对象在这个列表中的表示方式，那就更好了。

现在，实际上有一种方法可以实现这一点，那就是在我们的类中使用一个神奇的方法。

现在有一个神奇的方法叫做双下划线我们的 EPR。

我们的 EPR 代表代表你的对象。

这就是为什么你实际上可以继续使用这个神奇的方法。

然后，当您在控制台中打印对象时，您将可以控制对象的显示。

现在，我实际上推荐看一个视频，在一种与之相似的金属之间进行比较，这种金属被称为双下划线 str。

你可以看一下整个系列的描述，来实际观看我正在谈论的视频。

好的，让我们继续，用 RPM 方法来理解这是如何工作的。

所以我要在我们的类内部说 def。

我将使用双下划线 re，PR 双下划线，不出所料，它会收到 self。

现在我们能做的是返回一个字符串，它将负责表示这个对象。

显然，我们不想使用对每个实例都不唯一的东西。

因为假设我现在要使用返回项，类似的东西，然后运行我们的程序，那么你可以看到我将会收到一个包含这个字符串的列表五次。

但是很难确定哪个实例代表了这里的每个字符串。

所以如果我们返回一个唯一的字符串，会很有帮助。

因此，我将在这里关闭控制台，然后在这里使用格式化字符串。

为了使它独一无二，最好的做法是像我们创建实例那样精确地表示它。

所以我在这里要做的是活的项目，并使用括号开瓶器和关闭。

然后我会让这里的返回字符串，尽可能的等同于我们创建那些实例的方式。

因此，我将从这里键入单引号开始，以避开来自这里的双引号。

我将用 self dot name 来引用 name 的值。

然后我会留下我的单引号。

我会用这样的逗号。

然后我会继续参考我们的价格。

我将使用多一个逗号，我会说自己点的数量。

现在，如果我们再次执行我们的程序，那么你可以看到，现在我们会收到一个列表，它比我们之前看到的要友好得多。

你也可以看到，第一个元素，相当于这条线。

现在你可能会好奇为什么我如此努力地用创建对象的方式返回对象的代表版本。

因此，根据 Python 文档，这是最佳实践，因为它将帮助我们立即创建实例，只需将它们复制并粘贴到 Python 控制台。

所以如果你现在想一想，如果你打开一个 Python 控制台，你将导入这个类，那么它将像抓取这个并粘贴到 Python 控制台一样简单。

然后你会有一个实例被评分。

这就是我想出这个方法的唯一原因。

当然，我只是想返回一个唯一的字符串，它将真正代表我们的实例。

你可以看到，用这个列表很容易识别我们类的实例。

用这种方法，好的，所以直到这一点，我们明白了如何改变我们表示我们的对象的方式。

我们也知道如何通过这个我们有意命名为 all 的类属性来访问我们所有的实例。

现在，在这一部分中，当我们打算扩展这个应用程序并添加更多功能时，我们将着眼于解决我们在最佳实践方面遇到的另一个问题。

现在您可以看到，到目前为止，我们只通过实例化将数据作为代码保存在 main.py 文件中。

那五样东西。

现在，当我们希望扩展这个应用程序并添加更多未来功能时，我们可能很难添加这些功能，因为实际的数据和代码都保存在同一个位置，也就是说在同一个 main.py 文件中。

现在，您可以考虑创建一个数据库来维护这些信息。

但是出于本教程的目的，我想让事情变得更简单。

这就是为什么我要使用一种叫做 CSV 的东西，你们可能听说过。

csv 代表逗号分隔值。

这意味着您可以继续使用 CSV 文件，您可以将值以逗号分隔的形式存储，其中每一行代表 CSV 中的一个结构化数据。这是一个很好的选择，因为它允许数据以表结构格式保存。

好了，让我们继续创建一个 CSV 文件。

实际上，我将继续为这些项目命名，点 c 是 V，就像这样，我将继续粘贴一些 CSV 内容，这些内容将在一天结束时负责表示我们在这里看到的相同数据。

所以你可以看到在第一行，我有名字，价格和数量。

你可以看到它们是用逗号分隔的。

这些代表了我们将要维护的数据列。

在第二行以及更远的地方，我们将拥有一些数据，这些数据将代表我们希望维护的实际数据。

因此，如果我们现在拆分窗格，那么你可以看到，它们是完全等效的。

现在，我们应该只寻找一种方法来读取 CSV 文件，并实际实例化这些对象。

现在我们可以看到我有一个 pi charm 的建议，安装一个将支持 CSV 文件的插件。

因此，我只需点击它，然后安装这些插件。

您可以看到，我这里有一个 CSV 阅读器。

我们将看看是否能在表格中看到这些数据，那会好得多。

所以让我们继续安装它。

现在，您可以看到我有更多的选项，我可以在这里继续使用，我知道这很小，但实际上您有一些选项卡，您可以继续点击它们。

如果我单击“table editor ”,并实际上给予该文件更多关注，那么您可以看到我实际上有了读取该数据的最佳方式。

现在，你可以看到我有我的列，你可以看到我的行。

这很好。

现在，我可以更好地直观显示我的数据了。

这是维护数据的更常见的方式。

好了，现在我们了解了 CSV 文件是如何工作的，让我们继续阅读我们的 CSV 文件，并以通用的方式实例化实例。

所以删掉那五行是有道理的。

我将使用 apply discount 下面的那些行，并使用一个金属，我可以这样命名它，从 CSV 实例化。

现在，你可以看到这个也将接收它自己，因为如果你记得我说过，在我们将要设计的每个金属中，我们需要接收至少一个参数，该参数将作为实例本身传递，因为这是 Python op 的工作方式。

现在的问题是，我们手头没有任何实例来从实例中调用这个方法，因为这个方法实际上是为实例化对象本身而设计的。

这意味着不能从实例中调用这个方法。

所以解决这个问题的方法是，把这个方法转换成一个类方法。

现在，类方法是一种可以通过以下方式访问的方法。

所以我将使用这个线工具，删除它，它只能从类级别访问。

所以这看起来像是从 CSV 实例化的 item dot，然后在这里，我们可能会传递我们的 CSV 文件。

所以这个方法应该完全负责为我们实例化那些对象。

既然我们已经理解了这一点，让我们继续看看如何创建一个类方法。

所以可以肯定的是，我们需要删除自我。

我知道我们有箭头，但是我们要在一秒钟内解决每一个。

现在为了将它转换成一个类方法，我们需要使用一个装饰器来负责将这个方法转换成一个类方法。

Python 中的 decorators 是一种快速改变函数行为的方法，我们只需在创建函数的那一行之前调用它们。

所以我们可以使用加号，在这里使用 class 方法，然后这个从 CSV 方法实例化的方法将是一个 class 方法。

好了，现在我们明白了这一点，那么在我们继续设计这个方法之前，我们还应该明白一条信息。

现在我想告诉你，如果我删除整个名字，并尝试在这里重新创建这个函数，会发生什么。

我会说再次从 CSV 实例化，现在注意如果我打开和关闭括号会发生什么，现在我们可以看到它仍然接收一个参数，但这一次，它被命名为 CLS。

现在，这里发生了什么，这里发生的事情是，当我们调用我们的类方法时，类对象本身总是在后台作为第一个参数被传递。

所以这有点像它也作为第一个参数被传递的例子。

但是这一次，当我们用这种方法调用类方法时，类引用必须作为第一个参数传递。

所以这就是为什么你仍然应该收到至少一个参数，但是我们可能知道我们不能给这个自我命名，因为那会太令人困惑。

好了，现在让我们继续写一些代码来读取 CSV 文件并实例化一些对象。

现在，我将首先进入顶层，我将导入一个名为 CSV 的库。

因此，我将转到这里，我将使用导入 CSV 行，因为这将是库，它将完全负责读取 CSV 文件。

然后我们会看到如何实例化一些对象。

好了，现在我可以使用上下文管理器来读取 items dot CSV 文件了。

现在这两个文件位于同一位置。

所以我可以直接说，等等，开放项点 CSV，我在这里传递的许可可能是一个小时，因为我们只看这个。

我会这样说 f。

现在，在这个 open 中，我将继续使用一些元数据来直接读取 CSV，它最终将负责将其转换为 Python 字典。

所以我会说 reader 等于 CSV，点 d ICT reader 之类的。

我会像这样传入我们文件的内容。

现在，这个方法应该继续下去，以字典列表的形式读取我们的内容。

但是在一天结束的时候，我们也应该把它转换成一个列表。

因此，我将继续创建另一个等于 items 的变量。

我将把阅读器转换成一个列表。

仅此而已。

现在，我们已经通过读取 CSV 文件完成了我们想要完成的操作，让我们继续使用 Shift Tab 键进行缩进。

现在，在我们开始实例化一些对象之前，让我们来看看 items 列表的迭代结果。

现在我将继续使用 items 中的 item。

然后我会用打印的东西来展示这种行为。

不好意思，应该是第一项。

好了，现在我们明白了这一点，那么让我们继续下去，看看我们在这些线。

因此，在我们的类定义之后，我们只继续从 CSV 方法调用这个项目点实例化。

所以如果我运行它，你会看到我收到了一些单独的字典。

这是因为我在这里迭代了一个字典列表，这太完美了。

好了，我们现在唯一错过的就是创建实例。

现在除了打印它们，我们还可以说一些类似 item 的东西，打开和关闭括号。

这将足以实例化我们的实例。

现在我可以继续，把我的论点传到这里，基本上是从字典里读关键字。

所以我可以说 name 等于 item dot get，那就要接收 name。

现在，我可以添加一个逗号，复制这一行两次，并相应地更改它们。

这就是价格。

这就是数量。

现在我需要替换我的键名。

这里是价格，那里是数量。

现在让我们继续，看看如果我调用这个方法会发生什么。

并且调用 item dot all 的属性，因为这个属性存储了列表中的所有实例。

如果我继续运行它，你会看到我有一些箭头。

现在你会看到箭头与价格相关。

你可以看到我们得到的不大于或等于零。

现在，让我们继续快速解决这个问题。

所以在点 CSV 的项目中，你可以看到这些实际上是大于零的整数。

所以问题可能在于它们是作为字符串传递的。

所以我们需要把它们作为整数传递。

所以我要把它们转换成 int，就像这样。

现在，让我们继续下去，看看我们是否会有任何问题，因为我预计会有任何问题，因为数量应该抱怨同样的事情。

你可以看到这正是这里正在发生的事情。

所以我们可以用同样的方法来计算这样的量。

您可以看到，现在我们可以完美地看到我们的实例。

现在我想展示另一个我们将来可能会遇到的问题，我们现在应该避免。

所以这三条线将会和 Aveda 的结构一起工作。

但是如果我把键盘的价格改成 74 点 90 左右，然后重新执行我们的文件，你会发现我们会遇到一些问题。

所以我们需要把价格转换成浮点数，而不是整数。

这是解决这个问题的唯一方法，因为我们不想直接把价格转换成工业价格，因为它可能是浮动的。

因此，现在我们可以继续执行，您可以看到，现在它工作得很完美，虽然我们看到的价格是 100.0，但这是我们将来会研究的事情，但目前它工作得很完美。

现在我们准备进入下一个话题。

好了，现在我们已经完全理解了类方法，让我们继续，也理解一下现在建立的静态方法，metal show 为你做一些工作，这与类有一些逻辑联系。

例如，如果你想检查一个数字是整数还是浮点数，那么这是创建静态方法的一个很好的选择，因为这和我们使用的类有一些联系。

因此，检查一个项目的价格是否有小数点是有意义的，通过说有小数点，我显然会计算出那些零点。

老实说，你可能会觉得类方法中的 static 非常相似。

但是我们将很快解释主要的区别。

好，我将使用这些行来创建我们的第一个静态方法。

现在让我们继续使用 def 关键字。

我们将这个方法命名为下划线整数，因为我们说过我们想写一个静态方法来检查接收到的数字是否是整数。

现在，如果我打开和关闭括号，这显然会收到它自己，现在我想让你们仔细看看，如果我把这个方法变成一个静态方法，会发生什么，这个方法会非常类似于我们对类方法所做的，我们将使用一个称为静态方法的装饰器，这将负责转换。

所以我会继续使用这一行，我会说像这样添加静态方法。

现在注意接收到的参数是如何变成我们熟悉的常规橙色的，因为那只是我们接收到的常规参数。

这意味着这个静态方法永远不会在后台发送，实例作为第一个参数，这与类方法不同，类方法发送类引用作为第一个参数。

这就是为什么我们必须接受 CLS 奖。

这就是为什么它被故意染成紫色的原因。

但是对于静态方法，我们从不将对象作为第一个参数发送。

这就是为什么我们应该使用静态方法，就像一个普通的函数只接收参数，就像我们熟悉的孤立函数一样。

现在，我将用几分钟的时间深入探讨这个问题。

但是让我们先完成我们的静态方法。

所以它应该接收 num 作为一个参数，因为我们至少应该接收一些东西来检查它是否是一个整数。

好了，现在我们在这个方法里面了，接下来我可以用几个语句来检查接收到的参数是整数还是符号。

如果你还记得，我们说过我们想，我们会数出十进制的浮点数，也就是零点，好吗？意思是，比如 5.0 10.0 等等。

好了，现在我们理解了这一点，让我们继续使用 if 语句视图。

因此，如果在 in 中，我们将调用被称为 is 实例的内置函数。

这应该有两个参数。

我们可以理解这个函数将要为我们做什么，它将检查接收到的参数是一个浮点数的实例还是一个整数的实例。

所以我们将把 num 作为第一个参数传入，把 float 作为第二个参数传入，而不调用那些括号，所以只引用 float 关键字。

所以这个条件应该继续检查 num 是否是一个折叠数。

在这个 if 语句中，我会说 return num.is integer，所以通过说. is integer，我基本上是说计算出小数点后的浮点数。

这意味着，如果我在这里传入一个数字，比如 10.0，那么它将返回 false，但是请记住，它会传入这里，因为他认为这是一个缺陷，因为它是这样表示的。

因此，East amisco 访问应该检查该点是否为零，并相应地返回 true false。

现在，我还将在这里使用一个 else if 语句来检查它本身是否是整数。

所以我会说 l E 是 instance num，并检查它是否是一个整数的实例，然后我会返回 true。

如果只是别的东西，我会像那样返回 false。

那么现在我们已经设计了这个方法，那么我们来看看我们可以如何调用它。

现在我将删除这个和这个，我不会实例化任何东西，我只是向你们展示如何访问静态方法。

所以我将调用这个 item.is interview，我将传入一个数字，我想检查它是否是一个面试。

现在可以肯定的是，我们想把这个印出来。

所以我们会看到结果。

现在让我们继续前进，并在七年内通过。

所以，你可以看到我们现在接收 through，如果我传入 7.5，那么我会收到 false，后台发生的事情是，它进入这里，但它看到它不是一个整数，所以它返回 false。

但是如果我把它改成 7.0，那么这个会显示抱歉，它仍然会返回 true，因为它会进入这个条件，然后检查它是否是一个整数，但是我们说过这个方法会计算出 0 点的浮点数。

所以它仍然返回 true，这是一个完美的设计。

所以我想出了一个新的文件，我将在这里解释什么时候使用类方法，什么时候使用静态方法。

所以我们可以完全理解这两者之间的区别，因为我记得我自己很难理解为什么我需要这个，为什么我需要另一个。

所以这将是我将在这个 Python 文件中回答的主要问题。

所以不要觉得你必须复制和粘贴代码，按照我在这里解释的，通过倾听应该足够了。

所以在这个文件中，我将继续创建这个类项目，我们有权利，我将使用传递不接收箭头。

现在我们将使用静态方法。

因此，当我们想做一些不应该是每个实例唯一的事情时，我们将使用静态方法。

就像我们之前做的一样。

所以他的访问是一种方法，只是负责检查一个数是否是整数。

这就是为什么我可以允许自己把这个包含在 item 下，就像我可以把这个 def 作为一个独立的函数放在类的上面一样。

这也没什么。

但我宁愿不这样做，因为虽然这是一个与实例无关的金属，但在某种程度上与项目类有关。

这就是为什么你想创建一个静态方法，就像我们之前设计的那样。

你想创建一个类方法的原因是为了从你拥有的一些结构化数据中实例化实例。

正如我们所做的，我们创建了一个类 metal，它负责读取 CSV 文件并创建一些实例。

正如我在这里所写的，它们用于操纵不同的数据结构来实例化对象，就像我们对 CSV 文件所做的那样，我们也可以使用类方法，比如从 JSON 文件或从莫亚文件实例化，这些只是以最佳实践方式维护数据的不同方式，也就是您希望包含在类方法中的代码。

这就是它们应该存在于任何类中的原因，尤其是当你希望在程序中实例化数百个对象时。

因此，拥有至少一个类方法是个好主意，就像我们在 item 类中所做的那样。

现在，类方法和静态方法之间唯一的主要区别是，静态方法没有将对象引用作为第一个参数在后台传递，这一点很明显，我们没有特别突出紫色，在我的例子中是第一个参数。

如果你还记得，如果我在这里使用第一个基本参数，比如 num，你会看到这是第一个用橙色标出的参数，因为这是一个常规参数。

但那是紫色的，因为这是我们应该接收的强制参数，因为我刚才解释过了，这是静态方法和类金属之间的主要区别。

如果你还记得的话，我故意说了类方法和静态方法只能从类级别调用。

但是，这些也可以从实例中调用。

如你所见，我实际上可以实例化一个对象，并调用整数，实例化对象可以传入 5 个，我不会收到任何箭头。

如果我运行这个助手，你可以看到我没有出错。

现在，我要诚实地告诉你，我从来没有看到一个调用静态方法的理由，或者从实例级别调用类方法的理由。

但这只是一种选择，我知道这非常非常令人困惑。

但这是你很少会看到的。

就像我说的，我从来没有发现调用静态方法或者从实例中调用类方法的好理由。

所以我的建议是不要让你困惑，不要从实例级调用它们。

好了，我把我们目前为止在类项目中写的代码最小化了。

现在，为了开始解决我们将在这一集解决的问题，我将在这里创建两个实例。

所以我会说中一等于一个项。

而且姑且给它起个 JC phone v 10 之类的名字吧。

然后用一个随机的价格和数量。

我将复制并粘贴它，并在其中使用另一个变量，如 phone，我们将版本增加 10。

假设手机二的价格是 700。

好了，现在我们已经创建了电话的两个实例，请注意这两个项目是电话。

所以我们可以考虑一些可以代表现实生活中手机的属性。

想想像坏掉的手机这样的属性，因为我们可能有一些可能已经坏掉的手机。

所以我们不能把它作为一部真正能卖出去的手机。

这意味着我们可以继续说，一个坏掉的手机，假设我们现在手上不幸有一个坏掉的手机。

因此，我将继续为我们的第二个电话分配相同的属性。

既然我们已经得出了这个现实的属性，那么我们可以考虑的下一步是创建一个方法，继续计算实际上没有损坏的手机，这意味着用损坏手机的数量减去数量，因为这完全有意义。

然后，我们就可以了解哪些手机是我们可以在未来销售的。

但是我们有几个问题，创建一个方法，继续计算这样的东西，因为我们不能在我们的项目里面继续。

并且做得足够平滑，因为我们并没有真正地把坏掉的电话属性分配给 self。

实际上，我们不能在这个项目类中创建这个方法，因为这个方法对您将要创建的其他数百个项目没有用处。

这些只是代表一个电话类的项目。

因此，为了根据面向对象编程的最佳实践来解决这个问题，我们可以继续创建一个单独的类来继承 item 类带来的功能。

这正是我们可以从继承中获益的地方。

我们可以继续创建一个单独的类，我们称之为 name phone。

然后这个 phone 类将继承 item 类的所有属性中的所有方法。

让我们继续进行模拟。

因此，我还不打算删除实例，但我将在这里创建一个类，并将其命名为 phone。

现在注意我不会用分号，我会用那些括号，我会指定我想从哪个类继承。

所以我将继承第一项。

然后我会暂时使用一个 pass，因为我现在不想在这个类中使用额外的功能。

好了，现在我们已经创建了这个类，那么让我们继续，首先执行我们的程序，在第一阶段，实例将是项目实例。

这应该没有任何问题，因为我们知道我们可以创建这些项目实例，我们不会收到任何箭头。

但是如果我们把它们改成那样的电话，那么我们仍然不会收到任何箭头。

这只是一个基本的方法，你可以用继承来表示不同种类的对象。

现在，这也可以适用于其他房地产项目，你想拿出他们，并购买自己的。

但是在我的例子中，创建一些类是完全有意义的，每个类代表一种物品。

然后，我可以继续从每个子类中的 item 类进行继承，我将继续在将来创建这些子类，我还可以使用另一个类来处理类似于 laptop 这样的项目，然后我可以继续使用单独的功能。

现在，当我们谈论我们继承的类时，这些被认为是父类。

当我们使用从父类继承的多个类时，这些类被认为是子类。

所以这些只是当我们谈论面向对象编程时，你想熟悉的术语。

从这里，我们将看到更多高级的东西，您可以继续使用您的子类。

好的，现在让我们继续了解一些关于继承的更高级的东西。

现在，为了帮助本系列，我们了解到，一旦创建了这些实例，手动分配属性并不是一个好主意。

更好的方法是创建我们的构造函数，并传递我们想要的值，就像这里一样。

所以为了解决这个问题，我们需要想出如何去做，因为在这个 phone 类中创建构造函数将会很棘手，因为我们真的不想打破父类中的开发分数带来的逻辑。

但是我们还想传入一个额外的属性，比如坏掉的电话，我们将继续处理这个属性，并将其赋给 self 对象，就像我们在系列的第二部分中所做的那样。

所以为了保持这个子类的逻辑不变，并且接收更多的属性。

现在，我将继续复制构造函数中的代码，并将其粘贴到我们的 phone 类中。

这暂时是有意义的，因为当我们实例化一个实例时，我们收到了应该收到的完全相同的参数。

我们现在还可以控制接收更多的参数，就像我们想对坏掉的手机做的那样。

所以我们先说坏了。

我会滚动到这里，我会说坏掉的手机等于零。

让我们也接受一个默认值。

让我们继续输入损坏手机的确认信息。

所以我允许自己复制并粘贴这个。

我们将使用断言数量，我的意思是坏电话大于或等于零，我将把它改为这样的坏电话，实际上是坏电话，这应该与我们对数量所做的完全一样。

现在让我们继续到分配给自我对象的部分。

而我们可以用自己点的破手机等于那样的破手机。

您可以看到，这里我们有要执行的操作。

如果我们还能为 phone 类创建一个类属性，那就更好了。

这意味着我们可以在这里继续，说 all 等于一个空列表，然后我们可以继续，使用一个点加点的形式，就像这样。

如果我继续运行这个程序，你会看到我不会收到任何箭头。

为了检查这是否有效，我也要在这里传入一个。

我也要在这里做同样的事情。

我要把它们去掉。

好了，我要去掉硬编码的属性，程序仍然可以工作。

现在我也想通过应用我们目前为止在中写的一个方法来测试这个，这显然是我喜欢从父类中使用的方法，因为我们继承了那些方法。

所以我可以继续使用 phone one dot，计算总价，打印出来是有意义的。

所以我会把它打印出来。

您可以看到打印电话一个点计算总价。

现在如果我运行它，你会看到我收到了一个结果。

这意味着我没有任何箭头。

我不确定你们是否注意到了这一点。

但是如果我向上滚动一点，你会看到子类中的构造函数在抱怨什么。

让我们悬停鼠标，看看有什么警告。

现在你可以看到，它告诉我们，超类中的双下划线调用丢失了。

这意味着，当我们在子类中初始化双下划线 init 方法时，Python 会有意调用某个函数。

现在这个函数被命名为 super。

super 允许我们做的是，它允许我们完全访问父类的所有属性。

通过使用超级函数，我们不需要像我们对名称、价格和数量所做的那样，在属性赋值中进行硬编码。

以及其他的验证，我们每次想得到一个子类时都要执行。

现在想象一下这有多难。

如果对于我们将来要创建的每个子类，我们将不得不复制和粘贴 assert price 和 quantity。

在这三行中，除了赋予自我客体的东西。

这将是大量的重复代码。

现在为了节省我们的时间，这就是为什么我们需要使用超级函数，超级函数将允许我们从父类访问属性。

因此，当涉及到面向对象的程序时，我们将能够完全实现继承中的最佳实践。

现在，这个程序再次工作，因为我们在试用类中为销售对象分配了名称、价格和数量属性。

但是，如果我删除这三行，以及这两行，现在这两行恰好是我复制并粘贴的行，并尝试运行此程序，那么您可以看到我们收到属性错误 phone 对象没有属性 price，请注意它来自哪一行。

它来自 item 类的第 21 行，因为它认为它具有价格的属性。

但是我们在手机层面从来没有价格属性。

因为我们刚刚删除了自我点价格等于价格。

这就是为什么现在我们有一些问题。

我们将用下面我现在要执行的东西来替换我们已经删除的所有行。

所以我要去我们的构造函数的第一行，我要说调用超级函数来访问所有的属性斜杠方法。

然后我会说 super，net 我会打开和关闭括号。

然后我会像这样使用双下划线 init 方法。

现在你可以看到，当我完成这个操作的时候，这个子类中的构造函数就没有警告了。

您还可以看到，这些双下划线 init 方法需要一些特殊的参数。

这些特殊的参数显然来自我们继承的 item 类。

所以如果我在这里传递，名字，价格和数量，这应该没问题。

现在，你也可以问问自己，这是不是重复的代码，事实上我们也复制并粘贴了我们在子类中收到的参数。

是的，这是一个完美的问题。

这个问题可以通过更先进的技术来解决。

如果你听说过关键字论点，我们可以用这种方法解决。

然后我们就不需要复制构造函数的参数了，这不是我在这个阶段要展示的，我会坚持下去。

我现在就让它调用这个超级函数。

和 init 方法一样，它应该负责拥有和我们之前一样的行为。

因此，对于该打印行，我们仍然应该看到 2500，并且我们应该看不到任何箭头。

如果我运行这个程序，你会看到我们收到了预期的结果。

这样，我们为每个子类实现了面向对象编程的最佳实践，我们使用一个单独的构造函数，我们还需要调用超级函数，以便完全访问来自我们继承的类的所有属性和方法。

好的，我最小化了我们类的代码。

我还带走了一个泡沫的例子。

现在我想给你看以下事情的结果。

我会说 print，然后我会看到 item 类中的所有列表会带我们回来。

所以我要说 item dot all。

然后我还会说 phone，如果你还记得的话，我们在这里也实现了这个类属性。

所以我会把代码最小化回来。

然后我会运行我们的程序。

现在你可以在这里看到一些非常奇怪的东西。

然后我们基本上看到了来自 item 类的数组 PR 方法的结果。

发生这种情况的原因是，我们从来没有在表单类中实现 EPR 方法。

这就是为什么我们在项目的一般结果上看到这个。

现在您还可以注意到，我们只创建了 phone 类的一个实例。

这不是很好，我们在那些输出中看到项目。

所以我们称之为 use，而不是在 item 类的 rppr 方法中硬编码类名，然后我们一般访问类名。

现在，如果我用一些特殊的魔法属性来代替它，它将负责给我这个类的名字，那么这将是完美的。

所以我要删除它。

我要用花括号，我要说 self，点双下划线类，点双下划线名称。

所以这是从实例中访问类名的通用方法。

通过这样做，除了接收项目，硬编码字符串，然后我应该接收我从最开始初始化的类的名字。

这应该是 phone，因为这是我现在仅有的一个实例。

你可以看到这正是我收到的反馈结果。

所以这是完美的。

我之前说过，通过使用 super 函数，我们基本上可以访问所有的属性和方法，这些属性和方法来自我们继承的类。

这意味着什么，这意味着我们还可以访问项目类中所有内容的类属性。

我说的是这个属性。

现在为了展示这一点，我将从 form 类中打开代码。

我将删除旧属性。

我现在就要这么做。

我还将删除使用 form dot all dot append 执行的操作，因为 form 类中不再有旧属性。

如果我去掉这些，现在执行我们的程序，你会看到，我仍然会得到相同的结果。

因此，在子类中删除旧属性是一个好主意，在父类中只使用旧属性也是一个好主意，因为通过在子类中使用 super 函数，我们将可以访问旧属性。

所以这意味着如果有一天我们想要访问所有已经初始化的 items 实例，包括子类，那么从 item dot all 访问它们也应该足够了。

现在您可能会感到困惑，这一行是如何负责将这个实例添加到 all 属性中的，而这个属性恰好是一个列表。

发生这种情况是因为通过使用超级函数以及其中的，我们基本上在父类内部调用 in it 方法。

现在，在这个方法的最后一行中，我们还使用了 item dot all dot append，它也可以从 form 类中访问，这就是为什么从 item 类中调用 all class 属性是一个更好的主意，因为它将为我们提供完整的图片。

好了，在进入那一集的主题之前，我们需要在这里进行一些代码组织，因为正如你所看到的，对于我们将继续进行并在未来创建以扩展该项目的每个子类，我们需要在 main.py 文件中进行，因为这是我们正在处理的唯一一个文件。

现在我们的项目在增长，我们需要开始处理多个文件。

这就是为什么用一个文件来表示项目的类，而用一个单独的文件来表示外部子类会是一个更好的主意。

所以我们将 main.py 文件专用于创建这些类的实例。

所以让我们开始吧。

因此，我将转到项目目录并创建两个 Python 文件。

首先，我们将项目命名为. pi。

另一个应该命名为 phone.pi。

我将从我们的 item 类中取出代码。

我要把所有东西都拿走。

为什么，而下面，我要剪下这个，然后把这个粘贴到那个里面。

现在注意我使用的是 CSV 库。

这就是我需要这个图书馆的地方。

所以我要复制导入行。

这应该够好了。

现在，我将对 form . p . y 执行相同的过程，我也将把它复制到 form.py 文件中。

但是现在这个文件需要导入 item 类，因为如你所见，这里有一个箭头。

因此，我们应该说从项目，进口项目像下面的箭头应该消失了。

然后在 main.py 文件中，我们基本上可以使用这个文件来实例化实例，这意味着创建对 Python 有意义的数据。

这意味着我们可以从项目文件导入类，我们也可以从表单文件导入类。

然后我们可以继续做我们曾经做过的事情，我们可以说 item dot instantiate from CSV。

为了验证这种工作方式，我们还可以说打印和项目点都是这样。

如果我们现在想运行这个文件，看看它是否有效，那么我们可以这样做。

您可以看到一切都如预期的那样工作。

现在快速补充一下，我不会太依赖我们在最近一集创建的子类，为了显示我们在那一集要解决的问题，我会更多地依赖 item 类，这样更容易理解。

我们不会把事情搞得太复杂。

这并不意味着我不推荐使用子类或者类似的东西。

但是向你们展示我将在父类中展示的案例会更容易。

这就是为什么，例如，我临时删除了 form 类的输入行。

我刚刚想出了一个随机项目实例，名称是我的项目，价格恰好是这个数字，我没有指定数量，因为我们有一个默认值。

在这一行之后，你可以看到我用其他项目的字符串覆盖了这个属性。

现在，预期的结果不会让任何人感到惊讶，因为当我们打印这个属性时，我们看到了正确的时间。

但是我们可能会问自己，这是我们一直想要的行为吗？如果我们想限制我们的用户改变 name 的属性，一旦在初始化中设置了 name，意味着在那一行中？嗯，这是我们可能想要实现的关键属性，比如实例的名称，在我们的例子中，是项目的名称。

所以我们可以做的是，实际上我们可以创建只读的所谓属性，这意味着我们只有一次机会来设置项目的名称。

然后我们再也无法触及它的价值。

这意味着我们可以在初始化时设置它。

如果我们想覆盖它的值，我们应该有箭头。

当我们谈到面向对象编程的原理时，这也被称为封装，我将在以后的章节中更多地关注它。

但是现在让我们继续，看看我们怎样才能得到只读属性，怎样才能限制我们的用户在实例初始化之后覆盖这些属性。

好的，左边是 main.py 文件，右边是 item.py 文件，我们将在这个类中创建第一个只读属性。

现在你可以开始这样做的方法是首先使用一个装饰器，如果你还记得前几集的话，装饰器就像是你可以在另一个函数之前预执行的函数。

所以我可以使用属性装饰器，然后创建一个函数。

这是我可以设置只读属性名称的确切位置。

出于测试的原因，我们先把这个只读名字叫做，好吧，然后我会打开和关闭括号，这显然会收到 self，因为它属于每个实例。

现在为了测试的目的，让我们只返回一个随机的字符串，比如 a 三次。

好了，现在我们已经完成了，我可以转到我们的主 php 文件，尝试访问这个属性。

现在请注意，我将调用这些属性，而不是属性。

我将转到这里，尝试打印第一项，即姓名，现在我已经写了姓名，请注意只读姓名下拉列表中的不同之处，我们在左侧会看到一个完全不同的图标，它代表一个属性，在这里我们可以看到代表不规则字段的颤动。

所以如果我试着打印并运行我们的程序，那么显然我们会收到预期的结果。

但是如果我试图为只读名称设置一个新值，比如我们想把它改成这样，那么你会看到 Python 会对此有所抱怨。

即使我们尝试执行它，我们也会以一个异常结束，说属性错误可以设置属性。

这就是 Python 中所谓的只读属性的工作方式，你可以在函数之前使用属性修饰器来创建这些属性，然后返回你想返回的任何值。

现在，这里最大的挑战是将我们实际拥有的 name 属性转换成 read only 属性。

这将会有点挑战性。

不过，让我们继续努力吧。

首先，我要删除这三行，因为我们不会再使用这个属性了。

我将向上滚动一点，在这个构造函数下面工作。

因此，您可能认为将 name 属性转换为 read only 意味着一个属性就像首先使用 property decorator，然后继续说 def name，然后接收 self 作为参数一样简单。

然后使用类似于返回 self 点名称的东西，因为我们已经将 self 类型名称赋给了 self 对象。

但是实际上做这样的事情就像对那个类说，嘿，从现在开始，你将有一个名字属性，它将是 rain only。

这就是属性装饰器的效果。

因此，我将在这里留下一个如下所示的注释。

但是如果你还记得的话，我们试着在构造函数中把 self 点的名字设置成一个新的值。

所以你可以看到这个动作是非法的，因为我们在这里有一个只读属性。

因此，当您继续创建一个名为 basically name 的属性时，您通常可以设置这个值，您只能在您创建的任何实例中查看这个值。

这就是为什么如果我将鼠标悬停在这里，我们会看到一个箭头，表示不能保存属性名。

因此，解决这个问题的 pythonic 方法是在我们分配给 self 对象的实际属性名称前使用一个下划线。

通过这样做，我们获得了一些非常重要的东西。

首先，让我在这里加上下划线，就像这样。

然后现在我需要去我的属性函数，意思是属性。

我还需要在这里加上双下划线。

因为首先要做的是，我先为我的双下划线设置值，不好意思，单下划线的名字等于这个参数的值。

然后，我继续使用另一个只读属性，我有意地给出了 name 的名称，然后我返回 self 点下划线的名称。

现在我可以回到我的 main.py 文件，看看这些行现在对我们的实例有什么影响。

首先，我可以为我的项目设置一个名称。

我可以通过说“我不想要这个名字”来访问这个项目的名字。

所以我真的不需要继续使用 item one 点下划线的名字，因为那会有点难看，而且不方便。

因为访问属性时总是在前面加一个下划线，这对于您希望访问属性的每个实例来说都不太好。

在课堂上做一次就没事了。

但是试图在你的类之外访问那些属性，也就是说从实例中访问，并不会使它变得太漂亮。

所以这是克服这种事情的最好方法。

现在，如果我想打印它，那么，对不起，让我用一个点的名字来快速修正它，然后运行我们的程序，你可以看到它在工作。

现在让我们继续，看看我们是否能把我们的名字设置成和另一个类似的东西相等，看，如果那样的话，我能看到我不能设置那个属性。

但是无论如何，我仍然可以从实例级别看到这些下划线名称。

这可能是你希望避免的事情，如果我们能以某种方式完全阻止轴在这里使用下划线命名，那就更好了。

因此，实现这一点的方法是在属性名中增加一个下划线。

这可能会让你想起私有属性。

如果您熟悉编程语言，如 Java 或 C sharp，这与在这些编程语言中在属性前使用私有关键字的行为非常相似，在面向对象编程中有不同的原则。

总而言之，如果你在属性名中多加一个下划线，也就是说你使用了双下划线，那么你基本上就完全阻止了在类之外访问这些属性。

让我们来看一个模拟。

因此，我将最小化终端，并转到我的 item.py 文件。

除了在这里用，单下划线，我还要加一个。

然后我也要把它改成双下划线。

现在，如果我们转到 main.py 文件，让我们在这里使用一个点，尝试基本上使用双下划线并尝试访问 name，现在我们可以看到，我甚至没有从下拉列表中自动完成，因为我没有从实例级别查看该属性的权限。

当你想拥有一个干净的只读属性时，这就是你想要实现的。

这就是你可以做到的方法。

因此，如果我试图打印它，那么它只会抱怨在这个实例中它没有双下划线属性。

同样，如果我要删除那些双下划线，那么我将只把它作为一个属性来访问，意思是作为一个只读属性。

这正是我想要的。

好了，既然我们已经有了这个想法，那么我们可能仍然好奇如何为 name 属性设置一个新值。

显然，使用属性装饰器会将它变成一个只读属性。

但是仍然有一些 decorators 允许你为 name 属性设置一个新值。

让我们看看这是如何实现的。

所以很明显，这是行不通的。

因为它说不能设置属性。

所以我们可以使用一个新的方法，我们可以声明我们也想为这个属性设置一个新的值。

所以要做到这一点，就要去我们的课堂。

这里用了一个特殊的装饰器。

现在这个装饰器看起来像下面这样。

所以我要引用这个名字，因为这是属性名。

然后我将使用点设置器。

通过这样做，我基本上可以说，嘿，我还是想为这个名字设置一个新的值，尽管这是一个属性，意味着一个只读属性。

现在，如果我继续说，比如 def name，它会收到 self 和一个额外的参数，因为这个额外的参数应该指向我想设置的新值。

所以我会收到一个参数，我可以把它命名为 value。

然后在这里，我将只为我们的双下划线名称设置新值。

因为如果你还记得，当一个实例试图查看 name 的值时，我们基本上返回 self 点双下划线 name。

因此，当用户试图再次将名称设置为一个新值时，它应该执行 self dot name equals to value，通过这样做，我基本上允许我们的用户为名称设置一个新值。

现在让我们来看看这三行代码会对 main.py 产生什么影响。

你可以看到，现在箭头消失了，我现在可以到这里，使用打印项目一个点的名称。

这是可行的，我可以看到我有其他项目。

这意味着，我不仅可以为我的下划线名称设置一个新值，在初始化时也可以这样做，如果我在这里只使用这个约定的话。

现在那些 getters 和 setters 的东西在你工作的普通编程语言中总是令人困惑。

因此，我将对到目前为止我们所学的内容做一个总结。

好吧。

所以使用 add property，基本上可以让你控制，当你得到一个属性时，你想做什么。

如果我没有在这里实现这些 setters，通过使用这个，你基本上把这个属性转换成只读的。

现在你可以看到，当我把这些注释掉的时候，这一行会有一些问题，因为如果不这样做，我基本上就是说，嘿，name 是只读的，你不能设置它，如果我再次取消这些注释，那么我就可以控制把这个属性设置成我想要的任何属性，通过在这里使用这个语句，基本上得到这个属性，然后我基本上调用在这里执行的一堆代码。

所以每当我使用 item one 点名称时，Python 就会对自己说，好吧，你试着得到那个属性。

所以，我会继续，试着执行这里所有的代码行。

这就是这里发生的事情。

为了向您展示这一点，我可以在这里使用一个随机打印函数，它会说，您正在尝试获取这样的名称，然后您应该会看到在实际值之前打印的这一行。

因为首先，我们打印你试图适合的名字，然后我们返回 self 点下划线的名字，所以它打印在这里。

这就是当你试图获得一种态度时发生的事情。

但是当你试图设置一个态度时，Python 会对自己说，好吧，那么在这里，你尝试设置一个属性。

因为你设置了一个属性，所以我应该继续执行这里的代码，因为这是那个属性的中心。

这就是为什么当你继续使用这个装饰器时，你应该总是收到一个参数，因为另一个项目将作为参数传递给那个参数，理解这一点非常重要。

这就是为什么我只能允许我自己使用一行代码，告诉自己点双下划线的名字等于你试图设置的新值。

为了再次向您展示这一点，我可以在这里说，您试图在这一行中设置的打印应该出现在这一打印行之前，因为最初我试图为 name 设置一个不同的值，然后我就像这样打印它。

好的，如果我运行它，那么你可以看到，首先我们看到你试图设置的线，然后在它之后，我们实际上看到一个点名称等于什么。

之所以设置这个值，是因为我们在这里设置了它，然后下一次我试图获取这个值时，这些行就会被执行。

这就是 getters 和 setters 的生命周期。

这就是它的工作方式。

当你设置一个新值时，通过控制你想做的任何事情，你也可以限制它，你可以继续做一些调整，或者你可以继续提出一些异常。

如果您不喜欢收到的值，假设您想要限制属性名称的字符长度。

好的，这是你可以做的事情，你可以在这里说，如果当值大于 10，那么你想提出异常，这将会像你的，名字太长，之类的话。

然后你可以说 else，然后你可以执行负责设置这个值的代码行。

所以我有意让它保持原样，因为它的长度是 9 个字符。

所以我们不应该有任何箭头。

但是如果我在这里添加两个字符，就像那样，然后执行，那么你可以看到我们会收到一个异常，它会说这个名字太长了。

这就是 Python 中 getters 和 setters 的工作方式，现在您将拥有使用不同属性所需的所有知识，并以您喜欢的方式管理它们。

所以我相信，在那一集里你得到的信息之后，你就拥有了成功管理你的属性和使用它的一切，以及拥有多重属性的丰富的类。

然后，您可以为这些属性设置特殊的行为。

你也可以决定不在构造函数中强制接收这些属性，你可以决定删除构造函数中的一些参数。

你可以这样说，当你创建一个实例的时候，你不会想立刻把它们赋给 self 对象。

所以不管你喜欢什么，你有没有所有的工具来管理你的属性，面向对象编程有四个你应该知道的关键原则。

所以你会明白你应该如何设计你的大型程序，这样就更容易继续开发它。

我将会谈到封装、抽象、继承和多态这些原则。

所以第一个原则是封装。

我们稍后会谈到这一点。

所以封装指的是一种限制直接访问程序中某些属性的机制。

现在请注意，我们在最后一部分做得非常好，我们在项目中实现了封装原则。

所以请注意，在 name 属性经历我们在这里设置的一些条件之前，它不能被设置为新值，比如字符长度小于 10 个字符。

因此，限制在鞍内覆盖对象值的能力，正是封装原则的意义所在。

现在，为了给你一个更好的封装原理的例子，我们将把类似的东西应用到一个额外的属性上，这个属性就是价格属性。

现在，如果你快速浏览一下我刚刚执行的程序，你会发现我可以直接把这些对象设置成我喜欢的任何数字，这里也可以是-900。

因此，这可能是我们希望改变的事情。

我们可以通过实现一些方法来限制对 price 属性的访问，从而改变这种情况。

所以如果我们有两个方法，可以负责增加这些价格的百分比，那就好了。

折扣也是如此。

如果还记得的话，我们已经提出了一个类似的方法，当我们谈到类别属性时，看起来像是应用折扣，因为 self dot pay rate 乘以实际价格实际上会将该属性减少 20%。

因为付费率设置为 0.8，如果您还记得前几集，那么让我们继续设计这个价格属性，以完全支持封装原则。

首先，我要把这个奖转换成一个私有属性。

因此，避免像我们之前看到的那样直接设定价格将是一个很好的开始。

现在我不会在这里加双下划线，除此之外，我会抓住整个东西。

我将右键单击，然后我将说“重构”,“重命名”,然后我将通过像双下划线那样设置来重命名此价格，现在这样做实际上是要在我们尝试访问价格属性的整个类上重构此更改。

所以这是一件好事。

所以我们不需要到处都改变。

完成后，如果我们还看一下“应用折扣”,那么您可以看到我们将它设置为一个新的变量名。

既然我们已经完成了，那么让我们继续创建一个属性。

因此，我们将能够暂时访问只读的价格属性。

所以我要说添加属性。

然后我会说 def price，然后我会返回 self dot price。

因此，这是限制对价格属性的访问的一个很好的开端，因为现在我们仍然可以访问价格属性。

然后我们不能设置它。

因此，你可以看到，如果我们试图访问项目一点价格，我们会有一些错误，但我们可以访问来自初始化的实际值。

实际上，我看到我们遇到了一个错误，写着递归错误，这可能是因为我没有在这里加双下划线。

这实际上是我们现在遇到的一个很大的异常，你可以看到我们将遇到递归错误，超过了最大递归深度。

这是因为我试图返回不带双下划线的价格。

如果我们试着调用 self 点价格，那么它会试着调用这个函数。

如果我们试图返回它，它会再次循环。

在某个时候，它会因为递归错误而失败，就像你看到的。

所以这实际上是我们看到的一个很大的例外。

现在，如果你在你的面向对象程序中看到这个异常，现在你知道如何处理它了。

如果我现在回到缅因州并执行它，那么你可以看到预期的结果在这里。

好了，现在我们已经完成了这个，那么让我们回到我们的类，尝试修改双下划线价格的属性。

所以我会从这里切下这块金属。

我会把它放在我们得出的房地产价格下面。

所以我们会有一个更干净的外观。

首先，你可以看到我们有应用折扣。

我们还想做一层。

像下面这样递增。

这里我们想说，自点双下划线价格等于自点级别下划线价格加上自点级别下划线价格乘以我们可以作为参数接收的某个值。

所以我们实际上可以接收一个参数，我们可以把它命名为 implement value，然后我们可以把它乘以这个数。

既然我们想到了这个，那么让我们来测试一下。

好了，我要回到我的主页了。

然后我把它叫做一点应用增量，然后我就传入 0.2。

因此，我们将 750 的值增加 20%。

现在，下次我访问项目 one dot price 时，我们应该能够看到 price 的实际值，应该是 900。

如果我运行它，那么你可以看到价格已经增加到了 900 美元。

这实际上就是封装，因为您不允许直接访问价格属性。

此外，您还可以使用应用增量或应用折扣等方法来修改该属性。

如果我现在继续，使用 item one dot apply，discount，也会发生同样的情况，你可以用你喜欢的方式修改这个方法。

但这目前指的是我们在这里使用的类属性。

所以这应该也是，对 900 的价格打 8 折，我们应该能看到 720。

这正是这里正在发生的事情。

好的，我要讲的下一个原则叫做抽象。

抽象是面向对象编程的概念，它只显示必要的属性，隐藏不必要的信息。

现在抽象的主要目的基本上是对用户隐藏不必要的细节。

现在，我所说的看到用户，基本上是指像我或你这样的人，他们将使用 item 类来创建一些 item 对象。

现在我们可以看到，现在我们有了一个新的程序，它有一个项目对象，它的名称是我的项目价格是那个数字，我们有六个来自这个项目。

现在我们也可以看到我想出了一个其实并不存在的方法，叫做发送邮件。

因此，该方法在一天结束时应该发送一封电子邮件给想要决定该项目的人。

它会发送信息，告诉我们通过出售所有项目可以赚多少钱，也许还会发送一些与此项目相关的更多信息。

现在发送电子邮件不再是简单的打电话那么简单了。

因为在后台，发送电子邮件需要经过很多过程，比如连接到 SMTP 服务器。

并且在邮件正文中准备一条自动消息，显示关于这个项目的一些信息。

因此，正如我们所理解的，在我们继续之前，我们必须经历许多新的方法，并且只调用一个发送电子邮件的方法。

为了模拟这种情况，我可以说“发送电子邮件”。

所以我只创建必要的方法。

暂时我会用 pass。

正如我所说，我们还必须经历许多其他过程。

所以为每个进程创建方法是一个好主意，比如连接到一个 SMTP 服务器。

我只说 pass，因为我们在这里只是试图模拟抽象的概念，我并不是真的要给某人发送实际的电子邮件，我只是模拟发送电子邮件的想法。

我们还必须为自动邮件准备正文准备一个正文，然后我可以返回一个格式化的字符串，类似于 hello。

有人说，我们也可以接收这个参数。

然后我们可以说，我们有自己的点名，六次，对，所以应该是六次。

所以数量倍于此，然后我可以说问候刮胡子。

这只是一封非常简单的电子邮件，我们可以发送给某人。

现在我们可以理解，我们必须在同一个电子邮件中调用这些方法。

因此，模拟将自我点连接，然后自我点，准备身体。

可能我们还需要把它发送出去，所以我们可以这样说，发送到这里，然后我们传递它。

现在，您可以看到，这些金属最终只会从发送的电子邮件中调用。

因为这些只是电子邮件发送过程的一部分，这是一个更大的过程，我们在本课程中将其分为多个步骤。

现在最大的问题是，我们将从实例中访问调用这些方法。

这正是抽象的意义所在。

抽象原则告诉你应该隐藏实例中不必要的信息。

这就是为什么通过将这些方法转换成私有方法，我们实际上应用了抽象原则。

老实说，这在 Python 中是可以实现的，虽然不太方便，但通过添加双下划线是可以实现的。

同样，在其他编程语言中，这可以通过为方法设置访问修饰符来实现，比如 private 或 public。

而且我说的是 Java，C sharp 等编程语言。

因此，如果我们要将这些方法转换成私有方法，只需要添加下划线，那么这些方法从类的层次上来说，也就是在类内部，就变得很冷了。

因此，如果我们试图访问它，那么你可以看到我将有自动完成，这意味着我将有能力访问这些方法。

然后我会对其他方法做同样的事情。

这个箭头来自这里，因为我们没有指定任何参数，我将添加一个空字符串。

现在，如果我回到我们的 main.py 文件，你会看到我们会遇到一些麻烦。

即使我试图用双下划线来访问它，我也不会有自动完成。

原因是因为这是一个私有方法。

所以，如果你想让你的方法在你的类之外，也就是从实例中可访问，你真的必须考虑你的方法。

这正是抽象的意义所在。

您希望抽象出不需要调用或从实例中访问的信息。

好的，继承是面向对象编程的第三个原则。

继承是一种允许我们跨类重用代码的机制。

这是我们在整个课程中设计得非常好的东西，因为我们提出了更多的类，它们是 item 类的子类，每个子类代表一种项目。

现在请注意我是如何将导入行从 phone import 改为 from 的，我使用了 item 的子类，这是我们想出来的，称为 phone，你可以看到我在传递类似的参数，它们仍然可以使用在父类中实现的代码。

如果我们执行这个程序，那么我们不会遇到任何问题。

因为 phone 使用它从 item 类继承的所有方法和属性，而 item 类就在这里。

如果我们还记得，我们在父类中设计了 Send Email 方法，我们可以从电话实例中使用它，我们也可以对我们提出的其他方法这样做，这些方法确实会影响一些属性，如采访中的属性。

封装部分，我们应用了接收增量值的应用增量方法。

如果我们要测试这个增量，价格增加 0.2，然后打印一个点的价格，那么我们应该看到 1200。

如果我们把它打印出来，你会看到这就是结果。

这就是遗传的主要内容。

它是关于在所有类中重用代码。

这正是这里的情况。

这背后的美妙之处在于，你可以提出更多的子类，代表笔记本电脑、键盘、相机等你会想到的所有东西。

然后你可以修改特定的方法来调用你所拥有的那种项目。

这很好地描述了遗传的含义。

好的，我们现在的最后一个原则是多态性。

多态性是编程中一个非常重要的概念。

它是指在不同的场景中使用单一类型的实体来表示不同的类型。

现在，这个定义的一个完美的例子，是一些我们已经知道的存在于 Python 中的函数。

现在快速补充一下，多态指的是多种形式，保利是多种形式，态射是多种形式。

所以，在我们的程序中应用多态性的想法是有不同场景的能力，当我们调用完全相同的实体时，一个实体可以是我们刚刚调用的函数。

现在，正如你所理解的，多态性并不是特别适用于你如何创建你的类。

这实际上是指你的整个项目。

在接下来的几分钟里，我们将会看到一些没有应用多态性的不良实践。

我们还将看到多态在 Python 中的完美应用。

所以多态性应用的一个很好的例子，是在内置函数中。

因为 Python 中的 land building 函数知道如何处理作为参数接收的不同类型的对象，并相应地返回结果。

正如你在这里看到的，如果我们在一个字符串中使用 Len 内置函数，那么我们将得到所有的字符。

但是如果我们在一个列表中这样做，那么我们不会在这里得到整个表达式的字符长度。

此外，我们将收到列表中元素的数量。

为了向你们展示这是如何工作的，我将运行这个程序，当然，结果和预期的一样。

因此，正如多态的定义所说，正如所料，它只是一个知道如何处理不同类型对象的单一实体。

好吧。

既然我们已经了解了多态在 Python 中无处不在，尤其是在 land building 函数中，那么让我们也了解一下它在我们的项目中是在哪里实现的。

现在我们可以看到，我尝试调用了 apply discount 方法，该方法从未在 phone 类中实现。

事实上，我可以在 item 类中使用它，因为我们继承了这个类。

这是最基本的原因。

现在，如果我返回到主. php 文件并运行它，那么您可以看到它将会工作，因为 apply discount 是一个我可以从继承的 item 类中使用的方法。

这正是多态也是不作为的原因。

因为多态性又指的是一个可以用于多个对象的单一实体。

现在，如果有一天我继续前进，创建更多种类的项目，这意味着更多的类将代表不同种类的项目，并从它们调用应用折扣方法，这也将是可行的，因为应用折扣是一种方法，将可从所有种类的对象访问，所以这就是为什么你可能听说过继承和多态结合在一起的术语。

现在为了向你们展示这一点，让我们试着再创建一个与 phone 类相同的类，对了，我要创建一个键盘文件。

然后我就在这里说，同学们。

你知道吗，在此之前，让我们去电话，从这里复制所有内容，然后像这样粘贴。

我要把这些线去掉。

我将保持 init 不变，我将把类名从 phone 改为 keyboard，我还将删除我们不需要坏电话的属性。

好了，现在我们有了这个，然后我实际上可以前进到我的主. php 文件并使用一个更重要的行，它将说从键盘导入键盘，然后我将把它改为键盘将替换这个名称，只是为了使它更真实，然后我将运行相同的问题，你可以看到这是可行的。

这也是多态性发挥作用的地方，因为我们可以从不同种类的对象中使用这个单一的实体，它知道如何正确地处理它。

现在，通过说正确处理它，我的意思是，你现在可以控制你想在你的类中应用多少折扣，因为如果我们去键盘并使用一个类属性，就像我们在项目类中使用的支付率一样，那么我们将完全控制所有将应用于键盘的折扣。

向你们展示我将尝试输入工资率。

你可以看到，我甚至有自动完成功能，因为在子类中覆盖是合法的，所以我可以说支付率等于 0.7。

就这样了。

现在我所有的键盘都有相同的折扣金额。

如果我再次运行 main.py 文件，那么您可以看到结果正如预期的那样，我们看到 700。

这就是继承和多态背后的美妙之处。

如果我们决定要 50%的折扣，这也是肯定的。

所以我只需要说支付率等于 0.5。

仅此而已。

所以我希望你们现在对多态性有了更好的理解。

现在，简单地补充一下多态性是非常酷的，我们通过使用抽象类来实现。

这和在其他编程语言中使用接口的方法是一样的，比如 Java 接口是一种你可以实现一个类应该如何被设计的方法。

好的，这就像是一个课程的模板。

这可以通过使用抽象类来实现，我不打算在那一部分讨论。

但是，就像我说的，多态性是一个术语，在整个 python 编程语言的不同领域都有实现。

所以我希望你在学习面向对象编程课程的过程中过得愉快。

现在你有了很多工具，你可以继续前进，并尝试在你的项目中自己实现，这将真正帮助你作为开发人员进入下一步。

下次见。