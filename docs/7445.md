# 看看这些对初学者友好的 React 单元测试模式

> 原文：<https://www.freecodecamp.org/news/unit-testing-patterns-for-react-720a8275873b/>

依楼下盖奇

![1*JIQ0Vp6gRaNr40h4wDw7GA](img/c489f5852d08f79dc5eed51fc17a865a.png)

# 看看这些对初学者友好的 React 单元测试模式

测试 React 组件有许多框架甚至更多的方法。但是根据我的经验，不管您喜欢哪种测试框架(尤其是如果您刚刚开始了解 React)，了解一些模式都是非常有用的。所以这里有 5 个与框架无关的 React 单元测试模式。

[Alex Moldovan](https://www.freecodecamp.org/news/unit-testing-patterns-for-react-720a8275873b/undefined) 几天前发表了一篇关于 React 当前模式的[的伟大文章](https://medium.com/@alexnm/evolving-patterns-in-react-116140e5fe8f)。我最喜欢的是他处理问题的方式。你看，由于 React 是如此的独立，一个通用的风格指南并不适合这个社区(当[约翰·帕帕](https://www.freecodecamp.org/news/unit-testing-patterns-for-react-720a8275873b/undefined)为 AngularJS 出版他的风格指南时，我们看到了完全相反的情况)。

Alex 通过提供对初学者和更有经验的开发人员都有用的模式来解决这个问题，而没有说明一种“真正的”做事方式。

因此，作为他工作的继续，这里有一些我认为在为 React 组件编写单元测试时有用的模式。

首先:我应该测试什么？

每次我教授单元测试的基础知识时，都会有人问同样的问题:“我应该根据什么来编写测试？我的测试应该检查哪些情况？”用一句话回答所有可能的情况是很难的，但是在 React 的情况下就稍微容易一些。

您将使用的大多数组件都是无状态的，因此可以简单地将它们视为纯粹的函数:它们获得一些参数作为道具，并返回一个呈现的组件。因此，在这种情况下，上述问题的答案是:“检查不同的输入组合是否会产生正确的输出。”如果你问我的话，我会觉得这更容易理解和执行！

只是要小心:如果你在一个组件中看到 *this.state* ，这意味着它是有状态的。因此，除了前面提到的事情之外，您还需要编写针对状态突变的测试。

**#1:属性类型**

在大多数测试框架中，当没有提供 prop 或者 prop 的类型不正确时，就会抛出警告。出于某种原因，许多人忽略了这些，让它们堆积起来，从测试的角度来看，这些 PropTypes 毫无用处。

支持这样做的一个论点是，这些错误将在运行时作为错误出现在浏览器控制台中，因此没有理由在测试中提供所有需要的道具。

根据我的经验，虽然上面的陈述是正确的，但是这种方法有一个主要的缺点:一些错误和 bug 只能在运行时发现，而不能通过运行测试来发现。这也是我们编写单元测试的原因之一:这样我们就不必在运行时手动检查所有的东西。

如果您使用的是 TypeScript 或 Flow 之类的类型系统，这可能不适用于您，因为在这种情况下，编译时会抛出错误。这是一个很大的优势，在决定使用这些工具时应该考虑到这一点。感谢 [Liran Tal](https://www.freecodecamp.org/news/unit-testing-patterns-for-react-720a8275873b/undefined) ，指出这一点！

在单元测试中忽略设置一个 prop 并不是我们应用程序中的一个错误，那么我们为什么要费心正确地完成 PropTypes 契约呢？答案很简单:因为它有助于保持测试的健康。在组件中添加一个 prop 将导致测试中出现 PropType 警告，从而警告我们我们的测试没有覆盖所有情况。改变 PropType 的类型也是如此:如果在我们的测试中抛出警告，这意味着它们需要更新。

这种方法的唯一缺点是测试中的道具需要保持最新。接下来，我将讨论我更喜欢的做法。

**#2:可重复使用道具**

当测试一个 React 组件时，大多数测试用例都需要一组特定的道具来支持组件。最直接的方法是为每个包含所需道具版本的测试用例创建一个常量。

这种解决方案的问题是，很少会出现所有提供的道具都与给定的测试用例相关的情况。大多数时候，它们只是为了确保组件的正确行为(并满足 PropTypes)。

复制和粘贴这些额外的道具很麻烦，容易出错，并导致代码臃肿，难以阅读。

为了避免这种情况，我倾向于使用一个全局 props 常量，并在必要时使用 spread 操作符扩展它。

这种模式有三个主要好处:

*   不需要复制粘贴，代码更简洁，没有膨胀
*   属性类型总是正确地实现
*   测试的可读性增加了，因为给定测试用例所使用的道具被突出显示了。只要看看道具的定义就够了，看看在那里测试的是哪种情况。这就是为什么我喜欢在测试用例中重新定义一个属性，即使它在全局 props 对象中有相同或相似的值。

这种模式的一个变体也使用全局 props 对象。但是它不是总是为每个测试用例创建一个新的对象，而是不断地改变全局对象以适应当前的需要。我觉得这种溶液太脆弱了，不合我的口味。但是我最大的问题是它导致测试相互依赖，导致严重的性能问题，因为这些测试不能并行运行。

**#3:浅渲染**

一般来说，单元测试的一个挑战是编写测试给定单元的代码，而不是测试它的依赖关系。就像在任何像样的生态系统中一样，当我们想要模仿或存根 React 组件的依赖关系时，我们有大量的选项。

其中一个库使用了如此简单而优雅的解决方案，我认为它应该成为所有 React 单元测试的一部分。这个文库叫做[酶](https://github.com/airbnb/enzyme)。它是由 [AirbnbEng](https://www.freecodecamp.org/news/unit-testing-patterns-for-react-720a8275873b/undefined) 那边的好心人做的，我说的特点是浅渲染。

浅层呈现基本上是一种呈现 React 组件而不呈现其子组件的方式，从而使测试独立于这些子组件。

我给你举个例子。假设我们有一个名为 *TextAndButton* 的组件，它有一个名为*按钮*的子组件:

当 *TextAndButton* 在浏览器中呈现时，它的子组件也被呈现。所以最后它会看起来像这样:

但是，当您进行浅层渲染时，子组件保持原样:

这样，如果*按钮*有任何依赖关系，它不会被拖入渲染。更好的是:父组件不需要知道它的子组件的任何信息。

除了明显的性能优势之外，我喜欢这种方法，因为它简化了心智模型，并清楚地表明应该在哪里测试什么。

在我们的例子中，对 *TextAndButton* 的测试应该只检查是否将正确的动作传递给了*按钮。但是我们并不关心它实际上做了什么，比如显示正确的文本或者在需要的时候实际调用提供的函数。*

除此之外，您的测试将更加健壮，因为更改子组件不会破坏为父组件编写的测试。

虽然我可以想象出一些浅层渲染不是最好的方法的例子，但总的来说，我认为它可以而且应该用于所有的组件测试。

**# 4:Redux reducer 和 Action Creators**

React 的哲学深受函数式编程的影响，Redux 也是如此。所以不要被所有像“reducer”和“action creator”这样花哨的名字吓到:这些只是有特定用途的常规、纯粹的函数。

Redux 的流行部分是由于它的简单性。这就是为什么每当我看到项目使用过于复杂的 reducer 和 action creator 测试模式时，我都会感到惊讶。

根据我的经验，将还原器和动作创建器作为函数进行单元测试已经足够了。检查它们是否为给定的输入返回正确的值(例如，一个 reducer 应该为给定的输入状态和动作返回正确的状态对象)，就这样。做任何更多的事情，比如模拟动作或者在模拟商店上实际调度它们，都是多余的——这样，您最终会测试 Redux 本身(除了您的单元之外)。

不要相信我:[官方 Redux 测试文档](https://github.com/reactjs/redux/blob/master/docs/recipes/WritingTests.md)使用同样简单的、基于功能的方法。

另一方面，如果你的目标是创建集成测试来发现是否所有东西都连接正确，那么模拟动作也没什么错。但是重要的是不要混合单元测试和集成测试，所以相应地使用这种模式。

**#5:不测试 DOM**

根据我的经验，编写脆弱的单元测试几乎和不编写一样糟糕。如果一个单元测试在不应该的时候中断了(当单元的实际行为没有改变的时候)，它会消耗掉时间，直到开发人员修复脆弱性(花费额外的时间和精力)或者更糟的是仅仅注释掉它。

有很多方法可以为 React 组件编写脆弱的测试，但是有一种方法我见过很多次，它非常容易避免:针对 DOM 编写测试。

举个简单的例子，断言 DOM 就是检查给定组件的子组件数量。在我看来，这不是一个有用的测试，因为当我们真正破坏组件时(例如通过将密码字段切换为常规文本输入)，它不会失败。但是当我们进行微小的、不间断的调整时，它会断开(比如将文本放在一个 *span* 标签中)。

测试 DOM 的另一种方法是通过“继承”来查询组件中的某些元素，即遍历“子-of-child-of-sibling-of-child”链。一个给定的组件是如何在内部构建的，不应该进行测试，因为它改变得太频繁了，更重要的是，因为它没有附加价值。

选择专门的、类似 CSS 的查询，只针对您感兴趣的元素。同样，像 *div span img* 这样的查询不是一个好主意。请改用不依赖于 HTML 结构的基于类的查询。

**最终想法**

测试 React 组件，尤其是使用最新的工具，轻而易举。不要因为最初的困难和开始时花在谷歌上的几个小时而气馁。如果你坚持写高质量的测试，你将会赢回十倍的时间。

别忘了:你不仅是在帮助你未来的自己，也是在帮助你的用户，他们会很高兴能更快、更无错误地收到这些很酷的新功能。