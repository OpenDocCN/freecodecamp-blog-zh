# 了解如何解决编码面试回溯问题

> 原文：<https://www.freecodecamp.org/news/solve-coding-interview-backtracking-problem/>

回溯是一种算法技术，常用于解决复杂的编码问题。它考虑在每一个可能的组合中搜索来解决一个计算问题。编码面试问题有时候可以用回溯来解决。

我们在 freeCodeCamp.org YouTube 频道上发布了一个完整的课程，教你如何解决回溯问题。

Lynn Zheng 教授这门课程。她是 salesforce 的软件工程师，也是一名优秀的教师。

在这个速成课程中，你将学习一般原理，还将学习解决两个 LeetCode 难题。

观看以下全部课程或在 freeCodeCamp.org YouTube 频道观看(1 小时观看)。

[https://www.youtube.com/embed/A80YzvNwqXA?feature=oembed](https://www.youtube.com/embed/A80YzvNwqXA?feature=oembed)

## 副本

(自动生成)

Lynne 是 Salesforce 的一名软件工程师，也是一名优秀的教师。

本课程将教你如何解决回溯问题，回溯问题在编码面试和挑战中很常见。

大家好。

我是符晓薇。

我是一名软件工程师，业余游戏开发者，刚刚从芝加哥大学毕业。

欢迎来到这门解决回溯问题的课程。

无论你是 coda 访谈的新手，还是已经有过回溯问题的经验，这都是适合你的速成班。

我们将学习一个通用的模板，它可以帮助你解决任何类型的回溯问题，我们将把这个模板应用到 ko 问题上，比如八皇后问题，或者数独解算器问题。

当我为我的游戏开发算法时，或者甚至在我研究一个非凸优化问题时，这正是我用来解决编码问题的模板。

我希望您对此感到兴奋，让我们开始使用这个多功能的模板吧。

你可以在我的 GitHub 中找到这个模板，只是在下面的视频描述中有链接。

让我们从回溯问题中的一些关键词和概念开始，这将有助于我们更好地理解模板。

第一个关键字卡住了。

本质上，回溯问题是要求你找到一个有效的状态。

以我们稍后将在本视频中解决的 N 皇后为例。

一个国家的例子就是在一个 n 乘 n 的棋盘上任意放置 n 个皇后。

例如，这里我们将四个皇后放在一个四乘四的棋盘上。

相反，一个有效状态的例子要求蚁后被放置在不能互相攻击的地方。

如果你不熟悉国际象棋的规则，不要担心。

女王的神话很简单。

女王可以水平、垂直或斜向移动。

因此，为了使 N 个皇后的替换有效，它们不能站在同一行、同一列或两条对角线上。

那么我们如何构建这样一个有效的状态呢？嗯，我们是从以前的状态建立起来的。

假设我们从一张白纸开始，在一块没有皇后的棋盘上，我们可以任意放置我们的第一个皇后。

假设我们把它放在这里。

那么我们可以在哪里放置第二个查询，你可以看到现在我们的选择是有限的。

或者用背景术语来说，我们的候选态是有限的。

因为我们把第一个皇后放在这里，这一整列，这一整行，两条对角线对新皇后不可用。

假设我们把第二个皇后放在这里。

接下来，我们试着看看第三个皇后在哪里。

我们的候选人现在更加有限，因为我们把第二个皇后放在这里，这一列，这一行和这条对角线不可用。

所以我们的第三个女王只能去这里。

最后，让我们放置第四个皇后。

因为第三个皇后在这里，它挡住了这条对角线，这一行和这一列，留下第四个皇后在这里。

太好了。

现在这种全局布局是否是有效的解决方案，使得没有女王可以互相攻击？我们已经在支票上看到了。

像这样，我们找到了一个有效的方法来解决这个问题。

作为一个反例，考虑一下如果我们像这样放置前两个皇后。

现在，所有这些用红色标记的细胞都是可用的，我们只剩下一个给第三个女王，并且知道在哪里放置第四个女王。

这意味着状态搜索的成功不能导致有效的解决方案。

这基本上就是关于状态的问题，确定构建下一个状态的候选对象，并验证最终的解决方案。

现在让我们看看这些过程是如何在我们的模板中定义的。

我们的模板中有四个函数。

前三个，以及状态候选，搜索我们的助手函数。

最后也是最重要的一个，也是我们节目的切入点。

唯一的函数确实是一个小问题要求你写的函数。

它负责返回有效的解决方案。

让我们一个一个地看一个助手函数。

这个函数获取一个状态并返回一个布尔值。

它验证了一个状态是否可以作为我们的皇后问题状态的最终解决方案是一个经过验证的解决方案。

如果所有的 n 个皇后都被放在一个棋盘上，并且没有一个能互相攻击，得到候选人。

该函数查找可用于构建下一个状态搜索的候选列表。

这是一个递归函数。

它导致了前两个助手函数，并检查状态是否是我们回溯问题的有效解决方案。

如果是，它会通过制作该状态的深层副本来记录解决方案。

请注意，我们确实需要一个深层副本和一个浅层副本，因为随着搜索的进行，我们将继续修改状态。

但是我们需要有效状态的静态快照。

这条返回线被注释掉了，因为根据问题的性质，我们可能需要找到所有有效的解决方案，或者只找到一个。

如果我们只需要一个，我们一找到就可以回来。

否则，我们继续下去，直到我们用尽所有可能的搜索状态。

继续往下走。

如果这个州还不是一个有效的解决方案，我们会寻找候选来建立下一个州。

回想一下，候选人返回候选人列表。

对于每一个，我们将候选人添加到状态。

在一个测验问题中。

例如，假设我们的州只包含第一位女王的位置。

这里我们为第二点添加一个候选位置。

现在，我们将获取这个修改后的状态，并通过在这个修改后的状态上调用 search 方法对其进行递归。

如果修改后的状态有效，则记录该解决方案。

否则，像这里一样，搜索函数获取这个修改状态的候选项并递归。

此外，最终，对于一些州来说，没有更多可能候选人。

想想这个例子，我们不能把第四个放在任何地方，因为所有的空间都被占用了。

从递归搜索返回后，我们通过从状态中删除候选项将修改后的状态恢复到原始状态。

同样，在 Queens 示例中，我们撤销了第二个查询的位置。

现在我们也只有第一个查询。

所以它从一个空的解列表和一个空的状态开始。

搜索一个州和这个空解列表需要花费时间。

搜索最终会填满这个空的解决方案列表，然后返回解决方案列表。

记住，这是代码问题要求我们写的函数。

我们用这个模板保存可能不是，这只是一个模板。

所以你的助手函数，以及状态获取候选，它们可能会带额外的参数。

搜索还可能返回一个布尔值，表明是否已经找到了一个解决方案，如果有且只有一个有效的全局解决方案，就像我们最终会看到的数独问题一样。

我们对模板的简单介绍到此结束。

接下来，让我们用代码来解决皇后问题。

在这里，我们只是代码编号 51 的 N 皇后问题，这是阿利科心脏问题。

让我们首先阅读问题陈述，给定一个整数，我们要返回 n 皇后难题的所有不同解，我们可能以任何顺序返回答案。

lico 为我们代表董事会制定了特定的格式。

对于四个折痕示例，这是两个有效的解决方案。

而且这里用了笔记，不是第一排第一个方格没人占，第二个方格被一个皇后占了，第三个没人占，第四个没人占。

在第二行，前三个方格没有被占据，最后一个被皇后占据，以此类推。

而在 n 为 1 的情况下，女王只能在一个格子上。

这就是解决办法。

在跳到代码之前，让我们先想想我们可能如何表示这个问题。

逻辑上。

我们可能会尝试用一个 2d 数组来表示这个板的数据结构，但是这样做实际上有点浪费空间。

由于没有皇后可以在同一行或同一列，我们可以只保留一个一天的列表，跟踪皇后在每一行的位置。

具体来说，在左边的这个例子中，第一行，皇后在第二个单元格中，所以第一个索引是 1。

对于第二行，索引是 3，因为皇后在第四个单元格中，这里是 0。

这是两个，遵循同样的逻辑。

对于右边的例子，第一个索引是 2，第二个索引是 0，第三个是 3，最后一个是 1，因为第三个单元格，第一个单元格，第四个单元格，第二个单元格。

这就是我们用一维列表表示每个状态的方式。

这个回溯问题。

现在，我将获取我的模板并将其放入代码中。

我将把 surf 方法移到上面。

如前所述，surf 方法基本上就是代码要求我们编写的方法。

所以对于 soap 和 Queens 问题，我们只需修改 soap 函数，解决方案最初是一个空列表，因为我们可以以任何顺序返回所有有效的解决方案，然后我的开始状态只是一个空列表，因为我们还没有将任何 Queens 放入棋盘。

现在我们在这个日期调用 self 点搜索，给它一个要追加的解列表和 N 个皇后的参数 N。

搜索完成后，我们返回到解决方案。

让我们继续并删除这一部分。

太好了。

现在我们将编写状态函数，它将 self，state 和 add 作为参数，为了使状态有效，它需要将所有 n 个皇后放到板上。

所以如果状态的长度是 n，那么我们知道我们已经把所有的 n 个皇后放到了棋盘上。

至于没有女王可以互相攻击的情况，我们会在 get candidate 函数中处理。

本质上，我们将只返回那些意味着所有有效分数不会被先前放置的皇后自我状态所吸引的候选人。

太好了。

因此，我们在这里根据给定的状态构建候选对象。

如果没有状态，这意味着我们从一个空白板开始，我们可以将第一个查询放在任何我们想要的地方。

所以如果没有状态，我们返回所有可能的索引。

如果状态不为空，我们找到该状态中的下一个位置，以填充 position 作为状态的长度。

如果我们已经放置了第一个 Queen，我们希望放置第二个查询。

所以候选项最初从所有的索引开始，然后我们提示无效的候选项。

我使用集合是因为它比遍历列表要好，集合保证了唯一性。

好吧，卧倒的候选人将女王置于攻击之下。

因此，对于行列枚举状态，如果列索引被占用，则丢弃该列索引，因此，这部分会回忆起我们的状态正在记录每一行的列索引。

现在我们讨论对角线。

所以这个测试是位置和行索引之间的距离。

因为我们试图把一个女王放在第二排，现在我们已经填充了第一排，我们希望它在不能被第一个女王对角攻击的地方。

所以这一个是不可能的。

这是列加距离。

这个也是出了问题和列减距离。

最后，我们退回候选人。

现在让我们定义我们的递归搜索函数是你的 take states solution solutions，我们只是修改一下模板。

所以如果 self .是有效的状态 state，我们就把它加入到解中，然后返回。

否则，如果我们到这里，对于候选项，一个 salt 候选项状态，我们递归。

因为我们的状态在列表中，不再被设置，我们追加候选项，然后调用 self 点搜索，状态解，然后将修改后的状态恢复到原来的 repop 最后一个条目。

太好了。

这是我们唯一需要注意的事情，因为 lico 希望我们输出字符串。

这是列索引的列表。

所以让我们在这里定义一些额外的辅助函数。

状态转换为字符串状态，我们期望输出如下所示。

这就是我们如何转换我们的指数列表。

对于这个输出 stray 指定的轻代码，total return 只是 I am state 的一个列表，因为一个意味着 queen 在第二个单元格中，而其他单元格是空的，我们只需将空单元格的字符串和 Queen 的代码 cat knows 的字符串附加在一起以获得返回值。

字符串就是这个点，意思是空的正方形乘以 I 加上皇后的位置就是剩余的空单元格。

还有老鼠直男。

被直接退回。

这是宾夕法尼亚州立大学的自我解决方案。

我们做的状态字符串和字符串是由自己的点脚本产生的字符串粘贴。

太好了。

现在让我们运行示例代码，看看我们做得如何。

好吧，酷。

看起来我们的输出被接受了。

让我们提交，看看我们是否能通过所有的测试。很好，你可以看到我们的运行时间比几乎 70%的提交要好，并且一些内存使用比其他提交的 7%要好。

由于递归，我们确实使用了一些内存，但是对于回溯问题来说，这完全没问题。

接下来，我们将解决另一个 lico 心脏问题，称为数独求解器问题。

我们现在只合作问题 37 数独求解问题，这是一个困难的问题。

如果你还不知道什么是数独游戏，你可以看看它的描述。

因此，数独解决方案必须满足以下所有规则。

一到九的每个数字在每一行中必须恰好出现一次。

而每一列。

还有一个九格的三乘三子格，liko 用点字符表示空格。

举个例子，这里的代码想让我们写一个程序来完成这个数独游戏。

以一种有效的方式，棋盘被表示为字符串的 2d 数组，一些可能是数字，一些是空单元格，lico 希望我们解决这个问题并适当地修改棋盘。

约束不是因为它是一个数独问题，形状是 9 乘 9。

并且每个单元或者是数字串或者是空串。

并且保证输入板只有一个解决方案。

所以我们可以早点回来。

如果我们只找到一个解决方案。

让我复制粘贴我的模板，跳入问题。

好的，我们再次采用这样的浸泡函数，因为它要求我们不要返回任何东西，只需要在适当的位置修改端口，我想我们只需要做 socket search board。

然后我们去掉这个小函数。

我要在这里定义一些常数。

所以形状是九乘九。

如果我们试图验证子框，网格长度是 3 乘 3，空的用这个点表示。

所有的数字串都像假的。

四号屏幕在范围内。

一个形状，加一个。

这给了我们从 1 到 9 的应变。

而且我要用一套包装，因为顺序不重要。

我知道当我穿越大峡谷时会需要这个。

太好了。

让我们从写有效状态函数开始。

因此，它应该采取自我和董事会，并检查董事会是否是一个有效的解决方案。

所以让我们先验证所有的行。

对于行 a，我将在后面定义一些辅助函数。

所以让我们先做软获取行，它一个接一个地返回板子的每一行。

如果，如果我的行等于所有的数字，那就是有效行。

否则，这是一个无效的行和轮胎板是无效的。

如果未设置，行等于软数字。

返回假验证。

类似地，我们验证列调用返回 false。

或者最后，我们将验证子框。

对于网格、网格或。

如果所有的行都通过了验证，所有的列都通过了验证，所有的网格都通过了验证，而没有导致这个错误的返回，我们返回 true，这意味着电路板不是一个有效的解决方案。

现在让我们写信给候选人。

所以 self board 一行和一列，我用一行和一列，因为对于一个单元格，我想知道是哪一行哪一列，来决定哪些数字已经被使用了，还有哪些留给我们作为下一个状态。

所以用的数字是一组数字。

我将删除同一行中使用的删除数字。

所以使用的数字点更新自己的点得到行，这是另一个帮助函数，我将在后面定义同一列使用的数字。

于是用更新的自我点号得到第四列，而该列去掉了所用的位数不变，由三乘三的子框预算，更新得到分级滚动列。

因此，我们需要识别任意卖出的哪一个网格正在进行点名。

最后，因为我们可能已经使用了空字符串，在这里，当我们进行更新时，我们从我们使用的数字中减去它们。

Empty 是为空字符串定义的常数。

候选人只是留给我们使用的东西。

所以这些都没用，这就结束了我们的获取候选对象函数。

现在，我们继续进行搜索。

因为我们只有一个单一的解决方案，我们不需要它的解决方案列表在这里。

如此等等。

伊莎贝尔在舞台上。

所以如果 self .是有效状态板，我们返回真解。

否则，我们会找到下一个空位并进行猜测。

所以对于行索引行枚举或四列索引，实际元素枚举行。

如果元素是空字符串，那么软，空为如果这是空的，找到可以构建一个 X 射线的日期。

下一个命运候选人自我 dot 得到候选人委员会。

现在我们有了行索引和列索引，我们把它们传递给 a，我们按照问题的指示修改了黑板。

所以。

候选项，记住候选项只是数字串中的一个。

因为这里我们的搜索返回一个布尔值，如果其中一个搜索实际上完成了，这意味着电路板已经被修改到位，我们的问题就解决了。

所以它的解决现在等于自我点搜索。

这里补充一些评论，我们在 MADI 这边递归。

如果是这样，如果是这样，现在我们只是返回到整个搜索已经完成的意思。

否则，我们都会猜错。

重新开始。

所以我们把这个条目放回原来的空屏幕。

在这里我们已经用尽了所有的候选人。

但是没有解决问题。

我们返回 false，因为这是无效的连续搜索。

如果一开始就没有空位置，那么它就会返回。

现在我们可以从模板中去掉这些样板代码了。

现在结构已经很清楚了。

我需要做的就是填充这些辅助函数。

用于检索行、列和组的帮助函数。

这是我的助手函数，用于检索行、列和网格。

这非常简单，因为我们的电路板只是一个二维数组。

为了在我们的中心行和列索引中检索 cape 行、列或网格，我们基本上只是做一些真正智能的索引，有时依赖这两种工具的能力。

我将在我的 GitHub 链接上发布我的完整代码，这样你就可以自己消化这些帮助函数了。

现在让我们运行代码，看看我们得到了什么。

很好，我们的输出被接受，提交并测试所有的测试用例。

太棒了。

有了这个模板，我们仍然能够解决难题。

回顾回溯问题就是寻找有效的状态。

到目前为止有效的状态，我们确定满足问题约束的候选项，并使用它们来构建我们的当前状态。

一旦修改后的状态有效，我们就添加它作为最终解决方案。

现在我们已经解决了第二个问题，让我们再来看看我们的模板。

回想一下，我们有这四个函数，state 是一个具有布尔返回值的帮助函数，它验证给定的状态是否是最终的解决方案。

Get candidates 是另一个助手函数，它根据我们的当前状态返回满足问题约束的候选列表。

搜索是一个递归函数，或者花费两个辅助函数以及状态和获取候选项，并在自身上递归。

最后，solve 是另一个 lico 问题，它要求你写的函数，除了初始化一个空的解决方案列表之外，它没有什么特别的功能。

然后对他们进行状态和同事搜索。

关于回溯的更多练习问题，请访问“泄露 co.com”和 intacs 搜索回溯。

这将筛选出一个问题列表，所有问题都有回溯的想法。

你看，我们已经解决了数独解算器，和 n 皇后。

如果你正在寻找一个中等难度的问题，我推荐子集问题。

这是关于寻找所有可能的子集或幂集，通常给定一个整数数组。

当我们被要求寻找所有可能的解决方案并且可能以任何顺序返回一个解决方案时，识别回溯问题是相当容易的。

如你所见，在我的提交细节中，我使用了精确的模板来解决子集问题。

随着您经历越来越多的法律问题，并测试您对模板的理解程度，一旦您在编码面试中遇到回溯问题，您将更好地准备识别回溯问题。

我们的视频到此结束，这也是你在编码面试中解决回溯问题的唯一速成班。

更多类似的内容，请订阅下面我的 YouTube 频道链接。

我也在我的频道上的游戏开发演示中发布表单项目教程。

我最新的教程是关于使用完全基于云的技术，用你最喜欢的角色的个性来构建一个不和谐的人工智能聊天机器人，我相信你会喜欢的。

感谢收看，祝你好运准备编码面试。