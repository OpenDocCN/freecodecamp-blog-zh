# 如何掌握类型特异性的艺术

> 原文：<https://www.freecodecamp.org/news/the-art-of-type-specificity-d0fdb6918e45/>

更具体的定义是否会导致灵活性降低？

在这篇文章中，我会尽量避免关于**强/静态**对**弱/动态**类型的争论(还能说什么？)，甚至是**模式** vs. **模式少**的数据结构。相反，我想把重点放在类型定义的粒度上:有什么影响和权衡？

在光谱的一端，非常通用的定义包括对象的**潜在的**属性和行为。另一方面，您拥有丰富的类型层次结构，其中一些类型与其他类型只有细微的不同。

我将涉及 duck 类型、SQL 每类型表(TPT)和每类型层次表(TPH)概念，以及参数化 API。

当您想到泛型时，您可能会想到文档对象模型(DOM)、无模式 XML 或 YAML、JavaScript 中的文字对象或 NoSQL 数据库文档。这些是广泛通用的，因为对结构、关系和内容的限制很少。

相反，让我们讨论用户定义的类型。它们可能是也可能不是由编程语言或模式强制执行的，但是在处理它们的代码中会有约束，无论是假设的还是其他的。我们用**车辆**来打个比方。

### 车辆

车辆是一个宽泛的概念。即使我们将讨论局限于轮式车辆，也涵盖了从三轮车到半卡车的一切。你能在一种类型中包含那些三轮车、汽车和半挂车的属性和行为的范围吗？是的，你**可以**。显然，当在程序代码中处理车辆实例时，这会带来一些问题。

#### 车辆类型

车辆的可能属性和方法:

*   轮胎
    *编号
    *类型【充气，其他】
*   座位
    *编号
    *填充[布尔]
*   方向盘[方向盘，车把]
*   发动机
    *类型【无，燃气，柴油】
    *气缸数量【仅当类型为燃气或柴油时】
*   驱动器()
*   燃料()
*   灯[开|高|关]

即使是这种最小的属性集，车辆类型也涵盖了一个巨大的领域，并带来了一些挑战，数据完整性就是其中之一。如果我的车是三轮车，我没有发动机。如果我没有引擎，属性`number of cylinders`就没有意义。如果我有一辆没有引擎的三轮车，但是有`number of cylinders > 0`，这是一个错误吗？

我可以给汽车或卡车加油，但不能给三轮车加油。如果在三轮车实例上调用`fuel()`会发生什么？抛出错误？有可能一些应用程序逻辑被混淆了，但是这个请求可以作为一个空操作被优雅地处理吗？

车辆的一个明显优势是它的灵活性。如果我们将车辆分成子类**机动车辆**和**脚踏车辆**，我们可以将以下内容放在机动车辆中，而不是脚踏车辆中:

*   方向盘
*   发动机
    *类型【汽油、柴油】
    *气缸数
*   燃料()
*   灯[开|高|关]

这看似有道理。不过，三轮车有灯是可以想象的。它可能没有汽油或柴油发动机(无论如何，不是儿童三轮车)，但它可能有一个电动发动机。如果出现这些情况，那么就需要进行一些重构。

在一些语言或数据管理系统中，您可以定义接口，并组合实现这些接口的具体类型。因此，您可能有 IEnginedVehicle，它可能有相关的接口 IElectricVehicle 和 InternalCumbustionVehicle(它们又可能被分解为 IGasVehicle 和 IDieselVehicle)。

接口定义起来很便宜，并且擅长注释概念，但是它们不是一个完整的解决方案。一些接口可能与其他接口不兼容:一辆卡车可以既是冰淇淋车又是比萨饼送货车吗？我想，如果你想要冷比萨饼或热冰淇淋。

除此之外，更多的特殊性将你限制在内，并要求你对你将遇到的所有类型的车辆有一些预知。

随着时间的推移，会让你陷入困境的是那些例外情况。

由于这个原因，特别是当领域很广并且不断变化的时候，一开始就不太明确地定义车辆实体是很有诱惑力的。你想对任何事情敞开心扉(原谅我的双关语)。

#### 针对泛型类型编码

在编码方面，不能假设车辆是什么。你必须检查每个属性的存在。对于由 Vehicle 表示的特定实体，现有的方法可能没有意义。你最好的办法是让你的代码不做任何假设。然而，这使得测试成为一项挑战。你怎么可能在你的测试中包含所有合理的车辆配置？

另一方面，你有一个非常灵活的系统；也就是说，如果你的代码中没有假设的话(在“ **Why a duck** ？”中有更多关于这个的内容)).

太多的特定性需要对类型模型进行不断的调整，包括决定继承的分类是什么，什么属性在什么级别，以及当它们不仅影响数据层的代码，还影响表示层时，对模型进行更改的潜在困难。如果你做错了(由于匆忙的分析)，你会有很多连续的返工。

#### 类型及其属性

如果你从网上新奇商店买了一盒东西，你会得到一个盒子。你对它包含的内容有一个模糊的概念，但你不会知道，直到你打开它，并逐一整理每个项目。负担在你，客户身上，你能做的假设是有限的(你可能希望有一只橡皮鸡，但没有保证！).

一个急救箱所能容纳的物品范围很窄。这是一个更具体的对象类型，您可以对其内容进行假设，并相应地进行操作。里面会有纱布和绷带。它会有防腐剂，可能还有止痛药。对于它**可能**包含的东西，你至少有一个更好的想法去寻找什么。

### 为什么是鸭子？

鸭分型通过发生而不是声明来操作。程序逻辑围绕着对一个对象的审问:“顺便问一下，你有财产 A 吗？你有方法 B 吗？…".

基于对询问的响应来执行动作。如果它像鸭子一样走路，像鸭子一样嘎嘎叫，而且有羽毛，那么它很可能就是一只鸭子。基于鸭子类型的逻辑真的不在乎鸭子与否，因为它什么都不假设；它根据所发现的进行操作。

然而，假设会渗入任何认为自己得到了预期结果的软件逻辑中。也许多达 50%的软件维护涉及修正不正确的假设或改进现有的假设。

#### **鸭子打字和第一反应者**

假设我的厨房着火了，打一个紧急电话。第一响应者有徽章、头盔，并乘坐有警笛和闪光灯的车辆到达。耶！消防员！我的房子得救了。我指着厨房命令道:“把火扑灭！”

警察疑惑地看着我。

我做了我所有的鸭打字审问，但得出了错误的假设。也许这个城市最近决定警察应该对附近的火警做出反应，以帮助消防员。

我现在不得不在我的问题清单上加上一条:“你会灭火吗？”

#### 属性、鉴别器和命名类型

Duck 类型非常灵活，但是您的代码必须处理每个对象，就好像它可以是任何东西一样。不过，您可以添加一个特殊的**鉴别器**属性来标识您的代码正在接收的对象的类型，而不是询问所有的属性。一次审问，你就可以去比赛了。当然，对象必须有正确的鉴别器值。

命名类型不太可能给你带来问题，因为类型是在对象创建时分配的。在弱类型语言中，比如 Javascript，事情可能不像它们看起来那样，但是假设你是安全的。

尽管如此，鉴别器或类型并没有真正解决特异性的问题。好的旧对象类型没有说太多关于它的实例。它是一个类型，它确实做了一些保证，但自己做的不多。

你可以把一个对象文本传递给一个方法，但是这个方法必须要么 1)假设它得到的是什么，要么 2)准备去发现。

维护处理泛型类型的代码可能是一项令人烦恼的工作:虽然您可以看到客户端代码*可能*做什么，但是要知道它*将*做什么需要它正在处理的数据的细节。

调试器会有所帮助，但是如果您的断点隐藏在调用堆栈的深处，或者是为了响应回调，那么祝您好运！从逻辑上来说，你可能需要做大量的挖掘工作才能知道你是如何走到今天这一步的。

### 每类型表和每类型表层次结构

关系数据库也遇到了这个问题。如果一个表格代表一种类型的事物，[表格中的所有行都是同质类型的吗](http://blog.devart.com/table-per-type-vs-table-per-hierarchy-inheritance.html)？或者每一行反映一个更具体的类型，而表代表这些事物的超类型？

在第一种情况下(table-per-type，或 TPT)，每行中的每列都保证包含一个有效值(NULL 可能是有效的)。您的代码可以预测一致性一致的查询结果。

在第二种情况下，某些列或列值可能对某些类型(行)有效，但对其他类型(行)无效。这就是每类型层次表，简称 TPH。

TPH 表是一种松散定义的类型。每行中列值的完整性取决于程序逻辑。如果我有一个名为 Vehicle 的表，其中包含我的域中所有车辆的数据，那么列“oil weight”将不适用于代表三轮车的行。

现在，客户端代码需要理解车辆表中各种可能的车辆类型，并相应地执行逻辑。这非常类似于 duck 类型对象的情况，其中属性可能适用于也可能不适用于泛型类型的每个实例。

### 有人知道模式吗？

模式(或其他类型系统)解决这个问题了吗？不，正如刚才所示，关系数据库中的 TPH 模式可以表示一个超类型实体，但是每一行可以定义更具体的实体。鉴别器列值可以帮助挑选出每一行的子类型，但是必须在程序逻辑中进行检查。

使用 TPH 的主要好处是避免了包含许多表的庞大模式，并减少了为类型实例收集数据所需的连接数量。任何方法都有取舍。

### 参数列表和选项

方法参数是另一个问题。最常见的情况是参数类型按出现顺序定义:

```
function circle(int x, int y, double radius){…}
```

或者

```
function circle(Position xy, double radius){…}
```

以这种方式定义的参数是固定的:例如，不能将布尔值传递给 radius。在 JavaScript 中，没有类型化的参数，所以大多数函数根据出现的顺序假设类型。

不仅参数的类型是已知的(通过声明)或假定的(通过约定)，参数的数量也决定了方法的调用方式。

每当我想要将一些格式化的 JSON 转储到控制台，并且必须键入`JSON.stringify(obj, **null**, 4)`时，我总是感到有点烦恼。第二个很少使用的参数是用于[替换者](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)参数。

#### **选项**

在 JavaScript 中，您可以将对象文字作为参数传递，这通常用作命名参数列表。命名参数比参数列表更灵活，对于更复杂的方法来说，它们非常有用。

```
function circle(options) {
    const {x, y, radius, ...rest} = options;
    if (rest.linewidth) {...}
    if (rest.fillColor) {...}
    ...
}
```

灵活，是的，但是很多审问。另外，参数`x, y`和`radius`被假定在那里。最佳实践似乎是将特定于类型的参数列表与更“通用”的对象文字混合使用:

```
function circle(x, y, radius, options){...}
```

其中 options 通常被理解为是指一个属性被记录的对象。

### 怎么办？

很少有软件实践是完全好或坏的(GOTO 是个例外？ ])。一个严格的、类型丰富的系统无疑会防止一些编码错误，即使这些类型没有被语言或数据库强制执行。使用特定类型的代码可读性更好。

另一方面，严格的类型层次结构表示必须维护的元数据，客户端通常知道它在请求什么，也知道它将接收什么。有时，仅仅为了在两个内部方法之间进行数据传输而点上每个“I”和跨过每个“t”看起来就像簿记工作。

没有正确的答案，大多数程序员使用不同(或没有)特殊性的类型。很大程度上取决于领域。如果你正在为一个金融系统编写代码，看起来你会想要一个丰富而严格的类型定义集；但是，我理解有些财务制度是[写成腮腺炎](https://en.wikipedia.org/wiki/MUMPS#Current_users_of_MUMPS_applications)的，那我懂什么？