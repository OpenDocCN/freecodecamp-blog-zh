# 正则表达式不再神秘:正则表达式没有看起来那么难

> 原文：<https://www.freecodecamp.org/news/regular-expressions-demystified-regex-isnt-as-hard-as-it-looks-617b55cf787/>

作者:Vijayabharathi Balasubramanian

你是那种因为正则表达式看起来像外语而远离它的人吗？我就是其中之一。不再是了。

想想那些你能识别的声音、交通标志和气味。正则表达式也不例外。分析字符串就像手语一样。

我们今天将开始学习正则表达式。至少，**有规律的**用过表情。

就像任何编程语言一样，正则表达式本身就是一种简洁的语言。

到本文结束时，我们将知道如何很好地使用正则表达式。我们将解决简单的问题，并在此过程中学习负载。

你愿意投资 30 分钟，然后在 RegEx 中得到启发吗？那就安静下来。

#### 为什么是正则表达式？

我们每个人都有自己的“为什么”，不是吗？一个可能是测试字符串是否是有效的十六进制颜色代码。您可能正在编写一个处理器库，比如利用 RegEx 的 [Sass](https://github.com/search?l=&q=regexp+repo%3Asass%2Fsass&ref=advsearch&type=Code&utf8=%E2%9C%93) 。

我会让宇宙把“为什么”抛给你，并帮你掩盖“T2”如何“T3”。

### 0.准备好你的操场

#### 参考

大多数时候，我发现这个页面足以让我开始使用:[来自 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions) 的正则表达式。事实上，这一页就是你所需要的。可以不看这个帖子了。就现在。关闭此选项卡。？

还和我在一起吗？谢了。你需要一个沙箱在里面玩耍。幸运的是，你的浏览器上有一个。只需使用浏览器控制台中的开发工具。

#### 熟悉语法

首先，我们将使用`/expression/.test('string')`语法。

一个`expression`是我们构建的任何正则表达式。A `string`是被测字符串。根据匹配情况，`test`方法返回`true`或`false`。

斜线标记表达式的开始和结束。将它们视为双引号(")和单引号(')，用于标记普通字符串的开始和结束。

`/`之间的表达式是文字。**它们被视为文字字符。**变量名不会被解析成它们的内容。

为了使它成为动态的，我们必须使用`new RegEx(variable_name)`语法通过构造函数路径。这将在文章的最后拯救我们。

现在就做。只需将此输入您的浏览器控制台。

```
/a/.test("a"); //true
/a/.test("b"); //false
```

如果成功了，你就准备好了。别管它是什么。这就是我们在下面几行中要分解成的部分。

让我们开始吧…

### 1.从字母开始

让我们从小处着手。我们需要找到一个字符串是否有一个特殊的字符。在字符串中查找字符`a`。

这是它最辉煌的表现:

```
/a/.test("abc"); //true 
/a/.test("bcd"); //false 
/a/.test("cba"); //true
```

这个表达式做了我们要求的事情，“在测试的字符串中寻找`a`”。在我们的例子中，`abc`和`bca`确实有字符`a`。但是`bcd`没有。

#### 故障

现在，有很多斜线和反斜线。让我们把它们分解开来。

我们已经看到了`/expression/`是我们如何构建正则表达式的。所以毫无疑问斜线在那里。事实上，我们甚至可以把它赋给一个变量，让它看起来更好。

**同码:**

```
let e=/a/; 
e.test("abc"); //true 
e.test("bcd"); //false 
e.test("cba"); //true
```

在我们的例子中，斜杠之间的表达式只是单个字符`a`。我们只寻找那个角色。

#### 到达多字符

让我们扩展解决方案。

如果你想找到一个以上的字符呢？

把它们按顺序放好。将它们视为子字符串。

这里有一个例子:

```
/ab/.test("abacus"); //true 
/bac/.test("abacus"); //true  
/abc/.test("abacus"); //false 
/abas/.test("abacus"); //false
```

测试中的字符串应该包含斜杠中的精确表达式。如果条件满足，我们就得到一个匹配。

`bac`在`abacus`内，而`abas`不在`abacus`内。即使我们对这些字符进行了编码，我们也无法得到精确的匹配。

#### 复习所学内容

符号`/.../`。斜杠(/)标记正则表达式的开始和结束。忽略这些点，那是我们放置图案的地方。斜线之间的`/a/`字符是测试字符串上匹配的模式。在对被测字符串进行模式匹配测试时，斜杠之间的`/abc/`字符作为子字符串被查找。

### 2.数字模式

让我们增加一点趣味。假设你想知道一个字符串是否全是数字字符。

这是:

```
let e=/0|1|2|3|4|5|6|7|8|9/;
e.test("42"); //true 
e.test("The answer is 42"); //true
```

首先，图案看起来相当长。但是同样的一长串字符**可以用两个字符**来表达。我把它留到了这一节的结尾，作为一个戏剧性的结尾。

第二种情况应该不是真的。我们稍后再处理它。

目前，管道符号(`|`)表示**或**。在正则表达式之外，我们使用它作为双管道(||)的按位**或**和条件**或**。那是同一个人。

我可以说那很简单，就到此为止。但你会为更好的东西尖叫，对吗？我们是开发商。我们一天中的大部分时间都在思考更好的 Bash 和 Git 别名，以节省一些击键次数。

我应该输入九个管道符号吗？那鸿

又来了:

```
e=/[0123456789]/; 
e.test("42"); //true 
e.test("The answer is 42"); //still true
```

这样更好。9 个管道替换为 2 个方括号。保存了 7 个字符。按键次数减少了 77.7%。

顺便说一下，方括号内的任何东西都被认为是`Either this` 或`that`。这是一个字符集。在我们的例子中，字符串应该包含`0`，或者`1`，或者`2`，或者……原谅我，我答应自己每天写 1000 字，或者`3`或者`4`或者`5`。好吧，我们停下来。你明白了。

你在说什么？看起来还是挺冗长的？不满意？

好吧，我们再来一次:

```
e=/[0-9]/; 
e.test(42); //true 
e.test("42"); //true 
e.test("The answer is 42"); //true!
```

怎么样？看起来干净多了，不是吗？方括号内的`[]`表示**或**。`0-9`标记一个范围，意思是零到九。

因此，该测试在测试字符串中查找从 0 到 9 的字符。

如你所见，这个测试也需要数字。

#### 前缀和后缀模式

现在让我们来解决第二个失败的案例。`The answer is 42`匹配我们的测试，因为我们的模式在字符串中的某个地方**寻找数字字符。**未开始到结束**。**

让我们带来`^`和`$`来帮助我们。

*   `^`表示字符串的**开始**。他是个双面间谍，他会把我们绊倒的。他的第二个化身只是在最后一部分才被揭开。
*   `$`表示琴弦的**端**。

让我们整理一下前缀模式:

```
/^a/.test("abc"); //true 
/^a/.test("bca"); //false 
/^http/.test("https://pineboat.in"); //true /^http/.test("ftp://pineboat.in"); //false
```

任何跟在`^`后面的模式都应该在测试字符串的开头。

第二个字符串以`b`开始，而我们的模式寻找`a`。第四个寻找`http`，而字符串以`ftp.` 开始，这是他们失败的原因。

#### 后缀模式

后缀模式如下。`$`在模式的末尾指示测试寻找字符串的结尾。

```
/js$/.test("regex.js"); //true 
/js$/.test("regex.sj"); //false
```

这听起来应该像是“寻找`js`然后是字符串的结尾”。更好的是，“寻找以`js`结尾的字符串”。

#### 端到端模式匹配

这为从头到尾的模式匹配铺平了道路，你不妨称之为端到端。

```
let e=/^[0-9]$/ 
e.test("42"); //false - NO! 
e.test("The answer is 42"); //false 
e.test("7"); //true
```

令人惊讶的是，当我们添加`^`和`$`时，第一个失败了。

`/^[0-9]$/`读作“转到字符串的开头。从角色集中寻找一个**单个数字**。检查字符串是否就在这里结束。这就是最后一个条目返回`true`的原因。从头到尾都只是一个数字。

这不是我们想要的。我们想测试字符串是否有一个或多个数字。

我们很亲密。我们需要学习的最后一件事是如何指示模式在集合中寻找多个字符。

#### 三个火枪手的故事

一个问号(`?`)、一个加号(`+`)和一个星号(`*`)在一个战场上相遇。每个人都有不同的看法。

谦逊的问号(`?`)表示，“我看不到一个或只有一个。”

加号(`+`)表示，“我至少需要看到一个或多个。”

星号(`*`)表示，“我得到你们两个。我看不到一个，一个，或更多。”

其中一个很聪明地隐藏了他的能力。

问号首先登场:

```
/a?/.test(""); //true 
/a?/.test("a"); //true 
/a?/.test("b"); //true! 
/a?/.test("aa"); //true 
/^a?$/.test("aa"); //false
```

*   匹配空字符串`""`
    ，因为`?`代表 0 或 1
*   火柴`a`
    一根火柴
*   匹配`b`
    匹配 0 次
*   匹配`aa`
    第一个匹配而第二个`a`不是模式的一部分
*   `/^a?$/`与`aa`不符
    它寻找零或一个`a`，开始到结束，不多也不少

加号(`+`)看着问号，评论道:“我印象深刻，但你的重点是如此二元！”。上台炫耀:

```
/a+/.test("a"); //true 
/a+/.test("aa"); //true 
/a+/.test("ba"); //true! 
/^a+$/.test("aa"); //true  
/a+/.test(""); //false 
/a+/.test("b"); //false 
/^a+$/.test("ab"); //false
```

还记得 plus ( `+`)说的什么吗？它可以匹配前面模式的一次或多次出现。

所有返回的`true`都有一个或多个`a`。我们甚至设法在最后一个用`/^a+$/`返回 true 的字符串中得到一个只包含`a`的字符串。

现在应该有意义了，但是最后一个返回 false。`/^a+$/`从头到尾查找`a`，不允许其他字符。这就是`ab`测试失败的原因。

最后，节目的明星上台了。他夸口说，“我可以单独决斗，也可以同时和你们两个决斗”，他还说，“我可以和零个、一个或更多人决斗”。

```
/a*/.test("a"); //true 
/a*/.test("aa"); //true 
/a*/.test("ba"); //true 
/a*/.test(""); //true 
/a*/.test("b"); //true 
/^a*$/.test("aa"); //true 
/^a*$/.test(""); //true  
/^a*$/.test("ab"); //false
```

除了最后一个，其他的都可以处理。`/^a*$/`读作，0 或更多的`a`开始到结束。这就是为什么空弦`""`通过了测试而`"ab"`失败了。

#### 回到通用答案

还记得我们遇见三个火枪手之前在哪里吗？是的，“答案是 42”。

现在，如果我们需要从头到尾只寻找一个或多个数字，我们该怎么办？

```
//Let's throw in a plus 
let e=/^[0-9]+$/ 
e.test("4"); //true 
e.test("42"); //true 
e.test("The answer 42"); //false - Hurray
```

`[0-9]+`中的加号(`+`)帮助了我们。加号意味着前面的字符或模式不止出现一次。在我们的例子中，不止一个数字。

它也无法匹配我们的最后一个案例`The answer is 42`,因为在字符串的开头没有数字。

#### 练习模式

*   你能试着写一个十六进制数字的模式吗(由数字 0-9 和字母 a-f 组成，前面有一个可选的#号)？
*   二进制数怎么样？你能测试一个字符串是否只有 0 和 1 吗？

#### 戏剧性的结局

哦，我差点忘了。`[0-9]`代表任何数字字符集，也有一个速记版本`\d`。

```
let e=/^\d+$/; e.test("4"); //true e.test("42"); //true e.test("The answer 42"); //false - Hurray
```

只有两个表示数字的字符。不，没有比这更短的了。

有一大堆这样的特殊模式来指定集群，比如数字(`\d`)、字母数字字符(`\w`)、空格(`\s`)。

#### 回顾

*   `[123]`
    方括号内的表达式是一个字符集
    任何一个字符匹配都会通过测试。就一个角色。
*   `[0-9]`
    查找 0 到 9 之间的单个数字
*   `[0-5]`
    查找 0 到 5 之间的单个数字
*   `[a-z]`
    查找 a 到 z 之间的单个字母
*   `[A-F]`
    查找 A 到 F 之间的单个字母
*   `[123]+`
    加号(`+`)在集合中查找一个或多个出现的字符。这个匹配一个“23132”子字符串，该子字符串由一个更大的字符串“abc23132”中的 1、2 和 3 组成。
*   `|`
    管道符号代表**或**
*   `\d`
    数字的简写
    匹配单个数字。
*   `\D`
    非数字字符的简写
    除了数字以外的任何将被`\d`匹配的字符

### 3.重复匹配以查找重复项

这正是我试图解决的实际问题。我深入研究了正则表达式，最终导致了这篇文章。

你已经得到了一个字符串。找出它是否在日落前被注入了重复字符。

以下是重复字符在出现后立即出现的解决方案:

```
let e=/(\w)\1/; 
e.test("abc"); //false 
e.test("abb"); //true
```

表达式与字符串`abc`的任何部分都不匹配，因为序列中没有重复的字符。所以它返回 false。

但是它匹配字符串`abb`的`bb`部分并返回 true。

继续，在您的 DevTool 控制台上键入它。看看这个！

让我们把它分成容易理解的部分。

#### 反斜杠\释放

对于上一节引入的反斜杠，我一直有点沉默。对于那些去过那里的人来说，这可能并不令人惊讶。他们可能已经**逃离了混乱。但是如果你是编程界的新手，你需要了解更多关于反斜杠的知识。**

在正则表达式语言中，反斜杠是特殊的。反斜杠改变其后字符的含义。想起来了吗？

在字符串中遇到的`\n`怎么称呼？是的，一个新的系列。我们这里有类似的东西。

事实上，如果你想寻找一个新的行，`\n`就是你所使用的模式。这被称为`escaping``n`的通常含义，并给它一个全新的服装叫做`new line`。

*   `\d`
    数字的简写
    匹配单个数字
*   `\D`
    非数字字符的简写
    除了数字以外的任何将被`\d`匹配的字符
*   `\s`
    单个空格字符的简称，如空格、换行符或制表符。
*   `\s`的反义词
    除了空白以外的任何东西
*   `\w`
    字母数字字符
    的简写，匹配 a-z、A-Z、0-9 和下划线 _。
*   `\W`
    的反义词`\w`

#### 可取消的匹配

我们从寻找重复字符的解决方案开始了这一部分。`/(\w)\1/`匹配`"abb"`。这显示了正则表达式中内存和回忆的使用。

考虑在这种格式中使用括号`(expression)`。匹配括号中表达式的结果字符串会被记住以备后用。

`\1`记住并使用括号内第一个表达式的匹配项。同样，`\2`来自第二组括号。诸如此类。

让我们把我们的表达方式翻译成简单的英语:

匹配给定字符串中的任何字母数字字符。记为 `\1`。检查该字符是否出现在第一次出现的字符旁边。

#### 扩展 1 —反向线对

比方说，我们想找到两个以相反顺序相邻出现的字符。那就像`abba`。`ab`反过来就是`ba`并且紧挨着。

下面是表达式:

```
let e=/(\w)(\w)\2\1/; 
e.test("aabb"); //false 
e.test("abba"); //true 
e.test("abab"); //false
```

第一个`(\w)`匹配`a`，记为`\1`。第二个`(\w)`匹配`b`，记为`\2`。那么表达式期望`\2`首先出现，然后是`\1`。因此，`abba`是唯一匹配表达式的字符串。

#### 扩展 2-无重复

这一次，我们要看看没有重复的字符序列。任何字符后面都不应跟有相同的字符。简单明了。

在这里，看看解决方案:

```
let e=/^(\w)(?!\1)$/; 
e.test("a"); //true 
e.test("ab"); //false 
e.test("aa"); //false
```

不是我们想要的，但也差不多了。中间那个应该不会是假的。但是我们加入了一些需要解释的符号。这意味着再次面对最强大的火枪手。

#### 问号的回归

还记得我们之前遇到的三个火枪手吗？不起眼的**问号实际上是最强大的操纵者**，可以让其他符号执行他的命令。也就是说，如果你认为反斜杠是理所当然的。

方括号、问号和感叹号`(?!)`的组合被称为**前瞻**。准确地说是消极的展望。只有当**不是**后跟`b`时，`a(?!b)`才匹配`a`。

在整个 JavaScript 生态系统中，感叹号意味着**而不是**。但是它的表亲 CSS 来了个 180 度大转弯，`!important`意味着它实际上非常重要，不应该被忽略。我几乎滚动过去[陈的推文](https://twitter.com/vijayabharathib/status/910772769964548096)以为它被标记为不重要。我跑题了。

另一方面，`(?=)`是一个积极的**展望未来**。只有在`b`之后，`a(?=b)`才与`a`匹配。

我们有一个解决方案。`(\w)(?!\1)`查找不重复出现的字符。**但只针对一个人物。**我们需要对其进行分组，并使用加号(`+`)查找一个或多个出现的字符。仅此而已。

```
let e=/^((\w)(?!\1))+$/; 
e.test("madam"); //false 
e.test("maam"); //false
```

但是好像不管用。如果我们将模式分组在像`((\w)(?!\1))`这样的普通括号中，`\1`不代表`(\w)`，它代表将模式分组的更高级别的括号对。所以失败了。

我们需要的是一个**健忘**的分组选项。这就是问号`?`反击的地方。它与一个冒号`(?:)`成对出现，消除了括号带来的任何记忆功能。

最后一次:

```
let e=/^(?:(\w)(?!\1))+$/; 
e.test("madam"); //true 
e.test("maam"); //false
```

这一次，由于`?:`，第一级括号没有被记住，因此`\1`记住了`\w`返回的匹配。

它帮助我们在整个分组中使用加号`+`来寻找相似的字符对，这就像魔术一样。

在英语中，“寻找一个字符。向前看，确保后面没有相同的字符。对所有角色从头到尾都这样做。

#### 回顾

*   `\w`代表所有字母数字字符
    如果你大写字母“w”并使用`\W'`，这将意味着除了字母数字之外的所有字符
*   **`( )`
    括号内的表达式被记住以备后用**
*   **`\1`记住并使用第二组括号
    `\2`中第一个表达式的匹配。诸如此类。**
*   **`a(?!b)`
    括号、问号和感叹号(`?!`)的组合，叫做 **这种匹配只有当**不是**后跟`b`时才有效****
*   ****`a(?=b)`
    硬币的另一面
    只有在`b`之后才与`a`匹配。`(?:a)`
    **健忘分组**
    寻找`a`却不记得
    你不能使用`\1`模式来重用这个搭配****

### ****4.交替序列****

****用例很简单。匹配只使用两个字符的字符串。这两个字符应该在整个字符串中交替出现。“abab”和“xyxyx”的两个样本测试就可以了。****

****这并不容易。我试了几次都做错了。这个[答案](https://stackoverflow.com/questions/45504400/regex-match-pattern-of-alternating-characters)指引我到正确的街道。****

****以下是解决方案:****

```
**`let e=/^(\S)(?!\1)(\S)(\1\2)*$/; 
e.test("abab"); //true 
e.test("$#$#"); //true 
e.test("#$%"); //false 
e.test("$ $ "); //false 
e.test("xyxyx"); //false`**
```

****这是你说，“我受够了！”认输吧。****

****但是等待啊哈的时刻！你离金矿只有 3 英尺远，不是停止挖掘的时候。****

****在我们到达' **how 之前，让我们先搞清楚结果。**’`abab`火柴。`$#$#`火柴，这和`abab`没什么区别。****

****因为有第三个字符，所以失败。虽然它们是成对的，但是失败了，因为空间被排除在我们的模式之外。****

****一切都很好，除了，`xyxyx`失败了，因为我们的模式不知道如何处理最后一个 x。我们会成功的。****

****让我们来看看添加到我们皮带上的工具。很快就会有意义了。****

#### ****一次一片****

****你已经知道了大部分的曲子。`\S`是`\s`的反义词。`\S`查找非空白字符。****

****现在是简单英语版本的`/^(\S)(?!\1)(\S)(\1\2)*$/`。****

*   ****从头开始`/^`****
*   ****寻找非空白字符`(\S)`****
*   ****记为`\1`****
*   ****向前看，看看第一个字符后面是不是跟了同一个字符`(?!\1)`。
    记住这是一个**消极向前看的**。****
*   ****如果我们到目前为止是好的，寻找另一个字符`(\S)`****
*   ****记为`\2`****
*   ****然后寻找 **0 或更多对的前两个匹配** `(\1\2)*`****
*   ****寻找这样的模式，直到字符串结束`$/`****

****将它应用到我们的测试案例中。`"abab"`和`"$#$#"`匹配。****

#### ****结束****

****看完解决方案后，您可能认为这不需要单独的部分。但它的简单是优雅的。让我们解决那个失败的案例。正如我们已经看到的，最后一个尾随的 x 是问题所在。我们有一个`xyxy`的解决方案。我们所需要的只是一个模式，即“寻找第一个字符的可选出现”。****

****老规矩，先说解决方案。****

```
**`let e=/^(\S)(?!\1)(\S)(\1\2)*\1?$/; e.test("xyxyx"); //true e.test("$#$#$"); //true`**
```

****问号又来了。他逃不掉。我们最好让他成为我们的盟友，而不是敌人。字符或模式后的问号`?`表示与前面的模式匹配 0 或 1。它不贪婪地吞噬角色。****

****在我们的例子中，`\1?`表示通过第一组括号记住的第一个字符的 0 或 1 个匹配。****

****简单。放松点。****

#### ****回顾****

*   ****`\S`
    代表除空格、换行符等空格外的所有字符
    注意是大写的 S****
*   ****`a*`
    星号或星号，查找前面字符的 0 次或多次出现。在这种情况下，是 0 或更多的`a`
    记加号(`+`)哪个找 1 或更多？是的，这些人是表亲。****
*   ****`a(?!b)`
    这种括号、问号、感叹号(`?!`)的组合叫做**前瞻**。
    只有在`b`后面没有的情况下，它才与`a`匹配。
    例如:匹配`aa`、`ax`、`a$`中的`a`，但不匹配`ab`、虽然使用了括号，但不记得`a`后的匹配字符。****
*   ****`\s`
    小型大写字母`s`匹配单个空白字符，如空格或换行符。****
*   ****`a(?=b)`
    这个匹配的是`a`后面跟的`b`。****
*   ****`^ab*$`
    你可能会认为这相当于 0 次或更多次出现`ab`，但它匹配的是`a`后跟 0 次或更多次`b`
    例如:它匹配`abbb`、`a`和`ab`，但不匹配`abab`****
*   ****`^(ab)*$`
    匹配 0 对或更多对`ab`
    ，这意味着它将匹配空字符串`""`、`ab`和`abab`，但不匹配`abb`****
*   ****`a?`
    `?`匹配前面字符或模式的 0 次或 1 次出现
    `\1?`匹配第一次记住的匹配的 0 次或 1 次重现****

### ****5.匹配电子邮件地址****

#### ****生产警告****

****单靠正则表达式可能无法帮助验证电子邮件。有些人甚至认为不应该使用正则表达式，因为它永远无法 100%匹配电子邮件。****

****想想那些突然出现的花哨域名。还要考虑在电子邮件地址中包含符号，如点(.)和加号(+)。****

****你需要验证电子邮件两次。一次在客户端，帮助用户避免地址拼写错误。从语义输入标签类型`<input type='emai`l’>开始。一些浏览器无需任何额外的前端脚本就能自动验证它。****

****通过实际发送确认电子邮件，在服务器上再次验证它。****

****你最近没见过这样的吗？只需尝试订阅这个 [pineboat](https://www.pineboat.in/) 。你会收到一封真正的电子邮件，要求你确认这是你的。这封确认信是你的电子邮件有效的有力证明。****

****那是一帆风顺的，不是吗？****

#### ****电子邮件的正则表达式****

****现在我们添加了免责声明，您实际上希望看到一个模式，对吗？否，搜索电子邮件地址的正则表达式。来自 perl 模块的一个这样的结果不止一页。****

****所以，我甚至不打算尝试。这样长的正则表达式是计算机通过模式生成器生成的。不是为了我们这样的凡人。****

### ****6.匹配强密码****

****如果你是一个爱喝咖啡的人，这是一个喝浓咖啡的好时机。因为我们在这篇文章的最后一部分，但是到目前为止最长的一部分。****

****它引入了很少的新操作符和模式。但是它重用了许多模式。像往常一样，我们把最短的优化的留到最后。****

****ASCII 范围是这篇文章最精彩的部分。因为，我是在为这篇文章做研究时学到的。****

****现在问题来了。还记得那张注册表格吗？你试了好几次才满足他们的强密码要求？弱，好，强，很强？是的，我们将建立这种验证。****

****密码应该:****

*   ****至少有 4 个字符****
*   ****包含小写****
*   ****包含大写字母****
*   ****包含一个数字****
*   ****包含一个符号****

****这是一个棘手的问题。一旦你开始消费信件，你就不能回来检查它们是否满足任何其他条件。我们的线索就在那里。**我们不能回头，但我们可以向前看！******

#### ****字符串的长度****

****让我们首先测试字符串密码是否有 4 个字符长。很简单。在密码字符串上使用`.length`。完成了，对吗？不，谁需要简单的解决方案？让我们增加它的味道。****

```
**`//expression with just lookahead
//wouldn't consume any character
e1=/^(?=.{4,})$/; 
e1.test("abc") //false
e1.test("abcd") //false  

//after lookahead, 
//pattern to consume character is needed.
e2=/^(?=.{4,}).*$/; 
e2.test("abc") //false 
e2.test("abcd") //true`**
```

*   ****你可能还记得我们之前制作的[【无重复】](https://www.pineboat.in/post/regular-expressions-your-ally/#extension-2-no-duplicates)中的`(?=)`，那是一个前瞻使用
    它不消耗任何角色****
*   ****圆点(`.`)是一个有趣的字符
    它的意思是，**任何字符**。****
*   ****`{4,}`
    代表至少 4 个前置字符，没有最大限制****
*   ****`\d{4}`
    将精确查找 4 个数字****
*   ****`\w{4,20}`
    会寻找 4 到 20 个字母数字字符****

****我们来翻译一下`/^(?=.{4,})$/`。“从字符串的开头开始。向前看至少 4 个字符。不记得比赛了。回到开头，检查字符串是否在那里结束。”****

****听起来不太对。是吗？至少最后一点。****

****这就是我们引入变体`/^(?=.{4,}).*$/`的原因。一个额外的点和一个星。它是这样写的，“从头开始。向前看 4 个字符。不记得比赛了。回到开始。使用`.*`消耗所有字符，看看是否到达字符串的末尾。****

****这现在说得通了。不是吗？****

****这就是为什么`abc`失败而`abcd`通过模式。****

#### ****至少一个数字****

****这很容易。****

```
**`e=/^(?=.*\d+).*$/ 
e.test(""); //false 
e.test("a"); //false 
e.test("8"); //true 
e.test("a8b"); //true 
e.test("ab890"); //true`**
```

****从字符串`/^`的开头开始。向前查找 0 个或更多字符`?=.*`。检查是否有一个或多个数字跟在`\d+`后面。一旦匹配，就回到开始(因为我们在向前看)。消耗字符串中的所有字符，直到字符串结束`.*$/`。****

#### ****至少一个小写字母****

****这个跟上面的模式一样。****

```
**`e=/^(?=.*[a-z]+).*$/; 
e.test(""); //false 
e.test("A"); //false 
e.test("a"); //true`**
```

****翻译？当然可以。“从……开始吧，好的。”代替`\d+`，我们有`[a-z]+`，它是从`a`到`z`的字母字符集。****

#### ****至少一个大写字母****

****我们不要矫枉过正。将前面章节中的`[a-z]`改为`[A-Z]`即可。****

#### ****至少一个符号****

****这将是一个挑战。匹配符号的一种方法是将符号列表放入一个字符集中。`/^(?=.*[-+=_)(\*&\^%\$#@!~”’:;|\}]{[/?.>,<]+).*$/.test` ("$ ")那是一个字符集中的所有符号。必要的地方适当的躲避。我要花几个月的时间才能用简单的英语写出来。****

****所以，为了把我们从永恒的痛苦中拯救出来，这里有一个简单的方法:****

```
**`//considers space as symbol 
let e1; 
e1=/^(?=.*[^a-zA-Z0-9])[ -~]+$/ 
e1.test("_"); //true 
e1.test(" "); //true  

//does not take space 
let e2; 
e2=/^(?=.*[^a-zA-Z0-9])[!-~]+$/ 
e2.test(" "); //false 
e2.test("_"); //true  

//the underscore exception 
let e3; 
e3=/^(?=.*[\W])[!-~]+$/ 
e3.test("_"); //false`**
```

****等等，那是什么`^`又从中间什么地方来了？如果你已经到了这一步，这就是你意识到标志着一串开始的谦逊无辜的`^`是一个双重间谍的地方。也就是说，末日不远了。他已经暴露了。****

****在一个字符集内，`^`否定该字符集。也就是说，`[^a-z]`是指除了`a`到`z`以外的任何字符。****

****`[^a-zA-Z0-9]`则代表除小写字母、大写字母和数字之外的任何字符。****

****我们本可以使用`\W`来代替长字符集。但是`\W`代表所有字母数字字符**，包括下划线 _。**正如你在上面第三组例子中看到的，它不接受下划线作为有效符号。****

#### ****字符集范围****

****`[!-~]`的奇案。它们在键盘中并排放置，但是它们的 ASCII 值是对角相对的。****

****还记得 a-z 吗？A-Z？0–9?这些不是常数。它们实际上是基于它们的值的 ASCII 范围。****

****[ASCII 表](http://www.asciitable.com/)有 125 个字符。零(0)到 31 与我们无关。空格从 32 开始一直到 126，也就是 tilda(~)。感叹号是 33。****

****所以`[!-~]`涵盖了我们需要的所有符号、字母和数字。这个想法的种子来自符号问题的另一个解决方案。****

#### ****召集军队****

****将所有这些放在一起，我们得到了这个漂亮的正则表达式`/^(?=.{5,})(?=.*[a-z]+)(?=.*\d+)(?=.*[A-Z]+)(?=.*[^\w])[ -~]+$/`。****

****这开始困扰和威胁我们。尽管我们一直在单独研究它们。****

****这就是动态构建表达式对象的语法派上用场的地方。我们将分别构建每一部分，稍后再进行组装。****

```
**`//start with prefix 
let p = "^"; 

//look ahead  
// min 4 chars 
p += "(?=.{4,})"; 
// lower case 
p += "(?=.*[a-z]+)"; 
// upper case 
p += "(?=.*[A-Z]+)"; 
// numbers 
p += "(?=.*\\d+)"; 
// symbols 
p += "(?=.*[^ a-zA-Z0-9]+)"; 
//end of lookaheads  

//final consumption 
p += "[ -~]+";  
//suffix 
p += "$"; 

//Construct RegEx 
let e = new RegEx(p); 
// tests 
e.test("aB0#"); //true  
e.test(""); //false 
e.test("aB0"); //false 
e.test("ab0#"); //false 
e.test("AB0#"); //false 
e.test("aB00"); //false 
e.test("aB!!"); //false  

// space is in our control 
e.test("aB 0"); //false 
e.test("aB 0!"); //true`**
```

****如果您的眼睛还没有疲劳，您会注意到上面代码中有两个奇怪的语法。****

*   ****第一，我们没有使用`/^`，而是只用了`^`。我们也没有用`$/`来结束这个表达，而是用`$`来结束。
    原因是`RegEx`构造函数自动为我们添加开始和结尾斜杠。****
*   ****第二，为了匹配数字，我们使用了`\\d`而不是通常的`\d`。这是因为变量`p`只是双引号内的一个普通字符串。要插入反斜杠，需要对反斜杠本身进行转义。
    `\\d`解析为`RegEx`构造函数中的`\d`****

****显然，服务器端也应该对密码进行验证。想想 SQL 注入漏洞，如果你的框架或语言还不能处理它的话。****

### ****7.结论****

****这就把我们带到了故事的结尾。但这是旅程的开始。****

****我们只是用`test`方法划掉了 RegEx 的模式匹配部分。`exec`方法建立在这个基础上，根据模式返回匹配的子串。****

****String 对象有广泛使用正则表达式的`match`、`search`、`replace`、`split`等方法。****

****希望这能让您对 RegEx 的组合模式有一个坚实的理解，从而进一步探索这些功能。****

### ****8.行动呼吁****

****不，在我们经历了这么多困难之后，我不会让你订阅的。****

****做好软件就好。****

****如果这里出现的任何代码块不工作，请在我为这个帖子专门创建的这个 [github 问题](https://github.com/pineboat/pineboat.github.io/issues/3)上留下评论。****

****希望对你有用！分享它，如果其他人会受益。****

****你一直很好。感谢你的时间。以目前的标准来看，这份报告已经很长了。感谢阅读。****

****最初发布于 [www.pineboat.in](https://www.pineboat.in/post/regular-expressions-your-ally/) 。****