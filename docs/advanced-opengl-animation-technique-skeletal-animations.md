# 先进的 OpenGL 动画技术——使用 Assimp 制作骨骼动画

> 原文：<https://www.freecodecamp.org/news/advanced-opengl-animation-technique-skeletal-animations/>

如果希望 3D 动画角色以逼真的方式移动，需要对骨骼动画有很好的理解。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个完整的课程，教你如何用 OpenGL 和 Assimp 库制作骨骼动画。

艾泰·梅里创造了这个球场。Etay 是英特尔的软件工程师，也是一名优秀的教师。

无论是游戏还是视频中的动画角色，当他们在行走、奔跑和攻击时以特定的方式移动他们的肢体时，会感觉更加有机。当你正确地实现骨骼动画时，你的角色动作会看起来更逼真。

在本课程中，您将学习如何使用 Open Asset Import Library (assimp)导入和导出各种 3d 模型格式。

首先，您将学习如何使用 Assimp 加载 3D 模型。然后，课程有以下几个部分:

*   第 1 部分:装配、蒙皮和动画 3D 模型
*   第 2 部分:将模型的顶点映射到骨骼
*   第 3 部分:转换矩阵
*   第 4 部分:将 Assimp 矩阵集成到蒙皮网格类中
*   第 5 部分:将动画数据集成到蒙皮网格类中

观看以下全部课程或在 freeCodeCamp.org YouTube 频道观看[(2 小时观看)。](https://youtu.be/GZQkwx10p-8)

[https://www.youtube.com/embed/GZQkwx10p-8?feature=oembed](https://www.youtube.com/embed/GZQkwx10p-8?feature=oembed)

### 副本

(自动生成)

在这个中级 OpenGL 课程中，it Etay Meiri 将教你使用 3d 模型制作骨骼动画。

嗨，我是意大利人，我想欢迎你来上一堂关于 OpenGL 骨骼动画的课程。

如果你有一些 OpenGL 的经验，并且你想学习如何加载一个敌人的 3d 模型文件，比如在 unity 中使用的 FBX x，那么这就是为你准备的课程。

本课程由两个主要部分组成。

在第一个例子中，我们学习如何使用 SNP 库加载模型。

第二部分实际上由五个部分组成，我们一步一步地实现骨骼动画，我认为这里的材料是中级的。

因此，您应该熟悉常见的 3d 转换，设置顶点和索引缓冲区，并编写着色器来进行基本照明。

如果你需要一些关于这些主题的知识，你可以在我的 YouTube 频道和我的网站上找到初级教程，以及其他创作者的资源，当然，你可以在课程的编程语言 C++下面的视频描述中找到链接。

所以你应该很熟悉。

但是不用担心，你不需要成为 C++专家。

我用的是非常基本的东西，比如眼镜，没有 C++ 20 之类的花哨东西。

在操作系统方面。

我运行 Linux 作为我在美国的主要发展。

但是你也可以使用 Windows，当然，你可以在 GitHub 中找到所有的源代码，我也会包括 Visual Studio 解决方案。

所以事不宜迟，让我们开始吧。

欢迎回到监狱直播，我想很明显，手动创建的模型的复杂性是有限的。

金字塔没问题。

立方体也可以。

但是当涉及到从物理世界建模时，你需要一些帮助。

这就是为什么我们有 blender、Maya、3ds、Max 等软件和许多其他工具，让您可以在复杂的 3d 环境中创建模型。

有许多支持工具，帮助建模艺术家创造惊人的 3d 世界和对象，我们习惯于在现代游戏中。

建模软件负责计算位置纹理坐标和您可能需要的任何其他顶点属性。

它还将顶点分组为三角形，并管理相应的索引。

最后，建模软件将所有这些数据保存到文件中，以便您能够在游戏或应用程序中加载模型，并使用 OpenGL 或任何其他 3d API 操纵它。

你可能不会感到惊讶，因为有许多 3d 建模者，我们也有许多模型文件的格式。

选择部分列表。

所以如果你想把这些模型文件加载到你的游戏中，你可以自己写一个定制的加载器或者使用一个现有的库。

如果您喜欢从头开始编写任何东西，那么欢迎您自己编写这样的解析器。

但是我的建议是用现有的解决方案，因为它会节省你很多时间。

在本视频中，我们将使用开放资产导入库(SMP ),这是一个免费的开源库，非常易于使用，支持多种文件格式。

SMP 负责解析模型文件，顺便说一下，模型文件可以是文本或二进制文件，并将其加载到内存中自己的本地数据结构中。

我们需要做的是使用这个数据结构来填充 OpenGL 顶点和索引缓冲区。

加载任何可能存在的纹理，并设置顶点属性的布局。

让我们从安装 SMP 开始，这里有几个选项。

取决于操作系统。

我将在视频描述中包含您将要看到的所有内容的说明。

如果您在 Linux Ubuntu 上，您可以简单地执行下面的命令来安装 SMP。

如果您想自己构建 SMP，您需要克隆下面的 repo。

如果你没有安装 C make，你可以使用 sudo 来安装 Simic。

在这一点上，您可能会遇到各种各样的困难，主要是由于丢失了包。

让我知道评论中的任何问题，我会尽我所能帮助你。

您也可以使用 GitHub 页面上的支持论坛。

如果 CMA 成功完成，您可以执行 make，然后执行 sudo make install 来完成安装。

现在您需要将 SMP 集成到您的构建过程中。

您可能知道，我使用简单的 bash 脚本来构建我的源代码。

在这些脚本中，我使用包配置来获取构建和链接参数。

因此，我需要做的就是在命令 package config dash dash c flags 中添加一个符号 p 作为参数，以获得 include 目录，并在 package config dash dash libs 中获得 link 命令。

这两个命令的结果作为参数提供给下面的 g plus plus。

Package config 非常方便，因为它的行为是根据它所运行的发行版定制的，这使得它非常灵活。

在 Windows 上，您也有两个选择，您可以使用我的源 repo 提供的二进制文件，或者您可以自己构建源代码。

不幸的是，SMP 网站上似乎不再提供预构建的 windows 二进制文件了。

好的，如果你想使用我创建的二进制文件，你可以去旧的 jail dev 目录，去下面的 windows。

在 lib 目录中，你会发现这个文件是 PVC 142 空点 lib，这是你需要链接到它的 SMP 版本的库，你还需要运行时的 DLL，在这个目录 DLL 中。

这是同一个文件，只是扩展名是 DLL。

你还需要我们在旧监狱的所有头文件，包括 SNMP。

这就是这个库的所有头文件。

这是目前最新的版本。

现在，如果您想自己构建源代码，您需要使用 gate 检查它们。

我用 Tor 去他的星门。

我已经在以前的教程中解释了如何安装它，关于 Windows 支持的教程，所以你可以在那里找到它。

所以你需要做的是右键点击某个目录，然后得到克隆。

这是网站的地址，默认情况下会转到这个 SNP 目录。

现在我不需要按 OK，因为我已经在这里检查过了。

所以我们进去吧。

在这里，您可以右键单击并在此打开 PowerShell 窗口。

你还需要安装 C make，只需键入 C make，C make lists dot txt 并运行它，它将生成 Visual Studio 解决方案文件，我们可以在这里找到 SMP . SLN。

所以让我们打开这个。

在这里，它可以选择您想要调试版本还是发布版本。

正如他们所说的，检查到旧的 jail dev source repo 中的是发布版本，并确保您使用的是 x 64。

然后你只需要构建和重建解决方案。

好了，构建完成了。

所以我们可以回到 SMP slash lib。

并选择 debug 或 release(无论您使用什么来构建，在本例中是 release)。

我们在这里有这个文件，它就是被检查到源 repo 的起源的文件，在 slash bin 中，我们有 DLL。

好了，现在去你的项目。

右键单击它属性。

让我们来看看链接器和输入。

在额外的依赖项中，我们有 s&p lib 文件，您还需要确保在 C++中，general 您将在此处有 include 目录作为额外的 include 目录。现在，我已经从之前的所有项目中获得了该目录，它将从项目的位置向上移动三个目录和 Include。

好的，如果我们去 Visual Studio 项目文件的位置，在我们的监狱里有 windows 或 jail dev vs 2019。

我们的项目就在这里。

所以我们要上升三个目录。

这里是 include，这里是 SMP 头。

所以当我们包含头文件时，我们可以简单地在这里写这个指令，因为它引用了，我们刚刚看到的包含目录。

我们还需要确保 DLL 文件在运行时可以被访问。

因此，让我们再次转到项目属性，并转到调试。

这里我们可以看到，我已经在这里添加了 DLL 目录的位置。

所以现在我们可以运行它了。

现在让我们深入到代码中，我将解释 cmp 的结构。

首先，我创建了一个名为基本网格的类，它代表了一个使用 cmp 加载的模型。

这个类是在包含目录中的 OpenGL 开发基本元数据 h 中声明的。

这里有几个公共和私有函数，以及几个私有变量。

我们将在课程中重温这些内容。

现在我们来看看这个类在 ojio 中的实现，def basic mesh dot CPP 在通用目录中。

我想回顾的第一个函数是 load mesh，它是一个公共函数，将文件名作为参数，并作为整个加载过程的顶级入口点。

这个函数内部的第一个函数调用是声明一个私有函数。

这个函数清除了类的所有内部数据结构，允许您重用同一个类对象来加载不同的模型。

我们不会在本教程中使用这一功能，所以我将只保留它下次重新生成和绑定当前模型的顶点数组对象。

我们在之前的教程中已经介绍了视频，所以请务必观看视频以了解更多细节。

接下来，我们生成六个 OpenGL 缓冲区对象，缓冲区是六个无符号整数的私有数组。

在本教程中，我们将看到一种不同的存储顶点的方法。

到目前为止，我们使用的是一种被称为结构数组或 aos 的方法。

这种方法的核心元素是一个包含位置、纹理坐标、法线等顶点属性的结构。

为了存储多个顶点，我们有一个这种结构的数组，因此命名为结构数组。

这个数组加载到 open GL 缓冲区中，这意味着属性是交错的，它们的方式与 CPU 内存中的完全相同。

第二种方法，也是我今天要演示的一种方法，是数组结构或 SOA。

这里我们为每一个属性准备了一个单独的数组。

好的，我们有一个位置数组，纹理数组，坐标数组，等等，我们可以把这些数组放在一个结构中。

作为数组的名称结构，数组的长度必须相同。

因此，为了访问单个顶点的所有属性，我们需要使用相同的索引来访问每个数组。

OpenGL 允许我们使用这两种方法来构建我们的 3d 对象。

我们使用一个枚举来访问每个缓冲区的名字，而不是一个模糊的数字。

所以第一个缓冲区是索引缓冲区，我们在索引 1 处有位置，在索引 2 处有纹理坐标，法线让索引 3 法线向量是灯光效果所需要的。

目前，这只是一个占位符。

所以如果你自己写这段代码，你可以放弃它。

最后两个缓冲区 W，VP，math VB 和世界地图 VB 也是占位符。

当我们开始实例化时，它们将在将来被使用。

回到加载网格，我们可以看到我们在一次调用 GL Gen buffers 中初始化了所有的缓冲区。

顺便说一下，元素中的数组大小是一个方便的宏，通过将数组的大小除以第一个元素的大小来计算数组中元素的数量，第一个元素的大小必须总是存在。

为了访问 SMP 的服务，我们定义了一个 importer 类的对象，它是在 SMP 名称空间中定义的。

为了进行编译，我们必须包括来自 SMP include 目录的三个文件，importer，dot HPP，scene dot h 和 postprocess dot h，我们实际上加载了我们称为 importer dot read file 的模型，传递了模型文件名和 SNP 标志列表，该列表包含在 SNP load flags 宏中。

这些标志允许我们修改 SMP 的行为，所以让我们快速浏览一下。

首先，我们必须三角定位旗帜。

许多建模工具允许你使用多于三个顶点的多边形来建立模型，我们必须使用三角形。

所以这个标志告诉这个 MP 把这些多边形分割成三角形。

Jen 平滑法线用于照明。

所以让我们暂时保留它。

“裁剪 UV”沿纹理的 V 轴或 y 轴翻转纹理坐标。

这是您可能需要在模型中使用的东西，因为一些建模者允许您在导出模型时控制它。

最后，我们希望相同的工资加入相同的顶点，并相应地调整索引缓冲区。

这将为我们节省一些内存。

SNP 后处理点 h 头中有更多可用的标志，您可以在线找到完整的文档。

这其实也是 SNP 如此灵活的原因之一。

如果 read file 现在返回，那么调用失败，我们使用重要的点 get 错误字符串打印错误。

否则我们会得到一个指向 AI 场景类的对象的指针。

我们从场景中调用 init 来继续初始化。

场景是 SMP 创建的模型的内存表示中的顶级数据结构。

像往常一样，在我们离开这个函数之前，我们将 V O 从 OpenGL 状态中解除绑定。

让我们继续这个函数下面定义的场景初始化。

人工智能场景的构建方式是它与大多数建模者的行为相匹配，这使你能够将模型分割成子组件。

这允许您在一个组件上应用一些转换，而不影响其他组件。

所以你可以有头有臂有剑什么的。

如果模型被分割成子组件，SMP 为每个组件创建一个人工智能网格结构。

这个人工智能网格包含该组件的所有顶点和索引。

人工智能网格结构的数量在人工智能场景类的 M 数量网格变量中给出，我们在我们的私有变量网格中保留匹配数量的元素，这是基本网格条目的向量。

基本网格条目包含一些我们需要为每个人工智能网格维护的变量，比如顶点的数量，基本顶点，等等。

我们很快就会看到这些。

一个场景也可以包含纹理，SAP 用一种叫做材质的东西来表示一个或多个纹理。

这些存储在人工智能材料结构的阵列中。

这个数组的大小在 m&m 材料中给出。

我们有一个指向纹理类的指针的匹配向量，我们相应地在那里保留了空间。

现在，计划是这样的，我们将根据类型、索引、位置、纹理、坐标等，把我们刚刚创建的缓冲区中所有人工智能网格结构的所有顶点和索引堆叠起来。

然而，每个人工智能网格可能使用不同的纹理，但我们可以在绘制调用过程中切换纹理。

这意味着我们需要为每个网格分别启动一个绘制调用，这将使我们有机会根据需要在绘制调用之间切换纹理。

这也意味着我们不能使用总帐绘图元素。

因为这个函数只从缓冲区的开始处绘制顶点，所以我们需要一个更复杂的函数，允许我们从缓冲区内的不同偏移处进行绘制。

而 OpenGL 为我们提供了这样一个绘制功能。

好的，为了在索引和顶点缓冲区中分配空间，我们需要知道在整个场景对象中有多少个顶点和索引。

不幸的是，我们并不容易得到这些，所以我们需要实际计算它们。

我们在私有函数 count vertices and indices 中实现了这一点，它也更新了网格数组，我们只需要循环遍历网格数组中刚刚调整过大小的元素。

对于每个元素，我们从相应的 a 网格中复制材质索引，我们通过将面的数量乘以 3 来计算当前网格中的索引数量，因为在三角剖分之后，所有的多边形现在都是三角形，基顶点是当前网格在全局缓冲区中的第一个顶点的索引。

为了计算它，我们通过 AI 网格中顶点的数量来增加 num，我们以类似的方式通过将 num indices 增加我们刚刚计算的当前网格的索引数量来计算基本索引。

例如，如果我们有三个 100×250 顶点的网格，那么第一个网格的偏移量为 0，第二个网格的偏移量为 100。

最后一个在偏移量 300 处。

当我们退出函数时，顶点数和指数都包含每种类型的总数。

当我们从场景回到单元时，我们用两个计数器调用保留空间。

这个函数在四个向量中为位置、纹理、坐标、法线和索引分配空间。

这些向量是这个类的私有成员，它们将被用来从人工智能场景结构中积累更多的东西。

因此，我们可以通过一次调用 GL 缓冲区数据来加载每个 OpenGL 缓冲区。

回到 load mesh，我们称之为 all meshes，它简单地反转所有 SMP 网格结构，并在每个匹配中调用每个 SMP 网格。

在这个函数中，我们实际上用顶点和索引数据填充了我们刚才看到的向量。

我们通过遍历 a 网格中的所有顶点，并从它们在 AI 网格中各自的位置提取位置法线和纹理坐标来做到这一点。

注意，这些项目由 SMP API vector 3d 表示，它与我们的 vector 类非常相似。

在纹理坐标的情况下，我们还必须检查它是否存在。如果不使用零矢量，我们现在可以用这个数据填充我们的矢量。

此外，请注意，在纹理坐标的情况下，我们只使用三维向量中的 X 和 Y，填充索引非常相似。

网格包含一个称为 M 面的三角形数组。

每个人工智能人脸结构包含三个指数，我们需要将它们放入指数向量中。

你需要 sin calls 的下一个功能是你需要材料。

这是我们为模型中的图像分配 GL 纹理的地方。

图像文件存储在与主模型文件相同的目录中。

所以首先，我们需要提取模型文件的目录。

这是通过简单解析最后一个斜杠字符来完成的。

我们现在可以在 SMP 场景中反转材质数组。

材质基本上是多个纹理的容器，它可能包含漫反射和环境纹理，以及高度贴图、法线贴图等。

这些是更高级的东西所需要的，比如灯光，对于基本的纹理，我们只需要漫射纹理。

所以我们通过调用 AI 纹理类型的材质上的 get texture 来检查它是否存在。

下划线扩散枚举。

在第一个参数中，第二个参数是零，因为我们只需要第一个纹理。

第三个参数是一个 AI 字符串变量的地址，如果纹理路径存在的话，它将被返回。

当然，现在我们不需要其余的参数。

所以我们有空值。

那里。

如果调用成功，我们将构造纹理文件的完整路径。

在模型内部，纹理的路径相对于模型文件的位置。

现在我们可以像往常一样创建我们的纹理对象并加载它。

让我们最后一次从现场回到编织。

这里最后一个调用是对私有函数 populate buffers 的调用。

这是我们准备使用 SOA 的地方。

我们首先将位置缓冲区绑定到 GL 数组缓冲区目标，使其成为当前缓冲区，我们通过调用 GL 缓冲区数据将数据从向量加载到缓冲区。

字节数是通过将第一个元素的大小乘以向量中的元素数获得的。

基址是第一个元素的地址，我们使用 GL 静态绘制，因为我们不打算再次更新缓冲区。

接下来，我们为位置启用顶点属性。

在这个文件的顶部，我们有三个顶点属性位置的宏。

这不是最健壮的设计，因为我们必须让它与着色器保持同步，但现在它已经够了。

接下来，我们通过调用 GL 顶点三指针来配置位置缓冲区的布局。

同样，我们使用宏作为属性的索引，这里有三个浮点数，JL 表示不需要标准化，最后两个参数现在为零。

以前，我们必须在这里放置整个顶点结构的大小，以及顶点内部当前属性的偏移量。

由于位置是一个接一个地打包的，我们现在可以在这里放零，因为驱动程序已经知道了三个浮点数的所有内容。

我们对纹理坐标和法线重复同样的过程。

并且每次我们调用 GL 顶点一个三指针时，驱动程序存储缓冲区的地址，该地址当前被绑定到当前属性的 GL 数组缓冲区。

这使得每个属性来自不同的缓冲区。

好了，SOA 的数组结构。

最后，我们填充索引，只要记住在这里使用目标的 GL 元素数组缓冲区。

恭喜，我们完成了模型的上传。

这里我们唯一剩下的当然是渲染函数，我们从绑定这个模型的 V 开始，这带来了我们刚刚创建的顶点布局。

接下来，我们遍历内部网格数组，获取材质索引，并检查纹理数组中是否有对应的元素，因为可能有一个材质没有漫反射纹理。

如果有一个纹理，我们绑定它，颜色纹理单元只是一个宏，用于我保存在 OpenGL 开发引擎公共点 h 中的 GL 纹理零，我使用这个文件是为了保持教程的一致性。

现在有趣的部分来了。

我们不使用 GL 绘制元素，而是使用 GL 绘制元素基本顶点，它允许我们绘制顶点和索引缓冲区的子区域。

第一个参数通常是 gL 三角形。

第二个参数是当前网格的索引数量，这是我们在加载模型时计算的。

Next 是索引的数据类型在我们的例子中是无符号整数，next 是索引缓冲区中当前网格的第一个索引的偏移量。

所以我们将当前网格的基索引乘以一个无符号整数的大小。

为了得到偏移量，我们还需要将它转换成 void 指针。

我认为这是由于这个函数的一些历史问题。

最后一个参数是当前绘制调用的基础顶点。

你看，在每个人工智能网格结构中，我们从 SMP 获得的原始索引从零开始，但是我们决定在每个属性的单个缓冲区中堆叠所有顶点。

这打乱了索引，一个解决方案是根据网格在我们的单个缓冲区中的起始位置来调整每个索引。

一个更简单的解决方案是使用这里的最后一个参数作为基础顶点。

这个数字将被添加到每个索引中，这样它将与我们的缓冲区中的偏移量相匹配。

例如，假设我们有两个人工智能网格。

索引中的两个网格都是从零开始的，但是每个网格显然都指向它自己的顶点集。

我们将两个顶点组一个接一个地堆叠起来，假设第一个组的大小是 100。

因此第二组的基顶点将被计算为 100。

当我们渲染第二个组时，我们将在最后一个参数中传递 100，这样索引 0 将变成 100 索引，1 将变成 101，以此类推。

所以我们有一个索引子集，它在索引缓冲区中开始了一些偏移。

对于每个索引，OpenGL 会自动添加我们作为基础顶点的内容。

加载模型时，所有这些元素都已经计算出来了。

所以当我们到达这里时，他们已经准备好了。

好的，我们有一系列的抽签。

每个绘制调用都使用索引和顶点缓冲区的子集。

在每次绘图调用之前，我们都有机会切换纹理。

现在让我们看看主应用程序代码的变化。

在教程 18 类，我摆脱了所有的视频，视频，索引缓冲区，他们用来保持在这里，以及世界变换对象。

相反，我们只需要一个指向基本网格的指针。

在 init 方法中，我们需要用模型文件的路径调用网格。

在主渲染函数中，我们对基本网格类中的墙壁转换对象执行所有的转换。

因此，如果我们有多个网格，保持每个网格在其自己的对象内的变换就很简单。

此外，我们只需要调用网格对象上的渲染函数，而不是调用 GL 绘制元素。

这基本上是我们在这里需要做的所有事情。

让我们构建并运行它。

好吧，这看起来像只蜘蛛。

但这里显然有问题，对吗？问题是他们还没有启用深度测试。

没有它，帧缓冲区就像普通画布一样工作。

所以不管你最后用的是什么颜色，那都是你最终在屏幕上看到的颜色。

对于像立方体这样简单的东西，我们看不到问题。

但是对于更复杂的模型，问题就很明显了。

上一集已经讨论过深度缓冲了，这里就不赘述了。

通过启用深度测试，我们可以确保渲染最接近的像素。

不管呈现的顺序如何。

我们通过使用 GL depth this 宏作为参数调用 GL enable 来实现这一点，我们还必须清除每一帧上的深度缓冲区，否则它将包含来自前一帧的垃圾数据。

因此，在主渲染函数中，我们添加了 GL 深度缓冲位和我们提供给 GL clear 调用的位掩码。

好了，伙计们，你们现在可以继续尝试加载不同的模型，这些模型是你们在网上免费找到的，或者是你们自己创建的，如果你们知道怎么做，我不能保证这段代码是防弹的，并且对每个模型都有效，它可能仍然包含一些错误，如果你们遇到问题，请让我知道。

欢迎回到监狱。

在本教程中，我们开始看看骨骼动画以及如何在 OpenGL skillfull 中实现它。

动画或蒙皮被认为是制作几乎所有生物动画的标准方式。

它还可以用来制作怪物、外星人以及各种类型的机器，如机器人。

因此，它是游戏开发中的核心技术。

因此，在接下来的几节教程中，我们将对此进行深入探讨。

Si MP，我们用来加载模型的库，对几种文件类型的骨骼动画都有很好的支持。

所以我们会好好利用。

我讲述这个主题的方式将会非常注重实践。

我将提供该过程和技术的概述。

然后我们会在代码和理论之间来回跳跃。

我们将理解算法的某些部分，然后看看如何使用 OpenGL 在 C++中实现它。

然后回到理论等等。

我将使用 Blender 作为建模工具。

为了简单起见，我就用搅拌机这个名字。

但是当然，所有其他主要的建模工具也支持熟练的动画。

澄清一下，我不是艺术家。

但是为了开发这个迷你系列。

我确实花了一些时间研究 blender，因为我认为熟悉创建模型和制作模型动画的工具可以让你更好地理解这个过程中的开发人员部分。

现在让我们以人体为例。

举个例子。

你可能知道，我们身体的 70%是水，这就是为什么我们如此灵活，骨头被肉包裹着，肉被皮肤包裹着。

所以基本上，你可以说皮肤是由骨骼承载或支撑的。

这不会是一堂解剖学课。

我想说的是骨骼动画背后的想法很大程度上是从现实世界借来的。

到目前为止，我们使用的所有模型都只是真实世界物体的外部表现。

在物体内部。

在骨骼动画的上下文中，我们称模型本身为皮肤，这就是为什么这种技术也被称为蒙皮。

骨骼是骨架，它承载着皮肤，就像在现实世界中一样。

但是，由于我们在模型中的骨骼和皮肤之间没有任何肉，blender 提供的替换只是受每个骨骼影响的顶点列表。

这意味着，当骨骼被激活时，或者用我们更常用的语言来说，当它被平移和旋转时，应用于骨骼的相同变换必须应用于受其影响的顶点。

例如，当平移并旋转手臂的骨骼时，mash 中代表该手臂的部分也会平移并旋转。

跟随骨骼的运动和旋转。

计算由于骨骼移动而必须应用于顶点的变换是该技术的主要目标，重要的是要理解只有皮肤而不是骨骼被渲染。

骨骼和骨骼的作用只是帮助我们定义皮肤的活动范围。

例如，当两个肢体相互接触时，手臂和前臂之间的角度可以在零度之间，当前臂完全伸展时，角度可以在 180 度之间。

超过这一点，肘部就会断裂。

不好听，将虚拟骨骼放入皮肤内，使它们具有合适的长度以适应特定的身体部位，并将它们连接在一起成为一个骨架的处理混合器称为索具。

蒙皮是将顶点连接到骨骼并定义每个顶点受骨骼影响的程度的过程。

拼图的最后一块是动画。

这是您使用在阅读阶段放置的可用控件的地方，以便创建一组定义骨骼的骨骼移动的关键帧。

随着时间的推移，骨骼动画有两个主要特征，可以帮助我们模仿真实世界的运动。

首先，骨骼定义了骨骼的层次，大多数骨骼都有一个父级。

因此，当父骨骼移动时，子骨骼会遵循这种关系，这是子骨骼移动而不影响父骨骼的一种方式。

其次，每个顶点可能会受到不止一个骨骼的影响。

这意味着当一个或多个骨骼移动时，受这些骨骼影响的顶点的变换必须以某种方式组合每个骨骼的变换。

实际上，如果你有一个模型，其中每个顶点都完全由一根骨头控制，那么这个模型可能是一个机器人或任何其他类型的机器。

一辆汽车是一个简单的例子，你可以使用骨骼动画来制作车门的开关。

这扇门通过某种金属接头与汽车相连。

但是当车门打开时，唯一在移动的顶点属于车门，汽车的其余部分则完全停留在原地，这绝对不是生物的情况。

这里我们希望模型以一种模拟皮肤的方式变形。

这种行为在关节周围最为明显。

熟练的动画允许我们在基于所有受影响的球计算每个顶点的运动方面有高度的灵活性。

我们通过给骨骼和顶点的每一个组合分配一个权重来做到这一点，就像它是 0 和 1 之间的分数一样。

并且每个顶点的所有权重的总和应该是 1，我们将骨骼变换和它们的权重进行线性组合来进行计算。

例如，如果影响一个顶点的两个骨骼的权重是一半，这意味着该顶点受两个骨骼的影响相等，其移动将是两个骨骼移动的平均值。

如果一个方向是第九点，另一个方向是第一点，这意味着顶点可能离第一块骨头更近，所以它会跟着它走。

但是仍然会有一些小的影响来自第二块骨头，可能会把它拉向不同的方向。

Blender 为艺术家提供了强大的工具来设置不同骨骼的权重。

大多数艺术家可能会从自动分配权重开始。在这种方法中，Blender 根据顶点和每块骨骼之间的距离计算权重。

下一步将是审查结果，并开始固定和调整，并使用权重绘画调整模型。

权重绘制是 Blender 中的一项功能，通过使用特殊的笔刷来增加或减少选定骨骼顶点的权重。

通常，艺术家会先开发皮肤，然后在里面构建骨骼。

这是有意义的，因为骨骼必须与实际渲染的身体部位的尺寸相匹配。

在动画制作开始之前的这个阶段。

皮肤的姿势称为绑定姿势。

这一点非常重要，因为所有底层变换和数学运算都将参考绑定姿势作为起始位置。

对于模型在绑定姿势下的外观没有任何限制。

但是通常的做法是让模特保持这种放松的姿势，在关节部位不要有太多的弯曲。

如果你在 Google Images 中搜索熟练的动画绑定姿势，你会发现许多人类或半人类模型的这种姿势的例子，手臂伸展到两侧，腿伸直放松。

当您渲染模型而没有应用任何动画时，您应该使其处于绑定姿势。

一旦完成装配和蒙皮，模型就可以进行动画制作了。

自然，同一组骨骼可以用于多组动画。

想想人体在运动和灵活性方面提供的所有可能性。

所有这些都是用 206 块骨头完成的。

即使在人体模型中有一小部分骨骼，您仍然可以实现许多动画。

因此，每个动画集将模拟某种活动，如行走，跑步，战斗等。

动画集由一系列变换组成，这些变换在艺术家制作动画时应用于骨骼。

这些变换可以包括通常的缩放、旋转和平移。

在许多其他生物中的人类的情况下，我们只会遇到旋转和平移。

但是这项技术本身也可以支持骨骼的动画缩放。

将根据某个帧速率以规则的间隔提供变换。

例如，一个 10 秒的动画和每秒 24 帧将包括 240 组变换，这些组通常非常接近。

所以如果游戏中的实际帧率高于动画帧率，我们可以在连续的变换之间进行插值，得到最终的动画。

由于这些变换代表骨骼方向的变化，我们可以将它们应用到受这些骨骼影响的顶点上，并基本上激活模型。

好了，这是足够的理论了。

我已经忽略了许多我们需要完整实现的细节。

但是在这个阶段，我想用一些代码来弄脏我们的手。

现在各种文件类型都支持骨骼动画。

如果您实现了加载器，对于特定的文件类型，您可能需要您的骨骼动画代码来遵守该文件类型的约定。

然而，由于我们使用 SNMP，我们只需要我们的代码遵守这个库的约定和细节。

到那时，我们将能够支持许多文件类型。

正如我所说的，我们将在实践中逐步实现这些技术。

因此，让我们创建一个简单的实用程序，它将解析 SMP 创建的数据结构并从中提取相关部分。稍后，我们将把这个逻辑合并到我们的 OpenGL 应用程序中。

现在这个工具对于动画的实际执行是不需要的，但是对于调试等是非常有用的。

所以这个工具由一个文件组成，我称之为 CMP 沙箱 cpp。

我们在同一个目录中还有一个名为 build SNP sandbox 的构建脚本来构建它，它非常简单。

我们在这里有构建标志，称为 CPP 标志。

目前，我只包括了 dash g gdb。

三个，以便用调试信息构建它来进行调试。

我们还获得了名为 LD flags 的链接标志，这是对包配置 dash libs SNP 的调用。

我经常在我的构建脚本中使用包配置，以便我的代码能够在尽可能多的机器和系统上编译。

好的，如果你在命令行上运行这个，包配置破折号会创建一个 cmp。

在我的机器上，他告诉你 link 命令是 dash l si MP，而在其他系统上，它可能会生成一个不同的命令。

好的，最后的构建命令非常简单，我们调用 g+加上 CPP 文件的名称，编译器标志，链接标志破折号 O 和二进制文件的名称。

好的，现在我们来看看 CPP 文件。

顺便说一下，我有一个关于使用 SNP 加载模型的视频，所以一定要看看。

如果你想知道更多细节。

我将在这个视频中过一遍主要细节。

好的，首先我们需要为 SMP 包含这三个头。

好了，让我们向下滚动到底部。

这里我们有你的标准主函数，我们在这里检查参数的数量，需要两个，因为这个实用程序只有一个参数，就是模型文件名。

好的，如果不是这样，我们就退出这个工具。

接下来，我们从 arg v 数组中的位置 1 获取文件名。

我们定义了一个 SMP importer 类的对象，它基本上处理所有的 s&p 解析内容。

接下来，我们使用文件名和我定义的 s&p 的 load 标志在 importer 对象上调用 read file。

为了方便起见。

这是非常标准的。

我们已经这样做了，三角剖分网格中的所有多边形，生成法线并连接相同的顶点，我们检查错误，并使用从读取文件返回的 AI 场景对象调用猪。

因此，场景是处理我们与 SMP 所有交互的主要对象，它有几个有趣的功能，以及我们可以访问的成员。

在这种情况下，我们将直接进入网格，好的，这是一个数组，一个 API 网格对象的数组，它是所有顶点和索引以及骨骼所在的位置。

所以猪很简单，它只是用场景对象调用解析网格。

在未来，我们将有一个功能来处理层次和动画。

好的，这将在接下来的几个教程中不断发展。

这里我们有解析网格。

我们首先打印场景对象中的网格数，这可以在场景的 M 数量网格属性中找到。

接下来，我们准备几个计数器。

对于顶点、索引和键的总数，我们循环遍历网格的数量，并根据索引从网格数组中提取每个网格，我们获取顶点的数量，计算索引的数量，这是面的数量乘以 3，因为我们已经对所有多边形进行了三角剖分，并且我们还访问了 num bones。

好的，在人工智能网格结构中，我们在这里有一个骨骼阵列。

我们在这个属性中有骨头的数量，M num bones。

接下来，我们计算决策键中顶点的总数，我们将在这个函数的末尾打印出来。

这主要是为了提供信息，只是为了确保一切都正常工作。

这里重要的部分，我们称之为有骨骼，这是一个布尔函数，告诉我们这个网格中是否有骨骼。

然后我们在当前处理的特定网格上调用解析网格骨骼。

现在让我们来解析网格骨骼，在这里。

这也很简单，我们循环这个网格中的骨骼数量，我们调用解析单个骨骼。

现在，如果我们现在运行这个，我们将使用一个模型，它被检查到我的 repo 中，称为 Bob lamb clean，以及五个网格，顺便说一下，它来自 Doom three，您可以看到它告诉我们有六个网格。

这些是网格的名字。

好吧，我们有一具尸体，一张脸，一个头盔，烤架，烤架，还有另一具尸体。

对于每个网格，我们可以看到顶点和指数的数量。

这里很重要的一点是，骨骼的数量，身体有 28 块骨骼，面部只有两块骨骼。

这些人有一块骨头，最后一块有两块骨头。

好的，如果我们将它加载到 blender 中，我们实际上可以在右手边看到这些网格对应于 Blender 中的网格组件。

所以我们有这个人拿着的烤架，我们有尸体。

好的，身体的这一部分实际上是剑，脸和头盔。

好，现在让我们看看，解析网格骨骼，就在这里。

这是一个对网格中骨骼数量的简单循环，我们对每个骨骼调用解析单个骨骼。

从这个数组中，我们还会传入骨头的索引，我们稍后会看到。

所以让我们看看这个人工智能骨骼结构中有什么。

而且只有四个公共属性。

好的，我们有骨头的名字，这是用来提供信息的，正如你在 blender 中看到的，你想给骨头命名，这样你就能记住它应该做什么。

这里有权重的数量，实际上是这个数组中元素的数量，还有权重。

我们马上会看到，我们有一个名为 M 偏移矩阵的属性，它是一个 4x 4 的矩阵。

他告诉我们，在绑定姿势中，这个矩阵从网格空间转换到骨骼空间。

好吧，这听起来可能有点吓人，但我们会在未来的视频中看到如何使用它。

最后一个属性是 M 权重数组，它是 AI 顶点权重结构。

这个结构只包含两个属性。

好的，结构中的每个元素都有一个顶点 ID，它告诉我们受骨骼影响的顶点的索引，以及这种影响的强度，它必须在 0 到 1 的范围内，就像我们之前讨论的那样。

因此，在解析单个骨骼函数中，我们循环遍历骨骼中的权重数，从 M 权重数组中提取顶点权重元素，让我取消所有这些 printf 调用的注释，基本上是打印顶点 ad 和权重。

现在让我们再运行一次。

现在我们得到了每个网格的骨骼列表以及受其影响的诗句。

好的，这里我们可以看到第一块骨头 0 叫做耻骨，受这块骨头影响的顶点数是 190。

这里我们可以看到这些顶点的所有指数，以及权重。

所以我们可以看到这个模型其实很简单。

当我们浏览这个的时候，看起来好像当一个顶点受到两块骨头的影响，那么每块骨头的重量将会是一半，如果受到三块骨头的影响，那么重量将会是三分之一，所以每块骨头的重量总是和其他骨头的重量一样。

这是下一块骨头，骨盆比脊柱长 254 节，它继续这样。

所以骨头总数是 35 块。

这给我们带来了第一个挑战，每个骨骼都映射到它影响的顶点，并且许多顶点受多个骨骼的影响。

但是骨骼动画是在顶点着色器中实现的，因为这基本上是我们可以实际改变顶点位置的唯一地方。

因此，我们真正需要的是从每个顶点到影响它的骨骼的反向映射。

这些信息必须提供给顶点着色器，这样我们就可以基于所有这些骨骼计算每个顶点的变换。

所有这些以及更多内容将在下一个教程中介绍。

好吧，快速回顾一下。

在第一部分中，我们创建了一个小工具来从 SMP 加载与绑定相关的内容。SMP 将模型保存在一个或多个网格结构中，每个网格指向一个骨骼数组，每个骨骼指向它影响的一个顶点数组。

对于每个顶点，我们都有一个索引和权重，权重是一个介于 0 和 1 之间的浮点数，表示当前骨骼对该顶点的影响程度。

在第一部分的最后，我留给你一个挑战，将顶点映射回影响它们的骨骼。

好吧，也许有点太戏剧化了。

无论如何，这个视频将是非常技术性的，重点将是实现这个映射，并确保它正确工作。

既然这个迷你系列的核心原则是一步一步地工作，我们将首先在 SMP 实用程序中实现它，然后将这个逻辑移到主应用程序中。

我还想可视化骨骼和顶点之间的关系。

因此，在今天的演示中，您将能够实际看到每个骨骼在顶点上的效果。

在本例中，红色三角形表示受当前骨骼影响很大的顶点，这种影响随着我们从红色到黄色，再到绿色而减弱。

蓝色三角形表示不受当前骨骼任何影响的顶点。

您可以单击空格键并在不同骨骼之间切换。

片段着色器的这一部分在最终实现中是不需要的。

但我认为，如果你在自己的代码中实现这一点，这将是一个很好的调试步骤，只是为了确保一切都正确加载到 GPU 中。

好吧，让我们跳回 SMP 沙盒点 cpp。

我们首先将映射字符串包含在来自 C++标准库的向量头中，作为我们在这里需要的数据结构。

接下来，我们有一个宏，它定义了每个顶点的最大球数，对我的模型来说四个球就足够了。

所以只要调整一下，让它和你的资产相匹配。

接下来，我们有包含两个数组的顶点骨骼数据结构，一个数组用于影响该顶点的所有骨骼的索引。

对于每块骨头，我们也有相应的重量。

现在我将跳过这个结构的其余部分。

接下来，我们有三个新的数据结构，每个顶点都有一个顶点骨骼数据的向量。

这基本上是从顶点到影响它们的骨骼的映射。

我们有一个称为网格基顶点的整数向量。

是的，课堂上的 NPC 包含网格，网格中包含球，每个骨骼引用包含它的网格的顶点，就好像它们从零开始，我们将所有的顶点打包在一个名为顶点 2 骨骼的数组中。

因此，我们希望将相对顶点索引映射到唯一的全局顶点索引。

为此，我们为每个网格计算一个基础顶点，并将相对顶点索引加到这个基础上。

最后，我们有一个从骨骼名称到它们的索引的映射，因为 SNP 使用字符串作为骨骼的名称。

但是对我们来说，使用骨骼指数会简单得多。

所以现在让我们跳到正题。

我们在第一部分已经看到了这一点。

简而言之，主要调用猪，它调用，解析网格。

在这里，我们使用场景中网格的数量来调整网格基础顶点的大小。

所以对于每个网格，我们都有一个基础指数，我们需要计算它。

我们就在这里这样做，每个网格的顶点总数都会增加。

因此，在我们增加它之前，对于当前网格，我们保存当前的顶点总数作为基础，我们还根据更新的顶点总数调整顶点到骨骼的大小，因为我们在解析网格时需要这个空间。

这不是最有效的方法。

但是对于这样的实用程序，这是没问题的。

基本上，这个向量会一次又一次地调整大小，为每个新的网格提供足够的空间。

最后，我们称之为解析网格骨骼。

你可能会注意到，我添加了当前网格的索引，因为我们以后会需要它。

第一个网格骨骼没有改变，我们只是在第一个参数中添加了网格索引，为每个骨骼调用一个单独的骨骼。

在第一部分中，这个函数简单地打印了所有受当前骨骼影响的顶点及其权重。

我在这里添加了一些代码来创建从顶点到骨骼的映射。

首先，我们获得骨骼 ID，这是每个骨骼的唯一索引。

在循环内部，我们通过将 AI 顶点权重结构中的顶点 ID 添加到当前网格的基本顶点 ID 来计算全局顶点 ID，这是我们在过去的网格函数中设置的。

就在这里。

每个网格都有一批顶点，引用它们的球使用从零开始的索引，我们希望将所有这些批次的所有索引一个接一个地堆叠在一起，因为我们像这样将它加载到顶点缓冲区。

因此，我们必须使这些指数独一无二。

所以第一批从零开始，然后下一批的基数从上一批结束的地方开始。

让我们跳转到 bone ID，它将骨头的名称映射到它的惟一索引。

我们有一个字符串和整数之间的映射，称为骨骼名称来索引映射。

如果名称已经存在，我们只返回索引。

如果没有，我们设置映射，骨骼 Id 会随着我们在映射中添加更多项目而自动增加，以解析单个网格。

现在我们有了全局顶点 ad，我们用它来访问顶点两骨数组，我提醒你这是顶点骨骼数据结构的一个向量。

我们用当前骨骼的索引和来自 AI 顶点权重结构的权重来添加骨骼数据。

该函数在权重数组中搜索一个空闲的位置，并将骨骼 ID 和权重放入该位置。

我们假设如果权重为零，那么这个槽是空的，因为权重必须大于零，骨骼实际上影响那个顶点。

一旦我们找到了空闲的槽并进行更新，我们实际上就可以这个函数了，如果我们能找到一个空闲的槽，就会有一个断言，因为要么你有一个 bug，要么你需要增加每个顶点的最大骨骼数。

现在让我们在 Bob lamb clean.md 上运行这个。

五目锉。

您可以看到，我们获得了顶点 ID、骨骼索引、重量和插槽索引，这些信息都记录在插槽中。

让我们做一点 OHLC 魔术，让我们抓住顶点，让 oak 只打印这一行的值。

好的，那么我们在索引 3 处有顶点 ID，在索引 5 处有骨骼索引，在索引 7 处有权重，在索引 9 处有插槽。

我们可以通过顶点 id 来解决这个问题，我们可以看到第一个顶点完全受第二块骨骼的影响，第二个顶点受第二块和第三块骨骼的影响。

我们得到了它们在 0 号和 1 号槽的重量。

所以这是有道理的。

顶点八受 11，2，3 的影响。

所以这个看起来也没问题。

如果你愿意，你可以更彻底地检查这个。

但是我认为现在还可以。

下一步是将这个逻辑集成到我们的 OpenGL 应用程序中，并将每个顶点的骨骼索引和权重加载到一个顶点缓冲区中。

然后，我们可以从顶点着色器中访问它，并做一些很酷的事情，如将一些颜色应用到受特定骨骼影响的所有像素。

同样，这只是为了调试，但我们正在一小步一小步地取得进展，确保每一步都正常工作非常有帮助。

为了集成，我将所有 GL def 基本网格头文件和 cpp 文件复制到这个目录中，并将它们重命名为蒙皮网格点 h 和 cpp。

在下一个教程中，我们将在它自己的目录中包含相同文件的一个新版本，所以你将能够比较这两个版本，或者监狱死亡基本网格已经在以前的教程中介绍过了，我将在下面放一个视频的链接，现在我们将只介绍骨骼动画相关的代码。

这个类叫做皮肤网格，和头部一样。

这里是每个顶点的最大骨骼数量。

顶点骨骼数据在这里是一个私有声明，它与沙盒中的是相同的，所以不需要查看它，除了索引位置，纹理坐标法线之外，我们将为骨骼使用一个新的顶点缓冲区，所以我们在骨骼顶点缓冲区的枚举中有三个函数的声明，我们只是从沙盒中复制了这些加载网格骨骼加载单个骨骼并获得骨骼 ID，我使用 load 而不是 parse，因为它更常见。

在这个类中，我们有一个顶点骨骼数据的向量，和沙盒一样，我们将使用它来填充骨骼的顶点缓冲区。

最后，骨骼名称和它的索引之间的映射。

现在让我们转到 CPP 文件，我们有两个新的顶点着色器的顶点属性位置。

这将允许每个顶点访问其骨骼列表，权重确保这些数字与顶点着色器保持同步。

在保留空间函数中，我们根据骨骼的数量来调整骨骼向量的大小，这和这里的其他缓冲区是一样的。

在 init single mesh 中，我添加了一个加载网格骨骼的调用，该调用使用 get bone ID 来映射骨骼 tweets 索引的名称。

好的，同样，这与 SMP 实用程序中的工作原理相同。

基本上，当场景结构的处理完成时，我们在这个 M 骨骼向量中有了从顶点到骨骼的所有映射，然后，在填充缓冲区函数中，我们绑定并分配新的骨骼顶点缓冲区。

我们还启用了两个顶点属性来访问骨骼 id 和权重，我们还需要正确设置布局。

因此，对于骨骼 id，确保使用 GL int，而不是 GL float 作为所有其他属性，我们有四个整数用于四个 id，后跟四个 float，确保正确设置偏移。

对于第二个属性，我们有骨骼的最大数量乘以骨骼 ID 的大小，所以我们在这里应该得到 16 个字节。

好的，每个整数四个骨头乘以四个字节。

现在，我要确保骨骼顶点缓冲区被正确填充和加载。

所以在这个演示中，我们将使用特定的颜色绘制受每个骨骼影响的三角形。

让我们看看如何做到这一点。

在顶点着色器中，我们为骨骼 id 和权重提供了两个新的输入属性。

请注意，id 是 AI vac，而不是常规 veck。

常规 veck 用于浮点，id 是整数。

所以我们必须用伊维奇。

顶点着色器只是将这两个属性复制到片段着色器。

所以我们还需要将它们声明为输出属性。

这里，我们需要类型限定符 flat。

第一次，我们习惯于让光栅化器在三角形阶段插入属性，如颜色和纹理坐标。

但在骨头的情况下，这没有任何意义。

所以这个平面限定符基本上告诉光栅化器不要插值，简单地复制属性，我们在片段着色器中有相应的声明。

这里我们也必须使用降半音。

如果我们忘记它，我们会得到一个错误，说整数 Vereine 必须是平坦的。

片段着色器的其余部分将简单地从以前的闪电教程中复制，唯一的变化是在主函数中，我们循环骨骼的数量，并检查骨骼 id 属性中的每个槽。

这是否等于 display bone index，它是由应用程序设置的统一属性，我们马上就会看到。

如果这是真的，我们要设置输出颜色，这里，我试图模仿 Blender 的行为。

好的，所以在 Blender 中，如果你进入权重绘制模式，你可以在顶点组之间切换，顶点组基本上是骨骼，蓝色的顶点完全不受所选骨骼的影响。

红色受影响很大，绿色和黄色介于两者之间。

我试图在片段着色器中做类似的事情，好吧，它并不完美，但它非常有用。

如果当前骨骼的重量超过第七点，我们输出红色调制，因为它看起来像 blender 也使用插值第四点和第六点之间的颜色，我们使用绿色，然后黄色用于第一点以上的任何东西。

如果没有找到这个像素的骨骼索引，我们使用蓝色。

我还将来自照明的原始颜色乘以一小部分，以禁用我没有使用零的效果，这样编译器就不会对我大喊大叫，令人高兴的东西并没有真正使用，应用程序代码非常标准，所以没有必要从头到尾检查一遍。

这里唯一要注意的是，当空格键被按下时，我们增加当前显示骨骼索引，我们使用 modelu 来确保我们不会溢出骨骼的数量。

然后我们将这个索引设置到片段着色器中。

片段着色器对此索引有一个统一的整数。

这是我们用来检查骨头身份的。

让我们看看这是如何工作的。

所以下一步是理解在动画中控制顶点变换的矩阵。

所有这些以及更多内容将在下一个教程中介绍。

在第一和第二部分中，我们学习了如何使用 SMP 库加载框架信息。

我们创建了一个映射，这样每个顶点都可以访问影响它的骨骼。

还有重量。

我们使用一个简单的演示来验证实现，该演示显示了受选定骨骼影响的三角形。

在这个视频中，我们将研究核心变换，或骨骼动画技术。

请记住，在第一部分中，我们讨论了如何在 Blender 中使用一组关键帧来创建动画的外观，其中您可以调整每个关键帧中骨骼的位置和方向。

现在，如果这是一次工作面试，他们问你，根据 blender 的工作方式，你一般会如何实现动画，然后我想你会马上想到，你知道，你可以说你可以保存每一帧中所有顶点的位置。

然后在运行时简单地在每一帧中渲染一组不同的顶点。

好吧，我想这能行。

但是你可以明显地看到这种方法的缺点。

这可能会破坏你的模型文件，以及你的顶点缓冲区。

因此，实际算法采用的方法是保存一组位置，特别是我们在第一部分中讨论过的绑定姿势。

此外，我们将一组变换与每个骨骼相关联，每个关键帧一个变换。

在一段时间内，我们对影响每个顶点的所有变换进行加权平均。

在实践中，SNP 实际上保存了转换步骤读取项，一个矢量用于缩放，另一个矢量用于平移，以及四元数。

对于旋转，我们已经知道如何从这些家伙创建变换矩阵。

所以没问题，我们只需要弄清楚如何在模型上应用这些矩阵。

因为没那么简单。

我们希望父骨骼影响子骨骼，而不是相反，这一事实带来了额外的复杂性。

所以如果手指动了，不影响手。

但是当手动的时候，很明显，手指也会动。

为了理解这一切是如何工作的，我们需要引入一个新的坐标系，称为骨骼坐标系，或骨骼空间，骨骼坐标系的原点在骨骼的底部。

骨骼本身指向 Y 轴，X 轴和 Zed 轴垂直于 Y 轴，并且相互垂直。

当然，您可以通过选择离群点中的甲胄来打开 Blender 中该坐标系的显示。

进入“对象数据属性”选项卡，在视口显示中，有一个名为“轴”的复选框。

我们知道，一般来说，网格的顶点是参照局部坐标系指定的。

那么局部坐标系和骨骼坐标系是什么关系呢？嗯，骨骼形成了一个层次结构，这是一个简单的图形，在顶部有一个根，每个节点有零个或多个子节点，除了根以外的每个节点都有一个父节点。

当装配一个新的模型时，艺术家将在模型的核心指定一些骨骼作为根，其余的骨骼将从这条路线和彼此分支。

在简单人体模型的情况下，使用脊椎作为根是有意义的，然后直接的子对象将是四肢和颈部。

从那里，您可以继续向下到手指，根的骨骼空间是参照局部空间指定的。

所以你可以把局部空间想成一个主坐标系，原点 000 在轴上，通常是 100010 和 001，根骨的底部是这个系统中的某个点，和常规的诗句一样，根骨的入口是这个系统中的向量。

在下面的 2d 例子中，根的骨骼空间的原点位于 x 轴上的一个点和 y 轴上的一个点，骨骼空间轴是一些任意的单位向量，事情变得有点复杂。

当我们从层次的根移动到它的直接子对象时，子对象的骨骼空间是参照根而不是局部空间来定义的。

回到这个例子，我们可以在 x 轴和 y 轴上分别看到层次结构的根。

子骨骼的底部也是一个在 x 轴上，一个在 Y 轴上，但是参照它的父骨骼，也就是根骨骼。

参照局部空间，孩子的骨骼实际上位于 x 轴上的两点和 y 轴上的两点。

在这个例子中，我使两个骨骼空间的轴与局部空间的轴对齐，以便于我在头脑中计算一切。

但是很明显，不一定要这样。

通过将每个骨骼空间定义为对其父对象的引用，我们可以创建一个从每个骨骼返回到层次根的变换链。

节点变换的改变显然会影响它的所有后代，但不会影响它的父节点。

如果你需要这是如何工作的直觉，你可以以宇宙模型为例，你可以在一个以地球为中心的坐标系中描绘月球围绕地球的轨道。

这个坐标系的母体显然就是地球绕太阳运行的那个。

所以如果你想计算月球的位置，以太阳为参照，你需要把它在原系统中的坐标乘以从原系统到太阳原点所在的坐标系的变换。

下一步是将结果乘以从太阳坐标系到太阳围绕星系中心旋转的坐标系的变换，或者类似的东西。

最后的转换将是从星系坐标系到宇宙坐标系，这将给你宇宙中月亮的坐标。

所以我不确定专业天文学家会不会认可这个模型。

但我认为对我们来说，回到骨子里是没问题的。

骨骼动画中的过程从变换漩涡的位置开始，该位置通常在局部空间中给出，而模型处于影响它的骨骼坐标系的绑定姿势中。

从那里。

我们将其转换到父对象的骨骼空间，并继续下去，直到到达层次的根。

在这个过程的最后，我们回到了本地空间，这是定义根的地方。

我们可以继续像往常一样控制和观察空间。

SMP 有一个小变化，叫做全局逆变换，你们可能听说过，我稍后会谈到。

由于每个顶点经常受到不止一个骨骼的影响，我们实际上需要对几个骨骼的变换进行加权平均。

每一个骨骼变换都将以同样的方式计算，从骨骼一直到根部。

除此之外，我们还需要调整每个节点的转换。

否则，随着时间的推移，将不会有任何实际执行这一过程的行动。

SMP 为我们提供了两个矩阵。

第一个称为偏移矩阵，它是骨骼结构的一部分，也包含顶点的所有权重。

这个矩阵从局部空间直接变换到骨骼空间，它已经包含了从根到骨骼的所有变换。

所以不需要担心等级问题。

当你使用这个矩阵时。

官方文档说，偏移矩阵在绑定姿势中从网格空间转换到骨骼空间，这基本上是说，如果您在局部空间中取一个顶点，而模型在绑定姿势中，并且您将它乘以骨骼的偏移矩阵，您将获得该顶点相对于该骨骼的坐标。

这意味着，如果两块骨骼影响同一个顶点，那么通过将顶点位置分别乘以每块骨骼的偏移矩阵，您将获得两个不同的坐标，分别参考两个骨骼空间。

当然，你需要从每块骨头的根部开始，计算每块骨头的最终矩阵。

如果你用两个最终矩阵变换顶点，并假设两块骨头都在移动，你将到达局部空间中的不同位置，这就是为什么我们对两个最终矩阵进行加权平均，以获得两块骨头之间的某个位置。

在下一个例子中，我在 blender 中创建了世界上最简单的骨骼，标准框位于原点，单块骨骼与绿色的 y 轴对齐。

正如你所看到的，骨骼的 Zed 轴指向上，这实际上是 blender 的默认设置，我在设置中导出了模型以保持简单，否则 Blender 会将变换从它自己的坐标系添加到我们正在使用的坐标系中。

这将使回到 SNP 沙箱的分析变得复杂。

在功能栏“单个骨骼”中，我添加了一个调用来打印 SNP 矩阵，使用骨骼的 M 偏移矩阵属性作为参数，打印 SNP 矩阵被定义为出现，这非常简单，它只是很好地打印矩阵。

现在让我们在 Git repo 中的模型单骨点 FBX x 上运行这个，我们可以看到我们得到了作为偏移矩阵的单位矩阵。

当然，原因是骨骼的底部位于局部空间的原点，并且骨骼空间的轴与局部空间的轴对齐。

所以从局部空间转换到骨骼空间基本上就是什么都不做，是同一个系统。

让我们看另一个例子。

我已经添加了一个子骨骼，它沿着 Y 轴延伸了根骨骼，我们可以在 blender 中看到，根骨骼位于原点，骨骼的末端在 Y 轴上的一个单位处。子骨骼在同一位置开始，在 Y 轴上的两个单位处结束。

如果我们使用沙箱运行这个，我们可以看到父矩阵的偏移矩阵仍然是单位矩阵。

但是子节点的偏移矩阵将沿着负 y 轴平移一个单位。

这是有意义的，因为这个骨骼空间在正 Y 轴上移动了一个单位，所以为了变换一个顶点，例如，这里的这个，在局部空间上是一个 2 到孩子的骨骼空间，我们需要从 Y 轴上减去一个单位，因为这个顶点离骨骼的底部比离原点更近。

这里还有最后一个例子，叫做骨骼平移旋转点 F BX，其中子骨骼向上旋转了 45 度，我们可以看到子骨骼的偏移矩阵与我们过去开发的矩阵非常相似。

所以我会把这个留给你们作为家庭作业去探索。

好吧，我希望到目前为止一切都说得通。

现在，我们可以看看位于 SMP 场景新部分的第二个矩阵。

这是节点层次结构。

节点表示场景中相对于父节点具有位置和方向的实体。

实体可以是网格，骨骼，甚至是相机和灯光，你可以在 Blender 中设计一个完整的场景，然后用灯光中的相机导出，然后用相同的 p。

我以后可能会做一个关于它的视频。

但现在我们只关注骨头。

节点层次结构从一个根节点开始，每个节点包括一个指向零个或多个子节点的指针数组和一个指向零个或多个度量值的指针数组。

这允许您在模型文件中拥有一个网格，并使用多个节点将其放置在世界上的不同位置。

如您所见，创建我们之前讨论过的图表非常简单。

使用这种节点结构。

还有一个指向单亲和矩阵的指针叫做 M 变换。

这个矩阵的作用是将一个向量转换到它的母体的坐标系中。

所以这就像是从地球坐标系到太阳坐标系的变换。

在我们将位置向量乘以偏移矩阵后，我们发现自己在骨骼的坐标系中。

下一步是在图中找到相应的节点，应用这个节点的变换矩阵并一直延续到根。

通过遍历节点的父属性。

骨骼被映射到节点。

只需使用它们的名称，就可以在节点层次中搜索骨骼的名称，直到找到同名的节点。

让我们使用 SNP 沙箱来探索节点层次结构。

在解析函数中。

我已经添加了一个对 parse hierarchy 的调用，现在我将取消对它的注释。该函数将场景作为参数，然后使用场景的 M 根节点属性调用 parse node，例如，节点中网格和子节点的数量以及 M 变换矩阵事件，通过递归调用 parse node 的每个子节点来向下反转图形。

好了，现在我们来测试一下。

在第一个例子上，单骨点 F bx，我们可以看到根节点是单位矩阵，它有两个子节点，立方体和甲胄，甲胄的变换矩阵切换 Y 和 Zed 轴，也翻转了 Y 坐标的符号。

好吧，有意思。

骨架包含一个称为骨骼的节点。

你可以看到这里的 M 变换矩阵正好相反。

它是 Y 轴和 Zed 轴，并翻转 Zed 坐标的符号，之前是 Y 轴。

好吧，他们基本上是在互相抵消。

如果我们把这些矩阵相乘，我们可以验证我们得到的是单位矩阵。

所以我把这个问题贴在了 SFP 论坛上。

当我得到答案的时候，我会告诉你，这里实际上有一个额外的节点，叫做 bone，我想这是为了骨头的尾部，但是这个节点没有真正的骨头。

因此层次可能包含没有相应骨骼的节点。

但是如果这些节点有子节点，那么它们将对它们产生影响。

我们需要注意骨骼的变换，在 Y 轴上平移一个单位。

这是有意义的，因为骨骼也定义了一个坐标系。

所以如果你把这个坐标系 000 的原点乘以这个矩阵，你会得到 010，这是骨头的位置，在骨头的坐标系中。

所以这是一个微不足道的例子，但它帮助我们感受到等级制度是如何运作的。

如果我们在一个真实的模型上运行这个，就像我们的老鲍勃·兰姆·克雷，我们可以看到一个更复杂的层次结构。

我们这里有根，然后 MD 五个层次，原点，耻骨，骨盆，脊柱，颈部和头部。

这里的转换太复杂了。

所以，让我们只希望一切都会顺利。

下一步是将这两个矩阵整合到我们的蒙皮网格类中。

所有这些以及更多内容将在下一个教程中介绍。

今天，我们将把前一个视频中介绍的两个矩阵，偏移和变换整合到我们的蒙皮网格类中。

这包括两个步骤。

首先，我们需要使用偏移矩阵将顶点从局部空间转换到骨骼空间。

接下来，我们需要将骨骼空间位置乘以节点的变换矩阵，并在遍历到层次顶部的同时继续相乘。

这将把我们带回局部空间。

所以我们从局部空间开始，到局部空间结束。

那么，什么发生了变化？嗯，基本上没什么。

在本教程中，我们仍然没有应用动画数据，这实际上是动画模型。

我们只是应用了在 blender 和 si p 之间计算的基本变换。

因此，我们的期望是让模型回到暂停模式。

现在请记住，除了矩阵之外，我们还将使用权重来执行转换的加权平均。

所以这个结果是远远不能忽略的。

这是通往我们最终目的地的重要里程碑。

好了，让我们回顾一下蒙皮网格类的变化。

我们从蒙皮网格点 h 开始，我添加了一个公共函数，叫做获取骨骼变换，这个函数将在渲染循环中被调用。

它基本上计算所有骨骼的所有变换，并以矩阵向量的形式返回它们，调用者必须提供这些矩阵作为参考。

每个骨骼都有一个矩阵，我们可以使用它的骨骼 ID 在向量中访问它。

在最终的实现中，这个函数也将当前时间作为一个参数，然后根据模型的当前姿态，在每次调用中返回一组不同的矩阵。

在本教程中，我们仍然不需要它。

所以我暂时放弃了它，在 private 部分，我添加了一个名为 Read node hierarchy 的函数。

当我们讨论这个类的实现时，我会详细讨论这个函数。

我还添加了 SMP importer 对象和指向场景对象的指针作为私有属性。

原因是我们需要访问场景中的层次。

在运行时，当我在前面的实现中尝试这样做时，导入器是函数加载网格中的一个局部变量，我得到了一个分段错误。

所以我想我们需要在整个执行过程中让进口商活着。

最后，我们有一个名为骨骼信息的结构，它存储了几个矩阵，我们有骨骼偏移矩阵，这是为了方便访问。

文件转换存储整个转换链的中间结果，这样当整个过程完成时，我们只需从这里获取它并将其返回给应用程序。

这个类的构造函数接受有参数的偏移量矩阵，它把它存储在相应的成员中。

并且它将变换矩阵初始化为零。

当然，我们也有一个骨骼基础设施的向量，每个骨骼有一个结构。

好了，这就结束了头的变化。

和往常一样，实际上，在第二部分中，你可以将这个文件与以前的版本进行比较，因为在第三部分中，我们只接触沙箱，你将能够看到所有这些变化。

现在让我们来看看 CPP 文件，我们在加载网格函数中有一个小的变化。

代替场景中导入器的局部变量，我们在类中有了新的私有属性，所以我们将使用它们。下一个变化是在加载单个骨骼函数中。

得到骨骼 ID 后，我们检查它是否等于向量中骨骼的大小。

如果这被证明是真的，我们知道这是一个新的骨骼，因为骨骼 id 是一个运行索引。

在这种情况下，我们使用 AI 骨骼类中的 M 偏移矩阵创建一个骨骼信息对象。

记住，除了权重，SMP AI 骨骼类也有这个偏移矩阵。

在我们初始化骨骼信息对象后，我们将它推入向量。

这意味着我们可以使用骨骼索引来访问骨骼信息。

在这个文件的底部，我们有两个新的函数。

首先，我们得到骨骼变换，它引用一个矩阵向量。

我们首先使用我们拥有的骨骼基础设施的数量来调整这个向量的大小。

接下来，我们将局部矩阵初始化为单位矩阵。

我们称之为使用场景的根节点读取节点层次。

这个矩阵，在读取节点层次返回后，我们应该在骨骼信息向量的最终变换成员中有我们需要的变换。

所以我们需要做的就是将这些矩阵复制到颜色提供的向量中。

现在让我们来看看 Read 节点层次结构函数。

这有点棘手，因为它是一个递归函数。

它接受一个指向 AI 节点对象的指针和对父矩阵的引用。

对这个函数的第一次调用是使用层次结构的根节点和单位矩阵来完成的。

我们从使用来自节点的 N 变换矩阵创建一个无变换矩阵开始。

接下来，我们通过将父矩阵与这个矩阵相乘来创建一个全局变换矩阵。

因此，我们实际上是从上到下遍历图，而不是从节点回到根，因为这个全局矩阵将用于计算它的所有子节点，所以从上到下，我们只能计算一次。

注意，我们利用了矩阵乘法的结合律，这告诉我们只要保持矩阵的顺序，就可以改变括号的位置。

接下来，我们检查是否有匹配节点名称的骨骼，层次中相应节点的所有骨骼。

但是可能有没有骨骼的节点，我们已经在它们的索引中有了骨骼名称之间的映射。

所以这很容易做到。

如果我们找到这样的骨骼，我们将它的最终变换更新为 gets offset 矩阵乘以全局矩阵的结果，这基本上捕获了从节点回到根的整个链。

最后，我们遍历当前节点的子节点，并使用第二个参数中的全局转换矩阵在每个子节点上递归调用 Read node hierarchy。

因此，随着我们深入图表，这个全局变换封装了越来越多的 M 个变换矩阵。

让我们来看看应用程序代码的变化。

这很简单。

在渲染函数中，我们定义了一个矩阵向量，我们从网格中获取骨骼变换，我们对获取的向量进行循环，我们将矩阵逐个设置到蒙皮技术中。

这是一个非常简单的函数，可以更新着色器中的统一数组，所以我将跳过它，您可以稍后再看。

最后一个变化是在顶点着色器，我们有一个新的统一称为 G 骨骼。

这是一个由 100 个矩阵组成的数组，所以要确保这足够了。

对于您计划加载的模型。

在 main 函数中，我们创建一个骨骼转移矩阵，作为影响当前顶点的所有骨骼矩阵的加权平均值，我们使用顶点的骨骼 id 来访问骨骼统一数组。

看看第二部分如果你不记得，骨骼的想法是从哪里来的，每个骨骼矩阵都乘以相应的权重，这也是一个顶点属性。

如果骨骼的数量少于四个，权重将为零，因此计算将没有任何效果。

我们将所有这些乘法的结果相加，以获得最终的骨骼变换，并使用它将顶点从局部空间再次变换回局部空间，一旦我们整合动画数据，位置将与原始位置不同。

着色器继续照常将更新后的局部位置乘以 W VP 矩阵，片段着色器中实际上没有变化。

这个视频到此结束。

下一步是整合动画数据，这样我们就可以最终看到移动的东西。

所有这些以及更多内容将在下一个教程中介绍。

欢迎来到骨骼动画教程迷你系列的第五部也是最后一部，好的，所以基本上，这意味着我们需要在这个视频结束时让动画工作起来。

但是首先，让我们快速检查一下我们已经知道的相关 SNP 数据结构。

AI 场景类有一个网格列表，每个网格有一个骨骼列表。

除了权重和偏移矩阵，我们在节点层次结构中还有一个相应的节点。

该节点有一个变换矩阵，可以让我们找到其父节点的坐标系。

在上一个教程中，我们看到了这两个矩阵是如何协同工作的，所以一定要先看那个视频。

课堂上的 ice 也有一系列 AI 动画结构。

每个结构都代表了完整的动画序列，比如奔跑、打斗或者角色能做的任何事情。

在这个结构中有几个与时间相关的属性，我们有 m 持续时间，它是以文本表示的动画长度，还有空的 x 每秒，它基本上是由艺术家设置的动画的预期帧速率。

因此，例如，如果帧速率为 30，而您的游戏以每秒 60 帧的速度运行，您将需要在两个连续的动画帧之间插入一个额外的帧，反之亦然。

如果游戏比动画模型慢，我们将需要跳过帧来保持动画的预期速度。

显然，如果我们将持续时间除以 x/秒，我们就可以得到动画的实际秒数。

人工智能动画中最重要的属性是一个人工智能节点阵列和 M 个结构，称为 M 个通道。

数组的大小以 M 个通道给出。

层次中的每个动画节点在该数组中都有相应的条目。

所以如果我们进入 AI node nm 的声明，可以看到它有一个成员叫做 M node name。

为了找到层次结构中特定节点的动画数据，我们只需要找到它的名称。

在 M 通道数组中。

动画参数本身在三个单独的数组中给出，位置和缩放在向量中给出，旋转是四元数。

每个数组理论上可以有不同的长度，这就是为什么我们有 num 个位置键，num 个旋转键和 num 个缩放键。

在我们的例子中，我们有 140 个位置和旋转条目，没有缩放。

代码必须是灵活的。

为了处理所有可用的情况，AI 向量键和 AI 四键实际上是一对表示转换的属性。

以及发生这种转变所需的时间。

键保证按时间顺序排序。

因此，搜索当前时间仅仅意味着反转数组，直到我们找到当前时间所在的两个连续键之间的时间范围。

假设当前时间通常位于两个关键点之间，我们必须在这两个关键点的动画参数之间进行插值。

在我们插入动画参数后，我们将缩放、旋转和平移组合成一个单一的变换矩阵。

基本上就是这样。

所以现在让我们进入代码，看看如何实际实现它。

这一次，我想从应用程序代码开始，我们有一个小的变化，那就是时间的跟踪。

我为以毫秒为单位的开始时间添加了一个新的私有属性。

当我们完成 init 函数时，我们通过调用 Milly 的 Get Current Time 来初始化它。

该功能在通用斜线 O GL dev utils dot cpp 中定义。

您可以看到，我们实际上为 Windows 和 Linux 提供了不同的实现。

在 Windows 上，我们使用 get account，在 Linux 上，我们使用 get time of day。

这两个函数都非常简单，您可以查看自己的文档了解更多细节。

如果需要更高的精度，也可以使用高分辨率定时器，但我对毫秒级没问题。

好的，在渲染函数中，我们只需要再次调用 Milly's 中的 Get Current Time，并计算启动时间和当前时间之间的差值，这将为我们提供应用程序运行的时间。

请注意，我们在这里将结果除以 1000，并将其转换为 float。

所以我们用可能的分数得到了以秒为单位的动画时间。

在秒之间，我们提供动画时间来获取骨骼变换，以便我们可以计算当前时间点的正确变换。

好的，在录制的时候，我忘记告诉你获取骨骼变换需要把时间从秒转换成刻度，因为同一块指定了每一帧的开始时间。

我们通过将计时秒数乘以每秒的滴答数来实现这一点。

每秒的滴答数可以在 AI 动画结构中找到。

如果它不是由建模软件设置的，我们默认将其设置为 25，这只是我在 SMP 源中看到的值。

接下来就看你游戏的逻辑了。

如果您想要运行动画序列一次，您需要在动画应该开始的点重置开始时间。

在这个演示中，我希望动画一次又一次地运行。

所以我用 F mod 来做一个浮点模型操作，计算当前时间和动画的持续时间。

这将演示的整个执行划分为 M 个持续时间长度的片段，在动画时间刻度中，我们得到该片段中的当前时间。

现在让我们直接进入皮肤网格类的实现。

在第三部分，我提到了全局逆变换，所以我想花一点时间来讨论一下。

其思想是，在 SMP 加载的一些模型中，根节点的变换矩阵实际上可能是对象的世界变换。

这允许你将物体放置在已经在 Blender 中的世界中。

在这种情况下，我们需要将对象带回本地空间，在本地空间应用动画，然后将对象转换回您想要的位置。

为了做到这一点，我们需要反转根节点的转换，并将其应用到整个转换链的末端。

所以在我们加载模型之后，我们获取根节点的 M 变换矩阵。

我们将它存储在一个新的私有属性中，称为 M 全局逆变换，我们调用反函数来对这个矩阵求逆。

反函数在 math 3d dot cpp 中定义。

这是矩阵求逆的标准实现，你可以在网上的很多资源中找到。

所以这里没什么大不了的，全局逆变换用在读取节点层次函数中，你可以看到我已经把它加到了变换链的头上。

所以骨骼的最终变换首先是从局部空间到骨骼空间的偏移矩阵。

然后我们有全局变换，caps 捕获到层次根的所有节点变换，最后是逆全局矩阵。

好吧，我希望这说得通。

现在让我们跳回这个函数的顶部，我们从应用程序中获得以秒为单位的动画时间作为参数。

接下来我们需要做的是访问我们感兴趣的动画序列。

在本教程中，我保持简单。

所以我默认使用第一个动画。

但是如果你知道你的模型有几个动画，你可以在动画数组中搜索你想要的那个。

接下来，我们需要在 AI 动画结构中搜索与当前节点匹配的 AI 节点 nm。

我们在 Find 节点和 function 中这样做，function 就是在这里定义的，它采用 AI 动画结构和节点名称，它只是遍历动画中的通道，直到找到与节点名称匹配的通道。

在这种情况下，它返回匹配的 AI 节点枚举结构。

并非所有节点都是动画。

在这种情况下，我们现在返回，回到读取节点层次结构。

如果发现另一维数据，我们计算转换矩阵。

对于动画来说，我们将简单介绍一下计算。

但在此之前，我想让你注意一件非常重要的事情。

当当前节点有动画数据时，我们覆盖由图中的入口形成矩阵初始化的 no 变换矩阵。

对此的解释可以在文档中找到，它告诉我们从这些值计算的转换矩阵在特定时间替换节点的原始转换矩阵。

这意味着所有关键点都是绝对的，与骨骼默认姿势无关。

好的，所以如果你期望动画矩阵被应用，在没有变换的顶部，这是不正确的，如果节点没有被动画化，我们从图中的变换矩阵继续这个过程。

但是如果它有动画，我们必须用我们要计算的矩阵覆盖这个矩阵。

所以你要小心这里，否则它会得到垃圾。

动画的变换矩阵是通过初始化用于缩放、旋转和平移的三个单独的矩阵，并像往常一样将它们组合成单个矩阵来计算的。

例如，我们来看看缩放矩阵是如何计算的。

我们为缩放准备了一个向量，请注意，我在这里使用的是 SNP 向量结构，AI 向量 3d，我们用缩放向量、动画时间和节点动画结构来调用 calc 插值缩放。

这个函数首先检查我们拥有的缩放键的数量。

如果只有一个键，就没有空间进行任何插值，所以我们只返回第一个键的值。

如果有多个键，我们需要找到与当前时间匹配的键。

关键字是按时间排序的。

因此，我们需要找到第一个时间大于当前时间的键，我们需要在该键和之前的键之间进行插值。

为了做到这一点，我们有精细缩放，它遍历 AI 节点 nm 结构中的所有缩放键，并将当前时间与键中的时间进行比较。

请注意，for 循环从零开始，在结束前的一个键处停止，因为我们实际上是在 I+1 处检查键。

如果动画时间小于该时间，我们将索引 I 返回到 calc 插值缩放。

一旦我们有了正确键的索引，下一个索引就是我们找到的那个加一，我们必须在这两个键之间进行插值。

这是标准的线性插值，我们计算两个键之间的时间差。

插值因子是我们找到的时间范围的开始和当前时间之间的范围除以范围本身的长度。

这将给我们一个介于 0 和 1 之间的因子，取决于我们离范围的边缘有多近。

好的，如果我们非常接近起点，因子将接近于零，如果我们几乎接近终点，因子将接近于 1，我们实际使用因子的方式是从两个指数中抓取缩放向量，计算它们之间的范围。

结果是初始值加上因子和δk 的乘积。

因此，这允许我们在缩放向量之间平滑地插值，特别是当游戏以比模型最初设计的更高的帧速率运行时。

回到读取节点层次，可以看到我们使用插值缩放向量来初始化标准缩放矩阵，计算插值旋转和平移是完全相同的。

这里唯一值得一提的是插值两个四元数是使用 SMP interpolate 函数完成的，它是 AI 四元数类的一部分。

在将四元数还原为颜色之前，我们还对其进行了归一化，我们将三个变换矩阵按照标准顺序组合在一起，您也可以在文档中看到，缩放、旋转和平移。

仅此而已。

所以这就完成了骨骼动画的迷你系列。

我希望你和我一样喜欢它，请点击喜欢按钮订阅，在下面随意评论，他们会在下一个教程中看到你。