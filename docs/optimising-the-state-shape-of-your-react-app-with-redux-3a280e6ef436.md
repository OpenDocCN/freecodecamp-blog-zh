# 下面是如何用 Redux 优化你的 React 应用的状态形状

> 原文：<https://www.freecodecamp.org/news/optimising-the-state-shape-of-your-react-app-with-redux-3a280e6ef436/>

伊万·派洛特

# 下面是如何用 Redux 优化你的 React 应用的状态形状

使用 Redux 来管理应用程序的整体状态是一回事。但是确保你的状态结构是最优的，这样你的代码是可维护的和有效的，这是一个全新的游戏！

![1*MYp1pEZVIvemp_Af2P34FQ](img/f0797a25c85b04fd80d0b04dbd657006.png)

Photo by [Samuel Zeller](https://unsplash.com/photos/JuFcQxgCXwA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

管理应用程序的状态形状绝对是最基本的。随着应用程序的增长，如果你的状态形状没有很好地组织，管理它会很快变得混乱，甚至降低应用程序的响应速度。

如果您使用 React 作为前端框架，那么您可能会使用 Redux 来管理应用程序的状态。在这种情况下，您将实现一个或几个 reducers，以便在每次响应用户操作时修改应用程序的状态。下面让我们看看如何从一个最初的低效的国家形态结构转变为一个顶级的国家形态结构。

### 初始状态形状方法

假设我们正在编写一个应用程序，用户可以在其中发布推文，并且每条推文都有评论。我们还假设推文可以按主题或线索组织。下面是一个基本且低效的状态形状:

正如你在上面看到的，我们有一个复杂的嵌套结构。由于几个原因，这种状态形状被证明是非常低效的:

*   它是深度嵌套的，因此修改状态以更新 tweet 的属性需要开发人员在 reducer 中编写大量代码。
*   `tweets`数组做两件事:它保存数据(即单个`tweet`对象),并对 tweet 进行排序，因为 tweet 在一个数组中。
*   在这种情况下，数组是低效的。想象一下，一个线程中有 50，000 条推文。在数组中找到合适的 tweet 需要时间。数组内的搜索时间是 O(n ),因为计算机需要遍历整个项目列表，直到找到正确的项目。
*   注意，为了这个例子，我甚至没有在上面的结构中包括与每个`tweet`相关的注释，因为那样会更混乱。

不要用数组来存放复杂的对象。正如我们将在后面看到的，在我们的状态中使用数组的唯一目的是为了对元素进行排序。这是因为，与数组不同，我们不能依赖对象来排序它们所包含的元素。

### 用对象替换数组

第一个简单的改进是使用对象代替数组。使用我们之前的例子，现在只关注`tweets`数组，我们可以很容易地像这样修改它:

我们修改了以前的`tweets`数组，并把它必须做的工作分开

1.  创建一个`byId`对象，它的工作只是保存单个的 tweets
2.  创建一个`allIds`数组，它的工作是对 tweet 进行排序——但是这里我们可以只放每个 tweet 的 id，而不是整个`tweet`。

目前的结构已经比第一个结构高效得多。为了找到一条 tweet，我们现在将通过对象而不是数组来搜索它。通过一个对象的搜索时间是常数时间，即 O(1)，这与 O(n)相比是一个很大的改进。此外，我们不再关心每条 tweet 在`byId`对象中的位置。`allIds`数组在这里对推文进行排序，现在使用像`allIds`这样的基本数组就简单多了。

### 包括每条推文的评论

在不使我们的代码混乱的情况下，我们现在可以添加属于每条 tweet 的评论。一种实施方法如下:

与我们使用的第一个例子相比，以这种方式塑造我们的状态要有效得多。在每个 tweet 对象中，我们只通过一组评论 id 引用属于它的评论。在其他地方，我们有一个`comments`对象，在其中我们可以检索关于每个评论的信息。

我们现在有了一个更加“扁平”的结构，在这个结构上我们可以高效地工作。更新这个状态形状需要我们的 reducers 内部的少量代码。我们的代码现在很容易维护，并且我们减少了出错的机会。

### 把所有的放在一起

让我们看看与我们最初的方法相比，最终的结果会是什么。

与第一种方法不同，在第一种方法中，我们混合了数组和对象，使得修改和维护状态变得困难和痛苦，而最后一种方法现在很容易使用。我们的代码易于维护，我们的搜索操作非常快。这显然是一场胜利！

让我们考虑几种情况，看看在修改某些项目时应该做些什么:

#### 添加推文

*   在`tweets`对象的`byId`对象中创建新的`tweet`对象
*   将新 tweet 的 id 添加到`tweets`对象的`allIds`数组中
*   将新 tweet 的 id 添加到适当的`thread`对象内的`tweets`数组中

#### 编辑推文

*   在`tweets`对象的`byId`对象中通过 id 找到选中的`tweet`对象并更新它

#### 删除一条推特

*   在`tweets`对象的`byId`对象中通过 id 找到选中的`tweet`对象并删除它
*   删除`tweets`对象的`allIds`数组中的 tweet id
*   删除适当的`thread`对象的`tweets`数组中的 tweet id

#### 添加评论

*   在`comments`对象的`byId`对象中创建新的`comment`对象
*   将新注释的 id 添加到`comments`对象的`allIds`数组中
*   将新注释的 id 添加到适当的`tweet`对象内的`comments`数组中

#### 编辑评论

*   在`comments`对象的`byId`对象中通过 id 找到选中的`comment`对象并更新它

### 选择器

考虑选择器的一种方法是将它与 getter 和 setter 进行比较。调度类似于设置器，因为它修改状态，而选择器类似于获取器，因为它检索数据。

当用`mapStateToProps`将状态映射到 props 时，通常会在容器组件中使用选择器。假设(如我们的例子所示)每条 tweet 都有一个`isEditable`属性，或者是`true`或者是`false`，并且一次只能编辑一条 tweet。如果您想要检索可编辑的 tweet，您可以编写一个选择器，如下所示:

我只是提供了一个例子，但是你可以根据你想要检索的数据写尽可能多的选择器。

此外，正如 Dan Abramov 所建议的，最好将选择器和 reducer 放在同一个文件中。这是有意义的，尤其是当你把它们看作 getter/setter 的时候。此外，您还可以参考 Redux [文档](https://redux.js.org/docs/recipes/StructuringReducers.html)，其中提供了详细信息。

祝实现 Redux 愉快！

干杯！