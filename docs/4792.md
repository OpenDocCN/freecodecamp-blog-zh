# 背包问题的一个变种:如何用 Java 解决划分相等子集和问题

> 原文：<https://www.freecodecamp.org/news/a-variation-on-the-knapsack-problem-how-to-solve-the-partition-equal-subset-sum-problem-in-java-7e0fc047f19b/>

作者:费边·泰尔

以前，我写过关于用动态编程解决背包问题(KP)的文章。你可以在这里阅读。

今天我想讨论 KP 的一个变种:[划分等子集和问题](https://leetcode.com/problems/partition-equal-subset-sum/)。我第一次在 Leetcode 上看到这个问题——这促使我去了解 KP，并写下关于 KP 的东西。

这是问题陈述(部分转载无示例):

> 给定一个只包含正整数的非空数组，找出该数组是否可以分成两个子集，使得两个子集的元素之和相等。

关于完整的问题陈述，包括约束和示例，请查看 [Leetcode 问题](https://leetcode.com/problems/partition-equal-subset-sum/)。

### 动态规划

像 KP 一样，我们将使用动态编程来解决这个问题。因为这是 KP 的变体，所以逻辑和方法很大程度上是相似的。

### 解决办法

我们将把我们的解决方案放在一个返回布尔值的方法中——如果数组可以划分成相等的子集，则为 true，否则为 false。

#### 步骤 1:防范奇数数组和

很简单，如果数组中的所有数字加起来都是奇数，我们可以返回 false。只有当数组的和为偶数时，我们才继续。

#### 步骤 2:创建表格

接下来，我们创建表格。

表格行表示要考虑的数组元素的集合，而表格列表示我们想要得到的总和。表值是简单的布尔值，表示是否可以用一组数组元素(行)得到一个和(列)。

具体地，行 *i* 表示从索引 0 到( *i* -1)的一组数组元素。偏移量为 1 的原因是因为行 0 表示一组空集的元素。因此，第 1 行表示第一个数组元素(索引 0)，第 2 行表示前两个数组元素(索引 0–1)，依此类推。我们总共创建了`n + 1`行，包括 0。

我们只想知道我们是否能精确地求和到数组总和的一半。所以我们只需要创建`totalSum / 2 + 1`列，包含 0。

#### 步骤 3:预填充表格

我们可以立即开始填充表中基本案例的条目——第 0 行和第 0 列。

在第一行中，除了第一个条目，每个条目都必须是`false`。回想一下，第一行代表一个空集。自然，除了 0 之外，我们无法得出任何目标总和(列数)。

在第一列中，每个条目必须是`true`。不管我们要处理的元素集合是什么，我们总是可以达到目标和 0。

#### 步骤 4:构建表格(问题的关键)

如果满足以下三个条件之一，则表格中第 *i* 行和第 *j* 列的某个条目为`true`(可达到):

1.  第 *i* -1 行和第 *j* 列的条目为`true`。回想一下行号代表什么。因此，如果我们能够用现有元素的子集得到一个特定的和，我们也可以用当前的元素集得到这个和——只要不使用额外的元素。这是微不足道的。姑且称此为`prevRowIsTrue`。
2.  当前元素正是我们想要获得的总和。这也是千真万确的。姑且称之为`isExactMatch`。
3.  如果以上两个条件都不满足，我们还有一个方法来达到我们的目标金额。这里，我们使用当前元素——与前一行中的元素集合相比，当前行中的元素集合中的附加元素——并检查我们是否能够获得目标总和的余数。姑且称之为`canArriveAtSum`。

让我们打开条件 3。如果小于我们的目标总和，我们只能使用当前元素**。如果它们相等，条件 2 就满足了。如果它更大，我们不能使用它。因此，第一步是确保当前元素的<目标总和。**

使用当前元素后，我们还剩下目标总和的剩余部分。然后，我们通过检查上一行中的相应条目来检查这是否可以实现。

与常规 KP 一样，我们希望自底向上逐步构建我们的表。我们从基础案例开始，直到我们得到最终的解决方案。

#### 第五步:返回答案

我们简单地返回`return mat[nums.length][totalSum / 2]`。

### 工作码

感谢阅读！