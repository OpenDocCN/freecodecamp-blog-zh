# 如何使用 React 钩子

> 原文：<https://www.freecodecamp.org/news/how-to-use-react-hooks-ef70894d9fd/>

谢尔盖·甘诺琴科

# 如何使用 React 钩子

![0*ayfiDWDbZ9rrvmd4](img/13332d94370c9faae4761162df9c40d0.png)

Photo by [Artem Sapegin](https://unsplash.com/@sapegin?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

React 16.7.0 终于出来了。它没有机载挂钩，但迟早会有 React 挂钩。所以今天我们要谈一谈，到时候我们就可以马上使用它了？

有时候，当你写纯函数组件时，你会意识到在某个时刻你需要有一个标志，它表示一个模态是开放的，计数器增加了，或者…什么的。然后你的第二个想法是:“哦，伙计，现在我需要迁移来做出反应。组件”。嗯，用钩子——不是任何别的东西！

我假设您安装了以下版本的节点:6.14.0、8.10.0 或高于 9.10 的版本。如果没有，您可以随时使用节点版本管理器来修复它。请记住，我们必须安装所有的全局包，以防我们切换节点版本。

本文要求你至少具备 React 的基础知识，包括"*组件*"和"*纯函数*"概念，"*状态*"和"*组件生命周期*"。但即使你没有，别担心，你会在这个过程中赶上来的，会很有趣的！

#### 步骤 1:样板文件

打开您的终端，因为我们将为 React 应用程序使用一个超级著名的代码生成器，名为 *create-react-app* :

```
npm install create-react-app -gcreate-react-app react-hooks
```

现在，我们可以看到一个名为`./react-hooks`的文件夹，因此我们将它视为应用程序的根目录。

为了真正启用钩子，我们需要在[npmjs.com](https://www.npmjs.com/package/react)查看 React 的版本列表。到写这篇文章的时候，启用钩子的最新版本是[16 . 7 . 0-α2](https://www.npmjs.com/package/react/v/16.7.0-alpha.2)，所以让我们安装这个。我们还需要安装一个完全相同版本的名为 *react-dom* 的 pair 包。

所以，

```
npm install react@16.7.0-alpha.2 --savenpm install react-dom@16.7.0-alpha.2 axios --save
```

不要忘记启动应用程序:

```
npm start
```

#### 第二步:使用状态()

让我们找到`./src/App.js`文件，重新编写成这样:

这是我们可以使用的第一种钩子:用 *useState()创建的状态钩子。*基本上， *useState()* 接受某个值的初始值并返回一个数组，其中第一个元素是一个带有初始值的变量，第二个是一个允许我们改变变量的函数。在我们调用了 *setCounter()* 之后，组件被重新渲染，并更新了计数器的值。

没有挂钩的等价代码是:

但是有了钩子，代码就干净多了，它甚至不依赖于面向对象编程和 *this* 语句，对于没有经验的 JavaScript 开发人员来说，这些语句有时真的很难理解。

状态可以是一个复杂的对象，没有问题:

但是根据钩子的原理，最好定义两个状态值:

这使得你的代码非常容易理解。

#### 第三步:使用效果()

在 react 世界中，*副作用*是通常在 *React 的*componentdimount()、componentDidUpdate()* 和 *componentWillUnmount()* 生命周期方法上执行的动作。组件*。但是，如果我们仍然希望有一个副作用，但有一个纯粹的功能呢？没问题！考虑代码:

在第一次渲染和所有后续渲染时调用 *useEffect()* 中的函数，这与我们直接将代码放在组件函数中没有任何区别。

但是等等。这还不是全部！

我们可以通过告诉 *useEffect()* 只在某些值改变时运行来做一些优化。考虑一下这个:

因此， *useEffect()* 将记忆*【for Batman，for joker】*值，并且仅当这些参数中的某些内容发生变化时，才会重新运行效果。

让我们考虑更多的用例。

#### 案例 A:在卸载时执行代码

如果我们想捕捉组件被卸载的瞬间，该怎么办呢？我们要做的就是像这样返回一个函数:

*“子组件卸载*”将会出现在控制台上，只要你点击 5 次*一个应用*按钮。

#### 情况 B:仅在装载和卸载时运行

我们还可以通过传递一个空数组作为依赖项，强制一个效果只在装载和卸载时运行:

它之所以有效，是因为 *[]* 在组件存在的所有时间内保持不变，直到它被卸载，无论发生什么情况。

#### 案例 C:在装载和更新时异步装载数据

我想演示的最后一个用例是如何通过一些数据加载实现异步效果。明确地说，我不认为在一个地方有呈现数据的逻辑和加载数据的逻辑实际上是一个好主意。单一责任的主要原则告诉我们，应该有一个纯粹的哑渲染逻辑和纯粹的丰富商业逻辑，这就是为什么我强烈建议你尝试 *Redux* + *Saga* 。但我想这是一个很好的话题。

有两个重要时刻需要注意:

*   我们不能使用*use effect(async()=>*{ })，不支持异步效果(还不支持)，但是我们仍然可以在那里使用承诺，并且
*   我们不希望这段代码在每次渲染时都运行，所以我们需要以正确的方式为 *useEffect()* 定义第二个参数。我们总是问自己:“为了重新运行效果，需要改变什么？”。*好的答案是“刻画”。*

#### Step 4: useRef() & useMemo()

如果我们打开 *React* 的源代码，我们可以看到其他可用的钩子。其中就有 *useRef()* 。我们可以结合 *useEffect()* 使用它来做一些事情。考虑代码:

它所做的只是设置一个输入字段的值，然后组件一安装好就调用 *focus()* 。

另一个不错的是 *useMemo()* 。它基本上允许我们在渲染过程中记忆一些值。

为什么这样做？万一我们需要计算一些相当重的东西(渲染时很重，嗯？)，或者进行一些远程调用，但是只有当某些值发生变化时，我们才可能使用 *useMemo()* thingy *。*它仍然没有传统的记忆方法强大，因为它只能在渲染时使用，但仍然…

#### 第五步:引擎盖下

您可能想知道，这个功能是如何工作的？我的意思是，组件只是纯函数，变量如何在函数调用之间保持它们的标量值？嗯，例如， *useState()* 返回一个数组，我们从这个数组中使用第一个参数作为标量。但是这个数组可以在 *React* 中被记忆，所以下次渲染引擎在这里时，它已经知道将哪些值放入那些标量中。

#### 步骤 6:不要

*   首先，钩子仍然处于 alpha 阶段，API 可能会在未来改变，所以在生产中使用它需要你自担风险。
*   你不能在组件函数之外使用钩子，这就是它们的工作方式。但是，你可以把[做成钩子](https://reactjs.org/docs/hooks-custom.html)的组合。
*   React 依赖于钩子在组件函数中出现的数量和顺序的**。所以**不要想用某种条件逻辑来包装这些调用。相反，你可以把你的 *if-s* 放在一个钩子体内。****
*   目前，钩子不能用于服务器端渲染。我希望这个问题能在最终版本中得到解决。

#### 结论

尽管钩子还没有正式发布，但它们肯定会让我们的生活变得更简单，代码也更简洁。拥有可理解的代码总是很重要的，尤其是在使用 React 时。

感谢阅读！如果这篇文章对你有帮助，不要犹豫，在社交媒体上分享它！:)

#### 临时演员

*   这里是为本文制作的概念验证存储库
*   考虑读一读脸书的官方挂钩参考文献

快乐的反应！