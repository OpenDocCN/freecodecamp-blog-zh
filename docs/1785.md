# 技术面试的图形算法

> 原文：<https://www.freecodecamp.org/news/graph-algorithms-for-technical-interviews/>

在技术面试中，面试官通常会要求你解决编码难题。如果你想在这些挑战中表现出色，你应该对图形算法有很好的理解。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一门课程，将教你关于图算法以及如何使用它们来解决编码挑战。

阿尔文·扎布兰创建了这门课程。Alvin 的动态编程课程是 freeCodeCamp 频道上最受欢迎的课程之一，现在他回来教你图形算法。

以下是本课程涵盖的主题和算法:

*   图表基础
*   深度优先和广度优先遍历
*   有路径
*   无向路径
*   连接的组件计数
*   最大组件
*   最短路径
*   岛屿计数
*   最小岛屿

观看 freeCodeCamp.org YouTube 频道的全部课程(2 小时观看)。

[https://www.youtube.com/embed/tWVWeAqZ0WU?feature=oembed](https://www.youtube.com/embed/tWVWeAqZ0WU?feature=oembed)

## 副本

(自动生成)

本课程将帮助您了解实现图算法所需的东西，并使用它们来解决编码挑战。

阿尔文的动态编程课程是我们频道最受欢迎的课程之一。

现在他回来教你图形算法。

嘿，程序员们，我是 Structy 的 Alvin。

欢迎来到我们的图表课程。

特别是，这将是你技术面试的图表。

当然，在那些技术面试中，图表是一个非常常见的话题。

特别是，我想在整个课程中强调的，是在那些技术面试中反复出现的一些模式。

在大约两个半小时的时间里，我会给你所有你需要的工具，基本上涵盖了我认为大约 80%的图形问题。

所以我为这门课准备的是，我认为你们的数据结构和算法，尤其是你们的图表，取得胜利的关键是将事物可视化，对吧。

所以我们要做的是跟踪许多不同的算法，并确保在高层次上理解它们。

这意味着在这里浏览不同的动画，我认为图形作为一个困难的主题有一个很坏的名声。

因为对于一个初学者来说，你可能会对一个问题有非常非常不同的叙述，而不是真正理解。

它们都是基于图形前提的。

所以我们会意识到，很多不同的东西都可以理解为图形。

所以当谈到这门课的先决条件时，我会假设你对图一无所知。

但是你知道如何编码，对吧，所以我希望你能理解一些递归。

所以当你通过这门课，学习不同的图形模式时，我们会用这些模式来解决一些非常经典的关于图形的面试问题。

我会给你很多机会在不同的问题中练习这些模式，我们会在你技术面试的时候准备好。

我喜欢图形这个话题的原因是，只要使用一些不同的算法，你就可以解决大多数的图形问题，对吧。

对于我们讨论的每个图形问题，我们将把它分成两个部分，第一部分是关于视频的方法。

因此，我们将检查战略和整体理论，并确保勾画出一个美好的有意义的画面。

我们还将在视频中讨论算法的复杂性。

按照每一种方法，我们也要实现代码，当然，我要用 JavaScript 写我所有的代码，你可以用任何你喜欢的语言来理解。

这意味着偶尔我会切换到我的代码编辑器，你当然可以跟着做。

我们也将确保提供描述中的链接以及屏幕上的链接。

这样你就可以像以前一样阅读每个问题的提示，以及查看不同的测试用例。

好了，我想这是足够的介绍。

现在，让我们直接进入课程。

好吧，程序员们。

所以让我们直接进入课程，我想先给你们一些关于图表的背景知识，我们将回顾一下在技术面试中开始解决问题所需要的图表基础知识。

首先，什么是图表？图实际上只是节点和边的集合。

关于节点，你可以把它们想象成一些圆圈，里面有一些数据。

所以我会在我的节点里放一些字母值。

当我们提到边时，那只是节点之间的任何连接。

举个例子，如果 A 和 C 之间有联系，应该是这样的，对吗？我可以正式地说，A 和 C 之间有一条边，我可以在这个图中的任何节点之间创建许多边。

当谈到描述节点时，你可能会听到另一个词，就像你可能会听到使用顶点这个词一样，对，它们实际上是一回事。

在本课程中，我将坚持使用节点这个词。

边只是一对节点之间的连接。

这就是图形的全部，在高层次上，有趣的是我们如何使用这个图形框架来解决问题。

因此，如果你把这些节点看作事物，把边看作关系，那么图就是描述事物之间关系的网格。

例如，我们可以说这里的节点是城市，边是连接城市的道路，类似地，这里的节点可能是路线，边代表先决条件。

所以在未来，我们将使用图表作为一种方式来说明和构建一些叙事问题。

来说说这个图吧。

特别是在这里，我真的画了一个有向图。

那是因为我在边缘有一些箭头。

这将是一个无向图的比较。

这里，我有真正相同的结构，除了我在边缘没有任何箭头。

这意味着它没有方向性。

如果我看有向图，假设我在节点 A，那么我可以移动到 B 或者 C，假设我移动到 C。

然而，一旦我到了 C，我就不能去 a，我只能去 E，对吗？那是因为我必须服从这里箭头的方向。

看看我的无向图，假设我现在在这里，我可以选择去 a 或者 E，对吗？如果我旅行到 a，这很好，我甚至可以旅行回 c。

所以把无向图想象成一条双行道。

现在我们将继续我们的导演版本。

让我也介绍一些有用的术语，我们可以在讨论我们的图表中的节点时使用。

如果我当前位于 a 节点，我可以将 B 和 C 称为邻居节点。

好的，所以邻居节点实际上是任何可以通过边访问的节点，当然，服从边的方向。

换句话说，如果我现在位于海节点，我只有一个 E 的邻居，对，如果我在海边，你知道，那么我不会考虑邻居。

太棒了。

当你可视化图形算法时，你真的应该画一张图，看起来就像这样，把节点画成圆圈，把箭头画成你的边。

然而，当谈到我们如何在一些代码中实现这个算法时，我们必须用一种更程序化的方式来表示它。

对吗？所以在我的大脑中，我会想到这样的图像，像节点和它们之间的箭头。

然而，在我的程序中，我将使用典型的邻接表，这可能是我们表示和绘制信息的首选方式。

因此，根据我们通常使用的编程语言，我们会使用一些哈希映射数据结构来表示邻接表。

真的，我们期待使用一些常数时间，我将查找具有键值对映射的数据结构。

所以如果你在 JavaScript 中，它们将是一个对象，如果你在 Python 中，它们将是一个字典。

如果你用的是 Java 或 C 之类的语言，你将会使用无序映射。

看这个哈希表，我画了这个邻接表，这个邻接表的关键字是我的图中的每个节点，对，所以我把所有的节点值 A 到 F 作为关键字。

但是，如果你查看相应的值，这些值实际上是一个数组，对吗？如果我看第一个条目，它说我有一个节点 a，然后在填充的数组中，所有的邻居都有一个 a，a 有两个邻居是 BNC。

这就是为什么我在邻接表中有这个对应关系。

这适用于我的邻接表中的每个条目。

举个例子，看看 e 的条目。

所以我去了那个地方，做了 j，c 列表，这里的键是 E，它只有一个输出边。

这就是为什么他的数组只能在里面。

还有一点要注意的是，即使一个节点没有邻居，它仍然应该在我的邻接表中作为一个键出现。

例如，如果你看 D，节点 D 没有输出边。

这就是为什么它的邻居数组是空的。

然而，它至少应该作为一个键出现在我的邻接表中，这样，你仍然可以知道 D 节点的存在。

所以在课程开始的时候，通常会把邻接表作为表示一个图的信息。

但是当我们在白板上画草图的时候，我们应该用这样一张漂亮的图片来可视化它们。

太棒了。

让我们实际上进入我们的第一对算法。

对我来说，对于一个图，必须知道的算法实际上是对它进行某种遍历。

我们为什么不从深度优先遍历开始，你可能以前听说过，对，现在我们要讨论在图上操作的深度优先遍历算法。

所以让我们从高层次上理解深度优先遍历会给你什么样的顺序开始。

假设我有一个开始节点，我会选择 a 作为开始节点，我会把它涂成黄色。

如果我遵循深度优先遍历。

现在我已经，你知道，选择了我的起点，我可以选择 B 或者 c。

接下来，我将使用 b。

假设到目前为止这个序列有一个逗号 b。

在这一点上，如果我真的遵循深度优先遍历，我必须深入到 D 节点。

换句话说，我还没有到 C 节点。

酷，这将是一个真正的深度优先遍历，对不对。

在这一点上，现在我已经在 D 处触底，D 是个死胡同，对吗？我不能从 D 旅行到 F，因为那会违反箭头。

所以现在我可以移到 c 的另一个邻居

从这里开始，算法会继续，对，我从 C 到 E，然后 E 到 b。

从技术上来说，我必须两次遍历一些节点，比如这里的 B 和 D。

总的来说，在这个黄色部分，我给深度优先遍历要探索的整个区域着色，注意到如果你从 a 开始，就不可能到达 f。

这很正常，对吧？这就是为什么我们使用这些遍历算法，它可以告诉你，你是否可以在一些节点之间移动。

稍后我们会看到字面上的问题。

对吗？所以你可能会想，你知道，我们到底如何实现这个，但是现在，我只想专注于我们得到的顺序，对吧。

关于我们的深度优先遍历，我们记得算法的前三次迭代，我们找到了序列 a B，D，right，这表示深度优先遍历。

现在让我们将它与广度优先马里昂进行比较。

我要画一个完全相同的图，我们也要从 a 节点开始遍历，但是这次遵循广度优先的顺序。

所以我有一个第一个，比方说，你知道，我选择 B 作为我的下一个节点，当涉及到广度优先遍历时。

你选择哪个初始邻居并不重要，所以我会选择 b。

但是现在我选择了 B，如果我遵循一个真正的广度优先遍历，我必须点击 c。

这就是我们深度优先和广度优先反转的主要区别，对于同一个图，我的深度优先从 B，D 开始，而我的广度优先从 a，B，c 开始。

所以你可能会想，这种细微差别有什么重要性吗？什么时候我更喜欢深度优先于广度优先，或者反之亦然？深度优先或宽度优先遍历将探索图中相同的确切节点。

然而，它会以不同的顺序探索它们，对吗？当我们有一个更大的图，有更多的边时，这一点更明显。

让我们看看深度优先遍历是如何再次探索的，但这次是在一个更大的图上，让我们看看这个。

因此，我将选择一些随机节点作为起点，假设我选择了这个黄色的节点，这是在进行深度优先遍历，我要做的是，你知道，选择一个方向，并在切换方向之前尽可能向同一个方向移动。

假设我向右移动，在这一点上，我必须继续向右移动，直到我不能再向右移动，在这一点上，我必须选择一些新的方向，假设它是向下的。

我会继续这样做，直到我再也不能向下移动。

所以我现在必须向左移动，现在我将继续沿着这条单一的路径，向一个非常深的方向前进。

这是深度优先遍历的表现，对吧，在转换方向之前，你在尽可能远的探索一个方向。

让我们将其与广度优先遍历进行比较。

假设从粉色的同一个节点开始，如果我遵循广度优先遍历，它看起来会像这样。

从起点开始，我会探索这个节点的所有近邻，就像这样的一个圆。

现在我只是继续应用这种行为。

正如你注意到的广度优先遍历，它倾向于均匀地探索所有方向，而不是只支持一个方向。

这是深度优先和广度优先遍历的唯一区别。

在课程的后面，我会提出一些你可能更喜欢其中一个的明确问题。

好吧，但是现在，我想做的是给你所有你需要的背景。

所以你实际上可以构建这个算法，它会在一个高层次上谈论一些事情，把它当作伪代码，然后，当然，我们稍后会用一些 JavaScript 代码来表达它。

因此，当谈到在代码中实际实现这两个算法时，关键是要理解深度优先遍历使用堆栈，宽度优先遍历使用队列，回想一下，堆栈是你从顶部添加和移除的东西，还是 Q 是你从前面添加和移除的东西，它给你两种非常不同的排序。

这是这两种算法的唯一区别。

让我们从深度优先遍历开始，当然，使用堆栈，所以我要用一个稍微不同的图。

为了形象化我的堆栈，我将使用这个条来表示堆栈的底部，显然，对我来说，至少我认为堆栈是一些垂直的数据结构。

酷毙了。

假设我任意选择了 a 作为开始节点来执行深度优先遍历，从长远来看，我只想打印出这个图中所有不同的节点值。

所以我要做的是，我要把 a 的起始节点，立即初始化到堆栈中。

所以现在作为我栈上唯一的东西，它也在我栈顶。

现在我可以在这里输入主算法的流程，因为我有一个栈，我唯一能做的就是移除栈顶。

这意味着我从堆栈中弹出一个，并考虑一个节点，我的当前节点，对吗？此时，假设我在控制台上打印出一个。

从这里开始，我想做的是考虑 A 的邻居，对。

如果我看着 C 节点，我应该做的就是把 C 压入栈中，然后把 B 压入栈中。

不管你按什么顺序推这些邻居。

如果我想让它先碰到 B，那么我会第二个推它们，对吗？太棒了。

这将像我的深度优先遍历的第一次迭代一样结束。

酷毙了。

所以在这一点上，我可以看看我的栈，我的栈上还有一些数据。

所以我应该再次弹出我的栈顶。

所以我要退出我的堆栈。

这变成了我的电流，我也要把它打印出来。

此时，我查看 B 的邻居，B 有 D 的一个邻居，所以我把 D 推到栈顶。

注意，因为我有一个栈 D 在 C 的上面，对吧。

现在当我进行另一次迭代时，当我弹出栈顶时，我把 D 节点看作当前节点，我可以打印出 D。

这感觉很好，因为到目前为止，我的打印订单是一个 BD，注意，我好像是沿着一个 BD 走的。

但是我必须看看 DS 邻居，我可以把 f 放在栈顶。

下一次迭代，我的栈仍然是空的。

所以我应该做的是弹出最上面的 F 现在是我的当前，我可以打印出 F，但是 F 没有邻居。

所以 F 不会把任何东西推到栈顶。

对吗？在这一点上，我到了下一步，我弹出栈顶。

这意味着 C 现在是我的电流，我可以打印出 CS 值。

然后我可以看看苏的邻居。

我把 e 放在栈顶。

在最后一次迭代中，我在栈顶弹出，他现在是我的当前值，我打印出他，因为他没有邻居，所以我没有把任何东西放到栈顶。

此时，我已经达到了堆栈为空的状态。

这意味着我的算法是正确的，这意味着你在你的图表中探索了尽可能多的东西。

请注意，您不一定能够找到图中的每个节点。

这个例子是可行的，太棒了。

所以让我们用广度优先算法重做那个轨迹，这意味着我们只是稍微调整一下。

我们使用排队顺序。

请记住，队列是一种先进先出的数据结构，这意味着东西从后面进入，然后从前面离开。

假设我用这个箭头来表示队列的方向。

我以同样的方式开始我的广度优先遍历算法。

假设我想从节点 a 开始。

所以我只是用一个 cool 来初始化我的队列，所以我从移除队列的前端开始。

所以 a 成为我的当前节点，我也可以打印出。

而现在我考虑 A 的邻居，对。

所以我考虑 B 和 c。

如果我想在 C 之前到达 B，那么我应该先把 B 放到我的队列中，所以我把 B 放在队列的后面。

我还应该在我的队列后面加上 c，对吧。

这将结束我的第一次迭代。

所以现在我看看我的队列里还有一些东西。

所以我移除了队列的前端，这意味着 B 变成了我的当前值。

当然，我打印出 b。

现在我考虑 B 的邻居。

所以我只看 D 节点，我把 D 推到队列的后面，因为 D 从后面进入，在 C 后面结束，这是非常重要的行为。

下一次迭代，我移除了队列的前端。

所以我现在的是 see，对，我可以打印出 see，然后看看 see 只是 E 的邻居，我把 E 添加到队列的后面，这意味着在我的队列的顺序中，他在我的下一个迭代之后结束，我从队列中删除了 D，我把 F 的编辑邻居打印到队列的后面。

下一次迭代，我把 e 从队列前面去掉，打印出来。

因为他没有邻居，所以他不打算在队列后面添加任何其他东西。

当然，最后，F 离开了队列的前面，我打印出 F，F 没有邻居，此时我的队列完全是空的。

因为我们的队列是空的，这将是我们算法的结尾。

好了，这就是我们深度优先和广度优先算法的全部内容，它们将成为我们用来解决许多不同图形问题的很好的基线代码。

我认为这是足够的理论。

现在，我想做的是切换到我的代码编辑器，在那里你可以用 JavaScript 实现这些，嘿，程序员们，我现在在我的编辑器里，我想做的是向你们展示如何实现深度优先和广度优先算法。

所以我们先从深度开始。

我的目标是构建一个函数，根据深度优先遍历，打印出图中的所有值，我们要定义这个函数深度优先打印，在 JavaScript 中创建一个箭头函数，它会接收图中的值，这是一个很好的邻接表。

这实际上是同一个图表。

现在我们追踪的最后一个例子，我也需要在这里指定一些开始节点，我称它为源节点，我们将开始遍历。

从那个节点开始。

酷毙了。

所以我们知道深度优先遍历是一个堆栈。

因此，我将向您展示如何迭代地实现这一点，这意味着您需要一个显式堆栈。

对于 JavaScript 中的我来说，这就像使用 JavaScript 数组一样简单，对吗？一开始我会让它空着。

我可以把这个数组作为一个栈来使用，如果我致力于使用操作数组的同一端。

换句话说，如果我只使用 push 和 pop，那将总是操纵数组的末尾，对吗？移除并添加到该数组的末尾。

我想确定的是，我想用我的起始节点，也就是我的源节点，初始化堆栈。

记住，这里的节点实际上是由某个字符指定的。

酷毙了。

当涉及到像算法的主循环这样的设计时，你想在栈不为空的时候继续运行算法吗？换句话说，墙栈的点长度大于零，那我必须保持运行。

这与我们在白板上表达的内容非常相似。

因此，当要首先执行这种深度的单次迭代时，我想做的是删除堆栈的顶部。

所以如果我堆栈点弹出，将会移除数组的最后一项，在这个例子中，就像堆栈的顶部，然后返回给我。

所以我要把它保存到一个变量里，我称它为我的电流。

所以这一点实际上是一个很好的机会来打印电流。

所以我将控制台点日志电流，对不对？看这个例子，因为我初始化了一个栈，只包含 a 的源注释，在第一次迭代中，这个 while 循环，我当然会弹出 a，然后打印出来。

从这一点出发，我想做的是考虑 A 是 B 和 c 的邻居。

所以如果我想看和 a 相关的数组，我可以输入我的图形，因为我的图形现在是一个对象。

所以如果我说图形，方括号，电流，对，如果电流是 a，这意味着图形，方括号电流会返回给我这个数组。

我想遍历数组中的每个节点或每个邻居。

所以我要在这里嵌套一个循环。

我说让数组的邻居。

所以如果你熟悉 JavaScript，如果你只是使用 for of 循环，他们会通过数组迭代一个顺序。

所以现在我打了一个邻居作为 B 和邻居看到。

我想对这些邻居做的只是把他们推到我的栈顶。

所以这将只是堆叠，推和推这个邻居。

太好了，我一定会把所有邻居。

所以有时候我会有两个邻居。

其他时候，我会有一个邻居，甚至没有邻居。

这就是实现良好基线深度第一次打印的全部内容。

我想指出的是，我最喜欢的实现这个算法的方法是，当你的节点离开堆栈时，而不是当它进入堆栈时处理它。

换句话说，我通常像我的打印声明一样，就在某个东西被弹出之后。

我弹出的东西就是我打印出来的。

没错。

所以让我们试一试，看看我们能得到什么。

看起来在我的终端中，我得到了 AC e b df 的命令，你会注意到它与我在这里所期望的略有不同。

然而，这也是一个有效的深度优先遍历，我们必须记住的是，你知道，取决于同一个邻居数组中值的任意顺序，你可能一开始倾向于不同的方向，对吗？当首先验证深度的时候，我寻找的最重要的事情是确保，如果你知道，在转换方向之前追逐相同的方向，对吧。

因为我从 C 开始，所以我到 a，然后到 C，下一步是到 E，这就是我的代码中发生的。

一旦我按下 E 键实际上是个死胡同。

然后我可以继续到我的另一个横向邻居，比如 B，对吧。

所以我可以设计出同样的顺序，如果我把这个翻过来。

所以我把 c 放在 b 后面。

我会分发的。

它们都有效。

深度优先遍历。

看看我们现在有什么。

酷，现在我得到了 A，B，D，F，c 的确切顺序。

好好想想为什么会这样。

假设我刚从堆栈中取出一个。

所以我打印了一份没什么特别的。

然后从那里开始，我开始遍历与一个 right 相关的数组，所以在第一次迭代中，我遍历 C，对吗？如果我在堆栈上按下 C，假设这是我堆栈的底部，通过按下堆栈，它就在这里。

然后我把 B 压入栈中。

现在 B 在上面。

因为 B 在上面，我知道像下一个顶级迭代，这个 while 循环，我会删除 B，这将是我访问的下一个音符。

所以它们确实都很有深度。

很好。

所以要注意两件事，你肯定要用栈来实现深度反转。

您可以通过几种不同的方式使用堆栈。

对吗？所以我在这里使用一个显式的数组作为堆栈。

我用一些迭代代码来实现这个。

所以使用几个循环，你也可以递归地实现深度优先，因为我知道任何递归都使用底层调用栈。

让我也向你展示一下如何实现它。

说到拥有所有这些不同的工具，我肯定会练习迭代和递归。

我们将在本课程的后面部分看到这一点。

假设我想解决同样的问题。

但是现在递归地，它实际上将是更少的代码。

所以我会有同样的论点，我会有一个图，它是邻接表，也是一个源节点，就像源节点，就像你的当前位置。

如果我在某个节点，也许我应该做的第一件事就是打印出我自己，对，打印出这个节点，所以我要做的是控制台点日志，这个源节点。

这从一开始就感觉很好，因为当我们真正对这个递归函数进行顶级调用时，他们会传入一个作为源节点的。

所以我想从 a 开始，作为我文章的第一个注释，然后从那里，我需要看看 AES 的邻居。

好的，如果你想像以前一样看邻居，只要在图中键入，使用那个节点的邻接表，对，这会给我一个 CNB 数组。

现在我只是遍历数组。

所以我说让数组的邻居。

在这一点上，我现在要做的是递归，对，所以我对这些邻居中的每一个进行递归调用。

对我来说，这意味着叫做深度优先打印，你给同一个图形，对，图形对象没有改变，但是你应该像源节点一样改变。

现在，您希望将该邻居作为源节点传入。

你要对数组中的每个邻居进行递归调用。

这实际上是我们所需要的。

让我们继续运行这个版本。

分割线跑过来。

看起来现在我们得到了订单。

这又是另一种深度优先打印，对，不完全是这个顺序，因为这次我们先追 C，对，我们到了 C，我想得到完全的这个顺序和我的递归，然后我必须先放入 B，完全相同的模式。

现在让我们开始吧。

很好。

关于这个递归，我首先要说的是，它没有显式的基本情况，这意味着没有明显的 like，if 语句，就像你在大多数递归中看到的那样返回。

这是因为在这个问题中，我有一个隐含的基本情况，当像他这样的节点是一个死胡同。

好的，假设我的当前源是 he，那么当我在这个 for 循环中迭代时，我在这个空数组中迭代，我的意思是零次迭代。

如果你没有迭代，那么你永远不会进行递归调用。

对吗？这和有一个基本案例是一样的，对吗？基本情况实际上只是一个没有递归调用的场景。

这就是这段代码的工作原理。

好了，现在你知道如何用两种方法实现深度，迭代和递归。

它们都使用堆栈。

现在让我先向你展示如何实现你的广度，同时注释掉一些代码。

现在我们先深呼吸，给自己留些空间。

所以首先从广度上来说，我们想迭代求解 swan。

只有迭代才有可能，对吧。

我知道广度优先遍历需要一个队列，如果你想用递归来实现广度优先遍历，在底层，有一些堆栈数据结构，这将与你想要的队列顺序相冲突，对吗？所以对于广度优先遍历，你通常会写一些迭代代码。

一些循环，对吗？让我定义一下，我会说广度优先打印，接受完整的图，邻接表，以及源节点，我想初始化我的队列。

根据源代码说明，这里的队列只是 JavaScript 中的一个数组。

所以我说 const q 等于一个只从源节点开始的数组。

太棒了。

我将通过在我的 JavaScript 数组上提交两个特定的方法来使用这个队列。

所以如果我用数组点移位来移除数组的第一个元素。

如果我对数组进行点推进操作，就会增加到数组的最后一个位置。

结合使用这两种方法，会给我一个很好的提示，对，加到一端，从另一端去掉。

像之前一样，我们会有一个 while 循环，我们会在队列不为空时进行迭代。

所以当队列点长度大于零时，很好。

和我们的迭代一样，你知道，首先，你想从移除队列的前面开始。

所以我会说 q 点移位，这将删除第一个元素，并将其返回给我。

所以我可以保存在一个变量中，我喜欢称它为当前变量，就像白板一样，对吗？从那里，也许我会把它打印出来。

所以控制台点日志，这个当前节点。

从这里开始，想想你的邻居，对吧。

所以如果我在我的图中键入，使用这个当前节点，这给了我一个它的邻居的数组，我想遍历这些邻居。

所以我可以说 4 表示数组的左邻。

对于那个邻居，我想把他们添加到我的队列的后面。

对我来说，这意味着简单的 q 点推送，我将继续推送那个邻居。

太棒了。

所以我从前面移除，然后添加到后面。

所以看起来相当不错。

让我们试一试吧。

实际上，在这之前，我要改变一下顺序，把 CNB 放进去。

再说一次，邻居的相对顺序并不重要，我只需要这个精确的输出，我们会讨论为什么它是正确的。

试试看。

所以我得到了 ACB 电力公司，就像我期待的 ACB 电力公司一样。

假设你在这个广度优先打印的第一次迭代中，我知道我会删除 a，因为我在队列中初始化了 a，对吗？所以我的当前值是 a，我打印出 a，然后从那开始，我开始遍历这个数组。

所以在第一次迭代中，我有 C，这意味着我把 C 放到我的队列中，对吗？然后，我放 B，如果你放 C，然后放 B，这意味着 C 在队列的前面，这就是为什么在第二次迭代中，我先放 C，对吗？这就是你如何操纵横向顺序的方法。

太棒了。

这就是这个遍历算法的全部内容，我真正想要强调的是，特别是如果你看看苹果到苹果的迭代代码，你先比较深度还是广度，这几乎是相同的代码。

您实际上只是改变了访问数组中项目的方式，对吗？你要么弹出，要么按下，要么移动，然后更用力地按下，这段代码的整体结构是一样的，对吗？好吧。

这就是我们对图形的深度优先和宽度优先的介绍。

在下一节，我们要开始解决一个问题，对，那会很有趣。

我只是利用这段代码作为我们的基线工具。

然后那一节还承诺，开始做这些算法的 bego 分析。

让我们跳回白板。

嘿，程序员们，欢迎回来，好的，让我们来看看这个路径问题的解决方法。

所以在这个问题中，我们要用一个邻接表来表示这个问题的一个图，实际上所有的图问题，你肯定想用一张图片来形象化这个问题。

所以我们要做的是，把这个邻接表的每个键解释为代表一个不同的节点。

如果我看任何特定的列表，我可以看到这个 f 节点应该指向 G 和 I。

在这个问题中，他们告诉我们，我有一个有向图。

所以我要在这些边上画箭头。

所以 F 点 G，还有 F 点平手。

我将根据给定图形中的信息创建相似的边。

所以我们最终得到了这样一个图像，直到他们告诉我们这是一个解释箭头的有向图，但是他们也告诉我们这个图是一个循环图。

如果你不熟悉，循环意味着没有循环，这就回避了一个问题，什么是图中的循环。

所以一个循环是一条通过节点的路径，我可以在我想开始的地方结束。

换句话说，如果我从这里的 a 节点开始，我可以到 B，然后从那里，我可以到 C，然后回到 a，等等。

所以如果我遍历适马图，我会得到一个无限循环。

他们的意思是，我们的图形输入是有方向的。

所以它有箭头，但也有循环，所以我们在这里不用考虑任何无限循环。

也就是说，在这个问题中，我们不仅要获取图信息，还要获取源节点和目的节点，我们要做的是返回 true 或 false，以表明我们是否可以从源节点旅行到目的节点。

换句话说，这两个节点之间是否存在路径？对于这个问题，您可以使用深度优先或宽度优先搜索来实际解决这个问题，我将在这个方法视频中跟踪，只是深度优先搜索。

但是在本演练中，我将确保用两种方式编写代码。

假设从我的源节点开始，我知道如果我做深度优先遍历，我可以选择 IRG，假设碰巧选择 G。

现在我别无选择，对吗？如果我先做真正的深度，我应该深入到 h。

然后我按了这个 h。

当我遍历这些不同的节点时，我需要问自己当前的节点是否等于我的目的地。

到目前为止，这不是真的。

在这一点上，我用我的 h 节点触底，我不能再往下走了。

现在，我可以横向移动到一个节点，比如 I，此时我可以移动到 K 或 G，如果幸运的话，我刚好移动到 G，这实际上会把我带到我之前探索过的路径，我们可以稍后优化它，但不会有太大的问题。

最终，如果我继续在图中进行深度优先搜索，我会在匹配我的目的地的节点结束，在这一点上，我可以返回 true，表示一定有从 F 到 k 的路径，只是进行深度优先搜索。

当我们进行深度优先搜索时，遵守箭头的方向非常重要。

所以我不应该试图逆流而上。

这就是我们能够找到从源头到目的地的路径的情景。

这就是我们返回 true 的原因。

我们重置一下，现在说，我应该返回 false。

好吧，假设我的消息来源是 j。

所以我从 j 开始。

我正试图到达我的目的地 f。

如果我开始深度优先遍历，这里，对不起，我的 j 节点移动到了 AI 节点。

在这一点上，我可以点击 G，好吧，假设我碰巧点击了 k，这是底部的点。

所以现在我可以转到 g 调了。

然后从那里到 h。

在这一点上，实际上我没有别的地方可以去，对吧。

所以如果我完成了对图的遍历，不管是深度优先还是宽度优先，我都没有到达目的地，那么我可以返回 false，对吗？从我的源头到我的目的地肯定没有这样的路径。

当涉及到在这个图上实现深度优先和宽度优先的反转时，这将完全是我们所习惯的，你可以使用堆栈并递归地解决它。

或者可以迭代进行。

并使用队列，在这种情况下，您将进行广度优先遍历。

我们讨论过这个问题的复杂性，假设 n 是我们的图的节点数，你也可以用这些图的问题来做一件常见的事情，就是定义 e 为边的数量，边指的是两个节点之间的连接，基本上就是箭头。

所以如果我们使用节点数和边数这两个术语，我们会得到边数的时间复杂度，因为我们必须遍历图的每一条边。

这里，空间复杂度将基于节点的数量，对吗？如果我用某种深度优先堆栈递归地，甚至迭代地解决它，那么最坏的情况是，我必须让堆栈上的每一个节点，对吗？同样，如果我首先看到一个宽度的永恒，我将拥有队列中的每一个节点。

这只是我们定义术语的一种方式，用来分析这个图的时间和空间。

通常，对于图形问题，分析算法的时间和空间的另一种可接受的方法是只使用一个变量，并将 n 定义为节点数。

这是因为如果你说 n 是节点的数量，那么我们也可以说 n 的平方就是边的数量，或者那个大 o。

大概是最坏的情况。

让我们想象一下最坏的情况。

假设我只有 ABC 的这些节点。

好吧，如果我想创建尽可能多的边，我该如何创建一条边呢？嗯，边只是两个节点之间的连接。

所以你可以在图中为每一对节点画一条边，就像这样。

这就是为什么我们可以说 n 的平方是任何一个特定图的边数。

所以如果你想用 n 来定义这里的复杂度，那么你可以说你的时间是 O 的 n 的平方，而你的空间复杂度仍然是 O 的 n。

我知道这是两种有效的方法来定义一个非常典型的图形问题的复杂性。

也就是说，我认为这很简单。

让我们进入演练视频，同时我们实际上实施了深度优先和广度优先的解决方案。

我在那里等你。

嘿，程序员们，我是阿尔文，现在。

让我们来看一下这个问题的 JavaScript 解决方案。

所以我们直接切入正题，先用深度优先遍历来解决这个问题，我知道这需要一些底层堆栈数据结构，我会用递归来实现。

所以我可以利用调用堆栈来获得我的订单。

所以我要递归地解决这个问题，我要把我的源参数看作是我在遍历过程中的当前位置。

所以我可以检查一下基本情况。

好吧，如果我的来源等于我的目的地，那我一定找到了我要找的东西。

所以才返回 true。

这个基本情况意味着我找到了我的目的地。

所以肯定有一条路。

所以我返回 true，总是注意他们希望我们为这个函数返回的类型。

假设这不是真的，那么，他们需要继续寻找。

所以我应该考虑我的当前节点，也就是源节点，考虑它的邻居节点。

如果我输入邻接表，我知道这将是一个对象。

所以我用我的源输入它，这会给我一个它所有邻居的数组。

举个例子，假设它正盯着这个，如果我的当前源是 F，我说图形方括号，F，我会得到一个 gi 数组。

所以现在我想看看邻居，对吗？我可以看到，这里把我们变成了一个循环，对于那些邻居中的那个邻居，我想遍历它们，这意味着我递归地调用。

右呼叫有路径，保持你的图形不变，但更新你的当前位置。

现在我要去邻居家了。

目的地保持不变，对，总是有相同的目标，递归地解决这个问题。

所以想一想这将返回什么类型，我知道它将返回布尔值，它将告诉我在我的邻居和目的地之间是否有路径。

所以如果在我的邻居和目的地之间有一些连接点，或者一些连接路径，那么我知道从我的源到目的地一定有一些路径，因为你的源肯定在你的邻居旁边，对吧。

所以我们之间会有一条路。

所以我要做的是，检查这个递归调用是否返回 true，我会在这里把它显式化，也许很清楚。

所以如果有一条路径通过我的邻居到达目的地，那么我可以返回 true，只是向上传递这个 true。

因为一旦我找到了一条路径，你就可以退出并把那只鞋一路退回到最高级别的颜色。

但是假设这个调用返回 false，这意味着没有通过邻居到达目的地的路径。

但不可能是其他邻居真的会去工作。

所以我不想说的是，如果 else 返回 false，你应该可以立即捕捉到这样的可疑代码，因为没有必要进行 for 循环，对吗？如果在任何一种情况下，你总是要返回，那么你永远不会有这个 for 循环的第二次迭代，对吗？所以如果我找不到通过邻居的路径，如果这个调用返回 false，那也没关系。

继续下一次迭代，搜索你的另一个邻居。

这就引出了一个问题，我们应该在哪里返回 false，需要在 for 循环之后？所以我找遍了我所有的邻居，却没有找到一条成功的路？我应该返回 false 吗，这就是我们的深度优先遍历。

让我们试一试。

太棒了。

我们找到了。

这里要记住一件事，我们利用了问题中的假设，对，它们直接告诉我们，这个图是病态的，所以没有循环。

这就是为什么在我们的代码中，我们并不真正担心陷入无限循环。

在我们即将面临的问题中，我们将有更硬的草来实际处理这种病态的情况。

但是现在，这是一个很好的基线解决方案。

既然我们在这里，让我们也做一个参考解决方案，你知道，现在应该迭代，没办法像广度优先递归。

所以我需要创建自己的队列。

所以我可以创建一个队列，在紧要关头，我总是在 JavaScript 中使用一个数组，我要用我的源代码初始化那个队列。

所以我要提到源和目的地，它们实际上是节点。

但是在我们的问题中，它们实际上只是给了我们字符串，但是它们表示节点，对吗？所以想想它们代表的信息。

当我的队列不为空时，我将进行迭代。

因此，虽然 q 点长度大于零，应该是熟悉的代码，非常类似于我们的树算法。

我通过移除队列的前端来开始引用的单次迭代。

所以我可以说 q 点向前移动了一些，我可以称之为我正在遍历的当前节点。

现在有东西离开了队列，通常这里是我检查的地方，我可以检查。

好的，如果我刚刚访问了一个东西，如果那是我的目的地，那么我可以返回 true，对，我找到了我要找的东西。

所以必须有一条路径连接我最初的源头和我的目的地。

很好。

但是假设这不是真的。

那我需要考虑它的邻居。

就像之前一样，看看你的邻居，把源输入你的图，就像它是一个图，方括号源。

这给了我一个所有邻居的数组，所有邻居节点。

这就是我在这里要做的，迭代那边的每一个邻居。

然后我可以将它们添加到我的队列中。

因此，q dot 推动单个邻居，并确保首先实现您真正宽度。

所以你需要让东西从你队列的一端离开，然后你把东西加到另一端。

所以这些代码看起来不错。

所以你应该首先意识到这和我们以前的二叉树宽度是多么相似，除了现在我们必须考虑这样一个事实，我们在这里可以有动态数量的邻居，而不仅仅是点左和点右。

所以我只是遍历所有的邻居，把它们相加，我需要等待返回 false。

你猜对了，移动是在你完成整个 while 循环之后，如果你的立方体变空了，那么你必须尽你所能探索。

如果你从来不返回 true，现在你可以返回 false，因为在源和目标之间肯定没有路径。

让我们来测试一下，时间和空间的复杂度是非常相似的。

但这将是我所有迭代粉丝的代码。

这里我有一个小错误。

让我们看看我们在这里做错了什么。

看来我超时了。

让我们一起来看看这个 bug，我不得不猜测这意味着我做错了什么，陷入了一个无限循环。

这个条件看起来没问题，右 q 点长度大于零。

所以在这里，一定是我没有正确的迭代邻居，我只是写了 source。

相反，我需要说当前，因为现在我在迭代地做这个，对。

因此，无论哪个节点刚刚离开我的队列，我都认为这些节点是邻居，并通过我的队列将它们添加为下一个要访问的节点。

让我们试一试。

无心之过。

酷毙了。

这就是我们对这个路径问题的广度优先解决方案。

所以我想让你们做的是，先练习深度，再练习广度，就像你们期望的那样，接下来我们会做很多图形问题。

取决于你知道问题是什么，有时候你会更喜欢一种算法。

所以练习这两种算法非常重要。

现在，所有的问题都相对容易。

所以练习一下，自己尝试一下。

我会在下一个问题中抓住你。

在那里见。

嘿，程序员们，我是艾尔文，对吧。

现在让我们回顾一下这个无向路径问题的解决方法。

所以我们直接切入正题。

在这个问题中，我们将得到一个无向图的边列表。

如果我熟悉这里的术语，实际上我们所说的是每一对，这个边列表代表两个节点之间的连接。

例如，如果我看第一条边，和列表，我看到 I 逗号 j，这意味着在 I 和 j 之间有一条边或连接。

因为这是一个无向图，我不仅可以直接从 I 移动到 j，当然也可以从 j 移动到 I。

所以它实际上代表了两个方向的联系。

所以当我们开始攻击时，我们要做的这个问题实际上是把这个美味转换成一个更好的格式，比如邻接表。

这是因为通常，当我们执行遍历算法时，它们在邻接表形式上工作得最好。

让我们从这里开始转换。

实际上我很容易编写代码。

所以我想生成一个图，我把节点作为键，我想让它们指向它们邻居的数组。

例如，如果我想把第一条边转换成邻接表的形式，我能做的就是为 I 和 j 创建键。

现在我是 J 的邻居，J 也是我的邻居，所以我要分别填充这些邻居。

现在只需按照这个过程的另一个优势。

所以如果我看边，k 逗号 I，我需要为 k 创建一个新的键。

我将用 I 填充它，然后对于 I 的现有键，我只需将 k 添加到集合中。

所以请记住，关于这个转换，最重要的事情是，因为我们知道这个图是无向的，无论何时你在图中放置一个连接，确保你有一个反向连接。

所以如果我有一个从 k 到 AI 的优势，他们也需要有相应的信息。

好吧。

并且这个过程将对整个边列表继续进行。

在转换结束时，我们会得到一个邻接表，就像这样。

现在我们准备执行我们的主要算法。

当我们遍历代码时，我将向您深入展示如何创建这个邻接表。

因此，当我们想真正提出一个遍历算法来解决一个图的问题时，如果你能真正把你的图的形状可视化，那会很有帮助。

所以我想用节点和边来形象化这个。

这意味着它们之间有一堆圆圈和线条。

如果您为这个图形信息绘制一张漂亮的图片，您最终会得到这样的图。

因此，我们将参考该图来浏览本方法视频的其余部分。

在这一点上，我想提出一个重要的问题，对于这个图来说，我们要处理的一个很常见的情况是，如果你的图有一个循环。

对于无向图来说尤其如此。

为了这个方法视频的目的，我将添加一个额外的边，这样我们就可以讨论一个显式循环。

所以我要从 k 到 j 增加一条新边。

酷毙了。

原因是现在有一个长度为 3 的大循环，现在用红色突出显示。

这个循环非常重要，因为如果我们不做任何特殊处理，我们可能会陷入无限遍历。

想象一下，我从这个主题演讲开始，然后移到 J，然后移到 I，然后回到 k，然后回到 J，然后是 I，等等。

所以现在它给了我一个周期，我们必须对此加以防范。

所以我可以有一个三节点的循环，你可以有一个基本上任意大小的循环，只要它不止一个。

举个例子，如果我往下看，注意到我的图实际上包含了两个独立的岛，但是我们会把它们看作一个巨大的图，对吗？所以我得到了 O 和 N 的小岛，它们实际上形成了一个平凡的循环，对吗？如果我在 o 点开始遍历。

从那里，我可以移动到 n。

因为我知道 O 和 n 之间的边是双向的，写了一个无向图，这意味着我可以回到 O，然后回到 n。

这给了我循环的行为。

因此，在这个问题中，必须小心所有类型的周期。

所以在这个问题的背景下，我们不仅得到了一个图，我们还将得到两个节点。

让我们看一个例子，我想返回真或假，在 I 和 l 之间有路径吗？

所以我要在我的以色列图上标出这些。

所以我要从通知开始。

为了解决这个问题，你可以使用任何类型的遍历。

所以无论是深度优先还是广度优先，我都将显式地遍历深度优先遍历。

没错。

现在，为了避免无限遍历，我想在遍历节点时将它们标记为已访问。

所以我不仅要把自己定位在这个 I 的源注释上，还要把它标记为已访问。

您可以像标记访问过的模式一样实现这一点。

以及一些不同的方式。

当我们稍后编写代码时，我们可能会用一个集合来表示我们访问过的内容。

但是现在，我将在我的图表中把它们勾掉。

所以在我的图中，如果你看到一个节点旁边的勾号，这意味着我已经访问过它了。

既然我在这个节点上，我想移动到它的邻居，所以我要移动到 j 的邻居。

我也会确保在参观时检查它。

在这一点上，我可以移动到一个 Jays 的邻居，让我们说我移动到 k。

我还会将它标记为已访问。

现在，马特 K，我可以搬到几个不同的邻居，我可以搬到 LRM。

假设我偶然选择了 I，一旦我到了这里，我知道，我马上就能看到，哦，我之前访问过这个节点。

所以我应该做的是不要再经历一次。

相反，我应该回到 K，对，因为这个眼节点已经被访问过了。

这就是我避免无限循环的地方。

所以，我搬到了凯的其他邻居家，比如说我选择了 l。

此时，我会将其标记为已访问。

如果我快速检查一下，我可以看到我在 L 的这个音符也是我的目的节点。

所以我一定是找到了一条从源头到目的地的路径。

因此，在这一点上，如果我找到了我的目的地，我可以返回 true，这是我们在之前的问题中谈到的模式，我们需要的唯一附加标准是将节点标记为已访问。

这样，我们就不会陷入无限循环。

只有当我们的图中有圈的时候，才会用到它，如果这些圈没有给我们任何我们应该警惕的假设的话。

让我们来看另一个例子。

假设我有 k 的来源。

我的目的地是，从图中可以看到，没有从 K 到 O 的路径，因为它们是不相连的，对，它们在不同的岛上，无论如何都要通过算法，所以我要从 K 开始，标记为已访问，我要访问 Ks 的一些邻居。

所以我可以移到 I，然后移到 j。

在这一点上，我将移回 K，并真正确保它们不会浏览任何 K 个已访问的邻居，因此我不会移回 I 右，而是应该移至一个未访问的邻居，例如 l market 被访问，那么我只有一个其他节点要访问，这将是这个 m 节点。

在这一点上，我实际上已经用尽了这个完整的图形区域，没错，我没有别的地方可以去。

一旦我完成了我的遍历，如果我没有找到我的目的节点，那么我可以返回 false，对吗？从我的源节点到目的节点肯定不存在路径。

这就是这个算法的全部内容。

先说复杂的。

如果说 n 是节点数，那我们也定义他是边数。

就像我们之前说过的，对于我们的图形问题，这通常是可以接受的。

我知道时间复杂度大概是边的数量。

我的空间复杂度是 O/n，也就是节点数。

我认为这是值得一步，你知道这种复杂性实际上意味着什么，你知道，大 O 指的是最坏的情况。

让我们考虑一个最坏的情况图。

有一些不同的图形，你可以设计和思考，我只给你看一个例子。

假设有人给了我一张这样的图，对吗？注意，虽然 z 是一个独立的岛，所有这些节点都是一个三音符和一个 C 音符。

他们都是同一张图的成员。

假设我想知道 A 和 z 之间有没有路径。

所以如果我从这里开始遍历算法，我会从 a 开始，然后移动到 B，然后到 C，然后到 D，然后到 e。

此时，我已经覆盖了图中的所有边。

记住这里的边是箭头，因为我必须穿过这个图的每一条边。

这就是为什么我们说最坏情况下的时间复杂度是边数的 o 倍。

这里我们可以说空间复杂度是 O/n。

因为如果使用深度优先堆栈或宽度优先队列，在最坏的情况下，您必须将访问过的所有内容，或者所有节点添加到堆栈或队列中。

这就是为什么我们说对于常规的图遍历算法，我们有 o v 的时间复杂度，和 O n 的空间复杂度。

好了，我想我们已经很好地掌握了这个算法的方法。

在这一点上，我想加入我的演练视频，在那里我们可以看到如何在一些代码中实现这些访问模式。

我在那里等你。

嘿，程序员们，我是艾伦，对吧。

现在让我们来看一下这个无向路径问题的 JavaScript 解决方案。

就像我们说的那样，我们将直接进入，在接近视频中，将有两个部分。

首先，我们要把边列表转换成邻接表。

这样，就更容易对它进行经典遍历。

所以我假设这里有一个辅助函数。

这给了我一个邻接表。

我称之为图表。

我将调用这个辅助函数，我们称之为构建图形。

如果我通过它，只是我所有的边，我希望它为我做转换。

现在让我们来研究一下这个辅助函数。

然后我们将跳回无向路径。

所以我将创建我的构建图形函数，只需要获取边，对吧。

我知道我希望我的邻接表是普通的旧 JavaScript 对象的形式。

所以在这里创建图形对象。

最后我会像这样把它退回去。

我想做的是用边上的信息填满这个图表。

所以我要遍历每条边。

所以对于边中的边，这样迭代，通过每一条边，我知道一条边会是一对。

所以我要把它去结构化，可能只是我的两个节点标识符，我们从边上把它们叫做 a 和 b。

很好。

我现在要做的是将这些节点初始化为这个图形对象的键。

所以 a 应该是这样的，我记下了这个 k 节点。

所以我要做的是检查 A 是否在我的图中，我想真正清理这段代码，我们最好检查它是否不在图中。

如果 a 节点不在图中，我可以在图中初始化它。

所以把它作为一个键，赋给一个空数组。

我会为 B 做同样的事情。

好的，如果图中的 A 和 B 不存在，我就初始化它们，一旦我这样做了，我就可以安全地将邻居添加到它们的边中，对吗？所以我可以说，图形方括号 a 点推 b。

所以现在我说对了，B 应该是 a 的邻居，但是我知道这是一个无向图，对吗？所以这应该是对称的。

换句话说，然后确保你把 a 推进 b 的邻居。

所以你要注意到这是一个无向图，这一点非常重要。

所以你的邻接表需要那样对称。

所以如果 A 在 B 的邻居中，B 也应该是 A 的邻居。

所以看起来相当不错。

让我们来看看这个图表是什么样子的，在这里做一个小小的侧面测试。

因此，我必须窃取这个片段，在这里获得完整的片段，我可以手动运行它，以确保我可以在使用它们之前测试这些小助手功能。

所以我们试一下，我们应该在这里看到这些边的邻接表形式。

看看它看起来怎么样。

所以看起来相当不错。

所以我看到，好的，我连接到 J 和 k。

对吗？根据这些边缘看起来是正确的。

太棒了。

我还想确保它是对称的。

所以如果我和 j 在这里，我应该让 JNI 也在这里，对，这应该是双向的。

好了，现在让我们开始真正的算法，这是一种遍历。

现在您有了一个好的邻接表，您可以进行广度优先或深度优先遍历。

我想，我要先实现一个深度。

对我来说，如果递归的话，提高 push 会更容易。

所以我假设我有一个函数，叫做 has path，它现在会出现在我的图中。

以及开始节点和结束节点。

所以我想找到一条从节点 A 到节点 B 的路径，当然，我要假设这个函数返回一个布尔值。

但是当然，我得为自己写那个函数。

所以在我们的代码中保持组织，我们说有路径。

我将把图中的节点 A 和节点 b 也包括进来。

我认为这些论点有个更好的名字，因为我在递归地做这个。

让我们称这个为源，这个为目的地。

随着时间的推移，我们将递归调用并更新这个源节点。

这应该是解决其他一些问题的常见模式。

最近。

所以想想我的基本情况。

好的，我知道我已经成功地找到了一条路径，当我的源节点等于我的目的节点时，如果这是真的话，因为我刚刚找到了一条路径。

不然我还得继续找。

所以我应该能够查看我的源节点的邻居。

所以我可以说图形方括号来源，对吗？记住，通过这个递归源的任何一点都代表我的当前位置。

如果我说图，方括号来源，让我们说来源是我，我将访问所有的 ies 邻居，对不对？所以我想做的是真正的迭代，让邻居，或者说，有图的来源。

因此，如果第一次迭代邻居上的源 I 是 j，则第二次迭代邻居可能是 k。

对于我的每一个邻居，我想去拜访他们。

所以调用有路径，你可以保持你的图形参数不变，需要改变你的源，尽管现在你位于你的邻居，你的目的地是固定的，或者你总是试图到达同一个节点。

我要考虑这个返回是什么类型，我知道它会告诉我布尔值，对吗？真的还是假的？从我的邻居到目的地有没有路径，我要去查一下。

好的，如果那个调用返回 true，我会在这里显式的，那么我就找到了一条路径。

所以只要返回 true，对，一直向上传递。

我们在这里形成的逻辑是，我知道根据定义，源和邻居肯定是有联系的。

所以他们之间肯定有一条路。

它们通过一条直接边连接在一起。

所以如果我的邻居有一条到目的地的路径，那么我知道，那么源也有一条到目的地的路径。

太棒了。

在这个 for 循环运行之后，假设我们没有发现我们的邻居有一条成功的路径，那么意味着我完成了这个 for 循环而没有返回 true，这意味着我可以返回 false right，一定是这个源节点没有到目的节点的路径。

因此，我认为我们可以继续进行，给这个代码一个测试运行。

如果您观看方法视频，您会注意到这段代码中缺少了一些重要的东西。

但我们会运行它，告诉你如何在这里钓鱼。

所以这里我得到了一个错误，边缘没有被定义，我做错了什么，34 个月前，这里是 34 行。

所以我得取消这个电话，不再需要它了。

我请客。

让我们开始测试吧。

所以这不是我预期的错误。

不过，我预计会出现某种无限循环。

太好了，我已经超过了最大调用堆栈大小。

所以我得到了一个无限递归。

这是会发生的，因为我们没有考虑图中有循环的情况，对，我们需要避免这种情况。

因为如果我的图中有一个循环，我永远不会碰到任何一个基本情况，我只会继续绕着一个圈走。

如果不清楚的话，记得看进场视频。

就像我们说的，这里的举措是添加某种数据，显示你以前去过哪里。

通常，我们解决图形问题的方法是跟踪一些被访问的集合。

所以当我对这个 house path 进行顶层调用时，我知道这是执行遍历的实际函数，我将在这里传递一个新的参数。

我会把它变成一个新的 JavaScript 集合。

因此，如果你不熟悉集合和 JavaScript，它们实际上只是一个项目的集合。

集合真正伟大的地方在于，我可以在集合中添加一些东西。

我还可以检查集合中的一些东西，对于我们的遍历来说，会非常非常快。

我不想用像数组这样慢的东西，因为在一个数组中做查找或检查，实际上需要 O 或 n 次，或者对于一个集合，需要 O 或 1 次。

所以我要在这里做一个新的论点来接收一个被访问的专栏。

我想做的是检查我的源节点是否已经在被访问的集合中，在 JavaScript 中我可以检查被访问的节点。

所以如果源节点在被访问的集合中，那么我可以在这里返回 false，对，没有理由再遍历这个节点了。

因为如果它是被参观过的，那么我以前一定去过。

这就是我避免无限递归的方法，如果我想的话，也可以把这条线下移。

假设我通过了 if 语句。

这意味着，这个节点源没有被访问过。

但我现在正在参观。

所以我需要做访问点添加源。

所以这个表达式检查 source 是否在已访问的集合中，并且这个表达式将 source 添加到已访问的集合中。

我想在这里改变一些其他的细节。

确保在所有的递归调用中传递相同的访问集合。

因为你希望这个被访问的集合在整个遍历中是全局的，所以我需要知道我过去去过哪里。

一旦我们有了这些，这就是我们所需要的一切，来防止任何循环给我们带来无限的递归。

让我们试一试。

太棒了。

我们的无向路径问题有一个解决方案。

这里要带走的重要的东西确实要考虑这个问题，一分为二，对吗？第一阶段非常简单，只需将边列表转换为邻接表，这实际上是一项需要练习的重要技能。

因为当涉及到，你知道，你在野外会遇到的一些问题，它们基本上都是图的问题。

但有时他们会给你图表，喜欢不同的格式，你总是可以转换成你觉得舒服的格式。

从那里，我们有了一个真正的核心模式，只是遍历一个图，但也防止无限循环，对不对。

为了做到这一点，我们只需要使用某种访问过的集合。

嘿，程序员们，欢迎回来，现在我想复习一下解决连通分量计数问题的方法。

所以在这个问题中，我们想要做的是用一个邻接表来表示一个无向图。

和往常一样，对于任何图形问题，您都希望从可视化实际图形开始。

所以如果你给这些信息拍张照片，它最终会看起来像这样一个结构的图表。

关于这个可视化图形，我们应该注意的第一件事是 a 有多个连通的组件。

例如，我可以看到这个粉红色的组件仅包含一个和两个节点，我可以看到另一个包含四个或 5678 个节点的组件。

最后，第三个组件只覆盖三个节点。

这就是为什么我们说这个函数的结果应该是 3，对吗？因为有三个不同的连接组件。

让我们想出一个算法，我们可以用它来计算元件的数量，我们知道一个通用的计算算法会用到一些变量，我们将把这个计数变量初始化为零。

这里的技巧是结合使用一些标准的图遍历代码，可能是深度优先，以及一些迭代代码。

我会在左边列出所有不同的节点。

我要做的是从迭代开始，遍历列表的每个节点。

我要做的是，当我现在在这个迭代列表的某个节点时，我要在那个节点开始遍历。

所以现在从一的节点开始，我们说一个深度优先遍历，你可以用深度优先或者广度优先来实现这个模式。

假设我从这里的一个节点开始。

我现在应该做的是尽可能继续这种遍历，这是这里胜利的关键。

所以从这一个节点，我可以移动到两个节点的邻居。

当然，当我遍历这些节点时，我希望确保将所有内容都标记为已访问，这样可以避免循环。

将事物标记为已访问也将确保我们不会重复计算这里的任何组件。

一旦我注意到这一点，我实际上已经完成了这个完整的组件，没有其他地方我可以探索。

所以在这一点上，我应该把我的计数加 1。

所以每当我在图的某个区域完成一次新的遍历，我都需要增加我的计数。

在这一点上，我现在退回到我左边的迭代代码，我迭代通过下一个节点。

所以我现在看第二个节点。

如果我看一下第二个节点，我会看到我已经将它标记为已访问。

这意味着我不需要在那个节点开始遍历。

所以有效地跳过这两个并保持计数不变。

下一次迭代我有一个 3，3 现在是未访问的。

因此，我应该从这三个节点开始一个新的遍历，这意味着我只是将它标记为已访问。

因为这三个是一个单独的节点，对，它没有连接到任何人，我实际上要完成它们的遍历，就在这三个节点上。

至此，我已经完成了一次遍历。

所以我把我的计数加 1。

所以现在我总共有两个，我回到我的迭代代码。

所以我从三节点移动到四节点。

我看到这四个节点没有被访问，这也意味着我必须从这四个节点开始遍历。

我将扩展这个遍历。

尽可能从四个开始，在我回到我的迭代代码之前，对，所以我要探索六个，探索这五个，探索这七个，最后探索这八个。

至此，我已经完成了一次遍历。

所以我可以把我的计数增加到三。

然后我不得不继续，退回到我的迭代代码。

看看这五个节点，我看到这五个节点已经被标记为已访问，所以我不开始遍历。

而且我看到，这六个节点，同样的东西不需要开始遍历七个已经访问过的节点，八个已经访问过的节点。

至此，我已经完成了整个算法。

这是我最后一次数到三。

这里有几个有趣的机制，你需要明确地实现一些代码或函数，尽可能地遍历一些组件，然后你还需要一些迭代代码，以便可能在每个起点开始遍历。

您需要做的是，在遍历节点时，确保将节点标记为已访问，因为只有当您将新节点标记为已访问并完成遍历时，才应该增加计数。

您可能想知道我们如何在一些代码中实现这一点的具体细节，但不要担心，您会意识到这实际上只是我们之前在演练视频中的图形算法的副产品，但现在，我们看到 n 是一些节点，他像往常一样有一些边，我们知道这实际上只是遍历整个图形。

所以我们可以说时间复杂度是 o v，空间复杂度是 O/n，对吧，取决于你是先做广度还是先做深度，你会使用那个空间，然后根据你的栈或者立方体。

我们也可以考虑使用我们集合中的空间，如果你使用一个集合来标记你的节点为已访问，但总的来说，它仍然会导致线性时间和线性空间的解决方案。

好了，我想我已经准备好编码了。

我们在演练视频中再见。

嘿，程序员们，我是 Alvin，好了，现在让我们来看一下这个连接组件计数问题的 JavaScript 解决方案。

因此，我们将实施我们在方法视频中谈到的策略。

因此，请务必先观看，我们知道这将需要两种不同的机制，需要我们的交互代码来跳转到不同的连接组件。

我们还需要一些遍历代码来尽可能地探索某个组件。

所以我现在要做的是从迭代代码开始。

所以我需要在每个潜在节点开始遍历。

所以我可以说，让我的图中的节点，在我的图中，因为在这个问题中，我们看起来像 JavaScript 对象。

所以如果我说让图中的节点，会给我每个键，比如 015，等等。

所以对于图的每个节点，我想做的是开始遍历。

我们假设这里有一个函数，我称之为 explore。

当然，我会传入这个图，还有那个节点。

我想让这个函数做的是，比如说，深度优先遍历，尽可能从那个节点开始，所以可能需要在这个主函数中加入更多的逻辑。

但现在，我认为是时候真正充实探索了。

所以我将选择递归地使用这个探索方法。

我们将定义 explore，它将包含一个图，以及我当前的节点，我就称它为 current。

然后从那里，我想解决这个问题，先用一个深度。

所以递归是好的。

这里没什么要做的，但是我想遍历这个节点的所有邻居。

所以我可以说，就像当前图的邻居，我记得这个图是一个邻接表。

如果电流扩散开来。

因此，如果 current 是一个像 8 这样的节点，那么在第一次迭代中，邻居将是 0，下一次迭代中，邻居将是 5。

所以在这里，我只是遍历当前节点的所有邻居，我只需要不遍历它们。

所以我可以调用 explore，沿着相同的图传递，这不会改变。

但是现在我的新的当前节点将是邻居，就像这样，这将执行深度优先遍历的基线。

但我们也需要将事物标记为已访问，就像我们在方法视频中所说的那样，这是解决方案中非常重要的一部分。

我希望这个 like visited 集合在我的整个遍历中是全局的。

所以我必须创建它，也许这是我的主要功能。

所以我可以创建我的常量 visited，使它成为一个 JavaScript 集合，因为 JavaScript 为我设置了 O 个查找，O 个添加，我可以传递这个 visited 集合作为我的引用，直到所有这些调用都在这里。

所以我知道我现在会在这里接受访问。

现在我想开始使用 visited。

有几件事要注意，对吧，我肯定要用 visited 来防止循环，对吧？这是我们经常访问我们的图形遍历的主要原因之一。

这里有一些熟悉的代码。

如果我已经访问过这个节点，那么如果被访问过，有这个当前节点，那么这里没什么可做的，可能只是返回 false。

稍后，我们会看到。

我们在这里使用的真正酷的技巧是返回 false，right，实际上有两个目的。

返回 false，因为这可能是一个循环。

然后我需要确保我在这里也传递了被访问的集合。

很好。

假设我们有一个未被访问的当前节点。

所以这个说法是假的。

那么，看起来我们现在正在访问这个节点。

所以现在我们应该将它添加到已访问集合中。

很好。

除此之外，我们需要确保我们的浏览器函数在类型上是一致的，对吗？所以我要让我的浏览器函数做的是，每当它探索一个新的节点时，它都会返回。

如果你看一下这段代码，我的函数在第 17 行返回 true，那么它一定已经完成了对所有邻居的搜索，因为我知道这个 for 循环完成了搜索所有邻居的工作，对吗？所以只有在所有邻居的电话回复后。

我会返回真实吗？这意味着我已经尽可能地探索了这个组件。

对吗？这看起来不错。

我现在能做的是在我的主函数中，当我调用 explore 函数时，它会给我布尔数据，对吗？如果它在探索一个新的岛，或者一个新的组件，它将返回 true。

所以我可以检查。

好的，如果 explorer 返回 true，那么这是一个新的组件。

所以我可以在这里增加一些计数，我应该创建。

我说 11，计数等于零，我要增加这个计数，当我找到一个新元素，最后加等于 1，我当然应该返回这个计数。

你会注意到，在我们迭代到一个已经浏览过的节点的情况下，当我进行这个调用时，我知道这个调用将返回 false，因为如果已经浏览了某个内容，它将被添加到 visited 中。

这就是为什么我在这个递归函数中使用了一些布尔返回值。

所以代码看起来相当不错。

我想在这一点上，我们可能已经准备好测试这个了，让我们在这里试一试。

一些非常复杂的代码，不是很长。

这是一个真正的核心模式。

看起来我得到了一个错误，我们有一些错误。

所以看起来答案应该是 2，但是我给了 7。

所以我数得太高了。

所以我要做的就是调试这个程序，也许只是打印出我访问过的。

这是 JavaScript 中一个很常见的错误，我想这个例子，我可以手动测试。

我想确定的是，也许在每次迭代时，比如说这个 for 循环，我每次都用访问过的关联访问过的变化来记录点日志。

我将通过点击 run 来手动运行它。

让我们看看这里有什么。

有几件事要注意，看起来我们的一些键，或者集合中的一些项是字符串或者字符串中的零。

其他时候它们实际上是数字，请注意它们缺少引号，这与 JavaScript 对象有关，从技术上来说，JavaScript 对象的键总是被转换为字符串，尽管这些数组中的数据是数字。

集合实际上可以存储这两种类型。

所以如果你有两种不同的类型，就不能算出它们代表的是同一个节点。

例如，看这个被访问过的集合，我喜欢数字 1，还有字符串 1，这不好。

让我们把它们都转换成字符串。

所以我将检查它是否有我当前节点的字符串版本。

所以我只做我自己的转换。

同样，我想在这里添加当前节点的字符串版本。

这样，我有非常一致的类型。

让我们手动运行一下，现在应该可以看到所有的字符串了。

太棒了。

我认为我们可以运行所有的测试案例。

所以在 JavaScript 中这是一件非常重要的事情。

JavaScript 在这方面非常独特。

它会自动把你所有的键转换成字符串。

太棒了。

好了，程序员们，这是我对这个连通分量计数问题的全部了解，你们要做的是真正练习这个问题。

这其实是一个非常非常常见的面试问题。

这个问题有很多变化，我们将来会做。

嘿，程序员们，我是艾尔文，对吧？现在我想介绍一种方法，我们可以用它来解决这个最大的组件问题。

所以在这个问题中，我们要做一个图表，就像我们最近做的一样。

你应该做的第一件事就是把这个图想象成一张图片。

所以希望你把它画出来了。

这样你才能真正理解这是在问什么。

我们的图信息已经作为邻接表给出。

所以很容易画出来。

既然我有一个这样的图，我首先应该注意的是它可能包含多个组件，对吧。

所以在这里，我看到了两个独立的岛，两个独立的组件。

我想考虑每个组件的大小。

如果我看一下我的第一个组件，跨越节点 015 和 8，我知道它们的大小是 4，它们是 4，代表该组件中的节点数。

所以我真正感兴趣的是有分量的节点的数量，而不一定是边的数量。

如果我看一下跨越两个、三个和四个节点的另一个组件，它肯定有一个三节点组。

这个问题真正关心的是最大的组件，所以我应该只返回 4，因为这是最大的组件大小。

所以当这个问题问的是什么的时候，如果你已经按顺序做了这些问题，你确实有一些熟悉的模式，当然，我总是建议你按顺序做这些问题。

那么我们如何着手解决这个问题呢？嗯，我知道我需要某种迭代代码，这样我就可以移动和跳转到不同的组件或不同的岛，我可能会做一些深度优先遍历变化，也可以找到连接组件的大小。

让我们一步步来看这个算法是如何运行的。

在侧面。

我将列出我的节点，来表示我将如何进行迭代，以每个节点为起点进行遍历，所以我将从节点 0 开始。

因为节点 0 没有被访问，现在，我要开始一个全新的遍历，从节点 0 开始。

我将把我的节点标记为已访问过，因为像通常的无向图一样，你要注意并防止你可能陷入的任何循环。

而且我知道这种深度优先遍历，是要尽可能地探索这个完整的区域。

借助递归的力量，实现某种模式变得非常容易，这种模式可以在遍历时计算每个节点。

当然，我会把每个节点都当作一个单独的音符。

最终，这些将返回到我的顶层调用，在这种情况下，我可以把它们都加起来，总共得到四个。

如果这感觉很像手动波动，并且你想知道，我们到底要如何编码那个模式，不要担心，它实际上是我们以前见过的模式。

所以我会在代码中详细介绍。

就目前而言，获取节点数其实没什么大不了的，对吧。

现在我知道这个组件的大小是 4，我应该做的是将它存储为我目前看到的最大的岛或组件，因为这是我考虑的第一个组件。

在这一点上，我应该回到我的直觉代码。

我看着节点 1，我应该注意到节点 1 已经被选中，已经被访问过了。

所以没有理由从这个节点开始另一次遍历，因为如果它被访问了，这意味着我已经浏览了节点一是其成员的组件，所以我基本上可以跳过它，在我的迭代中继续到节点二，因为节点二没有被访问，我应该开始一次新的遍历。

在这里，我知道这个深度优先遍历将尽可能地探索该组件，它将继续下去，并将所有这些节点计为一个。

最后这些数字加在一起，我数到三。

下一个组件的大小为 3，我需要将这三个组件与我当前最大的四个组件进行比较，显然，四个组件更大，所以四个组件仍然是最大的。

当我回到我的迭代代码时，我注意到我已经访问了三个三，所以没有理由重新开始。

遍历，四是已经访问过了，所以没事做，五是访问过了。

当然，八号也被拜访了。

此时，我们已经查看了图表中的每个节点，并且我们一定已经研究了每个组件，因此我们可以返回存储在最大变量中的最终值。

太棒了。

当谈到这个算法的复杂性时，它是非常简单的。

这基本上就是我们到目前为止看到的所有算法，我们看到 n 是节点的数量，e 是边的数量，我们知道时间复杂度大约是边的数量的 O，实际上只是浏览整个图，我们还可以看到空间复杂度也将是线性的，实际上只是 n 的 O。

因为通过所有这些，我们可能会将所有节点存储在一个集合中，以跟踪访问过的节点。

根据您实现遍历算法的方式，无论您是使用深度优先还是宽度优先，您还将在堆栈或队列中使用线性空间量。

总的来说，我们正在寻找一个非常有效的线性解决方案。

就这样，我想我已经准备好编写这个程序了。

不过，我想让你做的是，首先可能在你自己的第一个集群上尝试一下这个，实际上只是利用一些我们过去见过的代码。

所以你自己去试试吧。

如果你被困住了，你可以在漫游视频中找到我。

我在那里等你。

嘿，程序员们，我是 Alvin，现在让我们来看看这个最大的组件问题的 JavaScript 解决方案。

所以这个问题将会是我们上一个问题的衍生。

所以我们马上开始。

和往常一样，确保你先看了进场视频。

我们将从构建代码开始，这将帮助我们在这里开始一个不相连的孤岛上的遍历，对吗？我们应该说，这是连接的组件。

所以我将开始遍历图的每个节点，这意味着我只是遍历输入对象的键。

因为记住，我们已经给了这个图一个邻接表。

所以我可以说对于图中的 let 节点。

所以我给我 015 这样的节点，以此类推。

我要做的是从这里开始遍历，对吗？我们假设我有一个函数，我称它为探索大小。

如果我给它图的信息，以及我想遍历的节点，希望它真的遍历了整个连通区域。

我要假设的是，让我假设这个函数实际上返回了整个组件的大小。

这是一个数字，代表这个组件中的节点数。

如果我在这里得到它，称它为大小。

我知道我需要一些最大值逻辑，来处理整个 for 循环。

所以我要创建 longest，将其初始化为零。

然后从那里，我可以检查。

好的，如果我刚刚找到的组件的大小，如果它比最长的大，那么我可以替换最长的，简单地说，最长的等于大小，在 for 循环之后，我会读取 Turn 最长的过程，我需要写这个 explore size 函数。

所以我首先将它实现为一种深度。

所以我要让它递归，至于大小，取图，以及我们当前的节点。

这里我应该注意一些事情，它们告诉我们，我们有一个无向图。

所以我们需要确保避免任何循环。

我们还设置了一些经典的结构，我将使用一个访问过的集合，我们将使用一个集合，因为它给了我 O 个查找和 O 个插入。

现在我有了我的已访问集合，我可以在开始遍历时传递它。

现在让我们做一个基础案例，检查我是否已经访问了这个节点。

所以如果被访问的集合已经有了我需要返回的当前节点，基本上要避免递归调用。

但是我也想要一个一致的类型，对吧，所以我假设这个函数在我遍历的某个点返回一个代表大小的数字。

如果我到达一个已经被访问过的节点，那意味着我已经计算过了。

所以我现在把它当作零，因为我不想重复计算我的节点，否则这里会不准确。

除此之外，我还可以在这里创建一个变量，我称之为 size，我会把它设为 1，来表示我现在所在的节点，对吗？如果这个条件不成立，那么这是我第一次看到这个节点，所以我需要计数。

我们还要确保将它添加到“已访问”中，这样我就不会在以后进入节点循环。

很好。

此时，我需要对这个节点的邻居进行递归调用。

就像我们通常做的那样，我们可以说，让节点的图的邻居。

所以记住你的数据形状。

因此，如果节点是一个键，比如 5，当我说，图节点的邻居，这将迭代通过邻居 5，0，然后 8，等等。

所以在这里，我进行递归调用，我要调用同一个函数 explore sighs，传递同一个图形。

但现在你位于你的邻居，你可以提供相同的访问集。

这里是我做信念递归跳跃的地方，对，我假设这个探索大小函数是有效的。

如果它在工作，它会返回什么，它会返回一个数字，代表图形的大小，从我的邻居开始。

所以不管我在这里得到什么数，我都想把我的大小增加这个数。

这将累计这个全连接组件中所有节点的基本计数。

在我探索完我的邻居之后，我会完全探索整个组件。

所以我可以返回我的最终答案，也就是这里的大小，你需要做的真正重要的事情是，确保如果你遵循这种策略，你开始的大小等于 1，随着时间的推移，你会增加它，因为这代表我所在的当前节点，我知道每个调用都会计算它自己的节点。

所以随着时间的推移，这实际上会积累我需要的一切。

感觉很好，有我们良好的访问逻辑。

我们已经在这里写了我们的主函数。

请注意我们是如何将这段代码拆分成一个很好的小助手函数的，我认为这是表达这一点的最好方式，这与我们之前做过的一些问题非常相似。

好吧，我想在这一点上，让我们继续尝试一下。

看，我们得到的，应该能通过一些不同的测试案例。

很好。

这里，我们有最大的问题。

有几件事，我想让你记住，对于你的图形问题，或者你有断开的组件，你不仅需要你的遍历代码，还需要一些迭代机制，通常只是一个循环，以确保你可以跳转到不同的组件，对吗？因为如果只有常规的 like 遍历函数，根据定义，独立组件之间没有边界。

所以你永远无法探索整个图表。

否则，好吧，程序员练习，我下节课再找你。

嘿，程序员们，我是艾尔文，对吧。

现在让我们来看一个解决最短路径问题的方法。

这里我们有另一个图的问题，你的图将作为边列表给出。

所以我们应该做的第一件事，当然，是想象这个图表。

在你的代码的上下文中，如果你把它转换成一个邻接表可能是最好的。

因为我们在最近的一些问题中见过几次这种模式。

我会把那部分留给你。

但是我们最终会得到一个类似这样的图表。

在这个问题中，我们也将得到一个两个节点，假设 W 和 z，我想做的是返回这两个节点之间的最小路径。

这里有两条明显的路径，对吗？从 W 到 z 的一种方法是通过 x 和 y。

我可以看到路径长度是 3。

请注意，我们将把路径链接视为路径中的边数。

所以不是节点的数量，对吗？这意味着我如何计算三呢？实际上只是三条线，对，三条边。

这是从 WC 得到的一种方法，从 W 到 z 的另一种明显的方法是通过 VI，在这种情况下，我只需要使用两条边。

所以路径线当然是两条。

而这个问题，我想做的是返回尽可能小的路径长度。

所以我这里应该还两个最后的答案。

所以我们知道这个问题需要我们做一个图寻路算法。

问题是，我们应该采取哪一个，我们当然要么可以选择深度优先遍历，要么宽度优先遍历，这里我就开门见山了。

实际上，这两种方法都会给你一个有效的策略，这意味着你可以用深度优先或广度优先的策略来解决这个问题。

但是也许这些算法中的一个会比另一个更好。

所以让我们考虑一下可能性。

假设我有一些大图，现在可以抽象地思考一下。

我们来看一个抽象的例子。

假设我正在进行深度优先遍历。

假设我的起始节点是黄色的，目标节点是蓝色的。

所以我想做的是，再一次，算出这两个节点之间的最小路径距离是多少，显然，你知道，只是从长远来看，你应该得到一个像这里的 2 这样的答案，对，因为 2 绝对是这两个节点之间的最短路径。

如果我们进行深度优先遍历，我知道深度优先会迫使我尽可能往一个方向看，直到我不得不转换方向。

我从黄色开始，假设我们向右移动，一条边再向右移动，两条边再向右移动，三条边。

此时，我再也不能向右移动了。

假设你向下移动，在 456 处，你不得不改变方向，再一次，7，8。

在这一点上，我们已经看到，这最终可能会到达蓝色的目标节点。

但那不会是最短的路径。

不幸的是，虽然我的星形和节点非常接近，但是深度优先遍历可能是不幸的，因为它可能在完全错误的方向上搜索，并在图中蜿蜒前进，直到它最终找到我的目标节点，此时我肯定没有最短路径。

所以我认为广度优先遍历在这里会更有用。

假设从我的绿色节点开始，仍然是我的起点。

如果我进行广度优先遍历，我知道广度优先意味着我将非常均匀地探索所有方向。

所以它看起来像这样。

所以我会从起点的一边开始探索所有的节点。

然后，从那里开始，我将开始探索所有节点两个边缘远离我的出发点。

在某个时刻，我会点击我的目标节点。

如果这是我第一次看到我的目标节点，那么根据定义，我一定是找到了最短路径，对，最短路径是两条。

所以这是我的高层次的论点，为什么广度优先搜索会更有用，在我看来，对于这个问题，让我们一步一步地通过这个过程多一点算法。

假设我有我的原始图表。

如果我要进行广度优先遍历，我知道我必须正确使用队列，不管是什么队列给了你广度优先顺序。

我要做的是查看我的队列中的项目，我不仅要存储节点，还要存储离起点的距离，这意味着我要初始化队列中的起始节点，以及距离 0。

这代表了一个事实，W 的音符离起点零边，因为它本身就是起点。

所以在任何时间点，我的队列中的项总是成对的，在节点逗号距离的右边。

所以现在我们要开始我们的通用算法，我要继续迭代。

虽然我的队列不为空，但是一次 screening 的迭代将会删除我的队列的前端，我将把它标记为我的当前节点。

在这一点上，我应该检查一下，W 的当前节点是我要找的东西吗？不是，所以我需要探究 W 的邻居。

这样我就能看到 x 节点。

我知道我需要把它加入我的队列。

但是当我把它添加到我的队列中时，我想确保我用一个距离来标记它。

因此，如果我的当前节点有这个零，我知道这个节点的邻居的距离是 1，所以我只需将当前距离增加 1。

所以在我的队列中，我放了一个写着 x 逗号 1 的条目。

对于这个 V 节点，我有一个类似的场景。

也是 w 的邻居。

所以我也把 v 逗号放在我的队列中。

此时，我可以进入下一个迭代，或者移动队列的前端。

所以我看着 x。

然后我看看 X 的邻居，记住，因为我有一个无向图，X 有两个邻居，它有 w 和 y。

你应该已经知道了我需要追踪拜访过的人。

换句话说，当 X 要考虑它的邻居时，它应该只关心 Y，对，我不希望 X 把 w 放回队列，因为那样我会得到一个无限循环。

所以我要看看这里的 Y。

我要把它添加到我的队列中。

因为我知道我现在的 X 的距离是 1，y 的距离一定是 2，总是把距离增加 1。

酷毙了。

然后我继续这个算法。

我现在去掉了我的队列的前面，那将是 V 音符。

在这一点上，我可以考虑 V 的邻居，我确实看到它的邻居之一实际上是谢轩，这是唯一未访问的邻居，我要确保将 z 添加到我的队列中，并用距离 2 标记它，对，因为如果我的 V 的距离为 1，它的邻居的距离将为 1。

在这一点上，你已经可以看到这个算法是如何工作的。

最终，这 z 个节点将离开队列，这将是我的目标节点。

既然我已经在队列中添加了一个与目标匹配的节点，我知道我已经有了最终答案。

这里的 2 代表了我们在逻辑路径上的边数。

当然，我也会把它还回去。

所以在很大程度上，这个算法听起来就像一个经典的广度优先遍历。

使用图中的队列，唯一有趣的一点是现在我们还将跟踪当前距离。

你知道，当计算一条路径的长度时，你需要一些计算机制。

因此，如果你的队列从距离为零的起始节点开始，每当有东西离开立方体，并添加它的邻居时，它应该将距离增加 1。

就像你已经猜到的，这个算法非常有效，因为我们不需要遍历一个以上的图。

我们会看到这是一个线性复杂度。

好了，我想我已经拥有了编写这个程序所需要的一切，我确信你对这些实现细节感到疑惑。

因此，您想要做的可能是自己尝试一下这个实现。

如果你需要帮助，你可以在那些视频里找到我。

在那里见。

嘿，程序员们，我是艾伦，对吧。

现在让我们来看看最短路径问题的 JavaScript 解决方案。

所以我们马上开始，希望你能看到接近的视频。

所以我们将开始把我们的边列表输入转换成对我们的遍历更有用的东西，比如邻接表，我们将写一个非常经典的函数。

当我称之为构建图形时，就像你期望的那样，它包含了边。

我想让它返回一个邻接表。

对我来说，这意味着一个 JavaScript 对象，我称它为 graph，在这个函数结束时，这将有助于我返回图形和一些公共代码，我将迭代每一对，对，基本上是每条边，我说，是边的左边。

当我在每条边上迭代时，当我想把这条边分解成它的组成节点时，我把它叫做 a 和 b。

现在我可以开始格式化我的邻接表了。

所以我知道我想要这个图的键明显是节点，我想要值是那个节点的邻居的数组。

所以我要做的是，这是第一次遇到一个节点，我会检查。

好，如果这是一个节点，如果它还没有作为键出现在图中，那么我应该第一次创建它。

所以把它作为一个键，把它的值初始化为一个空数组，基本上，在开始的时候没有邻居。

b 也一样。

然后，在这一点上，我知道 A 和 B 现在肯定作为键存在于图中。

所以我想加上这些邻居。

所以如果我有一条边，比如 w 逗号 x，我知道 x 是 w 的邻居，w 是 x 的邻居。

所以简单地说，图 a 点推 B，然后它的逆应该就可以了。

酷毙了。

这应该给了我们图表。

现在让我们在主函数中使用它。

所以我们就说图等于在边上建图。

我们现在要做的实际上是按照我们的广度优先逻辑工作，就像我们在方法视频中所说的那样。

我要做的几件事是，我一定要建立我的队列，我们说过，胜利的关键不仅是在你的队列中存储节点，而且对于队列中的每个 like 帧，也存储它与节点 a 的距离。

所以我只用一对东西。

所以我的队列的元素总是一对。

我会加上初始节点 A，还有数字 0，因为在开始，这个节点 A 离它自己有 0 条边。

所以可以开始了。

随着时间的推移，我会增加。

这个号码，好像很好听。

所以让我们继续坚持下去。

好的，一个 while 循环，典型的情况是，当你的队列不为空时，我将从队列中移除一些东西。

所以，如果你想遵循一个真正的广度优先的顺序，总是从前面开始。

所以我可以做点移动。

这将返回给我一个数组，或者这里的一个子数组。

我知道永远都是一对，所以我可以打开包装。

我会说好的，获取当前节点和距离。

很好。

我将在这里检查刚刚从队列中删除的节点。

如果那个节点是节点 B，那我一定找到了一条路径，我知道这条路径的距离，我可以返回它。

但是如果这个条件不成立，那么我需要继续搜索我的图。

因为这意味着我需要将这个节点的邻居添加到队列的后面。

所以我要迭代，记住我们一直都有邻接表。

所以我要说，比如说，节点图的邻居。

所以得到这个节点的所有邻居。

我要做的就是把这些邻居加入我的队列。

所以 q 点推，邻居，试着记住我们的图形在这里是什么形式。

也许作为一个快速的小抽查，确保在同一页上，让我只是控制台点日志，邻接表，让我们说我们手动采取了这个例子，只是粘贴下来。

我会给它一些不错的手动运行，我还没有运行测试用例。

所以我们把这个边列表转换成这个邻接表，对。

当我们对 W 这样的东西说不，当我们说图形，方括号，不，这会给我们这个数组，共同创作的排序器，迭代，通过这个节点的所有邻居，并将它们添加到队列中，我们应该注意的一件事是，当我们将东西推回队列时，我们希望保持相同的格式。

所以我其实还是想维持对子的。

因此，我将创建该对的第一个元素，第二个元素上的相邻节点需要是距离。

因为它是邻居，所以它的距离在这里是+1。

这就是我成长和计算距离的方式。

让我们试一试。

不过，还有一些事情我们需要继续努力。

但是我们将跳过其中的一些例子，至少在我们暂停讨论一个特定的例子之前。

这段代码缺少的一点是任何周期预防，对吗？我知道这将是一个很常见的场景，因为我有一个无向图。

所以我肯定要做的是维护一个被访问的集合，一种你已经习惯了的模式，我们只是要实现我们的迭代，现在喘不过气来。

所以从一套开始。

当您迭代地这样做时，要确保如果有东西被添加到队列中，它也应该被标记为已访问。

所以如果我用节点 A 初始化我的队列，那么我也想用节点 A 初始化我的访问过的集合，就像这样。

所以如果你不熟悉 JavaScript 中的 set 构造函数，如果你想用一些值初始化它，你实际上必须传入一个包含这些值的数组。

所以我访问过的集合的值就是节点写的节点 id。

酷毙了。

然后我想把这个逻辑运用到我的 while 循环中。

所以每当我要向队列中添加东西时，也就是说，我要向队列中添加一个邻居，首先检查这个邻居是否还没有被访问过，所以只有在没有被访问过的情况下才有邻居。

对，所以只有当这个邻居还没有被访问过，我才应该把它添加到我的队列中。

如果我要将它添加到队列中，就像我们刚才说的任何感兴趣的东西，队列应该立即被标记为已访问。

所以在这里我会说访问，添加，邻居网络应该避免将任何特定的节点添加到队列中超过一次，避免任何循环。

太棒了。

所以感觉很好。

让我们试一试。

现在。

我们希望不要超时，至少，所有相同的例子，我们实际上返回了未定义的，我们期望的是负的。

如果你看实际的提示，他们告诉我们，如果你找不到 A 和 B 之间的路径，那么你应该返回负 1。

我们来看一个例子或者考 04。

你把它画出来，你会发现没有这样的路径连接 B 和 g。

我们现在返回 undefined 的原因是我们要完成遍历，这意味着我们的队列要清空了。

然后我们将到达这个函数的末尾。

如果我没有在 JavaScript 中默认点击一个回车，我将会被定义。

所以我们知道，如果我们完成了 while 循环，我们没有找到节点 B，那么我们可以返回负 1，这意味着没有这样的路径连接 a 和 B。

让我们试一试。

现在。

这应该是我们最短路径算法的最终版本。

太棒了。

所以在继续之前，一定要练习这个算法。

一定要确保你理解广度优先于深度优先的选择，对于大多数基本的 just graph 问题，要求你计算最短路径，意思就是边的数量。

通常，你会发现宽度优先最简单的计算方法，嘿，程序员们，阿尔文，现在让我们来看看这个岛屿计数问题的方法。

在这个问题中，我们将得到一个代表陆地和水域网格的 2d 数组，这里 l 个字符代表陆地，W 个字符代表水域。

让我们试着想象一下。

在这个问题中，我们要做的是返回一个代表网格上岛屿数量的数字。

我们将把一个岛屿看作一个垂直或水平相连的陆地区域。

所以在这个例子中，我们应该返回 4。

因为有四个不同的岛屿，我们可以给它们贴上标签，这对我们来说是任何类型的问题。

我们真的应该把它当成一个图表来思考，我会把这些风格问题称为网格图。

所以尽管我们没有得到任何明确的节点和边，我仍然可以把这个图的位置看作节点。

例如，让我们考虑这里的指数。

所以我的行索引在左侧，列索引在顶部。

我可以用一对行列来指定这个网格的任何位置。

举个例子，如果我看位置 3，逗号 4，那就是这里的位置。

我应该做的是，在精神上把一个位置想象成一个节点。

如果我遇到了某个节点，我确实有一些潜在的邻居。

给定传播的任何位置，我在上下左右方向上最多有四个邻居。

给定网格的任何位置，都很容易确定我们的潜在邻居是什么，只需要在行或列上加 1 或减 1。

让我们推广这个公式。

假设我在某个位置，我们称它为我们的，如果我想让它向上，这意味着你减少一行，保持列不变。

如果你向下移动，这意味着行增加一行，如果你向右移动，这意味着列增加一列。

如果你想向左，那么你应该减少一列，记住我们网格的左上角位置是 00。

这就是为什么我们有这种算术规则。

所以现在我们开始框定这个网格问题，就好像它是一个图，我们可以使用一些常见的模式，我知道这个问题实际上是要求我统计这个网格上连通的组件的数量或者岛的数量。

所以我需要一些迭代代码，可能是一些嵌套循环来迭代每个潜在的岛，并从那个岛开始遍历。

因此，当谈到我们的迭代代码时，我们只是希望嵌套循环遍历每一行每一列。

这意味着迭代应该像这样，只是从左向右移动。

直到我们完成这个案子，我们可以去下一排。

让我们把算法中需要的主要逻辑去掉。

假设我们从头开始嵌套循环，我要做的是检查我当前的位置，我要做的是检查我当前的位置是否是陆地，现在是水，所以我可以继续。

在下一次迭代中，我确实有一些陆地位置。

因为我现在在一片陆地上，所以我想尽可能地探索这片陆地，可能会使用深度优先遍历。

请记住，就像我们的大多数无向图问题一样，我们需要确保将事物标记为已访问，这样我们就不会陷入无限循环中。

举个例子，如果我开始一个遍历，在这个位置，我可以向下。

但是我也可以从这里往上走。

我可以在这两个上升和下降之间反弹，给我一个无限循环。

所以我们知道如何使用我们所有的图形机制来解决这个问题，对，只要使用一个被访问的集合。

因此，如果我从这个位置开始进行深度优先遍历，我知道我会将所有这些地块标记为已访问。

我还想做的是确保我增加客户，这代表我刚刚完全探索了一些新的岛屿。

所以现在，我的计数是零，因为我刚刚探索完一些东西，现在我的计数是一。

在这一点上，我可以回到我的迭代代码来扫描另一个岛。

所以我移到右边，是水。

所以继续，水继续。

现在我有了另一个岛。

同样，我只是做了一些深度优先遍历。

当然我会增加我的计数。

这种模式将遵循对吗？最终，当我到达新的一排时，我可以在陆地上。

但我也要确保这块土地的位置没有被勘探过，对吧。

所以既然我在位置 1，逗号 0，并且这块土地已经被探索过了，我不需要开始深度优先遍历。

我也不需要在这里开始遍历。

这样继续下去，避免开始遍历。

无论我去过哪里，我们都知道，最终，我们会到达一个像这样的新岛屿，在那里我有一块未去过的土地。

因此，在这一点上，这是我开始新的深度优先遍历的标准，我探索这个区域，增加我的计数，并像往常一样继续工作，直到我到达这个未访问的最后岛屿。

所以我访问它并增加我的计数。

在迭代结束的时候，我应该得到最后的四个数。

这种逻辑实际上非常简单，只是我们经典的连接组件，计数逻辑的一种变体，只是现在我们调整了用于查看邻居的标准，对，我们的邻居实际上是在我们当前位置的左上方或右下方。

我们谈到了这个算法的复杂性，我们应该考虑输入的大小和它有两个维度的事实，对吗？所以如果我说 R 是行数，C 是列数，那么迭代代码非常简单，我知道这会给我 R 乘以 C 的迭代次数。

如果我也考虑任何潜在的深度优先遍历，我会从某块地开始。

在最坏的情况下，我可能会有一个巨大的岛屿，这也将是我们的时间去看看。

所以总的复杂度，只是我们的时间复杂度，空间复杂度也是我们的时间复杂度，因为假设我们将所有这些位置标记为已访问，这可能意味着我们必须将它们添加到某个集合中。

对，所以我们有时间看不同的位置。

最后，我可以把它们中的每一个都加入到我的集合中，我们这个时代的空间复杂性。

See 还包括任何与遍历相关的数据结构，如堆栈或队列，这取决于您如何实现它。

所以总的来说，这将是解决这个问题的一个非常有效的解决方案，你应该做的可能是先自己尝试一下，如果你卡住了，你可以在演练视频中找到我。

我在那里等你。

嘿，程序员们，我是 Alvin，现在，让我们来看一下这个岛屿数量问题的 JavaScript 演练。

所以和往常一样，确保你先看了进场视频。

我们马上就开始。

所以我们知道，这实际上只是我们的图形连接组件问题的衍生，除了现在我们有一个网格图，对吗？我仍然可以把这个网格想象成一个图形，因为如果我考虑这个网格的任何特定位置，我知道我有一些相邻的位置，我可以主要穿过，我的四个邻居上，下，左，右，让我开始写一些迭代代码，可以在这个网格的每个节点或每个位置开始遍历。

这样我就可以开始考虑不同的岛了，对吧。

为此，我将只使用一个 for 循环，我将遍历每个位置所有可能的行列组合。

所以我说 R 等于零，迭代到网格的长度，所以网格点长度到我们的加号等于 1，对嵌套在里面的列做一些非常类似的事情，对吗？注意这里的一些细节，看看这些例子，我们不能真的假设我们总是得到一个正方形的网格，意思是行数和列数是一样的，因为有时我会偶尔得到一个不对称的网格，对吗？如果我看第一个，看起来宽度是 5，但是高度是 6。

所以分开列，我想参考这里的列线。

所以我们要说网格，零长度。

很好。

在这一点上，我有一些行组成，我想开始一个遍历，让我们说一个深度优先遍历在那个位置。

这里我调用了一些辅助函数，这将使它变得有点，我称之为 explore。

接下来要做的，当然是获取网格信息，以及我想遍历 nice 的行和列。

在这一点上，我认为我们将实际上跳转到构建这个助手函数，然后我们可能需要在我们的主驱动函数中填充更多的逻辑。

所以我们来烘焙这个 explore 辅助函数。

拿网格和你的行列来说，我还应该考虑的是，因为我知道这是一种图形问题，对吗？我想防止无限循环，对吗？考虑一下，假设我在遍历的中间，假设我在这片土地上，我知道这片土地将穿过它右边的邻居。

这可能是这样的情况，这片土地现在穿过它左边的邻居，所以我向左，然后向右，然后向左，再向右。

现在它给了我一个无限循环。

因此，无论何时你有了无向图或无向图这样的概念，那么一定要用一个被访问的集合来保护。

我们以前见过这种模式。

所以也许在全局上，对于整个遍历，我将创建一个访问过的集合。

所以在 JavaScript 中，只是一个新的集合，你可能会想，你知道，我要把这个集合的成员变成什么？我需要指定位置，对吗？想象一下，位置就像这个图中这个网格的节点，对吧。

所以我要做的是传递这个访问集，这样我就可以在这里接受它作为一个组织。

当涉及到使用你访问过的集合时，你要做的是确保你组合了你的行和列，因为它们一起指定了你的实际位置。

我认为与其他编程语言相比，这实际上更像是 JavaScript 中的一种语言。

快点，让我给自己腾点地方，可能要一会儿。

因为如果你不熟悉集合，你不知道它们的细微差别，可能会在以后打击你。

假设我有一个集合，我将创建一个偏移量。

所以你能设置，比如说我添加了我不知道，像一个包含行列位置的数组。

所以我要说的是，好吧，也许我有位置，我不知道，一个逗号三。

我把它加到了我的节目里。

所以我没有加那个位置。

这实际上是 JavaScript 中的一个常见问题。

如果你把任何类似的引用类型，比如一个数组或者一个对象放到你的集合中，当你稍后检查引用是否存在时，它实际上会检查引用是否相等。

换句话说，现在我真的不能做控制台点日志 s 点有一个三，因为这个数组字面量在技术上是内存中的一个不同的数组。

所以我希望在这个场景中，我能得到真实的，但是我不会得到真实的。

所以我们将手动运行它，看看会得到什么。

所以，我们说，我们会得到一个假的，这不是很好。

因此，您的解决方案是将它转换成一些字符串数据。

所以相反，可以写得好像你有一个逗号 3，因为字符串是基本类型，我实际上可以存储那个字符串。

所以每当我说字符串文字的时候，这实际上会给我一个匹配，所以我应该在这里得到一个很好的 true。

太棒了。

所以我们想利用这种模式。

也许我会先创建一些位置变量，就像 FIDE 的字符串，我们位置的一个版本。

取我的行，加个逗号，把列放在这里。

很好。

我想用逗号分隔的原因是，我需要我的行和列有不同的界限。

换句话说，想象我有一排，比如说，12 个。

我有四个专栏。

如果我把它变成一个键，或者一个位置，我的位置看起来像 12，另一个场景是逗号，假设我有第一行，第 24 列，我的位置是右边的？一个逗号 24。

对，用逗号来分隔行和列的位置，这很重要，因为想象一下，我没有用逗号，那么这里会有冲突，我有两个完全不同的位置，对吗？12，4 和 124。

如果我不加逗号，它们看起来有相同的位置键。

这就是为什么我需要用逗号把它们分开。

常见的问题。

但是现在我有了这个职位，我可以在这个访问集中利用它。

如果我已经访问了这个位置，如果我的被访问对象有这个位置，那么我应该退出，对，我需要返回一些东西。

我想让这个 explorer 函数做一些类似的事情，就像我们在以前的组件问题中所做的那样，我想让它返回一个布尔值，表明这是否是我正在探索的一个新岛屿。

所以如果它已经被访问过了，那肯定不是新的，对吧。

所以只需返回 false，表示它不是一个新岛。

如果我通过了 If 语句，换句话说，如果职位不是已访问，我需要立即将其标记为已访问，第二步，完成已访问，添加该职位。

所以现在我有了我的核心，比如循环预防逻辑。

除此之外，我还有一些其他的场景，我们知道在我们的遍历中，我们会看到不同的邻居。

所以我想做的是确保我在界内。

所以我要检查一下，把它分成几个变量，我说，一个布尔变量，叫做界限内的行。

我要做的就是检查零是否小于或等于这一行。

这一行严格来说小于我的网格长度。

所以我只是检查一下我的反对是否在界内，我快速检查一下，我需要包含 0，因为 0 是一个完全有效的指数，对吗？我需要独占长度，因为假设我有一个长度为 5 的网格，它的最后一个有效索引是 4。

所以我需要严格小于这里。

我将为我的 bounds 列写一个类似的变量，就像这样。

在这一点上，我可以写一个很好的语义 if 语句检查，好的，如果你的行不在界内，或者你的列不在界内，那么退出，对吗？所以像之前那样返回，我可以返回 false，对吗？因为我不应该像一个孤岛一样考虑无效位置和平衡位置，对吗？所以看起来不错。

我需要的最后一个基本情况是，如果我现在的位置是水呢？我只想穿越陆地。

所以我会添加另一个声明。

所以在这里，我可以检查。

好的，如果我的网格在行列中，如果它等于水，那么也返回 false。

没有理由去数它，在你索引到你的网格之前，把它放在边界检查中是非常重要的，对吗？因为想象一下你的行列越界了。

如果你像这样写第 15 行，你会立刻得到一个越界错误。

所以从你的警戒开始，检查你是否在界内，如果你想的话，因为大多数这些条件都返回 false，有相同的结果。

你或许可以把它们放在一起。

通常我喜欢把它们分开。

这样的话，我总是记得写它们，通常是为了解决你的网格图问题。

这是非常规范的代码。

好的，如果我通过了所有的基本情况，我有递归的情况，那么我一定是在一片未被访问的土地上。

我想做的是深度优先遍历。

这是我探索邻居的地方，我有四个邻居。

如果我想超过这个数，我就把我的行减 1，保持列不变，传递相同的访问次数，因为记住，这里有数组索引。

这是第 0 行，这是第 1 行。

所以我们将较低的行号表示向上，同样，较低的列号表示向左。

这是上，这是下，在这里负一，在左边，然后在这一列上加一，在右边。

酷，我可以保持这段代码非常简洁，因为这是我的一个巨大的支持者，当你写递归的时候，在大多数情况下，我总是试着确保我不会三思而后行。

换句话说，仅仅从这个逻辑来看，它不可能是，行减一出界了。

不过没关系。

因为如果它越界了，当我评估这个调用时，它会立刻被这个基本情况抓住，对吧。

如果我这样表达我的逻辑，如果我不看，在我离开之前，如果我只是跳跃，然后用基本情况抓住自己，你就不用写重复的代码了。

换句话说，有些人像这样写代码，就像，好吧，如果行减一，就像是在使用伪代码。

在这里，他们必须在 bounds 中写 row。

而且你必须在每个递归调用周围写一个保护 if 语句，相反，只写一个基本用例。

你可以捕捉所有这些不同的出界，对吧。

所以这就是为什么我更喜欢这样。

所以我知道，当我从这些递归调用中返回时，我已经回到了这段代码中。

我能做的是返回 true，因为我必须完成那个遍历。

我返回 true 的原因象征着我刚刚探索完一个全新的岛屿，所以我需要数一数。

很好。

这也与数据类型一致，我为这个 explore 函数设置了 Boolean。

所以在很大程度上，这看起来就像是我们之前的 like 图，深度优先代码的衍生。

现在我想在我的主函数中使用布尔数据。

所以我可以在这里数我的岛屿。

所以我想我真的需要一些逻辑，初始化一些等于零的计数。

每当你发现一个新岛，增加计数。

如果我发现了一个新的岛，我们会从这个调用中返回 true，对吗？因为记住我要开始一个遍历，从这个行列位置开始。

所以如果它返回 true，那么我可以把我的计数加 1。

请注意，每当我开始遍历一个我以前见过的位置时，它就会被添加到以前访问过的位置。

所以我会通过第 21 行的 if 语句返回，我返回 false。

如果我返回 false，那么我不会重复计算这个岛。

因此，我确实需要两种迭代代码的组合，以潜在地跳到不同的岛上。

但是我可以使用一个访问过的集合来防止自己重复计算任何特定的岛屿。

所以这看起来很不错。

当然，我们不要忘记在结束时返回我们的计数。

让我们试一试。

这可能是一系列类似网格图问题中的第一个。

试着去理解我们是如何把一个网格当作一个图形来看待的，对吗？我们只是对如何看待邻居有不同的规则。

对吗？现在，一个节点实际上是一个位置，它的邻居是它的上下左右四个邻居。

好了，程序员们，我希望你们练习这个模式，因为我们将在接下来的几个问题中看到它。

我会把它留给你在下一个里看。

嘿，这里的程序员们，现在让我们来看看这个最小岛问题的解决方法。

因此，我们将在这里得到一个包含内陆水域的网格，实际上只是网格内的一些字符。

当然，一如既往，让我们想象一下。

在这个问题中，我想做的是返回一个代表最小岛屿大小的数字，我们将考虑一个岛屿，一个垂直或水平连接的陆地的连接区域。

对于这个特定的输入，我们的答案应该是查看我们的网格，我有三个独立的岛。

它们都有不同的尺寸，对吗？大小有四个，两个和五个，我只选择最小的岛屿。

所以应该是那边的两个。

那么，我如何才能真正想出一个解决这个问题的策略呢，你们应该已经知道，这只是我们之前的网格图问题的一个衍生，在这个问题中，我不仅仅是计算岛屿的数量，现在我想找出岛屿的大小。

我知道要实际查看不同的岛屿，我需要一些嵌套代码，但我也需要一些深度优先遍历代码来探索单个岛屿。

总的来说，这对我们来说应该是一个非常经典的策略。

假设我们开始处理这个问题，我们知道我们将从左上角开始嵌套循环，如果我们当前的位置是水，那么我们实际上不需要做任何事情。

下一次迭代，我有一些土地。

此时，我可以开始深度优先遍历了。

我知道我应该把东西标记为已访问，以避免任何无限循环。

所以当遍历完成时，我会将所有这些人标记为已访问。

但我也想确定整个岛屿的面积。

所以每次我得到一个是土地的位置，我都要把它当成一个。

然后，当谈到我如何实现我的遍历，我可以只是收集这些，对，只是把它们加起来。

所以看起来会像这样。

对于该遍历的顶级调用，我应该得到一个大小为 4 的岛。

所以如果那种遍历算法，尤其是我们如何计算岛的大小，是相当复杂的，不要担心，当我们实际遍历代码时，这只是一些递归的问题，一些我们在过去的课程问题中见过的递归。

但无论如何，现在我有了这个四人大小的岛，它实际上是我看到的第一个岛。

因此，到目前为止，我将把它视为中型。

但我需要继续寻找，以防有更小的东西。

所以向右移动。

所以如果是水，我什么都不做，还是水，什么都不做。

现在我有了另一个岛屿，我开始了我的穿越市场。

当我找到这个岛的大小时，当然，它会给我两个，我把它和我现在的中等大小比较，两个比较小，所以我把两个存储为中等大小。

我们只是照常营业。

请注意，当我们到达一块土地时，我们真的希望确保它是土地，但也是一块未被访问的土地。

所以现在在那块土地上，但是它被访问了，所以我不应该穿我不需要从这里开始遍历。

同样，对于这个职位。

最终，我将到达一些新的未被访问的土地，在这种情况下，我应该从 Explorer 开始我的遍历，这个区域，我想统计所有这些土地。

我应该意识到这个岛的最终大小是 5，我可以把它和我现在的最小值比较一下，5 要大一些，所以 2 的大小可以保留。

在这个算法结束时，我可以返回最小的大小，基本上代表这个大小为 2 的岛，这个算法的复杂度很简单，我们应该说我们输入的大小是 r 乘以 C，因为我们有我们的行和 C 列，在这种情况下，时间复杂度就是我们的时间 C，对，我们必须迭代网格中的每一行每一列。

甚至当我们开始遍历时，在最坏的情况下，我们可能有一个跨越整个网格的岛，在这种情况下，它也将是我们的 c。

没错。

所以总的来说，我们所有的复杂性都是时间，空间的复杂性也是时间。

你要知道，从技术上讲，这是一个关于网格大小的线性解，因为网格本身正好是 r 乘以 C 的位置。

因此，我认为我们已经准备好编写这个代码，并首先在您自己身上进行尝试。

如果你被困住了，我会在视频中找到你。

在那里见。

嘿，程序员们，我是 Alvin，现在我们来看一下这个最小岛问题的 JavaScript 演练。

所以我们马上开始，确保你看了进场视频。

一如既往，这只是我们经典的岛屿跳跃逻辑的一个很好的衍生。

但是对于网格图来说。

所以让我们从可以帮助我们开始遍历的迭代代码开始。

从网格的每个不同位置开始，这意味着一些嵌套循环。

所以从遍历所有的行和列开始。

所以 r 等于零，当 r 小于网格长度时，对我的列做一个类似的循环。

但是一定要参考你的内柱线，因为这里可能有一个矩形的网格。

我现在想做的是从每一行每一列开始遍历。

所以我假设我有一个助手函数来完成这个遍历，我把它叫做探索大小。

这是因为从长远来看，我感兴趣的是那个岛的大小，对吧，就像一个代表那个岛有多大或者有多少位置的数字。

所以我将传递网格信息和位置。

我知道当涉及到无向图时，遍历可能会防止你的循环。

我在这方面有些远见。

所以我将传递一个很好的访问过的集合，我可以在整个遍历过程中全局地维护它，因为只有一个好的理由来探索一次正确的位置。

因此，我将创建 const visited，使其成为我的邻居 JavaScript 集。

有几个原因？

嗯，对于一个 JavaScript 集合，给我 O 次查找，也给我 O 次插入。

所以这将是一个非常快速的数据结构。

从那里，我们可能要在这里添加一些逻辑，实际上对大小做一些事情，但现在，我想我要改变一下思路，实际上看看如何构建这个帮助函数。

所以我认为建立这个遍历的最好方法是使用一个聋子钱包，典型的就是我去找这样的问题，它会接受我知道的网格，列中的行，也访问过，我需要一些基本情况非常经典的基本情况，我要从检查这个行列位置是否在界内开始。

所以我最喜欢的模式是把它分成几个变量，这样更容易阅读和调试。

我要说的是我的行入站，就像一个布尔变量。

所以我会检查，比如说，零是否小于或等于那一行，我需要说和对，那一行应该严格小于网格长度。

所以这个布尔值只有在界内才为真，对吗？和我的列边界非常相似的东西应该在零和网格零长度之间。

我相信就像这样很好。

然后我可以用这两个子句写一个很好的 if 语句。

所以我可以说，好的，如果我们说你的行不平衡，或者你的列不平衡，那么你肯定在边界上。

所以你应该用一些基本情况，对吗？所以我们在这里都选择返回 0，因为我想保持一个一致的数，正确一致的返回类型。

也就是说，我知道这个函数的目标是返回所探索的岛屿的大小。

所以即使在我的基本情况下，我也需要确保我返回某种类型的数字，返回零来表示，嘿，如果这是越界的，它不会对大小的计数有任何贡献，对吧，这很好。

我需要一些其他的基本情况。

如果我的位置在界内呢。

但如果真的是水呢，我也不想算进去。

我只想数岛屿。

所以向右着陆。

所以快速修复，我要做的是添加一个新的基本情况，我可以检查我的行列网格，如果它等于水字符。

所以大写的 W 也可以返回零。

如果你想的话，你也可以把它们合并成一个 If 语句，就写一串 ORS，我喜欢把它们分开，因为我很容易记住它们每个写的是什么，最后一个条件 have 在这里是好的，如果我通过了这两个基本情况，可能这个位置是陆地，但它是我已经到过的陆地。

这就是为什么我在我的被访问的逻辑中工作，我要表示一个位置，就像我们在上一集里说的，实际上只是一个字符串。

所以我可以把它作为我访问过的集合的成员。

所以我要说位置必须是行加逗号加列。

所以只是表示位置，那是因为我不能像数组一样添加到一个被访问的集合中，然后再去查找。

因此，如果 visited 拥有这个职位，那么它就是我探索过的重复职位。

所以归零。

不然还没去过呢。

所以我现在一定在参观它。

所以我可以补充一下。

很好。

所以我有我的基本案例。

现在我需要实际的递归代码。

所以我要探索我的四个邻居。

到目前为止，您应该已经熟悉了这种模式。

这样往上走，一行减去一列就传递了同一个访问过的。

所以我要分别探索我的上下左右邻居。

我做递归自助餐理论。

所以我希望从这些调用中得到什么类型的返回，他们会返回一个数字，代表我的邻居所在的岛的大小。

但是如果我的邻居是某个更大的岛的一部分，那么我也是，因为我们和我们的邻居是紧密相连的。

所以我想创建所有这些返回值的总和。

所以我要创建一些大小变量，比如说 let size，我要在这里把它初始化为 1，它是 1 而不是 0，因为 1 代表我的当前位置，我的行列。

不管这些调用返回什么，不管是什么数，我都要用那个数来增加我的大小，就像这样。

最后，我可以在这里返回我们的总尺寸。

这将是我的深度优先遍历，因为它是递归的，但我们也将统计这个岛区域的大小。

酷毙了。

现在我有了一个可用的 explore size 助手，让我们在这里的主函数中使用它。

所以我会从这个调用中得到一个数字。

我称之为我各自的尺寸。

这个逻辑的伟大之处在于，如果我有一个岛或位置，我已经见过了，我在这个 for 循环中又遇到了，那么我会提前返回，因为我会遇到这个基本情况，对吗？如果某个东西已经被访问过了，就自动返回零，因为我已经考虑过了，没有理由再考虑了。

但是现在我需要我的最小化逻辑，对，我想要最小岛的大小。

他们在问题中告诉我们，我们完全可以假设你的网格至少包含一个岛。

因此，我认为这里一个很好的默认值是使用正无穷大，这样我就可以将一些 min size 变量设置为正无穷大，JavaScript，如果我将其设置为正无穷大，我知道当我遇到任何有效的岛大小时，它将小于无穷大。

它应该取代它。

所以现在我可以在这里做一些最小逻辑检查。

好吧，如果这个岛的大小小于我目前看到的最小尺寸，那么就用那个岛代替最小尺寸。

然后，当我完成所有这些遍历潜在的逆转，我会返回我的中等大小。

这里有一些经典的模式。

有一个细微差别，我们没有考虑如何运行代码，我们可以一起调试它。

所以看起来我们失败了。

00.

所以我们期望回答的第一个例子，我们意外地返回了 0。

如果你看第一个例子，很明显，最小尺寸是 2，代表这个岛。

我们返回 0 的原因是根据我们的代码。

让我们看一下，我们正在进行第一次迭代，我将对它进行响应，我知道那一行将会是零，那意味着我的位置将会是这里的 w。

当我进行递归调用，并传递位置 00 时，我知道它会立即返回 0，因为那个位置是水。

我要检查一下，这是零吗，小于无穷大，所以我要用零来代替最小尺寸。

但仔细想想，零甚至不代表一个真正的岛。

如果一个岛的大小为零，那么它根本就不是一个岛，而是一片水，对吗？所以我想在这里增加一些额外的逻辑，只看非零量。

因此，只有当该大小也有效时，才进行比较。

当然，大小应该大于零。

我们想把这些加在一起。

让我们再试一次。

我们需要一点点细节。

太棒了。

这就是我们解决最小岛问题的方法。

这种模式我们已经见过几次了，对吧，还是经典的跳岛逻辑。

因此，当你认为岛屿就像一个图的连接组件时，这应该是你的第一种 go to 算法。

好的程序员们。

我们的图表课程到此结束。

我希望你在课程中学到了很多。

我一定要去 Shruti dotnet，在那里您可以继续练习更多的图形问题，以及探索任何其他数据结构算法主题。

我在那里等你。