# 使用 Minions 解释 JavaScript 回调

> 原文：<https://www.freecodecamp.org/news/javascript-callbacks-explained-using-minions-da272f4d9bcd/>

凯文·科诺年科

# 使用 Minions 解释 JavaScript 回调

![1*BWBpJFpxubK7zjG_ucusFg](img/32fe90d9992824d35a2df62e6a76f844.png)

复试。异步。非阻塞。

这些 JavaScript 概念让你抓狂。

我一度也在那里。我需要一个类比来使这些抽象的概念变得足够简单，这样我就可以把它们教给别人(并证明我自己真正理解它们)。

当然，也有一些不错的教程(比如[这个](https://github.com/maxogden/art-of-node)和[这个](http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/))。但是每个教程都是从复杂的术语开始的。

我需要一些我能联系到的东西。

我需要奴才。

![1*lYgVvfqI8_gVkIiwJAd31w](img/193a5a2cd326b4cf5b45249cbeebe457.png)

所以，我要用这些可爱的小黄人来解释回调。在这个小类比中，你是他们的主人。你可以命令你的爪牙在你的代码中做任何你想做的事情。但是:

1.  只有一个主人。
2.  奴才们必须听从你的命令。他们不能自己做决定。

![1*MGmQ9AlWiGcQ8mNs7dkBTw](img/c36cf5fba04835ab055a72256067820a.png)

> ***宠臣。*** *名词。没有权势或不重要的人，服从有权势的领导或老板的命令。*

#### 主要概念

每当你在 jQuery 或 JavaScript **中看到“function()”在另一个函数或方法**中，想象它是“minion()”。您实际上不能键入这个，因为 JavaScript 语言不识别“minion()”(除非您创建一个名为“minion”的实际函数)。但这就是你现在正在做的，当你创建一个回调函数- **给奴才们**下命令。

*一个仆人准备好接受订单的例子*

```
function myFunction(input, function(err, data){
```

```
});
```

这基本上是说…

```
function myFunction(input, minion(err, data){
```

```
});
```

一个只有简单的旧函数，没有可用的插件的例子:

```
function addOne(data){:
```

```
 return data++;
```

```
};
```

### jQuery 示例

#### 超级基本

所以请记住，这有点像在说:

回调在这里做什么？

作为主人/老板，您必须监视整个文件中的事件，甚至可能是多个文件中的事件。你没有时间玩一些小的 jQuery 点击处理程序！因此，您将它委托给一个 minion，如示例 2 所示。

现在，这是一个简单的函数，你可以自己完成，但是如果它有 20 行那么长呢？当你需要接受用户的其他指令时，你不能被一个 20 行长的函数分心！

所以，在用户点击之后，你在第一行告诉一个仆人这样做。我的按钮。这让你有时间给更多的下属下达其他的命令——比你自己做和让其他重要的功能等待更有效率。

![1*qetQ9kESbuqpF3Q31aFDng](img/33369460af6775f7b0ce30b914eda294.png)

#### 动画示例

让我们来看看一个显示/隐藏序列，以真正突出这些奴才的重要性。

在这个例子中，如果你按顺序阅读代码，并且身边没有跟班，控制台会记录“一”、“二”、“三”。但是，你有奴才，控制台将**实际上**在这种情况下记录“一”、“三”、“二”。原因如下:

第 1 行:您订购了第一个 minion，并继续观察用户触发的其他事件。

第 2 行:您的第一个 minion 阅读了控制台语句，然后转到第 3 行。

第 3 行:小仆 1 **带来了另一个小仆来帮助**:小仆 2。具体来说，Minion 2 必须等待 show()方法完成，然后才能继续执行它的指令。所以现在你有两个下属为你工作，同时尽可能快地完成他们的工作！

Minion 1 现在一直跳到第 7 行，因为 Minion 2 需要完成第 4-5 行。它读取 console.log 语句，然后就完成了——不再有回调，不再有工作要做。Minion 2 读取 console.log("Two ")，然后确保子 div 显示在第 5 行中。现在奴才也玩完了。

这里有一个非常重要的经验:你的回调函数**定义了不同动作发生的顺序**。想想这有多强大:您可以确保一个动作一个接一个地发生，而不是被迫创建一长串连续的命令。这允许更大的灵活性。如果你不能强迫奴才们执行你的命令，那你就只能自己动手了。

实际上，**上面的 jQuery 逻辑只适用于回调。**在第 5 行，显示子 div **必须**发生在显示父 div 之后。[如果父 div 被隐藏，你就不能显示子 div](http://stackoverflow.com/questions/5521387/show-child-div-within-hidden-parent-div) 。保证子 div 在父 div 之后显示的唯一方法是回调。

如果上面的例子中没有回调，第 5 行可能会导致错误，因为第 3 行中的 show()方法还没有完成。Minion 1 从第 1 行开始，将完成第 4–5 行的任务传递给 Minion 2，这样 **Minion 2 可以在开始第 4–5 行的工作之前等待第 3 行**中 show()方法的完成。这保证了 Minion 2 将在第一个 show()语句完成后开始并完成第二个 show()语句。然后，Minion 1 继续执行其余的外部函数，而不需要等待。

![1*cSSzRJb_1A4Sm8PMhU954g](img/e99234b5f3f682c5283cfe968b0fa449.png)

### 普通 JavaScript 和 Node.js 示例

#### 使用参数和回调

好吧，一个稍微复杂一点的例子！第 2 行和第 14 行只是声明函数，所以让我们跳到第 20 行，在那里动作实际上开始了。我用两个参数调用了 speakOrders 函数。第一个是一个对象，包含我最终希望我的助手报告的语句。第二个是回调——在本例中是一个名为 reportOrders 的函数。

在你说出命令之前，你的仆人不能报告命令！这就是这些函数的执行方式。在第 20 行，我用指令调用了口述命令。所以我跳到第 14 行，看看 speakOrders 函数应该做什么。显然，它只是将这些指令输入回调函数。

在第 20 行，我将回调函数声明为 reportOrders，但它可以是任何东西！memorizeOrders，tellMySpouse，任何你能想到的函数。标准做法是在第 14 行的函数声明中使用“callback ”,以确保查看您代码的其他人知道需要发生回调。可能是任何其他的词！这是一个被重述的、被迷你化的例子。

在整个代码片段中只有一个 minion 在第 14–15 行，代替了“callback”。

**第 20 行:**我叫口述命令。我传递订单-带有名称和专业的对象。第二个参数可以是任何东西——字符串、函数或其他东西。

**第 14–15 行:**我定义第二个参数实际上**必须**是一个回调函数，因为在第 15 行，minion 后面跟了()。因此，每当我们调用 speakOrders 函数时，我们现在知道第二个参数将是一个函数。在这种情况下，这就是报告订单。

**第 15 行:**从第 20 行我知道我的仆人将需要执行 reportOrders 函数。它接收 orders 参数，一个对象。它需要这些指令来成功报告。

**第 2 行:**第 15 行的 orders 变量现在在函数中被引用为 minionOrders。reportOrder 函数完成，名称和专业被报告回来。

在这里，回调对于**清晰地跟踪对象必须遵循的路径**非常重要。如果没有回调，这将是一堆按顺序排列的代码，没有重用函数和改变顺序的灵活性。

![1*2slDIzfK12CcxrIiMZEEpg](img/3884332e5a8b129eeb29c41ed66dcb33.png)

#### 节点. js

看看下面的例子，它使用了 [Express](http://expressjs.com/) 和[请求模块](https://github.com/request/request)。这是迄今为止最难的一次！

让我们假设用户刚刚沿着/storeData 路径执行了一个 GET 请求。所以我们从第 9 行开始。这个例子包括了前面 3 个例子中的回调用例。

1.  第 9 行的方法中有一个回调，类似于 jQuery click 处理程序示例。
2.  第 14 行是异步执行，围绕一个假的 API 请求，类似于 jQuery 动画示例。
3.  第 13 行声明了一个回调参数，类似于普通的 JS 示例。

为了尽可能清楚地说明这一点，下面是 minion 化的代码，用 minion 编号表示它们的执行顺序。

**第 9 行:**用户点击路线。你，老板，命令 Minion 1 开始执行你的命令。它跳到第 10 行，看到 readResult 函数。你现在可以在你的小喽啰工作的时候等待用户更多的提示。

**第 14 行:** Minion 1 看到请求调用，在假 API 上执行，命令 Minion 2 等待结果。Minion 1 可以继续其他工作。既然没有更多的了，Minion 1 就免了职。

**第 14 行:**请求呼叫结束时，Minion 2 开始动作。它现在承载着来自路由的三条潜在的重要信息——错误、响应和正文。

**第 15–16 行**:全局变量“results”被设置为 body 值。这个全局变量现在也可以用在其他函数中。Minion 2 告诉 Minion 3 是时候开始执行它的指令了。Minion 3 最初从**10 号线**接收指令，并一直等待完成它们，直到它被调用。现在是完成 logRes()的时候了！

第 5 行:指令是……一个 console.log，真令人失望。反正现在 Minion 3 完成了。

那么 Minion 3 是怎么在 Minion 2 之后被调用的呢？

某种小恩小惠？

![1*xW5AVfJ9zj8OqIzTzVO3hQ](img/fe132079c20194c9d47b09ccb9d0b4f8.png)

如果回到节点示例 1 的代码，您会看到第 13 行初始化了一个回调。这意味着每次调用 readResult()函数时，都必须有一个回调参数。这为稍后在第 16 行使用回调做好了准备。在第 16 行，回调能够使用第 14 行的 API 请求的产品，因为**请求调用本身有一个回调**！

想象一下，如果 callback/minion3 是比第 17 行低的一行，在请求调用的范围之外。首先，这会使它成为 Minion 2，因为它会在请求调用完成之前被执行。而且，请求调用的结果还不可用，这将使整个函数变得毫无意义。关键是进行请求调用，然后传递结果。

同样，在 readResult()函数中使用两个独立的回调函数确保了 Minion 3 在请求完成后开始工作。回调提供了一定程度的控制，因此您可以确定这种自定义顺序。

#### 结论

你是奴才式的主人，成群的尖叫的小仆人随时准备听从你的吩咐。如果你能给他们正确的指示，他们会让你的生活变得容易得多。他们做所有艰苦的工作，让你听从用户的指令。

这对你有帮助吗？请在评论中告诉我。