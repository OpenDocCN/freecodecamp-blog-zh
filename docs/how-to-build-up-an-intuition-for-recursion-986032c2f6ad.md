# 如何建立递归的直觉

> 原文：<https://www.freecodecamp.org/news/how-to-build-up-an-intuition-for-recursion-986032c2f6ad/>

道森·埃利亚松

# 如何建立递归的直觉

#### 以及如何用它来解决问题

![8aza4Gl8EaNwkDwVTGejjq-QqNXHIHXNNIO-](img/3df523878c413e36c6b4dfe6f8778a6a.png)

“white corner building” by [Simone Hutsch](https://unsplash.com/@heysupersimi?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

递归是学生在编程中面临的最令人生畏的话题之一。这很难理解，因为人脑无法执行递归，但计算机可以。这就是为什么递归对程序员来说是如此强大的工具，但这也意味着学习如何使用它是极其困难的。我想帮助你们建立对递归的直觉，这样你们就可以用它来解决问题。

我是大学计算机科学入门课程的助教。这周我已经用完全相同的方式解释了十几次递归。我的解释似乎对大多数学生有帮助。这篇文章在顶部有最一般的解释，在底部有最具体的解释。这样，你可以从头开始，当你觉得你已经足够理解递归的时候就停止。我已经用 Java 提供了一些例子，它们非常简单，任何有编程经验的人都可以理解它们。

#### 什么是递归？

为了理解递归，让我们从编程后退一步。让我们从建立这个术语的一般定义开始。某物在某种程度上被自己的定义所定义就是*递归*。这可能对你理解递归没有太大帮助，所以让我们来看一个数学定义。你熟悉函数——一个数进去，另一个数出来。它们看起来像这样:

*f(x) = 2x*

让我们稍微改变一下这个想法，转而考虑一个序列。一个序列取一个整数，出来一个整数。

*A(n) = 2n*

序列可以被认为是输入和输出仅限于正整数的函数。通常，序列从 1 开始。这意味着 A(0)是 1。上面的顺序如下:

*A(n) = 1，2，4，6，8，10，…其中 n = 0，1，2，3，4，5，…*

现在，考虑以下顺序:

*A(n) = 2 x A(n-1)*

该序列被*递归定义。*换句话说，任何给定元素的值取决于另一个元素的值。这个序列看起来像这样:

*A(n) = 1，2，4，8，16，…其中 n = 0，1，2，3，4，…*

任何元素都被定义为前一个元素的 2 倍。

*   n = 4 的元素 16 被定义为前一元素的 2 倍。
*   n = 3 的元素 8 被定义为前一元素的 2 倍。
*   n = 2 的元素 4 被定义为前一元素的 2 倍。
*   n = 1 的元素 2 被定义为前一元素的 2 倍。
*   **n = 0 的元素 1 被定义为…**

n = 0 元素不能递归定义。没有前一个元素。我们称之为**基础案例**，这是递归定义的必然结果。**它们必须在你的代码**中明确表示。我们可以用 Java 来表示这个递归序列，如下所示:

```
public int A(int n){    if (n == 0)        return 1;    return 2 * A(n - 1);}
```

您应该熟悉递归方法的结构。注意基本情况:如果 n 是 0，元素被定义为 1。否则，该元素被定义为前一个元素的 2 倍。我们必须递归调用方法来获取前一个元素的值，然后将它乘以 2。所有递归方法都有这两个组成部分:

*   基本情况，返回明确定义的值。
*   递归事例，返回递归定义的值。

![0E2HqB2n-Uaz7t4xog-zDG5IbGJdTFEuUN9c](img/e642153ade11ad496ec543219617c57e.png)

“white rose enclosed photograph” by [Annie Spratt](https://unsplash.com/@anniespratt?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

让我们再做一个例子，继续数学的内容。斐波那契数列经常被用来说明递归。斐波纳契数列的任何元素都是前面两个元素的和。事情是这样的:

*F(n) = 1，1，2，3，5，8，…其中 n = 0，1，2，3，4，5，…*

*   n = 5 的元素 8 被定义为 n = 4 的元素和 n = 3 的元素之和…

此时，你应该犹豫了。在前面的例子中，每个元素只依赖一个其他元素，现在每个元素依赖两个其他元素。这使事情变得复杂。

*   n = 4 的元素 5 被定义为 n = 3 的元素和 n = 2 的元素之和。
*   n = 3 元素 3 被定义为 n = 2 元素和 n = 1 元素的和。
*   n = 2 元素 2 被定义为 n = 1 元素和 n = 0 元素的和。
*   **n = 1 的元素 1 被定义为 n = 0 的元素和…** 的和

n = 1 元素不能递归定义。n = 0 元素也不能。这些元素不能递归定义，因为递归定义需要两个前面的元素。n = 0 元素没有前置元素，n = 1 元素只有一个前置元素。这意味着有两种基本情况。在写任何代码之前，我会写下这样的内容:

*n = 0 的元素定义为 1。n = 1 的元素定义为 1。*

*n 元素定义为 n-1 元素和 n-2 元素之和。*

现在我们有了这个任务是如何递归定义的想法，我们可以继续写一些代码了。在没有对任务有一个自然的理解之前，永远不要开始写代码。

```
public int F(int n){    if (n == 0 || n == 1)        return 1;    return F(n - 1) + F(n - 2);}
```

#### 调用堆栈

![1ddahVRxpZNWjPgx-9mfnaEmalc76XpEG175](img/20acc2a8f2a454068353ed8ab7ff46c9.png)

“assorted-title book lot” by [gotafli](https://unsplash.com/@gotafli?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral). It’s a stack of records, do you get it?

作为程序员，我们希望对递归有一种直觉，这样我们就可以用它来做事。为了有效地做到这一点，我们必须了解计算机是如何处理递归的。

计算机使用一种数据结构来跟踪方法调用，这种数据结构叫做**调用栈**。每个方法调用从方法参数中创建**局部变量**。在执行该方法时，计算机需要存储这些变量。然后，当方法返回时，计算机会丢弃这些值，以避免浪费内存。

调用栈(以及一般意义上的栈)的功能就像您想象的现实生活中的某种栈一样。想象一下，你的桌子上有一叠文件——开始时什么都没有，然后你一张一张地添加文件。除了最上面的那张纸，你对纸堆里的任何一张纸都一无所知。从纸堆中拿走纸张的唯一方法是从顶部一张接一张地拿走它们，顺序与它们被添加的顺序相反。

这基本上就是调用堆栈的工作方式，除了堆栈中的项目是**激活记录**而不是文件。激活记录只是存储方法名和参数值的小块数据。

没有递归，调用栈就相当简单。这里有一个例子。如果你有一些像这样的代码…

```
public static void main(String[] args)    System.out.println(myMethod(1));
```

…调用堆栈将如下所示:

```
*  myMethod(int a)
```

```
*  main(String[] args)
```

这里我们看到正在执行的两个方法，`main`和`myMethod`。需要注意的重要一点是，在`myMethod`从堆栈中移除之前，`main`不能从堆栈中移除。换句话说，`main`直到`myMethod`被调用、执行并返回值后才能完成。

这适用于任何方法组合的情况(方法中的方法)——所以让我们看看递归的例子:我们之前写的`A(int n)`方法。您的代码可能如下所示:

```
public static void main(String[] args)    System.out.println(A(4));
```

```
public static int A(int n){    if (n == 0)        return 1;    return 2 * A(n - 1);}
```

调用`main`时，调用`A`。当`A`被召唤时，它召唤自己。因此调用堆栈将像这样开始构建:

```
* A(4)* main(String[] args)
```

`A(4)`通话`A(3)`。

```
* A(3)* A(4)* main(String[] args)
```

现在，重要的是要注意，在`A(3)`首先从调用栈中移除之前，`A(4)`不能从调用栈中移除。这是有道理的，因为`A(4)`的值取决于`A(3)`的值。递归进行…

```
* A(0)* A(1)* A(2)* A(3)* A(4)* main(String[] args)
```

当`A(0)`被调用时，我们已经到达一个基本情况。这意味着递归完成，而不是进行递归调用，而是返回一个值。`A(0)`离开堆栈，然后其余的调用能够相继离开堆栈，直到`A(4)`最终能够将其值返回给 main。

直觉告诉我们:任何方法调用的返回值都取决于另一个方法调用的返回值。因此，所有的方法调用都必须存储在内存中，直到达到基本情况。当达到基本情况时，值开始变得定义良好，而不是递归定义。例如，`A(1)`是递归定义的，直到它知道基本情况 1 的定义。然后，明确定义为 2 乘以 1。

当我们试图用递归解决问题时，考虑返回值的顺序通常更有效。这与打电话的顺序相反。这种顺序更有用，因为它由定义明确的值组成，而不是递归定义的值。

对于这个例子，更有用的考虑是`A(0)`返回 1，然后`A(1)`返回 2 乘以 1，然后`A(2)`返回 2 乘以`A(1)`，以此类推。然而，当我们编写代码时，以相反的顺序(调用的顺序)编写会更容易。这是我发现在编写任何代码之前写下基本情况和递归情况很有帮助的另一个原因。

#### 助手方法和递归与循环

![Aicn9TpaTduZb3eahKIRYtL2DvZzb6cxf6M-](img/8fa33c92c3133ec00bf47210d678a154.png)

“two persons shaking each other's hand” by [rawpixel](https://unsplash.com/@rawpixel?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我们是程序员，不是数学家，所以递归只是一个工具。事实上，递归是一个相对简单的工具。它与循环非常相似，因为循环和递归都导致程序中的重复。

您可能听说过，任何重复的任务都可以使用 while 循环或 for 循环来完成。有些任务更适合 while 循环，而有些任务更适合 for 循环。

递归这个新工具也是如此。任何重复的任务都可以通过循环或递归来完成，但是有些任务更适合循环，有些更适合递归。

当我们使用循环时，有时有必要使用局部变量来“跟踪”计算。这里有一个例子。

```
public double sum (double[] a){    double sum = 0.0;    for (int i = 0; i < a.length; i++)        sum += a[i];    return sum;
```

```
}
```

该方法将一个 doubles 数组作为参数，并返回该数组的和。它使用一个局部变量`sum`来跟踪工作总和。当循环完成时，`sum`将保存数组中所有值的实际总和，并返回该值。这个方法实际上还有另外两个不太明显的局部变量。有双数组`a`，它的作用域是方法，还有迭代器`i`(跟踪索引)，它的作用域是 for 循环。

如果我们想用递归来完成同样的任务呢？

```
public double recursiveSum(double[] a)    # recursively calculate sum
```

这项任务是重复的，所以可以使用递归来完成，尽管使用循环来完成可能更好。我们只需要创建一些局部变量来跟踪工作总和和指数，对吗？

唉，这是不可能的。局部变量只存在于单个方法调用的上下文中，递归利用重复的方法调用来完成重复的任务。这意味着当我们使用递归时，局部变量几乎没有用。如果你正在编写一个递归方法，并且你觉得好像你需要一个局部变量，你可能需要一个助手方法。

一个**助手方法**是一个递归方法，它利用**附加参数来跟踪值。**对于`recursiveSum`，我们的帮助器方法可能如下所示:

```
public double recursiveSum(double[] a, double sum, int index){    if (index == a.length)        return sum;    sum += a[index];    return recursiveSum(a, sum, index + 1);}
```

该方法通过将工作值传递给具有下一个索引的新方法调用来构建总和。当数组中没有更多的值时，工作总和就是实际总和。

现在我们有两种方法。“起始方法”和辅助方法。

```
public double recursiveSum(double[] a)    # recursively calculate sum
```

```
public double recursiveSum(double[] a, double sum, int index){    if (index == a.length)        return sum;    sum += a[index];    return recursiveSum(a, sum, index + 1);}
```

术语“助手方法”实际上有点用词不当。原来，helper 方法完成了所有的工作，而另一个方法只是一个开始。它只是用开始递归的初始值调用 helper 方法。

```
public double recursiveSum(double[] a)    return recursiveSum(a, 0.0, 0);
```

```
public double recursiveSum(double[] a, double sum, int index){    if (index == a.length)        return sum;    sum += a[index];    return recursiveSum(a, sum, index + 1);}
```

请注意，对 helper 方法的启动调用中使用的值与循环示例中用于初始化局部变量的值相同。我们将用于跟踪总和的变量初始化为`0.0`，将用于跟踪索引的变量初始化为`0`。

前面我说过局部变量在递归的上下文中是没有用的。这并不完全正确，因为方法参数确实是局部变量。它们适用于递归，因为每次调用方法时都会创建新的方法。当递归被执行时，有许多方法调用被存储在调用栈中，因此有许多局部变量的副本。

您可能会问，“如果助手方法可以完成所有的工作，为什么我们甚至需要初学者方法？为什么我们不直接调用带有初始值的 helper 方法，然后只需要编写一个方法呢？”

好的，记住我们试图替换使用 for 循环的方法。这个方法很简单。它将一个数组作为参数，并将数组的和作为双精度值返回。如果我们用一个带三个参数的方法替换这个方法，我们必须记住用正确的初始值调用它。如果别人想用你的方法，如果他或她不知道起始值，那是不可能的。

出于这些原因，添加另一个方法来为我们处理这些初始值是有意义的。

#### 包扎

递归是一个非常具有挑战性的概念，但是你一直说到我解释的结尾。我希望你能更好地理解魔法。我现在正式授予你“递归大法师”的头衔恭喜你！