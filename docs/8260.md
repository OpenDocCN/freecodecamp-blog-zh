# ReactJS -参数化事件处理程序

> 原文：<https://www.freecodecamp.org/news/reactjs-pass-parameters-to-event-handlers-ca1f5c422b9/>

作者:Sanket Meghani

![1*Rxzsy_E2MgxPP5oVmh1Q_g](img/9dc37364a4e32012409965afb9a9dd46.png)

# ReactJS -参数化事件处理程序

将参数传递给自定义 React 组件的事件处理程序是非常常见的要求。根据我们是否需要引用事件，有几种方法可以用 ES6 实现这一点。

### 使用绑定函数

我们可以定义事件处理程序，并使用 JavaScript 的`Function.prototype.bind()`函数将其绑定到`this`。

如果我们需要传递自定义参数，那么我们可以简单地将参数传递给 bind 调用。SyntheticEvent 将作为第二个参数传递给处理程序。

像上面这样的 JSX 道具中的一个`bind`调用函数将在每一次渲染中创建一个全新的函数。这对性能是不利的，因为这会导致垃圾收集器被调用的次数远远超过必要的次数。如果将一个全新的函数作为一个属性传递给一个组件，该组件使用属性上的引用相等性检查来确定它是否应该更新，也可能导致不必要的重新呈现。

为了避免在每次渲染时都创建一个全新的函数，我们可以在构造函数中绑定这个函数。

现在，我们不需要在第 13 行指定事件处理程序时绑定函数。然而，这里的缺点是我们不能为参数传递动态值。

### 使用 ES6 箭头功能

每次打电话`bind`都很烦。为了避免调用`bind`,我们可以使用 ES6 arrow 函数，它自动将函数与`this`绑定。

我们还可以向事件处理程序传递额外的参数。

以上两种语法的问题在于，每次组件呈现时都会创建一个不同的回调实例，与`bind`函数相同。

为了避免在每次渲染时创建一个全新的回调实例，我们可以使用属性初始化器语法来正确绑定回调。

为了在使用属性初始化器语法时将参数传递给事件处理程序，我们需要使用 currying。

请注意，currying 会导致为每次调用创建一个新的实例。

### 结论

提供了上面所有不同的方法，使用 arrow 函数和 currying 似乎是定义接受用户定义参数的事件处理程序的最干净和最简洁(虽然不是最有效)的方法。

我很乐意听到您对上述方法的评论、建议或问题。