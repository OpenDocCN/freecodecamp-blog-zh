# 时间复杂性——大 O 符号课程

> 原文：<https://www.freecodecamp.org/news/learn-big-o-notation/>

大 O 符号是计算机科学家分析算法成本的重要工具。大部分软件工程师都应该有所了解。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一门课程，可以帮助你理解大 O 符号。

Georgio Tunson，又名 selikapro，创建了这个课程。他用图表和代码很好地解释了复杂的概念。

大 O 符号是一种描述算法运行需要多长时间或者算法使用了多少内存的方式。

以下是本课程涵盖的部分:

*   什么是大 O？
*   O(n^2)的解释
*   O(n^3)的解释
*   O(log n)解释递归
*   O(log n)解释迭代
*   什么是二分搜索法？
*   o(对数 n)编码二分搜索法
*   O(n log n)解释
*   O(n log n)编码合并排序
*   O(n log n)归并排序复杂度深度挖掘
*   O(2^n)用斐波那契解释
*   O(n！)解释
*   空间复杂性和常见错误

观看 freeCodeCamp.org YouTube 频道的全部课程(2 小时观看)。

[https://www.youtube.com/embed/Mo4vesaut8g?feature=oembed](https://www.youtube.com/embed/Mo4vesaut8g?feature=oembed)

## 副本

(自动生成)

大 O 符号用于根据算法增长或衰退的速度对算法进行分类。

理解这一点非常重要，对于许多类型的编程来说，Giorgio Thompson 在这门课中做了大量的工作，分解了大 O 符号。

嘿，大家好，欢迎来到我的大 O 符号迷你系列。

在这个迷你系列中，您将学习关于大 O 符号的所有知识，以及如何使用它来提高创建高效算法的能力。

我将使用白板插图来帮助您可视化和理解概念，随后是编码教程，您可以跟随它来进一步巩固您对概念的掌握，这将回答什么是大 O 符号？还有为什么有用？那么什么是大 O 符号呢？大 O 符号用于分析算法在其输入接近无穷大时的效率，这意味着随着算法输入的大小增长，空间或时间需求会随之大幅增长。

例如，假设我们有一个牙医，她花 30 分钟治疗一个病人。

随着患者数量的增加，她治疗所有患者所需的时间将与排队等候的患者数量成线性比例增加。

这是因为她总是花费固定的时间来治疗每个病人，即 30 分钟。

这让我们大致了解了我们的牙医治疗 10 名患者、20 名患者甚至 10 万名患者需要多长时间。

这是因为，既然我们知道牙医治疗每个病人需要 30 分钟的固定时间，我们就可以通过将病人数量乘以 30 分钟来计算出她治疗任何数量的病人所需的时间。

考虑到这一点，我们可以把她的效率归类为线性。

或者我们用大 O 项来表示 n 的大 O，其中 n 等于病人的数量，她完成工作所花的时间与病人的数量成线性或成比例关系，我们使用同样的技术来确定算法的效率，我们可以通过对给定功能的效率进行分类，就像我们对牙医的效率进行分类一样，来大致了解功能的时间效率。

让我们创建一个易于理解的函数，其规模类似于牙医。

所以这个函数和我们的牙医是一个线性范畴，让我们一步一步来，找出原因。

开始我们函数的输入是一个包含七个元素的数组。

对于其中的每一项，我们将记录这个乘以 1000 乘以 100，000 的表达式。

现在不要让这些大数代替你，1000 乘以 100，000 总要花同样多的时间。

因此，这一行代码需要持续的时间。

这就引出了一个非常重要的问题，当考虑一个函数的效率时。

这些花费恒定时间的线无关紧要。

至少对我们来说，他们没有。

这是因为如果我们的数组长度很长，比如 2 亿，那么将这个表达式改为更简单的形式，比如一加一，对函数的整体效率的影响可以忽略不计，我们仍然需要迭代数组中的 2 亿个元素。

事实上，即使这个函数看起来像这样，我们仍然会忽略所有这些常数，并说这个函数线性缩放或者是 n 的大 O。

类似地，如果我们回想一下我们的牙医的例子，我们会看到她花了 30 分钟在每个病人身上。

但是，即使她在每个病人身上花了三个小时，她看所有病人所花的时间仍然是线性增长的。

起初这可能很难理解，但随着时间的推移，它开始变得有意义。

在上一张幻灯片中，有很多关于忽略常数的讨论。

但是到底什么是常数呢？常数是不与函数输入成比例的任何步长。

例如，计算该表达式的时间不会随输入而改变，因为 101，000 都是常数。

也就是说，这些值总是相同的，这个表达式总是产生相同的值。

并且返回相同的结果总是需要相同的时间或恒定的时间。

就像我们用 n 的大 O 来描述线性函数一样。

对于常数算法，我们也有一个大 O 的名字，它是 1 的大 O。

一个很好的思考方式是每一行代码实际上都是一个函数，这是真的。

举个例子，让我们重新引入这个函数。

这一行代码就是为什么整个线性 func 函数是 O/n 的原因，因为正如你看到的，随着 n 的增加，for 循环必须遍历的迭代次数也增加了。

但是让我们考虑一下第二条线。

让我们假设有一个函数只包含这一行。

现在你可以看到，使用这个函数，我们传入一个数组，但是这个函数对数组什么也不做。

函数中唯一的运算是常量，因为它不随任何输入而缩放。

所以不管传递给这个函数的数组有多大，这一行总是产生相同的结果。

这是函数中唯一的一行。

因此，这整个函数超过了 1。

但是等等。

在这个函数中，我们有超过一个的多行，但是我们仍然优先考虑是 O/n 的行，忽略 O/1 的操作。

这是为什么呢？这让我们想到了最后一个重要的注意事项，在 bego 中，我们有一个增长层次，看起来像这样。

现在，不要惊慌，你还不需要理解所有这些。

所以我们只关注和这个视频相关的，甚至是一个老的。

我们将在本系列的后续视频中了解其他的。

这张图表按照从好到坏的顺序显示了效率类别。

也就是说，第一种情况是最好的情况。

最后一种是最坏的情况。

在大 O 记法中，在确定一个算法的效率时，我们只关心最坏的情况。

这意味着最高阶运算胜过性能更好的运算的最坏情况。

因此，如果我们将所有这些行的性能相加，所有为 0 的代码行将被抵消，因为 oh Vin 是函数中性能最差或最高阶的部分。

女士们，先生们，这就是我们忽略常数的原因，因为我们实际上只是剔除了非主导项。

因为作为函数，输入向无穷大移动，常数变得越来越不重要。

概括地说，在评估算法效率时，我们必须考虑算法中每一步的效率，然后找到最高阶的步骤，或者性能最差的步骤，并将其优先于所有性能较好的步骤、恒定的步骤、超过一级的步骤或者效率最高的步骤。

所以我们总是忽略它们，除非函数的整体是常数，或者是 0。

在这种情况下，我们会把整个函数归类为常数或 0。

女士们先生们，这就是你们对大 O 符号的答案。

好的，为了理解 n 平方的 O，我们需要考虑这个函数，这个函数看起来像这样。

这个函数要做的是接收一个数字，从数字 0 开始，一直到这个数字，遍历这个 for 循环，对于这个顶层 for 循环的每一次迭代，我们也要遍历这个嵌套的 for 循环。

这个嵌套的 for 循环做的事情和这个 for 循环做的完全一样。

它遍历每个数字，从零开始，直到嵌套的 for 循环中的数字，我们在控制台记录矩阵中 sell 的坐标。

但是为了让事情更清楚，我没有展示索引 I 和 j 的控制台日志，而是画一个正方形，在这个嵌套的 for 循环的每次迭代中，这些坐标应该在这个正方形中。

所以如果这听起来令人困惑，请试着容忍我，我保证它会变得清晰。

好，举个例子，我们用数字 4 来调用平方函数。

这意味着我们将从零开始迭代这个 top for 循环，然后我们将一直迭代，直到 I 不再小于 4，一旦 I 等于 4，我们将停止迭代。

这只是这个实际 for 循环的 for 每次迭代的顶部，然后我们将遍历这个嵌套 for 循环的全部，并执行这个控制台日志。

就像我说的，我们不是记录坐标，而是在坐标的位置画一个正方形，这样你们可以更好地想象。

所以让我们开始吧。

所以在第一次迭代中，等于零，然后我们进入这个嵌套的 for 循环。

然后我们将遍历这个嵌套的 for 循环。

所以现在我和 j 都是零，所以我和 j 都是零。

我们现在在这个 for 循环的第一次迭代中，我们将画一个正方形，然后我们向上移动这个 for 循环的一次迭代，所以 j 变成 1，我们将画另一个正方形。

然后 j 变成 2，它会画另一个正方形然后 j 变成 3，我们会画另一个正方形现在 j 是 4。

因为 j 是 4，这意味着 j 不再小于 n，因为 n 是 4，j 是 4，n 是 4。

所以 j 和 n 现在相等，所以不再迭代这个 for 循环。

现在我们回到这个 for 循环。

现在 I 等于 1，所以 I 等于 1，j 等于 0，所以我们画一个正方形，然后 I 等于 1，j 等于 1，所以我们画一个正方形，然后 I 等于 1，j 等于 2。

所以画一个正方形并且等于 1，j 等于 3，就会画一个正方形。

现在再回到这个顶部 for 循环，因为 j 和 n 现在相等，我们又回到这个顶部 for 循环，现在 I 等于 2，所以 I 等于 2，j 等于 0，所以我们画一个正方形，然后 I 等于 2，j 等于 1，所以我们画一个正方形，I 等于 2，j 等于 2。

我们将画一个正方形，I 等于 2，j 等于 3，我们将画一个正方形，然后现在 j 等于 4，这是我们的 in，所以将不再迭代这个嵌套的 for 循环，我们返回到这个 for 循环的顶部，现在，I 等于 3，I 在这一点上等于 3，j 又等于 0，所以我们将画正方形等于 3，j 等于 1。

所以我们会画一个正方形 j 等于二，j 等于三。

然后 j 等于 4。

所以我们不再迭代这个嵌套的 for 循环。

此时，I 等于 4，n 也等于 4。

只要 r 小于 in，我们就只迭代这个 top for 循环，但是我们的眼睛现在等于我们的 in。

所以现在我们停止遍历这四个循环。

我们剩下的就是这个矩阵。

我之所以说这些是矩阵中细胞的坐标，是因为这是一个矩阵。

这些是行。

这些是圆柱。

所以我们可以把 AI 看作是我们的专栏。

然后我们可以看到 j 正在被划。

因此，对于我们列的每个迭代 0123，我们也有一个行 0123 的迭代。

所以坐标为 0，0 是这个方块的坐标，然后 0 和 1 是这个方块的坐标，0 和 2 是这个方块的坐标，等等。

那么这一切和奥本广场有什么关系呢？好吧，嘿，就打断一下。

如果你觉得这个视频很有帮助，或者它让你有了某种理解，请花时间去喜欢和订阅。

如果我们考虑一下，这是一个正方形矩阵，也就是说每条边的长度都是一样的。

我说的长度是指 1234。

长度为 4，1234。

它的长度是 4，要计算正方形的面积，我们只需要用一边的长度乘以它自己，因为正方形的每一边都是一样长的。

如果这是一个矩形，我们将宽度乘以高度，但对于正方形，我们可以只乘以它自己，因为宽度和高度是相同的长度。

所以要得到这个正方形的面积，我们只需要乘以 4 乘以 4，4 乘以 4。

这等于矩阵中的单元数，也是我们执行这段代码的次数，4 乘以 4 等于 16。

四乘以四和四的平方是一样的。

所以 n 的平方的 O，我们的 n 实际上是 4。

这就是为什么通常函数都有嵌套的 for 循环，比如一个 for 循环和一个嵌套在其中的 for 循环，这个函数被认为是在正方形中。

我希望这有意义。

好的，为了理解队列中的所有内容，让我们考虑一个函数。

这个 cube 函数接受一个参数，其中有一个数字。

它将遍历这个 for 循环，for 循环的每一次迭代都将遍历整个 for 循环。

对于这个 for 循环的每次迭代，我们都需要遍历整个 for 循环。

我要提前为我令人失望的绘画技巧道歉。

但为了说明这一点，我实际上要画三维形状，这不是我完全擅长的事情，但无论如何，现在，让我们忽略这个图像。

暂时如此。

让我们把重点放在这个函数上。

所以对于的顶层，我们将一直迭代到。

所以如果我们把数字 4 传递给立方函数，我们将在第一个 for 循环中结束。

我们将从零开始一直迭代到 n，也就是 4。

所以让我们开始吧。

所以对于这个顶层 for 循环的第一次迭代，I 将为零。

现在，对于所有的 in 立方体，我们添加了额外的嵌套 for 循环。

所以不再只有一行一列。

现在我们有了行和列。

这里还有第三维度，我们称之为高度。

所以我们有这个方向的列，这个方向的行，和这个方向的高度。

所以在这一点上，我们用的是三维数组，不再是二维数组。

而且是同一个概念。

所以没有看起来那么难，我们现在要把它画出来。

我们从这个初始 for 循环开始，从零开始。

我们说这个初始的 for 循环代表了我们的列。

我们可以把这些数字写出来，这样你们就能看到了。

所以我们说当我归零时，这一列也是零。

当我一岁的时候，我们在谈论这个专栏。

当我说两个，我们在谈论这个列，一个是三个，我们在谈论这个列。

当然，一旦 I 变成 4，我们就不再迭代这个 for 循环了，因为 I 不再小于 n，也就是 4，它等于 4。

我们可以对这些行说同样的话。

所以我们会说第 0 排在这里，第 1 排在这里，第 2 排在这里，第 3 排在这里。

如果你看不出来，我道歉，这是三维的。

所以画这个真的不容易，但是我希望你们能想象我想说的。

高度也是一样的，高度用这个 for 循环来表示。

好的，让我们实际上，对不起，我应该，我应该用我们在实际函数中使用的字母来命名它们。

所以不叫这个高度，我们叫这个 k。

因为它是代表的，这个 this for 循环在这里被表示为代表 k，所以我们也就把这个叫做 k。

我们称它为人工智能，而不是这些列。

我们不叫它玫瑰，而是叫它 j。

所以对于这个 for 循环的每次迭代，我们都要沿着 k 轴向上移动。

所以如果我们要写 K 的指数是多少，现在很难看到。

但会是 012。

第三，让我们把它画出来。

所以，让我们一步一步来，让你们了解发生了什么。

所以对于这个顶层 for 循环的第一次迭代，将等于零。

这意味着，这条线，我们会在 I 的零索引处。

然后对于这个嵌套的 for 循环，J 也等于零。

所以 j 在这里。

我们在这里将会是零。

所以我们还是会在这里。

对于 K 来说也是如此。

这个 x 在这里，我们也会在这里，也就是零。

所以我们还是会在这里。

因此，我们不用控制台记录这些坐标，而是为这个坐标画一个正方形。

这个坐标是 00，0，00，0，所以我们在这里画一个正方形。

再说一次，你得原谅我可怜的画正方形的能力。

因为我们继续 K，直到 K 不再小于 n，我们将继续迭代这个 for 循环。

为了帮助你们，我可以告诉你们，我可以写 I 现在等于 0，J 现在等于 0 和 k。

它等于零，但我们只求 K 在零的平方。

所以现在 K 要迭代了，它要加 1。

所以 K 现在等于 1。

所以当 k 为 1，j 为 0，且为 0 时，那么 i j。

k 是 1，然后我们要去另一个方块，这可能有点难看到，因为我在尝试画三维空间，而在这里，我很不擅长画画，我会尽力而为。

再试一次。

好的，一旦我们这样做了，K 加 1，所以 K 现在是 2，2 在这里，然后 I 和 j 仍然是 0，所以我们仍然在 j 这里。

所以我们还是会在这部分。

我们将在这里画另一个二维正方形。

我的意思是，二维立方体，对不起，如果我称一个立方体为正方形，那肯定不是正确的立方体。

所以还有另一个立方体。

当然，K 会再次增加。

所以 K 会变成三。

然后在这里的三点，我们将钻另一个正方形，我的意思是，立方体，对不起。

在这一点上，K 会增加。

然后就等于 4 了。

而一旦 k 等于 4k 就不再小于 n，因为 n 也是 4。

所以现在 k 等于 n。

所以这个世界完了。

现在我们移到这个 for 循环。

这个 for 循环将增加 1，j 将等于 1，因为对于这个 for 循环的每次迭代，我们都要遍历整个 for 循环。

我们已经遍历了整个 for 循环。

现在我们可以在这个 for 循环中向上移动一次迭代。

我们不能回到这个 for 循环，直到我们遍历了这个 for 循环中的所有内容。

所以我们还在继续，所以我们只是增加行，然后我们回到迭代 k。

所以现在 j 等于 1 还是 0，所以我们还在这里，我们还在这里，因为这是列，然后我还是 0，这是我，我还是 0。

我们还在这里，但是 j 从 0 到 1。

所以现在我们在这里。

所以我们又回到了 k，k 又要从零开始了。

所以在 I 为 0，J 为 1，K 为 0 时，因为 0，好的，这是 K，这是 0。

我们在这里画一个正方形。

抱歉，我再说一遍，我说的是平方对，我们画 q 10k 增量。

我们再画一个立方体。

然后 k 递增，我们画另一个立方体。

然后 k 递增。

个体多一个 Q，因为一旦 K 达到 4，那么对，K，好的，我们再增加一次，它会达到 4。

现在 K 不再小于 in。

所以我们回到 RJ 循环，这将增加 1。

所以这个会变成两个。

这几乎是一回事。

贯穿整个函数，越来越难看到我在这里画的立方体。

但是最终，我们会到达一个点，整个立方体被填满，看起来像这样。

所以我们会到达一个点，这个立方体的整体将被这些微型立方体填满，这只是这四个循环的迭代。

所以一旦我们到了那一步，谢谢你这个立方体就完全填满了。

此时，这意味着我们已经遍历了这个顶级 for 循环的全部。

请随意花时间尝试自己画出来。

但是我基本上在这段视频中尽我所能地浏览了一遍，但是在整个立方体被填满之前都是一样的。

所以一旦这四个循环都完成了，你就会得到一个看起来像这样的立方体。

因为这是一个立方体，这意味着它的高度，长度和宽度都是一样的。

也就是说，它们都将在，因为如果你看这里，我们经历了 j 的迭代。

我们经历了 AI 的迭代和 k 的迭代。

再次，我很抱歉，因为我画得不好，我希望你能明白。

所以如果 n 是 4，这将是 4，这将是 4，这将是 4。

为了得到这个立方体的体积，得到这个立方体的体积，这个立方体的空间，因为我们知道所有这些都是一样的，我们只需要知道其中的一个。

其中一个是得到体积，我们刚才对立方体做的，4 的立方是 64。

这就是这个立方体的体积，也就是说在这个更大的立方体中有 64 个这样的微型立方体。

这就是音量。

所以 n 的立方是 O，r ^ n 是 4。

四个立方体的 o，等于 64，这是这个立方体的体积。

这也是我们执行这个函数的次数，控制台记录坐标，但是在我们的例子中，我们只做平方。

这就是为什么这个函数是 O 的 n 次方必须先了解什么是对数。

简单地说，对数是一个数需要被提升到的幂，以得到另一个数。

我知道脱离上下文没有多大意义，但别担心，我会保护你的。

让我们考虑一下数字 8。

所以我们想提高一些数字的幂来获得博士学位。

在计算机科学中，除非另有说明，否则我们总是可以假设我们要计算的幂和数是 2。

所以我们重写一下。

所以我们想用 2 的某次方得到 8。

所以这个等式可以写成这样，或者这两个叫做底。

我们不要忘记，在计算机科学中，基数总是 2。

所以要找到这个问题的答案，我们只需要找到这个问题的答案。

记住这一点，我们可以看到，如果我们把 2 提高到 3 的幂，我们得到的数字就是 8，所以以 2 为底的 8 的对数是 3。

记住所有这些，让我们继续了解 Oh login 的含义。

对于这一部分，我们将使用一个非常简单的递归函数来可视化 Oh 登录，但是不要担心，我会带你完成每一步。

和我在一起。

我们将从一个数字开始，我们将使用 8，这样你可以很容易地看到这与我们在上一张幻灯片中对对数的解释有什么关系。

所以我们会把这个变量传递给递归函数，就像这样。

所以这个函数的时间复杂度是哦，登录，让我们深入挖掘，找出原因。

现在，让我们忽略这第一行，把注意力集中在函数实际上在做什么。

所以当我们把一个数传递给这个函数时，它会除以 2 或分成两半，然后用新的一半或被除的数调用自己。

让我们用图表来形象化这一点。

所以我们首先调用值为 8 的函数，然后这个 8 除以 2。

然后，该函数获取除法的结果，并将其作为 n 的新值递归传递给自身，这又会导致我们更深入一层。

然后我们用新的 n 值做同样的事情，4 除以 2 得到一个新的 n。

然后，该函数将我们的新 n 值再次传递给对其自身的递归调用，从而使我们更深入一层。

然后我们对 n 的最近值做同样的事情，它是 2，我们把它除以 2，函数再次递归调用它自己，在这一级，我们将停止，因为我们不能再进行除法运算，结果得不到分数。

现在我们已经开始了解登录的秘密了，所以请密切关注。

如果你看我们的图表，你会发现我们已经深入了一到三个层次。

如果您还记得我们上一张幻灯片中的内容，八的对数底是三。

我们的输入是 8，我们已经深入了三层。

你还会注意到，我们必须将 2 提高到 3 的幂，或者乘以 2 乘以 2 乘以 2 得到 8。

因为除法正好是乘法的逆运算，我们可以看到当我们这样做的时候。

这意味着这个函数的时间复杂度是，登录。

为什么？因为我们的 n 是八。

在计算机科学中，我们的基数总是 2。

我们必须在递归函数中使用 n 三次，或者深入三层，才能到达一个我们不再能合理地输入的点，这是另一种说法，即以二为底的对数等于三。

女士们先生们，这就是理解登录时间复杂性的秘密。

快速注意，这不仅适用于递归函数。

如果你对我们之前提到的那行代码感兴趣，它所做的就是确保当 n 变成 1 时我们停止了划分，否则，函数会一个分数接一个分数地划分，直到我们最终超过最大调用堆栈。

所以我们从一个非常简单的函数开始，它只包含一个 while 循环，为每次迭代中的变量赋值。

在这个例子中，让我们想象我们正在为这个函数传递值 82 小时。

这意味着只要 8 大于 1，我们就会遍历这个 while 循环。

对于这个 while 循环的每一次迭代，我们都要把 n 除以 2，然后重新赋值给 n。

所以我们的 n 会在每次迭代中减半。

所以目前，我们的 n 等于 8，因为我们把 8 作为 in 传入，当 n 大于 1 时，我们将进行迭代。

所以现在是八，大于一。

因此，我们将在第一次迭代中做这个数学点 floor n 除以 2，这将使我们的 n 等于 8 除以 2，也就是 4。

这个数学点地板，它所做的只是地板我们除法的结果。

举个例子，如果我们有数学点底数，5 除以 2，我们会得到 2，而不是 2.5。

第一次迭代后，我们的 in 现在等于 4。

所以当 n 大于 1 时，我们将进行另一次迭代。

所以四比一大，所以我们要再做一次。

n 等于 4 除以 2，等于 2。

所以现在我们的 n 等于 2。

当 n 大于 1 时，我们要再做一次。

所以 in 目前大于 1，2 大于 1。

所以我们将再次进行第三次迭代。

所以 in 等于二除以二，等于一。

所以在这一点上，我们的 n 等于 1。

我们将再次回到这个条件。

所以当 in 大于 1 时，我们要这么做。

但是现在 n 等于 1，它不再大于 1。

所以我们不会继续这个 while 循环。

那么为什么是 login 这个功能，所以我们的 n 是八。

这意味着这个函数的对数应该是 0。

如果你还记得上一个关于旧登录复杂度的视频，这和对数基数为 2，8 的 o 是一样的，也就是说我们需要提高多少幂才能得到 8。

如果我们把这个写出来，我们需要提高多少次幂才能得到 8，我们看到我们需要提高 2 的三次幂才能得到 8，因为 2 乘以 2 乘以 2 等于 8。

所以这三个是最重要的，因为除法正好是乘法的倒数。

因此，如果我们需要将二乘以二乘以二得到八，那么我们也应该能够将八除以二乘以三得到一。

所以有 123 个。

这意味着对于这个函数，当我们传入一个 n 的值时，我们总是需要将这个值除以登录次数，然后才能得到一个，这是另一种说法，当我们传入这个函数时，我们将迭代这个 while 循环，在我们得到值 1 之前，记录迭代次数。

如果你看到这里，我们有一次迭代，两次迭代，三次迭代。

这里有三次迭代。

这是三次登录迭代。

因为再次，哦，所有登录，只是意味着哦，日志基数二八。

因为我们的 n 是 a，n，八的对数基数二是三，因为二的三次方等于八，也就是我们的 n。

这就是为什么这个非递归函数是登录，因为将有登录迭代 123。

在 while 循环结束之前。

我希望这有意义。

首先，我们应该明白，为了使二分搜索法能够工作，您要搜索的数组必须是有序的数组，升序和降序两种数组都可以工作。

让我们从可视化我们的数组开始。

在实践中，随着数组的大小变得越来越大，这将更加有用，但是我们将坚持使用包含九个元素的数组来帮助我们更清楚地理解这个概念。

所以让我们假设我们想检查我们的数组，看看数组中是否存在值 100。

简单的解决方案是遍历数组的每个元素，检查值是否等于 100，就像这样。

但是对于这个方法，我们必须遍历数组中的每个元素，直到找到我们想要的值。

如果我们必须对包含 1000 个、100，000 个甚至 100 万个元素的数组执行此操作，那会怎么样呢？

这就是像二分搜索法这样的东西可以派上用场的地方。

让我们再试一次。

所以在这里，我们仍然想检查值 100 是否在我们的数组中。

但是这一次，我们将利用二分搜索法来解决这个问题。

首先，我们需要找到数组的中点，也就是数组中间的元素，我们的中点在这里。

现在，因为我们的数组是升序排列的，我们知道，任何与中点比率相关的值都会比中点大。

中点左边的所有值都小于中点。

所以我们需要弄清楚，我们正在寻找的这个数字 100，是大于还是小于我们的中点。

这将告诉我们我们的数字在数组的哪一边。

因此，如果我们简单地写出 43 小于 100，我们实际上可以看到我们的数字在数组的这一边。

为了描绘一幅完整的画面，让我们假设我们要搜索的数字是 2 而不是 100。

在这种情况下，2 将小于我们的中点 43。

因此，它会在左侧。

女士们先生们，这就是为什么二分搜索法只研究有序数组。

因为如果没有顺序，就无法通过与中点比较来判断我们要搜索的数字在哪一边。

现在让我们回到例子中使用的原始数字。

所以现在我们知道 100 会在中点的右边，我们可以完全去掉中点左边的任何东西，包括中点。

所以我们剩下的就是这个，我们所做的就是把数组切成两半。

为了客观地看待这个问题，让我们假设有一个包含一百万个元素的数组，我们将它除以二。

只需一步，我们就将需要搜索的元素数量减少了 500，000 个，而不是遍历所有 100 万个元素并以这种方式进行搜索。

而且这还不止于此。

我们现在将对数组的这一半做完全相同的事情。

让我们记住，我们是在搜索数组中是否存在数字 100，我们首先需要找到我们的中点。

现在不要被这个数组中的偶数个元素所迷惑。

尽管中点两边的元素数量都不是偶数，但这并不重要，因为我们实际上只需要将数组大致分成两半。

例如，为了找到 mid 和 code，我们将做类似于将数组的长度除以 2 的事情。

由此产生的结果将作为我们 mid 的索引。

让我们写出这个数组的索引，记住数组是零，意味着起始索引也是零。

如果我们取这个结果 2，看看它指向什么值，我们会看到我们的 mid 是 100，这是我们要寻找的数字。

这样的话，我们就完了，我们已经找到了我们的号码。

但是为了证明我们选择使用哪一个实际上并不重要，让我们探索一下如果使用 mid 54 是我们所寻找的大于或小于我们的 mid 54 的数字会发生什么。

我们的数量大于 54。

这意味着我们可以去掉左边。

我们剩下的是一个只包含两个元素的数组，这也是一个偶数数组。

所以我们没有办法决定我们应该选择哪一个作为我们的 mid，让我们看看，如果我们用 124 会发生什么，我们的女仆是大于还是小于 100。

它大于，所以我们可以忽略这个数组的右半部分。

现在我们只剩下一个包含一个元素的数组。

所以我们所谓的中点只能是这个元素。

这个元素就是我们要寻找的数字。

所以我们到此为止。

所以你可以看到，不管你有一个自动数组还是一个偶数数组，只要它是有序的，搜索元素就会被找到，如果它存在于数组中。

女士们先生们，这就是二分搜索法实际上是如何运作的，以及它为什么有用。

让我们从创建一个文件开始，我们可以把它命名为 log in . js。

为了让二分搜索法工作，我们要搜索的数组必须是升序或降序。

所以你不能有一个随机排列的数组，然后在上面使用二分搜索法。

这是在本教程的剩余部分要记住的，我们的二分搜索法函数将接受四个参数，它将接受一个数组，数组将包含需要排序的整数值，所以我们将只做 1 到 8，我们还需要将数组的第一个索引传递给函数，我们就称它为 start。

这将是零。

我们需要接收数组的最后一个索引，我们称之为 end。

我们可以得到数组的长度，然后减去 1。

我们需要从数组长度中减去 1 的原因是因为数组的索引实际上是从零开始的，但是数组本身，长度实际上不是从零开始的，它只是数组中元素的数量。

所以数组长度是 8，但是长度为 8 的数组的最后一个索引是 7。

这就是为什么我们要减去 1。

最后但同样重要的是，我们需要接受一个目标值，也就是我们要寻找的值。

我们将只搜索八个。

然后我们可以开始构建我们的函数。

我们就叫它二分搜索法。

它会在数组末尾和目标处开始。

这个函数实际上是一个递归函数。

所以要开始这个函数，我们需要找到数组的中间索引。

所以你会注意到我们在这里使用了一个内置的函数 math . floor。

我们使用它的原因是因为如果我们去定义，它说它返回小于或等于它的数值参数的最大整数，这基本上意味着如果我们的括号内的除法表达式，在我们的函数内，括号返回类似于 5.5 的值，分配给 MIT 的值将只有 5，因为我们不想考虑小数点后的任何东西，因为我们只想找到一个索引，当然不会有索引 5.5。

因此，我们的 mid 就是 5。

接下来我们要做的是检查我们的中点是否是我们要寻找的数字，也就是我们的目标。

因此，如果数组的中间值实际上是我们要寻找的目标，这基本上会返回 true。

所以我们返回 true，因为这意味着我们要查找的值存在于数组中，这里就完成了。

实际上，我刚刚意识到，我可能会混淆你们，因为我把我们的中间值和我们的中间值互换了。

所以这里的 mid 实际上是我们想要得到的 mid 的指数，我们想要得到这个指数。

所以这里我们也可以添加索引。

所以当我说我们的 mid 时，我实际上指的是山谷，所以我们实际上想返回 true，如果在我们的 mid 索引处的值等于我们的目标值。

因此，如果我们的中间指数值不等于我们的目标值，我们就要继续检查，看看我们的中间指数值是大于还是小于我们的实际目标值。

所以实际上，这应该成为索引。

很抱歉。

实际上，我们还有一个错误。

所以我们将开始，然后目标应该在这里。

那应该有用。

所以，让我们花点时间来理解这行代码发生了什么。

因此，如果中间的值大于我们的目标，那么这意味着我们的目标实际上在数组的左侧。

因为如果我们看这里，我们考虑到在这种情况下，5 将是我们的 mid，在第一次执行这个函数时，5 将是我们的 mid。

如果 5 大于我们要搜索的数字，那就意味着我们要搜索的数字在左边，因为如果 5 大于 5，我们要搜索的数字在右边，因为我们的数组是升序排列的。

这是为了检查我们要搜索的项是否在数组的左侧。

如果是，我们要做的是，我们要传递我们的开始，它会保持不变。

所以我们将保持相同的起点，在这种情况下，它将是指数 0，然后我们的终点将是 mid 减 1 减 1，因为我们将实际上取消当前的 mid，实际上，这也应该是 nid 指数。

我们只需要将当前的 mid 减 1 赋给我们的 in 变量，因为我们下一次执行函数时会以此为结束，然后以此为开始，因此我们只需要搜索 1234，然后我们会依次找到 1234 的 mid。

然后我们会做同样的事情。

如果我们寻找的目标值大于中间值，会发生什么呢？让我想想。

因此，在这种特殊情况下，目标值将小于或等于中间值。

这意味着目标值在我们右边的左边。

但如果不是这样，那么如果我们的目标大于我们的中点，那么我们会做类似 else return 的事情。

所以我们仍然会调用函数本身，但是这一次，我们会传入数组，数组，而不是传入最初的起点，我们会传入中点索引加 1。

这将是我们新的起点。

这是因为我们从中点开始到数组的右侧，因为我们要找的实际值在数组的右侧，然后在这一点上，我们的末端可以保持不变，因为末端就是数组的末端。

让我们再来看看这个。

让我们再一次，假设这次执行，我们的 mid 是 5，但是这次，我们寻找的实际值大于我们的中点。

这意味着它不可能在左边，因为中点左边的所有东西都会小于，因为我们的数组是升序排列的。

所以它会在右边。

如果它大于我们的中点，那么当然，我们不需要考虑 5，这就是为什么不做 mid index，也不返回 mid index 和 end 到函数，我们只需要返回 mid index 加 1，这将是这个 index，它将是 index，它将是这个 index 的值 6，比我们实际的 mid 高一个 index。

现在，在这一点上，我们只搜索我们的结束和我们的 mid 加 1。

我们只在数组中搜索这三个元素。

这就是这两种情况所涵盖的内容。

所以第一个条件包括，如果这个项目在我们方法的左边，在这里。

第二个问题是我们要找的东西是否在正确的环境中。

这就是二分搜索法的工作方式。

这就是为什么二分搜索法比线性搜索更有效。

因为我们不需要检查数组中的每个元素，我们实际上可以通过知道我们正在搜索的项是小于还是大于中点来消除数组的一半。

因此，让我们继续下去，看看我们是否可以实际运行这个函数，并让它工作。

我现在要告诉你，我们将尝试运行它两次，我们将尝试运行它，搜索我们知道在数组中的实际值。

我们将尝试运行它，搜索一个不在数组中的值。

你会发现我们在这个函数中遗漏了一些东西。

所以让我们继续尝试运行它。

现在运行它。

显然，我们必须调用函数。

所以我们去二分搜索法。

我们将传递数组，开始和结束目标。

我们要拯救它。

所以我们将尝试使用 node，login dot j s 来编写它。

我们打破了它。

很好。

必须在这里加上目标。

所以导致了整个功能失效。

再看一遍。

好，让我们看看如果我们真的返回值会发生什么，我的意思是，控制台记录函数的返回值。

我们得到真，因为在数组中找到了 8。

但是你会看到，如果我们搜索数组中不存在的东西，我们会再次破坏它。

所以 10 不存在。

所以我们再试一次。

我们已经超过了最大调用堆栈大小，因为让我来告诉你什么是超过最大调用堆栈大小。

所以我们要做的是，每次我们不满足这个条件，我们就要再次调用二分搜索法，也就是我们再次递归调用函数本身。

如果我们，如果我们在寻找一个数组中不存在的数，二分搜索法基本上会一直递归调用自己。

永远不会有一个停止的时刻。

即使它没有在数组中找到该项，它仍然会继续递归调用自己，直到我们最终达到最大调用堆栈大小，这基本上就是你已经超过了分配给这个特定应用程序的内存量。

所以为了解决这个问题，我们想做的是添加一个基本条件，在检查完整个数组后，停止函数的递归调用。

所以我们可以这样做，如果 start 大于，然后返回 false。

这样做的原因是，如果目标不在我们的数组中，这意味着目标大于数组中的最大值，或者小于数组中的最小值。

这意味着我们的函数将一直检查我们的数组，直到我们到达最大的项，如果目标大于数组中最大的值，或者到达最小的项，如果目标小于数组中最小的项。

在这一点上，开始值和结束值相等，在这一点上，开始值和结束值相等，把我们的开始值传递到这条线，或者这条线，实际上，让开始值大于结束值。

现在，我们可以使用数组中不存在的 tin 再次运行此操作。

如你所见，我们得到假的。

如果我们在这里加上负的，负 10 是不存在的。

所以我们也会犯错。

让我们看看，我们还能尝试什么。

只是想我们知道有两个。

然后，我们通过了。

让我们把它改回 a，感受一下为什么这个函数是，登录，让我们继续，在这里创建一个更长的数组。

所以目前，我们的数组只包含这八个元素。

对于如此小的数组，我们很难全面了解输入的扩展方式，所以我们可以清空数组，然后创建自己的数组。

让我们来看看，我们可以做的交易是，i is，I 小于 1024。

对于人工智能的每一次迭代，我们都可以升级，推高。

让我们想一想，让我们来看看第一只眼睛。

然后我们让它小于或等于。

然后我们可以聊以自慰。

记录我们的阵列。

现在，让我们把这个注释掉。

让我们看看。

好了，现在，我们有了一个更长的数组，当我在这里做一些控制台日志欺骗时，这有望帮助你们直观地看到输入是如何扩展的。

所以是的，所以我们不需要再记录这个了。

实际上，删掉它。

所以我们在这里创建了一个新的数组。

这将是一个数组，包含从 1 到 1024 的元素。

出于这个例子的目的，我不希望我们找到元素，我的意思是，数组中的项，所以我们要把它改成数组中不存在的东西。

我们假设 100，000 不存在于我们的数组中，也不存在结尾，这是从当前数组中得到的结尾。

因此，在创建完整阵列后，我们需要将它降低到。

所以这个数组在这里是空的，然后我们在这个 for 循环中添加所有的值，然后我们得到数组的结尾。

当然，起点也可以是零，因为它是零。

此外，我们可以在这里删除，直到我们不再需要控制台日志，因为我们将执行另一个控制台日志。

所以我们要在这里执行函数。

然后这里就是我们要尝试创造一些奇迹的地方。

所以对于每个对二分搜索法的调用，就像每个递归调用一样，我们希望不只是递归调用第一个调用。

每一次递归调用，我们都希望记录下我们正在搜索的数组的样子。

一开始，它是完整的阵列，这是我们之前登录控制台时展示的。

然后在每次调用这个函数时，速率会减半。

因此，它将看起来像这样，控制台点日志将执行数组点切片。

我们要开始和结束。

因此，它只能显示比赛从开始到结束的部分，而不再显示完整的数组。

让我们看看这是否可行。

在这里，我们可以进行节点登录。

好吧，是的，这招奏效了。

所以也许我可以把它变小。

所以你可以看到，当我像这样把它变小的时候，你很容易看到，嗯，在这一点上有太长的时间来展示它的整体。

但是你仍然可以看到这里发生了什么。

因为值大于数组左侧的值，所以你可以看到，所有这些较小的值基本上都被消除了，它继续减半。

从这里你可以开始看到这里发生了什么，就像我可以看到，光线继续变得越来越小。

为了理解 ovan 登录，我们将考虑这个小函数。

这个函数具有 ovan 登录的复杂性。

让我们一行一行地检查这段代码，以便我们可以理解这里发生了什么。

这个函数有一个参数，在这个例子中，我们声明了另一个变量 Y，我们把它设为 n，我们稍后会知道这个变量 Y 代表什么。

此时，我们有一个 while 循环，它遍历 n，直到 n 等于 1。

对于这段代码中的每次迭代，while 循环都会运行。

让我们想象一下。

while 循环的第一次迭代开始时是 4，但是我们把它除以 2，所以 n 现在等于 2。

然后我们到了这行代码，这是一个 for 循环的开始。

这就是变量 y 出现的地方。

我们在循环开始之前声明这个变量的原因是因为 n 在每次迭代中被 2 除。

这反过来减少了变量 n 的大小。

但是对于这个内部 for 循环，我们需要遍历原始 n 的原始大小。

所以我们把最初的结尾存储在一个单独的变量中。

好，回到这个内部 for 循环。

对于这个 For 循环的每次迭代，直到 n 的大小，我们将记录或打印 I 的值。

一旦完成，我们就进入 while 循环的下一次迭代，重复这个过程，现在是 2，我们从除以 2 开始。

所以 n 现在是 1。

我们再次遍历内部 for 循环，直到 y 的大小。

现在，你会注意到我们的 n 现在是 1。

如果我们检查我们的 while 循环的条件，我们会发现我们只想在 n 大于 1 时进行迭代。

因此 while 循环现在将终止，函数也就完成了。

现在，该说的都说了，该做的都做了，该写的都写了，我们可以看到这里有一个顶级循环。

顶层循环的每次迭代都有一个内部循环。

这就是奇迹发生的地方。

所以要密切关注。

对于通过顶级循环的每次迭代，迭代直到 n 是 1 除以 2。

这意味着这个顶级循环实际上从不遍历我们输入的全部大小，因为 n 的值在每次迭代中被分成两半，这就是为什么我们会说这个顶级循环的复杂性为 Oh login。

如果你对这个顶级循环为什么是哦，登录，让我们花点时间写出来证明一下。

所以这是哦，登录。

让我们插入一些数字。

如果你在登录网站上看过我的视频，你知道在计算机科学中，对数的底数总是 2，除非另有说明。

所以这可以重写为以 2 为底的 4，4 的对数，因为我们用 n 的实际输入来代替 in，也就是 4。

4 的对数基数 2 是 2，因为你需要 2 的 2 次方来得到 4。

如你所见，这是有意义的，因为对于这个顶级循环，我们只迭代两次。

对于这个顶级循环，我们的对数基数为 2，4 等于 2。

现在我们需要看看在顶层循环的两次迭代中发生了什么。

对于每次迭代，我们遍历 y 的完整大小，这是 n 的原始大小。

这意味着每个内部循环的复杂度都是 O/n，也就是说处理时间随着 n 的增加而线性增加。

这是我们汇集一切的地方。

O of n log in 实际上就是 O of n 次登录的意思。

如果我们在这里插入一些数字，我们会得到这个。

因为记住，以四为底的对数等于二。

如果你看看我们的可视化，它非常有意义，因为对于顶部循环的每一次迭代，我们都迭代了整个 y，这是 n 的初始值。

女士们，先生们，这就是你在登录时看到的一切。

我们可以从创建一个文件开始，我们称它为合并排序，然后创建一个函数，它也会调用合并排序。

这个函数的参数将是我们要排序的数组，对于这个函数的第一部分，我们需要确保我们传入的数组长度大于 1，我们需要这样做，因为如果数组长度只有 1，并且数组中只有一个元素，那么它已经被排序了。

这也将是我们的基本情况，因为这个合并排序函数将是一个递归函数。

接下来，我们需要将数组分成两半。

为此，我们首先需要找到数组的中间索引。

所以这个数学点底数，确保我们只考虑除法结果的基数。

举个例子，如果我们除以一个数，结果是我不知道，比如说 5.5，我们不会考虑小数点后的数字。

所以我们只返回变量 5。

这是因为当考虑指数时，没有指数 5.5 或 2.2 或 1.1，只有指数 1，5 或 2。

这就是为什么我们在这里使用数学点地板。

一旦我们有了输入数组的中间索引，我们就可以把数组分成两半，为左边创建一个单独的数组，为右边创建一个单独的数组。

我们可以通过创建一个新的数组 left array 来实现，然后我们可以设置 left array 等于输入数组的点切片，然后索引就是我们传递的参数。

所以基本上是从和到切片。

所以我们想从输入数组的第一个索引开始切片。

我们希望切片到我们刚刚得到的中间索引。

这是因为我们想要数组的左边。

举个例子，这个数组是这样的。

我们赢了，我们继续，得到了我们的中间指数，大概是这里的 3。

然后我们想创建一个数组，从这个零索引开始，一直到中间的索引，也就是数组的左半部分，然后我们继续对数组的右半部分做同样的事情。

我们将继续对数组的右半部分做同样的事情，我们称之为右数组。

我们再做一次数组点切片。

但是这一次，我们将从中间的索引开始，一直到数组的最后一个索引，我们获取数组最后一个索引的方法是使用数组点长度。

这实际上有点混乱，因为我们知道数组点的长度给出了数组的长度，也就是数组中元素的数量。

我们还知道数组索引是从零开始的。

所以基本上，如果一个数组的长度是 5，就只有索引 0123，4，就不会有索引 5。

所以在这里，你可能想知道这实际上是如何工作的。

因为实际上，有一个错误。

这个方法不是切片器，只是切片，但这是因为这个切片方法切片到 in，但不包括 in。

所以基本上这个结束值，它不包含在实际的数组中，slice，只有之前的值会被包含进去。

举个例子，如果我们有一个数组，看起来像这样，我们会用这个数组的结尾是 3，即使只有索引 01。

第二，它会一直切片，直到结束，不包括 in，所以这就是为什么我们不需要从这个数组中减去 1，因为如果我们从数组点长度中减去 1，并把它作为最后一个索引，或者是传递给 slice 方法的结束索引，那么我们实际上不会得到完整的数组，我们只会到这个数组，但不包括这个数组。

所以他们只能在这张切片中看起来像这样。

我希望这有意义。

有点混乱。

还要记住，在我上面给出的这个例子中，我实际上没有考虑中间的索引。

特别是对于这个数组，它看起来像数组点切片，切片，直到数组点长度减 1，索引都是零。

不管怎样，最后但同样重要的是，对于我们实际的 emerge cert 函数，我们要做的是实现函数的递归部分，这是我们要返回的，请原谅，我们要返回一个我们还没有创建的 helper 函数。

我们称之为合并。

在这个婚姻助手函数中，我们将接受两个参数，分别是左边的数组和右边的数组。

我们要传递给 merge 的是对 merge 排序的递归调用。

然后是左边的数组，我们也要传递递归调用来合并排序，还有右边的数组。

现在这看起来有点混乱。

但是请耐心听我说，我会解释这是如何工作的。

我会试着为你解释清楚。

但是现在，我们实际上还没有这个合并函数，所以我们需要继续创建它。

让我们在这里创建这个新的助手函数，叫做 marriage，它将接受左边的数组和右边的数组。

哦，对不起，这不是合并，这是合并。

现在这个函数将会是合并两个数组的函数。

所以归并排序的工作方式是我们使用分治法，输入数组基本上被分成两半，直到我们得到长度为 1 的数组，在这一点上，长度为 1 的数组，如上所述，当我们创建这个空间例子时，长度为 1 的数组已经被排序了。

为了形象化，如果我们有一个数组，也就是一个，这个数组中只有一个元素，所以很明显，这个元素将是数组中的第一个也是最后一个元素。

所以没必要排序，因为没什么可以比较的。

在这个实际的合并函数中，我们要做的是把这些排序后的数组放在一起，进行比较，然后对这些单个的元素数组进行排序。

所以在编写这个合并函数的过程中，要记住的一点是，这个合并函数总是接受两个已经排序的数组，从长度为 1 的有序数组开始。

首先，我们要创建一个变量，它只是一个结果数组，它将以一个空数组开始。

所以这些都等于一个空数组。

我们也要为左数组和右数组定义基本索引，但是索引可以等于零。

现在我们将做同样的事情。

接下来，我们将创建一个 while 循环来逐个元素地比较这两个数组。

实际上粘在这里，这个长度。

所以在这个 while 循环中，我们将比较两个数组中的每个元素，比另一个小的元素将被添加到结果数组中，然后将增加被添加到结果数组中的元素的索引，因为该元素不再需要被比较。

如果你对此有一点困惑，请耐心听我说，我将为你创建一个插图来更好地理解它。

但是现在，让我们只写出代码。

让我们想象一下，我们想要合并的光线，对于左边的数组是这样的，对于右边的数组是这样的。

现在请记住，merge helper 函数合并有序数组，因此它不能处理无序数组。

在这个例子中，我们合并了两个长度为 3 的有序数组，以显示函数的全部功能，但这也适用于长度为 1 的自然排序数组。

因此，为了继续这个 while 循环，左索引和右索引都需要小于它们对应的数组的长度。

正如您所看到的，每次索引被推送到结果数组时，这些索引都会增加。

如果我们把它画出来，它看起来像这样。

下面是这两个数组及其索引。

在下一行中，我们检查位于左数组索引(当前为零)的元素是否小于位于右数组索引(也为零)的元素。

所以是三比一少。

号码

这意味着我们要做 else 条件中的事情，将当前索引处的右数组元素推送到结果数组，并递增右数组索引。

现在我们右边的数组索引是 1，所以我们可以移动它。

然后再一次，我们在 for 循环的顶部做比较，3 比 6 小？是的。

因此，我们将 3 放入结果数组，并增加左侧数组的索引。

我们也可以把这个移过去。

回到 for 循环的顶部，12 比 6 小吗？号码

因此，我们将使用 else 条件中的代码，将右边的数组元素 6 推送到结果数组，并递增右边的索引。

再一次，我们移动这个，现在是 12 比 15 小。

是的，所以我们将 12 从左边的数组推到结果数组，然后增加左边的索引，并将这个箭头移动到新的左边的索引。

现在 16 比 15 小吗？号码

因此，我们继续我们的 else 条件，将 15 从右边的数组推到我们的结果数组，并将右边的索引增加 1。

现在，这个 while 循环将会终止，因为如果你还记得这个 while 循环，只有在左索引小于左数组长度，右索引小于右数组长度的情况下才会继续。

此时，我们的右索引等于右数组长度。

你可能已经注意到了，在左边的数组中还有一个 16 没有被推到结果数组中。

但是 while 循环已经完成了。

那我们该怎么办？在 while 循环之后，我们将添加另一行代码，如下所示。

所以这个返回将返回一个数组，它是三个数组的组合或串联，结果数组，左数组的一部分和右数组的一部分。

所以这个切片函数，如果我们只给它传递一个索引，它将作为切片的开始，一直切片到数组的末尾。

我们来分析一下。

如果你还记得上一张幻灯片，我们的结果数组现在是这样的。

我们将从左侧数组中添加一个片段，从我们增加的左侧索引 2 开始，这导致数组只包含这一部分，我们将从右侧索引 3 开始添加一个片段，这导致一个空数组，因为索引 3 应该在这里。

结合所有这些，返回的结果是一个有序的数组，如下所示。

现在，我们继续添加刚才在插图中讨论过的回报。

这就完成了我们的合并功能。

现在合并函数完成了，我们的合并排序函数也完成了。

现在我们可以继续进行测试了。

为了测试这一点，我们需要创建一个数组。

这个数组，我们需要传递给合并排序函数。

这就是我们排序后的数组。

如果我们花点时间回到这里，看一下代码，你会看到在这个合并排序函数中，我们将输入数组递归地划分为，这使得这个合并排序成为登录函数的一部分。

实际上，这个合并函数是所有事件，因为它需要接触两个数组中的每个元素来对它们进行排序。

所以这个合并函数是旧的，实际的递归合并排序函数是 login 的。

对于递归函数深度之前的每一层，我们都要进行合并，这是 O/n。

为了得到总的时间复杂度，我们只需要将这个递归函数的深度乘以 O/N，这是 O/n log in，因为 N log in 只是乘以 log in 和 log in，在这种情况下，这将是这个递归函数需要遍历的深度。

让我们想象一下这个合并排序函数，我们将一行一行地检查代码。

假设我们有一个这样的数组。

所以这个数组是我们的输入数组。

这就是我们要传递给合并排序函数的数组。

所以这个数组是这个数组。

所以这里代码的第一部分，只是检查我们的数组是否大于长度 1，因为长度为 1 的数组已经被排序了。

所以如果我们在这里得到一个长度为 1 的数组，我们只是把它作为一个已经排序的数组返回。

但是如果数组的长度大于 1，那么我们将继续这部分代码。

这部分代码是分而治之方法的实现之处。

所以基本上，在这里，我们要分裂我们的输入数组。

通过获取数组的中间索引，我们将把它分成两个独立的数组，如下所示。

这些单独的数组是左数组和右数组。

拆分后，它们将再次被传递给合并排序函数。

再一次，我们在代码的这一部分结束，因为这个数组和这个数组被分别传递给这个合并排序函数。

对于每一个，我们都在代码的这一部分结束。

这两个数组的长度都不小于 do，我们有一个长度为 2 的数组，还有一个长度为 3 的数组。

因此，他们将继续这部分代码，我们将再次使用分而治之的方法。

让我们把它写在这里，因为它很重要。

因此，我们将再次获取数组的中间索引，并通过在中间索引上拆分单个数组来创建左右数组。

你会注意到这个数组，这个数组和这个数组的长度都是 1。

正如我们在这里看到的，我们将把这些长度为 1 的数组传递给归并排序，我们将把这些数组传递给归并排序，然后它们将到达这个条件，它们的长度小于 2。

所以我们要返回这些光线。

对于这些数组，我们可以停下来。

但是这里的长度是 2。

所以这个数组会再次到达这部分代码，我们会把它分开。

现在，这些数组的长度是 1，所以我们也可以停在这里。

所以这些对归并排序的调用，和这些对归并排序的调用是一样的。

但是我们还没有调用合并。

merge 要做的是，将两个已经排序的数组合并成一个单独的排序数组。

这看起来像是，它将在这里被调用，这些结果将被合并到一个排序后的数组中。

所以这两个排序后的数组将被合并，并作为一个长度为 2 的排序后的数组返回。

同样的事情也会在这里发生。

我们要合并了。

这两个排序后的数组将被合并，作为一个排序后的数组返回。

我们在这里也会这样做。

合并。

这两个排序后的数组将被合并，作为一个排序后的数组返回。

最后但同样重要的是，我们将在这里合并。

这两个排序后的数组将被合并，作为一个排序后的数组返回。

别忘了我们最初对归并排序的调用。

这就是我们如何可视化递归合并排序。

但是您可能仍然想知道这个合并函数实际上在做什么。

如前所述，这个合并函数接受两个已经排序的数组，并将它们组合成一个排序的数组。

这个函数看起来像这样。

如你所见，merge 接受一个左数组和右数组，两个数组都排序了，然后它会返回这个结果数组，这个结果数组是左数组和右数组排序后的组合。

因此，为了理解合并存储的时间复杂性，我们将考虑一个数组和长度为 4 的数组。

所以这个输入数组将传递给合并排序函数。

对归并排序的调用将会把数组大致分成两半，这一半将被递归地传递给归并排序，此时，我们有了长度为 1 的数组。

所以我们不能再分裂这些射线了。

而要理解归并排序的时间复杂度，我们需要理解，哦，登录。

我们知道，在计算机科学中，log in 和 log 是一样的，以 2 为底，在这种情况下，in 是数组的长度，也就是 4。

所以你需要理解登录的原因，是因为我们在这里实现的这种分而治之的方法就是登录。

也就是说，以 2 为底的对数是 4，也就是我们的 n 等于 2。

这是因为 2 的 2 次方等于 4，这意味着对于长度为 4 的数组，我们的递归树结构有两层。

我们可以看到，这里有第一级，我们有第二级。

所以这是一个水平，这是一个水平。

对于每一层，我们需要做的是接触 n 的每一个元素，因为我们需要对它们进行排序。

为了对它们进行排序，如果你还记得我们的 merge 的例子，在这个 merge 函数中，这个 merge 函数中的 while 循环，需要接触每个元素来比较元素并创建合并的数组。

这意味着对于每一层，我们都需要合并。

而这个归并函数需要触及 n 的每一个元素。

这意味着每一层实际上都是。

并且有 log n 个级别。

所以 n 次登录中的 O 实际上就是 4 的 O，因为 4 是我们的 in，in 代表 1234。

所以 4 是我们的 n 次对数，底数是 2，4。

正如我们在这里看到的，以 2 为底的对数，4 实际上是 4 的 2 倍。

所以数组中元素的数量，以及我们需要遍历的层次的数量，所以对于每一个层次，我们都需要接触数组中的元素，也就是 2 乘以 4。

这就是为什么 mergesort 的登录复杂度是 O/n。

因此，我们将从检查斐波那契数列的递归实现开始。

让我们想象一下，我们把数字 4 传递给我们的 fib 函数。

所以在这一点上，4 是 n 的值。

所以在我们调用这个函数之后，我们会在第一个 if 块结束。

如果 n 等于 0，这个 if 块返回 0，然后我们继续第二个 if 块，如果 n 等于 1，第二个 if 块返回 1。

所以一旦我们把数字 4 传入函数，我们会在第一个 if 块结束。

这两个 if 块都是基本情况，因为我们知道，对于递归函数，我们需要有一个基本情况，这样函数就不会继续调用自己，即使在我们完成之后。

所以我们把四传入我们的 fib 函数，四不等于零，所以不返回零，四不等于一，所以不返回一。

所以我们到了这里。

这个返回将两次调用 Fibonacci 函数的结果相加，第一次调用 Fibonacci 函数，我们用 n 减 1，也就是 4 减 1，第二次调用，我们用 n 减 2，也就是 4 减 2。

让我们来看看它是什么样子的。

正如我们所见，四减一等于三，所以这实际上是三。

这里也一样。

这就等于 2。

所以在这一点上，我们必须调用我们最喜欢的斐波那契函数。

一个我们传递 3 的是我们的 in，一个传递 2 的分子是我们的 in。

因此，对于这两个调用，都不会在这些 IP 块上返回。

所以我们会回到这里，看起来像这样。

再说一次，我们可以在括号里算算。

让我把它变小一点。

因此，在这一点上，对于这三个对斐波那契函数的调用，我们将达到我们的基本情况，因为我们为这个调用传递零。

我们会在这一点上返回 0。

我们为这两个调用传递一个。

我们将在这些点上返回一个。

所以这些将会是完整的。

这些做完了。

对于这个函数，我们要传递的是 n，它不等于零，而是等于一。

现在，我们将再次深入到这部分代码。

现在这两个也达到了我们的基本情况。

再来一次，我需要缩小这个。

所以现在我们将进入为什么这个递归斐波纳契函数是一个指数函数的原因。

首先，让我们从观察这个递归树结构开始。

正如我们看到的，这里，我们有一个，两个和三个层次的递归树结构。

所以我们可以写出一级，二级，三级。

对于第一级，我们调用了 fib 函数两次。

所以一，二，对于第二层，我们调用 fib 函数四次 1234。

在这一级，我们调用两次斐波那契函数，在这一级，我们调用四次斐波那契函数。

让我们暂时忽略这第三层。

让我们只关注这两个最高级别。

所以这里的 2 等于 2 的 1 次方，这里的 4 等于 2 的 2 次方。

如你所见，我们的指数与我们的能级相关。

因此，实际上，如果这三个函数对递归 Fibonacci 进行两次额外的调用，我们会得到类似这样的结果。

这里有两个调用，两个调用，两个调用。

所以我们就把这个写出来。

所以让我们想象这些也是递归斐波那契函数的额外成本。

让我们假设这是一秒钟的情况，这样我们可以更好地理解为什么这个函数是指数时间复杂度。

现在，如果我们计算第三层对递归 Fibonacci 函数的调用，记住这些调用实际上不会被调用，只会被调用。

但是我们只是把它写出来，这样我们可以更好地看到这里发生了什么。

因此，如果我们数出这些对斐波那契函数的调用，它将是 12345678。

所以在第三层我们有八个调用，八等于二的立方或者二的三次方。

正如你所看到的，我们的指数和我们的能级是一致的。

这意味着如果我们的 n 是 4，我们将深入三层。

在每一层，调用斐波那契函数的次数都呈指数增长。

但你可能会想，既然我们的 n 是 4，我们停在这里，当它是 2 的 3 次方，而不是 2 的 4 次方时，这怎么会导致这个函数一直到最后呢？嗯，其实挺简单的。

所以实际上，这个斐波那契函数是 2 的 O 的 n-1 次方。

如果我们把它写出来，你可以看到它是 O 的 2 的 4 次方减 1，这正好等于 O 的 2 的 3 次方，和第三层的调用次数一样，对吧。

如果你还记得，在 bego 中，我们忽略了常量。

所以如果实际上，这个函数是 O 的 2 的 n 次方减 1，我们忽略常数，这意味着我们要忽略这个减 1，这导致这个函数的时间复杂度是 O 的 2 的 n 次方。

在这一点上，你可能想知道我们如何在这里添加这些函数调用。

实际上，我在这里添加这些函数调用只是为了让你们更好地了解每一层发生了什么，以及为什么我们考虑将这个函数放到互联网上。

因为如果我们写出这些实际上没有调用的函数，会更容易想象。

我们可以做到这一点，因为对于 bego，正如我们所了解的，我们只寻找一个上限，就像我们不寻找一个紧界，我们不寻找非常具体的，我们只寻找你可以说是最坏情况的估计。

如你所见，在左边的函数中，我们调用 fib，然后从 n 中减去 1。

在右边这个，我们称之为 fib，然后从 n 中减去 2。

所以树的右边总是比左边短，总会有空白。

因为在树的右边，在每一层，我们都减去 2。

在树的上端，每一层，我们都减去一。

但是当我们考虑 bego 时，我们不需要担心这个。

不管我们把什么数传递给这个函数，在最底层，右边总会有一个缺口。

但是没关系，因为我们只是在寻找一个上界。

这些只是为了帮助你想象实际发生了什么，以及为什么这个函数被认为是指数增长的。

这就是为什么递归 Fibonacci 是指数时间复杂度，我希望这是有意义的。

我们从调用 f 的函数开始。

这个函数是一个递归函数。

所以代码的第一部分将是我们的基本案例。

如果传递给这个函数的 n 的值等于零，那么我们要打印这些星星。

然后我们会返回，但是如果我们传递一个值给 n，这个值不等于零，然后我们会到这个 for 循环。

那么我们先来举个例子。

假设我们把数字 3 传递给我们的函数，首先会发生的是，我们会检查在我们的例子中，3 是否等于 0，而不是。

然后我们继续这个 for 循环。

这个 for 循环要做的是，对于 in 的每次迭代，每次迭代，从 0 到 3，直到 3，这是我们的终点，我们要再次递归调用这个函数，这次用我们的 n-1。

所以让我们，让我们试着想象一下。

所以如果我们通过这个函数，在这个 for 循环中结束，我们可以这样写出来。

所以对于每个指数，一直到三，但不包括 3012。

我们只对每个索引 012 做的原因是因为在这里，I 从零开始，我们将迭代我们的输入值，直到 AI 不再小于 in。

所以一旦 I 等于 n，我们就停下来。

所以如果我是三岁，我们就不会再经历这个循环了。

这就是为什么是 012。

对于每一次迭代，012，我们将再次调用这个函数。

看起来会像这样。

如果你看这里，我们在 for 循环的每一次迭代中，从 in 中减去 1，传递给函数。

所以如果这里的 n 是 3，对于每一个，n 都等于 2，因为我们要为每一个减去 1。

所以这些实际上是 F2。

对于每一个函数，我们都要做和第一次调用这个函数一样的事情。

但是这一次，我们将只遍历索引 0 和 1。

所以这些都是对这个递归函数的单独调用。

每个都需要有自己的 for 循环，也就是 this，this in this。

所以在这一点上，f 是 2。

所以我们一直向上迭代，直到 I 不再小于 2。

所以我们要遍历索引 0 和 1，对于索引 0 和 1，我们要这样做，同样地调用递归函数，或者我们要这样做，同样地调用这个函数。

如果这里写得太小了，我很抱歉。

但是你会看到这个递归树很快变得很大。

所以我需要把它缩小一点。

这样我们可以有更多的空间。

所以对于其中的每一个，我们都要再次调用递归函数。

但是这一次，这个函数是用 2 减 1 来调用的，这意味着我们的 in 是 1。

实际上，让我们把它变小一点。

我再次道歉。

所以在这一点上，我们的 for each 对于索引 0 只发生一次。

伙计，这真是太小了。

好的，在这一点上，我们的 F 对于所有这些递归函数的调用都是 1，AI 从 0 开始。

只要 I 小于 n，也就是 1，我们就会执行这段代码。

只有当它为零时，它才会比 in 小，这是一次迭代。

所以对于递归函数的每一次调用，我们只会在第一次迭代中调用这个函数一次，也就是 0 次。

现在在这一点上，它将是 f ^ 1 减 1。

f ^ 1 减^ 1 实际上等于零。

所以会是 f 0。

所以我们要把零作为函数的输入。

因为它很小，所以看起来有点困难。

但是如果我们记住这里，在实际的函数中，我们的基本情况是，如果 n 等于零，那么我们只是去控制台日志，然后我们将返回。

所以对于递归函数的每一个调用，我们都要执行这个代码，这个控制台日志代码。

然后在我们执行这个控制台日志代码之后，我们将返回，所以它将结束，整个函数将结束，因为所有这些都将返回，它们将记录代码，然后它们将返回。

一旦所有这些都返回，整个函数将会完成，它将会终止。

因此，我们不用写出控制台日志，我们只需写下每个函数执行 log n。在日志之后，函数将返回。

所以会停下来。

所以最后一次，我需要把它变小一点。

好的，当这个函数完成时，我们剩下的是这个树形结构。

这个树形结构显示了，为了达到每个递归调用的基本情况，我们需要进行多少次递归调用。

如果你看这里，我会把它们圈起来，这样你可以看得更清楚。

如果你看这里，对于每个对函数的递归调用，我们必须执行这段代码，对于每个对函数的递归调用，我们必须执行这段代码。

所以在最后一层，我们的基本情况是，我们必须执行这段代码。

如果你数这些，你会看到这是 123456。

所以我们需要执行这个代码六次，将三个传递给我们的函数，导致我们需要调用这个函数的最后一个递归调用六次，并执行这个代码六次。

数字 6 是我们理解阶乘时间复杂度的关键，因为如果你看这里，我们有 3 个阶乘。

原因是因为我们的 n 是 3，对吗？所以我们只是代入所有三个阶乘右因子和三个因子。

马里奥实际上是 6，因为要得到一个数的阶乘，你只需将每个数相乘，直到得到那个数。

如果我们把 1 乘以 2，我们会得到 2。

如果我们把这个数乘以 3，就是 6。

同样，我们需要执行这个控制台日志代码，我们需要执行 123456 次。

如果我们再深入一点，我们会看到三阶乘是将每个数字相乘到 3 的结果，这也等同于将每个数字从 3 相乘到 1，如果我们观察它在我们的树结构中的进展，就可以看到这一点。

在这里，我们可以看到前三个是通过了。

所以前三个通过了。

然后三下二过三遍。

所以乘以三乘以二是最好的。

而三乘二的结果是六，六乘六乘一就过去了。

所以 6 乘以 123456 乘以 1 就过去了。

所以这个 for 循环首先传递到三次，所以传递到三次 123，和 333 一样，乘以二，三次 123，传递二。

当我们要求函数，我们做两次迭代，所以三次两次迭代。

所以我们要这样做，我们要在这个 for 循环中迭代两次，三乘以三乘以二，然后三乘以二等于六，因为我们对这三个中的每一个都做了两次迭代。

所以这个，这些迭代加上这些迭代，加上这些迭代等于六次迭代。

对于这六次迭代中的每一次，我们都要传递一个给函数，所以六次迭代，所以六次都会传递一个给函数。

这就是，6 乘以 1，6 乘以 1，这就是阶乘时间复杂度。

我希望这有意义。

为了理解空间复杂性，我们将考虑这个函数。

这是一个递归函数，基本上只是返回一个调用，它的输入是-1，它会一直这样，直到我们到达 n 等于 0 的基本情况，然后它会返回，到那时，这个函数就完成了。

让我们继续，画出这个函数的执行过程。

假设我们把数字 5 传递给了这个倒计时函数。

所以在第一次调用第五个参数倒数时，我们会在这个基本情况下结束。

我们会发现 n ^ 5 不等于零。

所以我们继续这部分代码，用 5 减 1 再次调用这个函数。

当然，五减一等于四。

再一次，我们会在这里结束，我们会用 4 减 1 再次调用这个函数。

我们将继续这样做，直到我们把零作为函数的终点。

我需要把这个弄小一点。

最后，我们到了调用，我们把零作为我们的传递到函数中。

此时，如果 n 等于零，函数将返回。

所以要理解空间复杂性，其实挺简单的。

因为这是一个递归函数，所以这些调用中的每一个都同时存在于调用栈中。

这意味着，如果我们用 5 调用我们的倒计时函数，它会用 4 调用它自己，此时，这个初始调用仍然存在于调用栈中。

当我们数到三的时候也是一样。

这两个调用仍然存在于调用堆栈中，并且一直向下，直到我们到达我们的基本情况。

这些调用中的每一个仍然存在于调用堆栈中。

每个调用都要占用内存。

所以堆栈中的每一个调用都会占用内存。

这就是我们如何理解空间复杂性的，以这个递归函数为例，因为如果我们在这一点返回，当我们到达我们的基本情况时，这意味着我们有 123455 个调用占用了我们调用栈的空间，而 5 恰好是 n 的值。

这意味着这个函数的空间复杂度是 O/n。

所以这个函数的空间复杂度是 obon。

因此，这里要记住的最重要的事情是，所有这些递归调用同时存在于调用堆栈中。

它们中的每一个都占用内存，这就是为什么，如果我们有，如果我们传入五个，两个作为我们的 n，我们将有五个调用同时存在于内存中，这意味着我们的空间复杂度将结束，然后它将与输入的大小成线性比例。

因此，如果我们增加这个输入的大小，执行这个函数所需的空间将与这个输入的大小成比例。

现在我们对空间复杂性有了一个了解，我们可以进入一些人们在玩宾果游戏时会犯的常见错误。

第一个是，当你第一次使用 Viggo 时，你可能会看到一个函数，看起来像这样，有两个 for 循环。

你可能会本能地认为这个函数的时间复杂度是，因为这里有两个 for 循环。

所以那一定意味着在广场上观察。

但实际上，正如我们所学的，n 的平方的 O 实际上意味着对于每一次迭代，直到我们的输入大小，我们将通过一个额外的 for 循环一直迭代到我们的输入大小。

这意味着什么，如果我们有两个 for 循环，它们不是嵌套的，也不在 square 中，这其实很简单。

这里有一个 for 循环，这里还有一个 for 循环。

我们已经知道，这个 for 循环的时间复杂度是 O/n。

这个也是 n 的 O。

所以这一点，我们需要所有的事件，所以这可以很容易地转化为，o，of，two，in，也就是所有的两个时间，所以我们有所有的两个时间。

但是如果我们记得以前的课程，我们会忽略常数。

在这种情况下，乘以 2，2 只是一个常数。

所以我们实际上可以去掉这个常数，在这种情况下，这就结束了。

但是这里有一件重要的事情我们需要认识到。

这都是因为我们在这四个循环中迭代相同的输入。

因此，只要我们的循环作用于相同的输入，那么这将是结果的复杂性。

但是实际上还有另一个常见的错误，人们在考虑时间复杂性时会犯，这和这个错误有点关系。

这个常见的错误是函数有两个独立的输入。

所以让我们先把这两个输入相加函数考虑进去。

如果你还记得上一个例子，我们只有一个输入，只有一个输入，是 a，两个 for 循环通过同一个输入。

但是对于这个，你可以看到我们有两个独立的输入。

所以我们有一个输入 a，它在上面四个循环中循环。

我们有一个输入 B，它在第二个 for 循环中循环。

有些人可能会错误地认为这和最后一种情况一样，结果是 0 或 2。

但这其实是不对的。

因为在这种特殊情况下，我们无法知道这两个输入的大小差异，就像我们只知道这是两个独立的输入。

因此，这两个独立的输入可以是完全不同的大小，也可以是相同的大小。

但从我们的分析角度来看，我们不知道。

在这种情况下，当我们有两个输入，并且每个输入都有一个单独的 for 循环时，我们需要跟踪这两个输入。

在这种情况下，遍历这两个 for 循环所需的时间是 O/A+B，因为我们需要先遍历这一个，直到达到 A 的值，然后再遍历这一个，直到达到 B 的 V 的值，在这一点上，不能再简化了，我们需要承认这两个输入都是独立的输入。

所以这将超过 a 加 b。

这里我们有类似的情况，我们有两个输入，但这次四个循环是嵌套的。

很多人会错误地说，这个函数看起来是 n 的 O 次方。

但这实际上也是错误的，因为 n 平方的 O 在 n 平方上意味着什么，这意味着对于一个输入的每一次迭代，我们都将遍历相同的输入。

但在这种情况下，当我们有一个时，我们有两个独立的输入。

对于其中一个输入的每次迭代，我们都要遍历另一个输入。

这意味着，这是错误的。

实际上，它是 o 乘以 V，因为我们需要再次指定这是两个不同的输入。

并且这些输入可以是不同的大小。

当我们考虑到我们的复杂性时，我们需要让这一点变得明显。

这就是空间的复杂性，也是人们在大 O 符号上经常犯的一些错误。

我希望这是有意义的。