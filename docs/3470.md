# 最终 Node.js 生产清单

> 原文：<https://www.freecodecamp.org/news/node-js-production-checklist/>

你在生产中做得对吗？让我们看看人们在生产中运行 Node 时会犯的一些常见错误(直接来自我自己的项目——比如 [codedamn](https://codedamn.com) )以及如何减轻它们。

当您部署节点应用程序时，您可以将此作为您的生产清单。因为这是一篇*生产就绪实践*的文章，所以当你在本地系统上开发应用程序时，它们中的很多都不适用。

## 以集群模式运行节点/独立节点进程

请记住，节点是单线程的。它可以将许多事情(如 HTTP 请求和文件系统读/写)委托给操作系统，由操作系统在多线程环境中处理。但是，你写的代码，应用程序逻辑，总是在一个线程中运行。

通过在单线程中运行，您的节点进程总是被限制在机器上的一个内核中。因此，如果您有一台多核服务器，那么在服务器上只运行一次 Node 就是在浪费计算能力。

“只运行一次节点”是什么意思？你看，操作系统有一个内置的调度程序，它负责如何在机器的 CPU 之间分配进程的执行。当您在一台双核计算机上仅运行两个进程时，操作系统会决定最好在不同的内核上运行这两个进程，以获得最高性能。

Node 也需要做类似的事情。此时，您有两种选择:

1.  **以集群模式运行节点-** 集群模式是一种内置于节点本身的架构。简而言之，Node 派生更多自己的进程，并通过单个主进程分配负载。
2.  **独立运行节点流程-** 这个选项与上面的略有不同，因为您现在没有控制子节点流程的主流程。这意味着当您产生不同的节点进程时，它们将彼此完全独立地运行。没有共享内存，没有 IPC，没有通信，什么都没有。

根据 [stackoverflow 的回答](https://stackoverflow.com/a/47122606/2513722)，后者(第 2 点)比前者(第 1 点)表现得好得多，但设置起来有点棘手。

为什么？因为在节点应用程序中，不仅有应用程序逻辑，而且几乎总是当你在节点代码中设置服务器时，你需要绑定端口。单个应用程序代码库不能在同一个操作系统上两次绑定同一个端口。

然而，这个问题很容易解决。环境变量、Docker 容器、NGiNX 前端代理等等都是这方面的解决方案。

## 限制端点的速率

让我们面对现实吧。并不是世界上的每个人都对你的建筑有好的意图。当然，像 DDoS 这样的攻击很难防范，甚至像 GitHub 这样的巨头在这种情况下也会倒下。

但是，您至少可以防止脚本小子破坏您的服务器，因为您的服务器暴露了一个昂贵的 API 端点，而没有任何速率限制。

如果您使用 Express with Node，有两个漂亮的包可以无缝地一起工作，对第 7 层上的流量进行速率限制:

1.  快速限速-[https://www.npmjs.com/package/express-rate-limit](https://www.npmjs.com/package/express-rate-limit)
2.  快车减速-[https://www.npmjs.com/package/express-slow-down](https://www.npmjs.com/package/express-slow-down)

快速减速实际上增加了请求的延迟，而不是丢弃它们。这种方式合法用户，如果他们不小心 DDoS(点击这里和那里的按钮的超级活动)，简单地被减慢并且没有速率限制。

另一方面，如果有一个脚本小子运行脚本来关闭服务器，Express rate limiter 会根据用户 IP、用户帐户或您想要的任何内容来监控和限制特定用户的速率。

速率限制可能(应该！)也通过 IP 地址应用于第 4 层(第 4 层意味着在发现它的内容之前阻止流量- HTTP)。如果您愿意，您可以设置一个 NGiNX 规则来阻止第 4 层的流量，并拒绝来自单个 IP 的大量流量，从而避免您的服务器进程不堪重负。

## 使用前端服务器进行 SSL 终止

Node 使用与所需 SSL 证书相结合的`https`服务器模块，为浏览器提供现成的 SSL 握手支持。

但是老实说，无论如何，您的应用程序首先不应该关心 SSL。这不是应用程序逻辑应该做的事情。您的节点代码应该只负责处理请求，而不是对进出服务器的数据进行预处理和后处理。

SSL 终止是指将流量从 HTTPS 转换为 HTTP。在这方面，有比 Node 更好的工具。我为它推荐 NGiNX 或者 HAProxy。两者都有免费版本，可以完成工作并从节点卸载 SSL 终端。

## 使用前端服务器进行静态文件服务

同样，不要使用像`express.static`这样的内置方法来服务静态文件，而是使用像 NGiNX 这样的前端反向代理服务器来服务来自磁盘的静态文件。

首先，NGiNX 可以比 Node 更快地做到这一点(因为它是从零开始构建的，只能做到这一点)。但它也从单线程节点进程卸载文件服务，该进程可以将其时钟周期用于更好的事情。

不仅如此，像 NGiNX 这样的前端代理服务器还可以帮助您使用 GZIP 压缩技术更快地交付内容。您还可以设置到期头、缓存数据等等，这不是我们希望 Node 做的事情(但是，Node 仍然可以做到)。

## 配置错误处理

适当的错误处理可以让你从数小时的调试和试图重现困难的错误中解脱出来。在服务器上，建立错误处理的架构特别容易，因为您是运行它的人。我推荐像 Node 的 [Sentry](https://sentry.io) 这样的工具，当服务器由于源代码错误而崩溃时，它会记录、报告并向您发送电子邮件。

一旦设置好，现在是时候在服务器崩溃时重启服务器了，这样整个网站就不会停机几个小时，直到你手动重新启动它。

为此，你可以使用像 PM2 和 T2 这样的流程管理器。或者更好的是，使用 dockerized 容器环境，使用类似于`restart: always`的策略，并设置适当的内存和磁盘限制。

Docker 设置确保即使您的容器在 OME 运行，进程也会再次加速(这在 PM2 环境中可能不会发生，因为如果正在运行的进程中某处出现内存泄漏，操作系统可能会杀死 PM2)。

## 正确配置日志

所有的答案都在日志里。服务器黑客攻击、服务器崩溃、可疑用户行为等。为此，您必须确保:

1.  每一次请求尝试都记录了 IP 地址/请求方法/访问路径，基本上记录了尽可能多的信息(当然，密码和信用卡信息等私人信息除外)
2.  这可以通过摩根的一揽子计划来实现
3.  在生产中设置**文件流日志**,而不是控制台输出。这更快，更容易看到，并允许您将日志导出到在线日志查看服务。
4.  并非所有日志消息都具有相同的权重。有些日志只是为了调试，而如果有些日志存在，这可能表明情况不妙(如服务器黑客攻击或未经授权的访问)。使用 winston-logger 记录不同级别的日志。
5.  设置**日志轮换**，这样当你看到服务器时，你不会在一个月左右后得到以 GBs 为单位的日志大小。
6.  **GZIP** 旋转后你的日志文件。文本是廉价的，高度可压缩的，易于存储。只要文本日志是压缩的，并且您运行的服务器有足够的磁盘空间(25GB 以上)，您就不会遇到文本日志的问题。

## 结论

很容易注意到生产中的一些实践，这些实践可以节省您以后的眼泪和调试时间。确保你遵循了这些最佳实践，并通过在我的 [twitter 账号](https://twitter.com/mehulmpt)上打招呼让我知道你的想法。

如果你喜欢这篇文章，让我们在社交媒体上见面。这是我的 [Instagram](https://instagram.com/mehulmpt) 和 [Twitter](https://twitter.com/mehulmpt) 。我非常活跃，很想和你聊聊天！我们来连线。

和平！
Mehul