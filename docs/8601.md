# 如何用 Redux-saga 和 ReactDnD 测试 React 和 Redux(咻！)

> 原文：<https://www.freecodecamp.org/news/testing-react-and-redux-with-redux-saga-and-reactdnd-whew-dedebcbd78dd/>

格雷戈里·比弗

# 如何用 Redux-saga 和 ReactDnD 测试 React 和 Redux(咻！)

#### 使测试更容易的助手和系统

![mDoghGWaZYvcTbg5qiDXP6Z1zxDvskf0NsqS](img/8424c8a92224cba182e1e8ec55b65ecb.png)

这篇文章是我希望在我开始使用 React 的所有花哨功能编码之前就已经找到的文章。

我目前正在为一个夏季音乐项目开发一个复杂的离线优先最终一致的日程安排应用程序，以取代多年前用 Objective C 编写的 Mac 应用程序。

该应用程序使用:

*   [Express](http://expressjs.com/) 中的 Node.js 后端，数据存储在浏览器中的 [CouchDB](http://couchdb.apache.org/) 和 [PouchDB](https://pouchdb.com/) 中，以保持会话之间的状态并管理复制和冲突，而[在前端用](https://facebook.github.io/react/) [Redux](http://redux.js.org/) 反应，用 [Redux-saga](https://redux-saga.github.io/redux-saga/) 管理异步事件，并使用[反应-DnD](https://react-dnd.github.io/react-dnd/) 增加一些拖放的乐趣。它也是一个测试驱动的应用程序，具有 100%的测试覆盖率，目前 591 行源代码与 7040 行测试代码的比率。

我学到的关于避免脆弱的测试、过度依赖的测试以及在一次测试中只测试一件事情的经验总结在这篇文章中。

首先:本文假设你将使用 [babel](https://babeljs.io/) 来传输 es6，或者直接在前沿浏览器中使用它。如果你需要了解这一点，有很多很多很棒的资源可以教你如何用 [webpack](https://webpack.github.io/) 或其他捆绑器来设置 babel，为你的应用服务。本文**仅**关注如何在您的环境启动并运行后进行测试。

### TL；速度三角形定位法(dead reckoning)

在[https://github.com/cellog/testHelper](https://github.com/cellog/testHelper)检查来源

但是你会想看这个的！

### 这东西有什么关系？

故事时间！我在很多年前就开始编写代码，并且已经看到了许多趋势的变化。80 年代和 90 年代的面向对象热潮革新了代码分离，但是导致了不可维护的代码。当我在 90 年代早期(短暂地)学习计算机科学时，它有点像狂野的西部。他们给我们出难题，我们一直黑到成功。大部分是。除了运行您的程序并将输出与预期输出进行比较之外，没有其他方法可以验证系统。朋友聚会。你明白了。

在 90 年代后期，极限编程成为一件事，突然有了测试框架可以使用。快进近 20 年，我们已经有了成熟的、可扩展的、快速的框架，具有真正的代码隔离，因此我们可以在没有副作用的情况下进行测试，也可以使用让测试变得简单的语言，比如我们的朋友 Javascript。

这些年来，我花了相当多的精力尝试不同的开发策略。大多数时候，我设计代码，然后在确定设计足够合理时编写测试。这很好，除了当它不好的时候，当它不好的时候，它就是一场灾难。我会发现代码实际上是不可测试的。

一个很好的例子是我用 [Meteor](https://www.meteor.com/) 编写的一个网站。Meteor 太神奇了，它让我在一个半月的时间里，从 0 到 60 岁，拥有一个可以工作的复杂网站。这是如此简单，测试甚至似乎没有必要。然而，我在 MongoDB 的构建方式上遇到了一个微妙的错误，现在我发现了另外 2 到 3 个错误，如果不从头开始重写，我真的无法修复它们。当 Meteor 引入测试时，它是专门针对 Meteor 的，并且不容易在多个浏览器中运行测试，并且如果没有 wallaby.js 的巨大块，它根本不支持 wallaby，这将需要它自己的单元测试来确保它的工作。当我试图解决这个问题时，我真的被噩梦惊醒了。

所以对于这个项目，我决定从一开始就编写测试，尝试测试驱动的设计。我发现，首先编写测试会导致设计从一开始就发生变化，我的代码变得更简单。当代码变得太复杂时，我开始产生直觉怀疑，当测试变得困难或复杂时，我开始清除整片代码，然后从头开始，用一半的时间找到更好的解决方案。这里有一个问题:开发速度比我以前习惯的速度慢了 4 倍。然而，我并不担心细微的 bug 爬进来。我不担心整体设计很脆。自信的感觉令人振奋，让我有时间去梦想解决方案，而不是去灭火。

此外，我经常进行重构，因为我对我正在设计的系统了解得更多，并且发现了关于我正在使用的库和数据库实际上如何工作或者我的设计选择实际上如何工作的微妙的错误假设。我发现自己经常删除和修改代码。因为我经常删除和移动东西，并且我的测试的代码行比实际代码行长 14 倍，为了以合理的速度开发，测试需要像外科手术一样设计，以避免任何微小的变化。我是吃了苦头才知道的。

我的大多数早期测试都微妙地依赖于设计选择，坦白地说，这对那个测试并不重要。当我进行重构的时候，我会发现自己要检查并复制/粘贴 20 个或更多的测试。因此，我坐下来研究从测试中移除任何依赖性的方法，并最终完成了本文描述的系统。

每个测试只测试一件事，通常只是一行代码，除了编译错误或其他容易修复的错误，对被测试组件的任何其他方面的更改都不会导致测试失败。我希望我早期的错误能帮助你避免它们。记住这一点，让我们开始吧！

### 出发

让我们首先列出我们将要使用的工具，以及在哪里可以找到它们。

这是我们需要的进口商品清单:

我们将使用 React、Redux 的标准导入，React 和 Redux 之间的绑定，以及 React-DnD 及其测试后端的上下文。先说茶匙。

茶匙是 Jason Quense 的一个杰出创造，它允许使用类似 jQuery 的接口测试 React 组件，就像它们是 HTML 一样。它允许测试特定的属性是否被传递，很容易用模拟数据触发事件，也很容易设置 React 组件的属性或状态。太美了。去看看文件。15 分钟后见。

![prYklFTuJoGSSwOdMl-lc0ioWc4BhKOG3aYL](img/3edec1a4b43e5859db48d58468462294.png)

Isn’t google image search for free images fun?

### 从头开始构建测试助手

欢迎回来！

下一步是构建基本的组件测试接口。我们首先需要做的是设置组件呈现代码。我已经试验了茶匙的浅渲染和深渲染，并得出结论，永远没有一个好的理由来使用浅渲染。

浅层渲染的主要问题是，在一周内，你会忘记在重构时使用了浅层渲染，你的测试会无缘无故地中断，迫使你浪费 15 分钟试图找出原因，直到你意识到你所要做的就是打开深度渲染，测试就会通过。

因此，我们从一个简单的 renderComponent 函数开始，我们将使用它来呈现任何 React 组件，并将它包装在茶匙中，以便我们可以测试它:

这段代码接受 React 组件类或函数，并传入 props 中指定的任何属性。简单。

接下来，我们需要连接 Redux，以便处理状态:

现在，我们可以编写测试来确保在组件中使用属性:

关于如何编写有效测试的更多信息，请稍后讨论。现在，让我们继续下一个问题。

很快，您将需要测试更改属性。不幸的是，这很难做到，因为渲染是异步的，而测试本质上是同步的。幸运的是，有一种方法可以强制渲染同步。不要太详细地解释为什么，使用一个更高阶的组件来包装你的组件类，并使用本地的 React 状态来设置属性将会强制重新渲染，这样我们就可以测试属性改变的效果。下面是新的 renderComponent:

接下来，我们需要考虑如何测试容器组件。根据我的经验，尝试以几乎相同的方式测试内部 React 类 HTML 输出很有诱惑力，但是测试容器实际做什么更容易维护。容器类有一个任务:将 redux 状态转换成 react 组件属性。

使用茶匙，您实际上可以验证容器获取了一部分状态，并可靠地创建了内部 React 组件所期望的组件名称和值，而不需要了解容器测试中 React 组件的内部情况。

这个事实最显著的例外是我们也需要测试动作。为了做到这一点，最好是测试在调度操作时预期的状态变化，或者检查操作是否已发送。

为了测试状态，我们需要在动作被触发后访问状态，我们可以通过使用 redux store 的 getState()方法来完成。因此，如果需要的话，我们需要退回商店。

解耦程度最高的方法是检查是否发送了正确的动作。要做到这一点，我们需要创建一个 redux 中间件，简单地将所有动作记录到一个数组中，然后用这个数组来检查发送的动作。让我们修改 renderComponent，使这两种场景成为可能:

如何使用这个更高级的功能的问题将在本文的后半部分解决，在那里我将描述如何使用这个助手来编写有效和有限的测试。

测试助手的最后一部分非常简单，只是增加了对 React-DnD 的支持。我们所需要的是用测试后端将所有东西包装在 DragDropContext 中:

现在，我们可以使用 React-DnD 文档中记录的`Draggable.getManager()`和`Draggable.getManager().getBackend()`访问可拖动管理器和后端。注意，为了访问 getManager()，需要使用`.prototype`。

在这个阶段，我们准备探索如何有效地使用这个测试助手。

### 使用助手编写优秀的测试

我如何编写测试有几个关键原则:

1.  不要重复任何事情
2.  使用巧妙的样板
3.  分别测试属性和操作

下面是一个被测试组件的例子，它既有属性又有动作。该示例使用 [sinon](http://sinonjs.org/) 进行回调测试:

请注意，如果您想要测试更改属性，以便测试诸如 shouldComponentUpdate 之类的生命周期方法，您应该使用茶匙的 [props()](https://github.com/jquense/teaspoon#fnprops) 方法。测试本地状态变化的 [state()](https://github.com/jquense/teaspoon#fnstate) 也是如此。

上面的测试使用了一些统一的想法:

1.  甚至 renderComponent()也被抽象成 2 个新方法，一个用于测试属性(render)，一个用于测试动作(make)。
2.  指定了一组通用的默认属性，这样任何测试都不会有 React 警告，允许每个测试关注一个单独的属性(恰当地命名为“generic”))
3.  除了确保基本搭建存在之外，没有直接测试可视属性/css/html
4.  测试的重点是确保组件的外部输入是正确的。每个属性都要测试，每个动作都要测试。
5.  CSS/HTML 仅用于定位属性在组件的虚拟 DOM 中的位置

接下来，我们将把这些想法扩展到测试连接的 react-redux 容器。

### 测试冗余连接的容器组件

redux 组件做的最重要的事情是将状态转换成属性，将回调转换成 redux 动作。使用我们创建的 renderComponent，我们可以很容易地对此进行测试:

在这里，我们可以专门测试我们的连接容器正在将状态转换成我们期望的属性，并且正在分派我们期望的动作。在我早期的大多数测试中，我会检查以确保动作修改了状态(doSomething 测试中的第二个方法)，但是这实际上重复了确保你的 reducers 正在减少的工作。因此，如果您重构一个 reducer，您必须为一个连接的容器更新每个测试。这可能会降低重构的速度。

取而代之的是，检查哪些动作被分派是与 reducer 完全分离的，只是简单地验证连接组件的契约。

解耦也有缺点，因为对缩减器的更改可能会对容器产生多种副作用。如果你意识到了这一点，那么你很好。在一个多开发人员的商店中，或者当您在几个月后患上健忘症时，您可能希望在进行更改时，与缩减器相关的所有东西都失败。

### 测试 redux-saga 操作处理程序

如果你想测试一个 redux-saga 生成器，在 redux-saga 网站上有非常详细的文档。如果你觉得这太令人困惑，想要一篇关于我是如何做到的(或者为什么我选择 redux-saga)的文章，请在评论中回复。

在这个需要 redux-saga 的应用程序中，我遇到的一种模式是将单个动作变成多个动作。在我的调度应用程序中，这个用例是我编写的侦听器，用于在记录被客户端更改时更新 CouchDB 实例。为了在记录独立在线更新时实现适当的冲突检测，每个记录需要具有相同的 id。因此，基于孩子可以演奏的作品的作曲家的名字来生成唯一的 id。当一个作曲者的名字被更新时，该作曲者的每个使用实例也必须被更新。因此，一个动作产生许多新的动作。由于数据库中可能会有遗漏的操作和不一致的状态，我编写了一个 saga 来监听修改操作，然后发出许多新的操作来进行所需的更改。

因此，当点击 save 按钮时，会发出一个不被任何 reducer 处理的动作。相反，它被传奇截取，并转化为许多需要的个人行动。它还更新数据库。

这本来可以用中间件实现，但是 redux-saga 使得处理所有的异步工作变得如此容易，当几行代码可以做同样的工作并且更容易测试时，重新发明轮子是没有意义的。我们如何测试这个？我们可以在测试助手中为动作设置一个模拟 redux-saga 监听器，但是在我们测试状态以确保它被修改之前，我们要等待多长时间来完成 saga？我们如何防止传奇实际上试图修改数据库？噩梦随之而来！

长话短说:在这种情况下，我们需要验证的只是连接的组件正在调度将被 redux-saga 拦截的动作。一个单独的测试可以用来验证传奇本身的正确性。一旦证实了这一点，我们就可以肯定行动会奏效。

因此，我们可以使用我们在测试助手中创建的日志中间件来查看我们想要发送的动作是否真的被发送了。轻松点。

### 测试反应-DnD

react——DnD 需要一个没有错误的拖放上下文，即使你在测试中没有做任何拖放操作。如果您已经包装了任何组件，您仍然希望能够测试该组件的基本功能，我们的测试助手使这成为可能。您可以使用我们的测试助手测试基本功能，忽略拖放，然后在一个单独的测试中使用 React-DnD 文档中列出的方法测试拖放。非常容易！

我发现的唯一问题是，如何模仿拖放并不直观，文档充其量也是参差不齐的。这是我真实项目中的一个样本测试，展示了如何测试拖放交互。注意，所讨论的组件是哑组件，属性`book`和`clear`是由 redux-connected 容器组件提供的回调。为了更清楚，我将包括容器，即使它实际上没有被这些测试测试过。还要注意 helper 函数的创建，它直接从组件中提取 sourceId 和 targetId，定义为 Slot.test.js 中的`source`和`target`函数

### 我使用的工具拯救了我的编程生涯

如果你还没有投资 wallaby.js 或 WebStorm，那你就错过了。拥有即时的测试结果，即时的测试覆盖逐行可见，以及你与 karma 的持续集成是天赐之物。我在 BrowserStack 上使用 karma 来验证代码在移动和桌面浏览器中没有中断，并使用 wallaby 来快速验证我的代码在提交前工作并被覆盖。

以下是我在项目中使用的 wallaby.js 示例，在测试中支持 CSS 模块:

此外，如果你没有使用[反应-故事书](https://getstorybook.io/)，你就错过了。这是开发你的应用程序的视觉外观的最好方法，并保证它会工作。它将手动测试系统化，这是任何成功应用程序的最后一个要素，最近的版本甚至可以自动化测试，尽管我个人没有使用过。

### 结论

有许多不同的测试方法。如果您正在 react-redux 中开发一个复杂的应用程序，您将需要仔细研究如何解耦您的组件，以便可以轻松地测试它们。幸运的是，有了这个简单的测试助手和测试设计原则，测试就变得容易了，而且您可以在对不相关的测试产生有限副作用的情况下进行重构，使得开发变得快速，更改变得容易。

编码快乐！如果你有我没有提到的其他系统，请留下评论，我总是在寻找新的想法。此外，如果我说的东西不清楚或不完整，请询问，我很乐意尝试澄清。

如果你喜欢这篇文章，也可以点击那个漂亮的心形按钮！