# 用 OpenGL 创建复杂图形

> 原文：<https://www.freecodecamp.org/news/create-complex-graphics-with-opengl/>

OpenGL 可用于创建复杂的 2D 和 3D 图形效果。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个高级 OpenGL 课程。

维克多·戈丹创立了这门课程。在这个课程之前，他创建了 YouTube 上最流行的 OpenGL 课程之一。现在，他将帮助你把你的技能提高到一个新的水平。

以下是本课程涵盖的主题:

*   深度缓冲器
*   模具缓冲区
*   人脸剔除
*   透明度和 Bl
*   帧缓冲区
*   立方体贴图和天空盒
*   几何阴影
*   举例说明
*   抗锯齿

观看以下课程或 freeCodeCamp.org YouTube 频道上的[(1 小时观看)。](https://youtu.be/GJFHqK_-ARA)

[https://www.youtube.com/embed/GJFHqK_-ARA?feature=oembed](https://www.youtube.com/embed/GJFHqK_-ARA?feature=oembed)

## 副本

OpenGl 可以用来创建复杂的图形效果。维克多戈丹的高级 OpenGL 课程将把你的技能提升到一个新的水平。

大家好！在本课程中，我将教你 OpenGL 中不同的高级主题，它们将帮助你实现更复杂的效果、更好的渲染和更优化的场景。如果你不知道什么是 OpenGL 或者对它不熟悉，那么你应该先看这个频道上的 OpenGL 初学者课程。这应该就是你需要知道的关于这门课程的全部内容，享受吧！

在本教程中，我们将看看 OpenGL 中的深度缓冲区，并看看我们如何利用它们来获得一点图形效果。

你可能还记得，我们已经在“走向 3D”教程中使用了深度缓冲来解决我们遇到的一个奇怪的问题。由于默认情况下缓冲区是关闭的，我们希望确保启用它，并像清除颜色缓冲区一样清除每一帧。这个缓冲区的基本功能是存储“深度”值，这些值表示某个片段离投影矩阵的近平面有多远。深度值为 0 表示它在近平面上，深度值为 1 表示它在远平面上。

使用这个深度信息，我们可以评估哪个物体应该在哪个物体的前面。我们可以通过使用 glDepthFunc 并插入以下输入之一来实现这一点。默认情况下，OpenGL 选择 GL_LESS，这意味着如果一个对象的深度值小于当前深度值，那么第一个值将替换第二个值。在大多数情况下，你应该使用 GL_LESS，但是我想如果你想让你的游戏或应用程序变得令人眼花缭乱，你也可以选择其他的。

现在是最酷的部分。让我们想象一下深度缓冲。我们可以很容易地做到这一点，转到片段着色器，输出 gl_FragCoord.z 作为片段颜色。问题是，一旦我们按下 run，你会发现屏幕几乎是纯白的。看到一点黑暗的唯一方法是非常靠近一个物体。这是因为 OpenGL 中的深度不是线性的。如果深度是线性的，那么近距离的深度精度和远距离的深度精度是一样的。因为我们几乎总是聚焦在离我们很近的东西上，所以我们想让精度在离我们很近的地方很高，在离我们很远的地方很低。这是通过使用这个公式实现的。别担心，我们不需要实现它，因为 OpenGL 是自动完成的。

但是，有时您想要使用另一个公式，因此为了做到这一点，我们必须首先通过线性化深度函数来获得 z 值，这可以使用此函数来完成。现在使用这个函数，我们得到了 z 值，请记住，这不是标准化的。这个值就是离近平面的距离。因此，让我们声明我们的平截头体的近常数和远常数，并用线性深度除以远长度来快速归一化它，看看结果是什么样的。现在让我们来看看你能得到的一个快速的问题，然后我将向你展示我们用深度缓冲器能达到的酷的效果。

因此，深度缓冲区产生的主要问题被称为 Z-fighting，它的发生是因为两个或更多的三角形具有相同的深度缓冲区，因此深度函数无法确定哪个比另一个更近，因此它会在它们之间不断变化。解决这个问题的一个简单方法通常是确保三角形之间不要太靠近或者太平行。如果 Z-fighting 出现在一个很远的距离，那么你也可以考虑调整深度缓冲的功能，以便在那个距离上有更高的精度。最后一个技巧是为深度缓冲区使用一个更大的整数。通常默认使用 24 位，但是如果你的卡支持的话，你可以把它改成 32 位。这将增加精度，从而减少 Z 形战斗的变化。

现在是酷酷的效果。我们可以将 z 值代入一个逻辑函数，该函数有一个陡度参数和一个偏移参数。陡度将控制深度值从接近 0 到接近 1 的变化速度，而偏移将决定这种变化的中途 z 值。这个很酷的一点是，如果你想要的话，它可以给你平截头体末端平滑的边缘，但是更好的一点是，它可以模拟雾的效果。因此，让我们改变我们的背景颜色为灰色，并使用我们的函数计算深度值。然后用我们通常的 direcLight()乘以深度值的倒数，再加上深度值乘以之前的灰色。现在我们应该有一个漂亮的简单的雾效果。请记住，您可能需要调整陡度和偏移一点，以获得刚刚好。

尽情体验不同的效果吧！

在本教程中，我们将看看模板缓冲区，以及我们如何使用它来创建有用的效果，如概述了一个模型。

因此，模板缓冲区，就像深度缓冲区一样，为你看到的每个像素保存一个值，这些值通常用于图像遮罩。与深度缓冲区不同，深度缓冲区中每个像素保存 2 到 4 个字节的数据，而模板缓冲区中每个像素只保存 1 个字节的数据，因此值从 0 到 255。但是你将主要只使用 0 和 1 的值。

让我们看看如何使用这个新的缓冲器。首先，我们有一个函数 glStencilMask，它允许我们选择模板缓冲区中我们想要修改的部分。它只是从蒙版中取出一个像素，从模板缓冲区中取出一个对应的像素，然后对它们进行逐位“与”比较。请记住，每个像素有一个字节的数据，所以 8 位。按位“与”运算将每个位与其对应的对应位进行比较，如果它们都是 1，则只输出 1。因此，如果我们将 0x00 输入到 glStencilMask 中，这意味着我们有 8 位等于 0，那么所有的比较都将失败，并且模板缓冲区根本不会改变。但是如果我们将 0xFF 输入到 glStencilMask 中，那么掩码的所有位都将是 1，因为 0xFF 等于 8 个 1，所以我们将能够修改模板缓冲区的任何部分。

现在让我们看看另外两个可以利用的函数:glStencilFunc 和 glStencilOp。glStencilFunc 允许我们控制模板缓冲区如何通过测试或测试失败，而 glStencilOp 允许我们指定当模板测试失败时，当模板测试通过但深度测试失败时，以及当两者都通过时会发生什么。

让我们更深入地了解一下 glStencilFunc。它接受三个参数:一个函数、一个引用值和一个掩码。该函数可以是其中之一，默认情况下设置为 GL_ALWAYS，因此测试总是通过。参考值就是我们在函数中用来比较的值。请注意，在比较模板值和参考值之前，我们如何使用掩码对两者应用按位 AND 运算。这意味着，如果您想要准确地比较两者的数值，您将希望您的掩码为 0xFF，这样就不会有任何变化。

现在对于 glStencilOp，它有四个参数:sfail、dpfail 和 dppass。这些代表模板失败、深度失败和深度通过。对于所有这些，您可以在以下选项中进行选择。默认情况下，它们都有 GL_KEEP，这基本上意味着没有任何变化。关于这些函数没有太多要说的，所以如果您想了解更多，可以在文档中查找它们。

模板缓冲区可以用于很多东西，比如门户、镜像等等，但是一个容易实现的特性是模型的概述，所以让我们来看看。我们首先要像平常一样渲染我们的对象，并在我们有对象片段的地方用 1 更新模板缓冲区，在我们没有对象片段的地方用 0 更新模板缓冲区。这将基本上创建一个这样的图形。然后，我们希望禁止写入模板缓冲区，这样我们就不会意外地修改它，同时禁止深度测试，这样我们就可以确保我们绘制的下一个对象将完全位于上一个对象的前面。现在我们要渲染一个放大的物体，但是这次是单色的，并且有以下条件:我们只画模板值不为 1 的部分，所以基本上不是之前物体轮廓的位置。然后，我们只需恢复对模板的写入，并再次启用深度缓冲。这就是我们要做的。

现在让我们用代码实现它。我们首先使用 glEnable(GL_STENCIL_TEST)启用模板缓冲区，并确保我们也启用了深度缓冲区。然后我们在 GL_KEEP、GL_KEEP、GL_REPLACE 中使用 glStencilOp 插件。这将使得当深度和模板测试都通过时，我们将使用由 glStencilFunc 指定的参考值。现在，让我们确保在每一帧之前清空所有的缓冲区，然后进入神奇发生的部分。

首先，我们指定模板测试总是通过，并将参考值设置为 1。然后，我们使用全 1 的模板掩码来启用对所有模板缓冲区的写入。现在我们简单的画出我们的物体。到目前为止，我们的模板缓冲区是这样的，颜色缓冲区是这样的。请记住，所有这些值都是 1，因为我们在 glStencilOp 函数中指定了，如果模板和深度测试都通过，那么让模板缓冲区的像素等于 1。现在对于轮廓，我们希望模板测试只在它不等于 1 并且深度测试通过时才通过。然后我们禁用深度缓冲，因为前面提到的原因，并禁止写入模板面具，所以我们可以保持我们原来的轮廓。

现在，因为我们想使轮廓为平面颜色，我们必须创建两个新的着色器和一个着色器程序。所以让我们首先像这样创建着色器程序。然后，对于“outlining.frag ”,我们只想返回一个颜色，而对于“outlining.vert ”,我们想获得位置，以及所有与转换相关的统一规则，加上一个名为 outlining 的新的浮动统一规则，我们将把它与比例矩阵相乘。现在回到主函数中，我们将把轮廓制服发送给着色器，值大约为 1.08。然后，我们简单地再次绘制相同的对象，但这次使用其他着色器。我们需要做的最后一步是启用对整个模板的写入，通过总是通过测试并用 0 替换值来清除它，并启用深度缓冲。现在如果你运行这个程序，你应该会看到你的物体的轮廓。如果你的物体的原点在它的几何中心，如果它没有非常复杂的形状，那么轮廓可能看起来很好。但是在我的例子中，你可以看到原点不在中心，因为轮廓向上倾斜，而且形状非常复杂，有许多曲线，因此这种方法不太适用。

一个更好的方法是在顶点着色器中导入法线，并将它们添加到位置向量，乘以轮廓，我们将从比例矩阵中删除，现在我们将从 1.08 降低到 0.08。现在，当缩放向量时，我们不是从原点开始缩放，而是从模型向外缩放，使用法线作为“向外”的参考。这会给你更好的结果，除了一个例外。如果你有硬边，那么你的法线会互相接近垂直，所以在扩展模型的时候会产生一点缝隙。

因此，第三个解决方案是简单地建立另一个比第一个更大的模型。更具体地说，它必须更厚，而不一定更大。您可以使用 Blender 的“固化”修改器实现类似的效果。这里你可以看到我有一个初始模型，和一个更大的版本。现在我已经将两者导出为不同的模型，我只需要像这样将它们导入到我的程序中。然后，我没有第二次画这个物体，而是简单地画了一个更大的版本，这次甚至不需要制服来缩放它。如您所见，这提供了最好的结果，尽管代价是存储成本翻倍...你当然可以创建一个类似于 blender 的固化功能，但是对于本教程来说会稍微复杂一些。

今天我将向您展示什么是面剔除，以及它如何影响性能。我们还将通过制作 FPS 计数器来测量这种性能变化。

因此，面剔除是图形管道中的一个步骤，它决定三角形是否会移动到片段着色器(也就是说，三角形是否会被绘制)。OpenGL 通过查看三角形的哪一侧当前正对着摄像机来决定这一点。一般来说，在大多数 3D 图形程序中，发送到片段着色器的是三角形的正面，而丢弃的是三角形的背面。

OpenGL 判断哪一侧是哪一侧的方式是通过索引约定，可以是顺时针，也可以是逆时针。在一个逆时针的框架中，如果一个三角形的指数顺序在面对我们时是逆时针的，那么我们看到的边就是正面。同样，如果一个三角形面对我们时的指数顺序是顺时针的，那么我们看到的边就是背面。对于顺时针框架，情况正好相反。大多数图形程序使用逆时针标准，但是不要期望所有的程序都使用这个标准。

现在，为了将所有这些放入代码中，我们只需使用 glEnable 和 GL_CULL_FACE 来启用面剔除，指定我们想要保留的面，99%的时间将是 GL_FRONT，然后指定我们想要使用的标准。我再次建议使用逆时针方向，因为据我所见，它比顺时针方向更常见。

现在，如果我们运行这个程序，你会注意到当我们进入一个对象内部时，我们将看不到它的内部，因为它包含了三角形的背面，这些三角形被丢弃了。因此我们只能看到背景。

让我们看看这是否会对性能产生影响。为此，我们需要一个 FPS 计数器，我将在窗口的标题中显示它。让我们从创建三个 doubles 开始，分别是上一个时间，当前时间，以及这两个时间的差。然后，我们还需要一个无符号整数作为计数器，看看在一定的时间内我们有多少帧。FPS 就是你在一秒钟内得到的帧数。这意味着为了得到 FPS，我们可以计算一秒钟内得到的帧数，一帧是主 while 循环中的一个循环。但这也意味着我们的 FPS 每秒只能更新一次。相反，让我们每 30 秒更新一次。

要做到这一点，我们只需要使用 glfwGetTime(时间差)获得当前时间(秒),并递增计数器。然后，如果差值大于或等于 30 分之一秒，我们继续测量 FPS。FPS 将简单地等于 1 除以时间差，即该时间差给出的每秒帧数，但时间差包含多个帧，等于计数器，因此我们还需要将其乘以计数器。现在我们可以停在这里，但知道一帧用毫秒表示需要多长时间也是有用的。要做到这一点，我们只需将时间差除以计数器，得到一帧所用的秒数，然后乘以 1000，将其转换为毫秒。然后，我们简单地把新标题放在一起，并使用 glfwSetWindowTitle 将其应用到窗口。然后，我们要将之前的时间设置为当前时间，以便将时差恢复为 0，同时将计数器设置为 0。

现在如果你开始你的程序，你将能够看到你拥有的帧数。如果他们停留在 60，那么这意味着你有 VSync，它试图保持你的 FPS 恒定在每秒 60 帧。如果您希望禁用它，那么在您的 main 函数中写入 glfwSwapInterval(0)。请记住，这将只能停用垂直同步，如果垂直同步不是由您的图形驱动程序强制的。无论如何，我建议保持在每秒 60 帧。但是如果您不想这样做，至少要确保处理用户输入的函数被放入一个像这样定期工作的 if 语句中，否则输入的响应性会随着 FPS 的变化而变化，这是您不希望的。

为了向您展示面剔除提高了您的 FPS，这里有一个非常高分辨率的模型和 FPS 的差异。这里的差别并不大，但从数字上看是显而易见的。当你有多个模型和许多事情发生时，差别会变得更加明显。

在本教程中，我将向你展示如何快速打开透明度，以及如何利用 OpenGL 中的混合功能。

所以你可能已经注意到了，到目前为止我们使用的所有纹理都有 4 个组成部分:红色、绿色、蓝色和阿尔法(RGBA)。前三个给我们的场景赋予颜色，而最后一个控制不同物体的透明度。现在，如果你看看我导入的这个草模型，你会发现它没有透明度。要做到这一点，我们只需创建一个新的片段着色器，它将与我们的普通片段着色器相同，但我们将检查 alpha 值是否小于某个阈值，如果是，我们将丢弃该片段。不要忘记为这个新的片段着色器创建一个新的着色器程序。所以如果你运行这个程序，你应该会看到草现在是它应该的样子。

现在，我将添加一堆随机放置的透明窗口。由于这里的代码与 OpenGL 无关，我就不解释了。我为这些使用的着色器是一个非常基本的着色器，它只显示没有任何照明的纹理。所以现在你可以看到有一堆窗口，但即使在我的纹理中它们是透明的，在这里它们不是。为了达到透视效果，我们需要混合。

现在来谈一点理论。这是 OpenGL 用来混合不同颜色的公式。所有的 C 项代表颜色，而 T 项代表透明度。以防你不知道或忘记，alpha 级别为 0 是完全透明的，alpha 级别为 1 是完全不透明的。然后源颜色是片段着色器中的颜色，而目标颜色是颜色缓冲区中的颜色。这些幻灯片可以有不同的公式。最常见的一种是源从源颜色的 alpha 部分获取透明度值，而目标的透明度是 1 -源的 alpha 值。所以现在让我们告诉 OpenGL 我们想使用这个配置，使用 glBlendFunc 指定源和目标函数。以下是出于某种原因您可能会用到的一些函数的列表。然后，如果你愿意，你也可以使用 glBlendEquation 与这些参数之一，以指定你希望以前的颜色如何相互作用，基本上改变默认的方程。最后，您可以使用 glBlendFuncSeparate 函数来选择如何与源和目标的 RGB 通道和 alpha 通道进行交互。请记住，您不能为每个 RGB 值指定一个函数，只能为所有值一起指定一个函数。

此时，我们只需在窗口前使用 glEnable(GL_BLEND)启用混合，然后在完成绘制后立即禁用它，这样我们就不会意外地影响到其他任何东西。你应该总是对透明物体这样做。然后编译，你会看到窗口是透明的。但是有一个问题...混合全乱了。只是看起来不太对。为此，我们要责怪我们的朋友深度缓冲区。由于窗口是以随机顺序绘制的，所以绘制在现有窗口后面的窗口根本不会被绘制，因为深度测试失败了。所以为了画出所有的窗户，我们应该先画最远的，最后画最近的。或者，你当然可以对此漠不关心，在绘制窗口时简单地禁用深度缓冲，但这在大多数情况下是行不通的，我通常不建议这样做。另一个选择是根据窗户离摄像机的距离来分类。

现在排序与 OpenGL 没有任何关系，所以我不会解释这一部分，实际上我鼓励你想出自己的排序窗口的解决方案。重要的是，我通过从摄像机位置减去窗口位置，计算出从一个窗口到摄像机的所有距离，并得到该向量的长度。然后根据这个长度，我把所有的窗口从最远的到最近的排序并画出来。就这么简单！你只需要在分类和如何存放物品上有点创意。请记住，这种按顺序绘制对象的方法并不能保证 100%的时候都有效。如果不同的透明物体相交或做一些奇怪的事情，你会得到奇怪的结果。但是其他方法相当复杂，所以现在只能这样了。

在本教程中，我将向你展示如何在你的 OpenGL 应用中实现一个自定义的帧缓冲区，以及如何使用帧缓冲区来实现后期处理效果。

首先，什么是帧缓冲区？你可以把一个帧缓冲区看作是多个缓冲区的集合，这些缓冲区产生了你在屏幕上看到的最终图像。因此它包含一个颜色缓冲区、一个深度缓冲区和一个模板缓冲区。现在你为什么要用它呢？如果我们创建自己的帧缓冲区，那么我们可以在覆盖整个屏幕的矩形上显示它，然后使用着色器修改矩形上显示的像素以实现不同的效果。这被称为后处理，因为你在所有渲染完成后处理像素。

好了，现在让我们实现帧缓冲区。就像任何 OpenGL 对象一样，我们创建一个无符号 int，使用 glGenFramebuffers 生成 Framebuffers，并绑定它。这就是帧缓冲区。现在我们需要添加一个颜色纹理来使它有用。因此，我们将创建一个纹理，就像在纹理教程中一样，确保我们将纹理夹到边缘，因为否则某些效果会由于纹理的默认重复而从屏幕的一侧流到另一侧。然后，我们简单地使用 glFramebufferTexture2D 将纹理附加到帧缓冲区。

请记住，我们将颜色存储在纹理中，因此我们可以从着色器中访问它，这是我们想要做的。但是在深度缓冲区的情况下，我们并不关心在本教程的着色器中读取它，所以我们可以使用渲染缓冲区对象，而不是使用纹理，这要快得多，但缺点是你不能直接在着色器中读取它。我们使用 glGenRenderbuffers 创建它，然后使用 glRenderbufferStorage 配置它的存储，插入 GL_RENDERBUFFER、GL_DEPTH24_STENCIL8 以及宽度和高度。我们使用 GL_DEPTH24_STENCIL8，这样我们可以在其中存储模板缓冲区和深度缓冲区。还要非常小心所有的 framebuffers 组件具有相同的宽度和高度，否则您可能会得到一个错误。然后，我们只需使用 glFramebufferRenderbuffer 将其附加到帧缓冲区。

为了检查一点错误，就写这个。遗憾的是，这些错误不是很具体，它们只是给你一个数字。以下是您可能得到的错误的含义。

现在我们有了 framebuffer 对象，我们可以创建一个矩形，它将总是覆盖整个屏幕，所以我们不想对它应用任何类型的变换。现在让我们为 framebuffer 创建两个非常基本的着色器，将它们制作成着色器程序，然后发送我们的纹理单位 0，因为它是该着色器中唯一的纹理。

现在让我们来处理绘图部分。首先，我们确保在绘制任何东西之前绑定帧缓冲区，包括背景。确保您的缓冲区已被清空，并且之后启用了深度测试。然后，在我们完成场景中的所有绘制后，我们希望通过绑定 0 切换回默认的帧缓冲区，并绘制显示我们刚刚取消绑定的帧缓冲区的矩形。只要确保禁用深度测试，这样矩形就不会在深度测试中失败。

现在，如果你运行这个程序，你应该看到你之前看到的没有任何区别。如果你的屏幕是平面颜色，那么首先检查你的 cmd 类窗口中没有任何错误，然后确保你的面剔除没有去除矩形(所以要么改变顶点的顺序，要么在绘制矩形时禁用剔除)。对于任何其他错误，请检查描述中的源代码，并非常仔细地检查您的代码，在这种情况下，有很多事情可能会出错。

好了，现在让我们变得有趣一点。在帧缓冲区片段着色器中，我们可以做各种有趣的效果。一些简单的方法是像这样反转颜色，或者把图像变成黑白的。但是这些没那么有趣。为了获得更有趣的结果，当我们选择单个像素的颜色时，我们希望对多个像素进行采样。为此，我们首先要声明一个 vec2s 数组，它将表示从我们所在的像素到它的 8 个邻居的偏移量。请注意，我是如何用 1 除以 800 来获得 800 乘 800 窗口的一个像素的宽度和高度的。之后，我们想创建一个浮动数组，它将代表一个内核。它基本上是一个矩阵，通过定义每个像素相对于我们当前所在的像素(即中间的那个像素)的重要性，来帮助我们实现很酷的效果。一般来说，你可能希望它们在某种程度上是对称的，并且总和总是 1。如果它们加起来大于 1，最终的颜色会更亮，如果它们小于 1，最终的颜色会更暗。这里虽然它们加起来是 0，但这是故意的，因为这是一个边缘检测内核，我希望所有的东西都很暗，除了事物的边缘。

现在，我们所要做的就是将内核的每个部分乘以某个偏移量处的每个像素，并在这个名为 color 的 vec3 中将它们全部相加。请记住，尽管这些看起来像矩阵，但我们实际上并没有用相同的方式将它们相乘。然后最后一步是输出颜色作为 FragColor，我们就完成了！我认为这个内核给出了一个非常酷的效果。这里有一些你可能想尝试的其他内核。我建议你只是玩一会儿，做你自己的内核，这样你就能感觉到它们是如何工作的。

在本教程中，我将向你展示 OpenGL 中的立方体贴图，以及你如何使用它们来创建天空盒。

那么什么是立方体贴图呢？它们只是另一种类型的纹理，拥有 6 个 2D 纹理，立方体的每一面都有一个。对立方体贴图进行采样时，需要指定一个 3D 向量，而不是 2D 向量。这使您可以轻松地在立方体的所有 6 个面之间进行采样。并且因为立方体的坐标对应于采样向量，所以不需要 uv。立方体贴图最常见的用途是四球纹理和天空盒。

现在让我们把它编码进去。你需要做的第一件事是写出立方体的顶点和索引。然后，我们将想要创建一个 VAO，VBO 和 EBO 就像在第一个教程。

现在让我们创建一个包含 6 个字符串的数组来保存我们将用于天空盒的 6 张图片的路径。然后，我们想创建立方体贴图纹理本身，就像任何其他纹理一样，除了我们之前放 GL_TEXTURE_2D 的地方，我们没有放 GL_TEXTURE_CUBE_MAP。确保在所有三个方向夹紧纹理，因为纹理是立方体，因此是 3D 的。这种夹紧应该防止任何接缝出现。

现在，我们将检查所有六个纹理，并使用 stb 库读取它们，一旦我们读取它们，就将它们放入立方体纹理中。注意我是如何禁用垂直翻转的。这是因为与 OpenGL 中的大多数纹理不同，立方体贴图应该从左上角开始，而不是左下角。还要注意我是如何将 I 添加到 GL_TEXTURE_CUBE_MAP_POSITIVE_X 中的。这代表了我当前正在为其分配纹理的立方体的边，我将 I 添加到其中是为了循环所有的边。这是你可以在 OpenGL 文档中找到的边的顺序，这是我们写路径的顺序。注意到奇怪的事情了吗？嗯，通常在 OpenGL 中，正面是负 Z 方向，但是对于立方体贴图，正面是正 Z 方向。这意味着立方体贴图在左手系统中工作，而大多数 OpenGL 在右手系统中工作。这可能非常令人困惑，我真的不知道他们为什么选择这样做，但哦，好吧。请记住，如果你不小心的话，你可能会因此而感染小病毒。在我的例子中，由于某种原因，我的右边纹理一直上下颠倒显示。为了解决这个问题，我在图像编辑器中翻转了纹理。所以要为这种事情做好准备，因为据我所知，这种事情在 skyboxes 上经常发生。

好了，回到教程。我们现在需要为天空盒创建两个着色器。顶点着色器将接受坐标，输出纹理坐标，并接受矩阵变换的统一。在 main 函数中，创建一个保存最终转换坐标的 vec4。现在，由于这些坐标现在在屏幕空间中，我们将做一些有点奇怪的事情。我们给 gl_Position 的不是坐标，而是 x，y，w 和 w 分量。这将导致透视分割后 z 分量始终为 1。由于深度缓冲区将 z 分量作为其深度值，天空盒的深度值将始终为 1，这是可能的最大深度值，因此位于所有对象之后，正如它应该的那样。最后，我们希望将纹理坐标导出为位置，只是我们将翻转 z 轴以防止坐标系发生变化。

对于片段着色器，我们只想导入纹理坐标、立方体贴图，然后将 fragColor 设置为等于纹理。就是这样。

回到主函数，我将创建一个着色器程序并导出天空盒纹理单元。现在剩下的就是画画的部分了。

我们首先将深度函数设置为 GL _ LEQUAL，而不是默认的 GL_LESS，因为我们的天空盒就在边上，也就是 1，所以我们需要等号。然后，我们将激活着色器并创建视图和投影矩阵，这些矩阵与我们在 camera 类中创建的矩阵相同，除了一个小细节。对于视图矩阵，我们将其降级为 mat3，然后将其升级回 mat4。这将使矩阵的最后一行和最后一列等于 0，因此对翻译没有影响。我们只希望天空盒旋转，而不是四处移动。然后简单地将这些矩阵导出到顶点着色器。

现在，最后一部分是绘制立方体贴图本身，就像任何其他对象一样，只是当我们绑定纹理时，我们使用 GL_TEXTURE_CUBE_MAP，而不是通常的 GL_TEXTURE_2D。在你使用完天空盒后，不要忘记将深度测试切换到默认的 GL_LESS。

如果你启动你的程序，你现在应该有一个漂亮的天空盒在你周围。如果任何一个面是反的或者类似的，在图像编辑器中调整图像的方向。相信我，这样做要比试图寻找两个不同的坐标系和不同的纹理读取原点所导致的逻辑错误容易得多。如果你有明显的线缝，那么你可以试着在代码中的某个地方添加 glen able(GL _ TEXTURE _ CUBE _ MAP _ SEAMLESS)。如果你的接缝不是线条，而是简单的一张脸和另一张脸之间的颜色差异，那么你可能只有一个劣质的天空盒。如果你看不到任何东西或者只看到天空盒的一部分，那么你可能启用了背面剔除，并且以错误的缠绕顺序写了索引。绘制天空盒时，只需禁用面剔除，或者以正确的缠绕顺序写入索引。

在本教程中，我将向你展示什么是几何着色器，以及如何使用它来创建诸如可见法线之类的东西。

到目前为止，我们只使用了顶点着色器和片段着色器，它们在大多数情况下都足够了。但有时在顶点和碎片着色器之间，您需要额外的步骤来修改网格的几何体。尽管看起来你可以在顶点着色器中做到这一点，但你只能对单个顶点做些事情。如果你想修改整个三角形，那么一组顶点，然后你需要使用几何着色器。几何着色器的第二个优点是，它可以在不同类型的图元之间切换，因此可以创建或删除顶点。

因此，让我们开始添加几何着色器到我们的着色器类。请注意，除了使用 GL_GEOMETRY_SHADER 之外，我是如何做与其他两个着色器完全相同的事情的。既然我们支持自定义几何着色器，让我们创建一个什么也不做的几何着色器。

就像任何其他着色器一样，我们将从版本开始。然后我们需要两个这样写的布局。第一个布局表示我们接收的原语的类型，可以是下面的一种，而第二个布局显示我们输出的原语的类型，可以是下面的一种。在这种情况下，我们希望接收一个三角形并导出一个三角形。然后，我们将输出到片段着色器。请记住，您应该将数据从顶点着色器传递到几何着色器，然后传递到片段着色器。

现在，为了将数据导入几何着色器，我们需要做一些稍微不同的事情。不是简单地有一个“in”，我们将有一种 C 结构，像这样写出来。请注意，我们不必在此包含职位，因为它已经内置于一个默认结构中，就像这个名为 gl_in 的结构一样。现在我们需要回到顶点着色器，用完全相同的结构替换所有输出数据，除了最后一部分和“出”而不是“入”。确保结构中的所有其他内容都与几何着色器中的对应内容相同。请注意我是如何包含投影矩阵的。这是因为我们只想在修改几何图形后应用投影矩阵。现在，要将数据分配给这些输出值，我们只需写下我们给它们的名称加上一个点，以及我们要将数据分配给的变量的名称。非常类似于 C 或 C++结构。

现在，在几何着色器中，我们拥有了所需的所有数据，所以剩下要做的就是将这些数据组合在一起。要做到这一点，我们只需分配他们的位置，法线，颜色和纹理坐标数据。请注意，除了我想要访问的结构部分的名称之外，我还有一个索引。这是因为我们在几何着色器中，因此我们本质上有一个这样的结构数组，每个结构对于一个特定的顶点有不同的值。一旦我们完成了一个顶点的赋值，我们必须使用 EmitVertex()来声明我们完成了这个顶点，顶点顶点顶点顶点。现在，我们可以对其他两个顶点做同样的事情，一旦我们完成了三角形所需的所有三个顶点，我们就可以使用 EndPrimitive()声明我们的图元是完整的。这就是默认的几何着色器。如果你运行你的程序，你会得到你之前所拥有的，太棒了！

但这真的很无聊，所以让我们改变一下，让几何着色器更有趣。一个非常简单的方法是使用叉积计算曲面法线，然后将该法线添加到图元的三个位置。这将使你的网格看起来好像所有的基本体爆炸或出故障。

现在让我们做一些更严肃的事情。让我们创建一个新的着色器，它将采用我们的默认顶点着色器，一个新的片段着色器和一个新的几何着色器。在使用默认着色器绘制模型之后，让我们使用该着色器来绘制模型。现在，对于片段着色器，我们将简单地输出一个平面颜色，没有任何花哨。

但是对于几何着色器，我们将得到一个三角形，并输出不是一个三角形，而是多条线！因此，现在我们实际上是在破坏和创建新的几何图形，因为正如你所看到的，我们将输出 6 个顶点，尽管我们只有 3 个。然后，我们将使用完全相同的结构，在 main 函数中，我们将简单地检索第一个顶点位置并声明它。但是，然后不是移动到下一个顶点，我们会留在这一个，但增加了顶点的法线，然后发射它。这实际上创建了一条穿过顶点法线的线。现在我们想对其他顶点做同样的事情，但是为了不把所有的线连接在一起，我们必须首先使用 EndPrimitive 结束这条线，然后继续前进。在对所有的顶点做了这些之后，我们可以按 play 键，看到我们现在能够可视化我们模型的所有法线，这对调试非常有用。

请记住，几何着色器对于草或细分模型也非常有用。所以它们真的很有趣。

在本教程中，我将向你展示什么是实例化，以及你如何使用它来大规模提高你的 OpenGL 项目的性能和外观。

因此实例化只是一个允许你在一次绘制调用中多次绘制网格的特性。你为什么想要这个？好吧，考虑一下这些场景，我有一个小行星带，全部由一个小行星网格组成，在顶点着色器中变形以产生一些变化。在左边的场景中，我简单地用一个循环来分别画出每颗小行星。这意味着每颗小行星都有一个抽签决定。现在在右边的场景中，我把所有的小行星画在一起。这意味着我只有一次听牌机会。如果你看看性能差异，你会发现它是巨大的。

现在让我们把它编码进去。我将从已经为第一个场景编写的代码开始，因为这对本系列来说并不新鲜。因此，为了启用 instacing，我们所要做的就是使用 glDrawElementsInstanced 而不是 glDrawElements，并在它的末尾添加我们想要的网格的多少个实例。唯一的问题是，这将在完全相同的位置绘制所有网格，所以它是无用的。

有多种方法可以将每个网格移动到一个独特的位置。例如，您可以在顶点着色器中编写代码来实现这一点。使用 gl_InstanceID，您将获得当前正在绘制的实例的索引，因此您可以使用它来生成受控的随机数。或者，您可以统一所有的转换，并使用 gl_InstanceID 检索特定实例的正确转换。但这样做的问题是，制服无法存储那么多数据。因此，拥有大量变换而不在顶点着色器中生成的最佳方式是将变换存储在附加到网格 VAO 的顶点缓冲区中。

让我们首先创建一个 VBO 构造函数，它接受一个 mat4s 向量。然后，我们希望向 Mesh 类添加一个无符号整数公共变量，以表示我们需要的实例数量。当然，我们还需要将它添加到构造函数中，以便轻松地更改它。同样，在构造函数中，我们应该为实例添加矩阵变换的向量，这样我们就可以将它插入顶点缓冲区。现在，在 Mesh.cpp 文件中，我们希望为实例创建一个 VBO，然后仅当我们绘制多个网格时，才将其属性链接到 VAO。确保将矩阵链接为 4 个不同的 vec4s，否则你的程序将无法运行。最后使用 glVertexAttribDivisor 插入每个 vec4 和 1 的布局编号。这个 1 意味着 vec4 将用于整个实例。如果它是 0，那么 vec4 将被用于一个顶点，然后下一个 vec4 将被用于下一个顶点，这肯定不是我们想要的。为了清楚起见，如果它是 2，在切换到下一个 vec4 之前，它将用于两个实例。现在，让我们也将 glDrawElementsInstanced 的使用限制为仅用于多个实例。

对于模型类，我们需要做与网格类完全相同的事情，我们将 instanceMatrix 作为变量添加到构造函数中，并再次作为变量实例化。现在，在我们的 loadMesh 函数中，我们希望在网格创建过程中包含实例化和实例矩阵。

现在，我们需要一个稍微修改的着色器，以适应新的布局。因此，创建一个新的着色器程序专门为小行星使用一个特殊的顶点着色器和默认的片段着色器。顶点着色器将与默认着色器相同，除了我们将为 instanceMatrix 提供第五个布局，我们将删除我们不需要的制服，并用 instanceMatrix 替换所有变换。不要忘记在主函数中导出灯光制服。

然后剩下要做的就是将平移、旋转和缩放矩阵合并在一起，并将它们全部添加到 instanceMatrix 向量中。然后简单地将它和实例编号添加到小行星的模型构造器中，并绘制一次小行星。记住我们只需要调用一次 draw 函数。现在编译和见证成千上万的小行星，性能影响最小。当然，请记住，不同 GPU 的性能会有所不同，因此它在您的 GPU 上可能不如在其他人的 GPU 上工作得好。

在本教程中，我将向你展示什么是反走样，以及如何在你的 OpenGL 项目中实现它。

所以你可能已经注意到，虽然水平和垂直边缘看起来非常清晰，但对角线边缘看起来有点起伏，就像一段楼梯。这是因为我们在屏幕上显示图像的方式。由于我们的显示器是由一堆微小的正方形，也就是像素组成的，所以对角线上不可能有平滑的线条。但幸运的是，我们可以通过像这样将边缘的颜色渗进相邻的像素来假装平滑。

现在，这些锯齿状的边缘被称为锯齿，反锯齿技术可以帮助我们获得更好的边缘。有多种反走样技术，每种技术都有其优缺点，但今天我将重点介绍 MSAA，它代表多采样反走样。那么这种多重采样又指的是什么呢？

在管道图元的光栅化部分被填充。决定哪些像素应该被赋予颜色，哪些不应该被赋予颜色的方法是通过检查像素的采样点(通常在像素的中心)是否在图元的形状内。这意味着，即使采样点只是稍微在三角形之外，它也不会被采样，即使你认为它应该至少部分地被采样。这就是 MSAA 的用武之地。正如您可能已经猜到的那样，这种技术只是增加了多个采样点，从而可以获得更精确的结果。

例如，这里四个采样点中的两个位于三角形内部，因此该像素的颜色将介于背景颜色和图元颜色之间。

现在让我们实际实现它。让我们从创建一个变量开始，在这个变量中我们指定我们需要多少样本。现在，如果你没有一个帧缓冲区，那么你可以给 GLFW 一个窗口提示，告诉它你想要 GLFW_SAMPLES 和你想要的样本数，然后激活 GL_MULTISAMPLE。这就是本教程的内容，因为...不，我开玩笑的。但是实际上，如果你没有一个帧缓冲区，那你就完了。如果你有一个帧缓冲区，那么你需要删除 GLFW 部分。相反，你需要去你的帧缓冲区，用 GL_TEXTURE_2D _ 多样本替换所有 GL _ TEXTURE _ 2D。然后用 glTexImage2DMultisamples 替换 glTexImage2D，插入纹理类型、样本数量、颜色格式、宽度、高度以及是否希望所有样本在像素中处于完全相同的位置。

然后，对于 renderbuffer 对象，我们需要将 glRenderbufferStorage 更改为 glrenderbufferstoragemultissample，并添加我们想要的样本数。

现在的问题是，我们不能再对这个帧缓冲区进行任何形式的后处理，因为它已经启用了多级采样。因此，为了避免这种情况，我们需要一个正常的帧缓冲区，我们可以进行后处理。这就像我在 framebuffer 教程中做的一样。

现在，在主函数中，我们要确保首先绑定多采样 FBO，清除屏幕，清除缓冲区，并启用深度测试。然后我们画所有我们想画的东西。之后，我们将多采样 FBO 绑定为只读，将后处理 FBO 绑定为仅绘制。现在，我们将使用 glBlitFramebuffer 解析所有的多重采样，并将结果复制到后处理 FBO 中。

现在，确保绑定默认的帧缓冲区，并使用后处理纹理绘制帧缓冲区矩形。运行这个程序，你会发现图元的边缘变得更加平滑和漂亮。请注意，在后期处理中应用内核实际上会覆盖反走样，因此您可能会再次出现走样。至于你应该使用的样本数量，我建议使用 2 个、4 个或 8 个。在某些 GPU 上，您可以达到 16 和 32，但这种性能/性能比并不值得。

这就是本教程的内容，因为源代码和所有使用的资源都在描述中。再见！