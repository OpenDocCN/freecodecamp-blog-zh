# Redux 有什么了不起的？

> 原文：<https://www.freecodecamp.org/news/whats-so-great-about-redux-ac16f1cc0f8b/>

贾斯汀·法尔科内

# Redux 有什么了不起的？

![1*BpaqVMW2RjQAg9cFHcX1pw](img/d3eab94324a34a36a31895a6a2671e75.png)

Redux 优雅地处理了用 React 的组件状态难以表达的复杂状态交互。它本质上是一个消息传递系统，就像在面向对象编程中看到的那种，但是作为一个库而不是在语言本身 [](#535d) 中实现。和在 OOP 中一样，Redux 将控制的责任从调用者转移到接收者——UI 不直接操纵状态，而是向它发送一条消息让状态解释。

从这个角度来看，Redux store 是一个对象，reducers 是方法处理程序，actions 是消息。`store.dispatch({ type: "foo", payload: "bar" })`相当于 Ruby 的`store.send(:foo, "bar")`。中间件的使用方式非常类似于面向方面的编程(例如 Rails 的`before_action`)和 React-Redux 的`connect`是依赖注入。

#### 为什么这是可取的？

*   上面描述的控制反转确保了如果状态转换的实现发生变化，UI 不需要更新。添加日志记录、撤销甚至时间旅行调试等复杂功能几乎是微不足道的。集成测试只是测试正确的动作是否被分派的问题；其余的可以进行单元测试。
*   React 的组件状态对于涉及应用程序多个部分的状态来说相当笨拙，比如用户信息和通知。Redux 给你一个独立于 UI 的状态树来处理这些横切关注点。此外，将状态置于 UI 之外会使持久性之类的事情变得更容易——您只需要在一个地方处理序列化到 localStorage 或 URL。
*   Redux 名义上的“reducers”为处理动作提供了难以置信的灵活性——组合、多重分派，甚至是`method_missing`风格的解析。

#### 这些都是不寻常的情况。常见的情况呢？

问题就在这里。

*   一个动作*可以被*解释为一个复杂的状态转换，但是大多数都设置了一个单一的值。Redux 应用程序往往以一堆设置单一值的动作结束；这里有一个用 Java 手工编写 setter 函数的明显提示。
*   状态*的一个片段可以在你的整个应用程序中使用，但是大多数状态与 UI 的一个部分是 1:1 的关系。将该状态放在 Redux 中，而不是组件状态中，只是增加了*间接*，而没有*抽象*。*
*   一个 reducer 函数*可以*做各种奇怪的元编程，但在大多数情况下，它只是对动作的类型字段进行单调度。这在 Elm 和 Erlang 这样的语言中是很好的，在这些语言中，模式匹配是简洁的和高度表达性的，但是在带有`switch`语句的 JavaScript 中却很笨拙。

但是真正阴险的事情是，当你把所有的时间都花在为普通情况做样板文件时，你忘记了对特殊情况的更好的解决方案甚至是存在的。您遇到了一个复杂的状态转换，并使用一个调度十几个不同的值设置操作的函数来解决它。您在 reducer 中复制状态，而不是在应用程序中分发单个状态片。您在多个 reducers 之间复制和粘贴 switch cases，而不是将其抽象为共享函数。

这很容易被认为仅仅是“操作错误”——他们没有 RTFM，一个糟糕的工匠责怪他的工具——但是这些问题的频率应该引起一些关注。如果大多数人都在错误地使用工具，这说明了什么？

#### 那么，我应该避免常见情况下的冗余，而把它留给特殊情况吗？

这是 Redux 团队给你的建议——也是我给我自己团队成员的建议:我告诉他们避免使用它，直到使用 setState 变得确实不可行。但我无法让自己遵循自己的规则，因为总有一些*T2 的理由让你想使用 Redux。你可能有一堆`set_$foo`动作，但是设置任何值*也会*更新 URL，或者重置一些更短暂的值。也许你有一个清晰的状态到 UI 的 1:1 映射，但是你*也*想要日志或者撤销。*

事实是我不知道怎么写，更不要说*教*“好 Redux。”我工作过的每个应用程序都充满了这些 Redux 反模式，要么是因为我自己想不出更好的解决方案，要么是因为我无法说服我的队友改变它。如果一个 Redux“专家”的代码很平庸，新手还有什么希望？如果有的话，我只是想平衡盛行的“把所有的东西都还原！”走近，希望他们能够用自己的方式理解 Redux。

#### 那么在这种情况下我该怎么做？

幸运的是，Redux 足够灵活，第三方库可以与它集成来处理常见的情况——例如 [Jumpstate](https://github.com/jumpsuit/jumpstate) 。而且要明确的是，我不认为 Redux 专注于底层的东西是错的。但是将这些基本功能外包给第三方会产生额外的认知负荷和自行车脱落的机会——每个用户都需要从这些部分构建自己的框架。

#### 有些人喜欢那种东西。

我是其中之一！但不是每个人都是。我个人喜欢 Redux，几乎做任何事情都用它，但我也喜欢尝试新的 Webpack 配置。我不代表大众。我*被授权*在 Redux 上灵活地编写自己的抽象，但是我又有多大权力被某个高级工程师编写的抽象所授权，他从来没有记录过这些抽象，并在六个月前辞职了。

很有可能*永远不会*遇到 Redux 特别擅长处理的难题，尤其是如果你是一个团队中的初级成员，而在这个团队中，入场券都给了更高级的工程师。你对 Redux 的体验是“每个人都使用的奇怪的库，在那里你必须把所有的东西写三遍。”Redux 很简单，你*可以*机械地使用它，不需要深刻的理解，但那是一种没有乐趣和没有回报的体验。

这让我想起了我之前提出的一个问题:如果大多数人都在错误地使用一个工具，那么这个工具说明了什么？优质的手工工具不仅有用耐用，而且使用起来感觉很好。最舒服的握法就是正确的握法。它不仅是为它的任务设计的，也是为它的用户设计的。高质量的工具反映了工具匠对工匠的同情。

我们的同理心在哪里？为什么我们的反应是“你做错了”，而不是“我们可以让它更容易使用”？

在函数式编程圈子里有一个相关的现象，我喜欢称之为单子教程的*诅咒:解释它们如何工作是微不足道的，但是解释它们为什么有价值却出奇的困难。*

#### 你真的要在这篇文章中间放一个单子教程吗？

单子是 Haskell 中的一种常见模式，用于处理各种计算——列表、错误处理、状态、时间、IO。有语法上的好处，以`do`符号的形式，允许你以一种看起来有点像命令式代码的方式来表示一元操作序列，就像 javascript 中的生成器如何使异步代码看起来同步一样。

第一个问题是根据它们的用途来描述单子是不准确的。[单子被引入 Haskell 是为了处理副作用和顺序计算](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)，但是单子作为一个抽象概念，与副作用或顺序无关；它们是一组关于一对函数应该如何交互的规则，没有内在的含义。结合性的概念*适用于*算术和集合运算以及列表连接和空传播，但是它完全独立于它们而存在。

第二个问题是 X 的一元方法的任何小例子都比命令方法更冗长——因此至少在视觉上*更复杂。显式选项类型 a la `Maybe`比检查隐式选项类型`null`更安全，但会产生更多、更难看的代码。使用`Either`类型的错误处理通常比从任何地方使用`throw`类型的代码更容易理解，但是抛出肯定比手动传播值更简洁。以及副作用—状态、IO 等。—在命令式语言中是微不足道的。函数式编程爱好者(包括我自己)会说这些语言中的副作用太容易了，但是说服某人任何类型的编程都太容易了是很难的。*

真正的价值只在宏观层面上可见——不仅仅是这些用例中的任何一个遵循单子定律，而是所有用例都遵循*相同的*定律。在一种情况下有效的一组操作可以在*的每一种*情况下有效:将一对列表压缩成一对列表与将一对承诺合并成一个以一对结果结束的承诺是“同一件事”。

#### 这会有结果吗？

重点是 Redux 也有同样的问题——难教不是因为它难，而是因为它太简单了。理解与其说是拥有知识，不如说是信任核心思想，这样我们就可以通过归纳获得其他一切。

很难分享这种理解，因为核心思想是老生常谈(避免副作用)或抽象到毫无意义的地步(`(prevState, action) => nextSt` ate)。任何一个具体的例子都无济于事；他们展示了 Redux 的冗长，却没有展示它的表现力。

一旦我们到了✨enlightened✨，我们很多人会立刻忘记之前的感觉。我们忘记了我们的启蒙只是来自于我们自己反复的失败和误解。

#### 那你有什么建议？

我希望我们承认我们有问题。redux[简单，但不容易](https://www.infoq.com/presentations/Simple-Made-Easy)。这是一个有效的设计选择，但它仍然是一个权衡。许多人会从一个用简单性换取易用性的工具中受益。但是社区的大部分人甚至不承认已经做出了妥协！

我认为对比 React 和 Redux 是很有趣的，因为尽管 React 是一款复杂得多的软件，并且具有明显更大的 API 面，但它似乎更容易使用和理解。react 唯一绝对必要的 API 特性是`React.createElement`和`ReactDOM.render`——状态、组件生命周期，甚至 DOM 事件都可以在其他地方处理。将这些功能内置到 React 中让它变得更复杂，但也让 T2 变得更好。

“原子状态”是一个抽象的概念，一旦你理解了它，它就可以通知你的工作，但是`setState`是一个你可以调用 React 组件的方法，它代表你进行原子状态管理，不管你理解与否。这不是一个完美的解决方案——它比直接替换状态或进行变异并强制更新效率更低，并且当异步调用时它有一些基础——但是 React 作为一个可调用的方法而不是词汇表术语要好得多。

Redux 团队和社区都[强烈反对扩展 Redux 的 API 表面积](https://github.com/reactjs/redux/issues/2295)，但是当前将一堆微小的库粘在一起的方法即使对于专家来说也是乏味的，对于初学者来说也是难以理解的。如果 Redux 不能扩展到内置对常见情况的支持，它需要一个“受祝福的”框架来取代它。 [Jumpsuit](https://github.com/jumpsuit/jumpsuit) 可能是一个好的开始——它将“动作”和“状态”的概念具体化为可调用的函数，同时仍然保留它们多对多的性质——但是实际的库没有祝福行为本身重要。

具有讽刺意味的是，Redux 的存在理由是“开发者体验”:Dan 构建 Redux 是因为他想理解并重新创建 Elm 的时间旅行调试器。但是随着它发展自己的身份——随着它成长为 React 生态系统的事实上的 OOP 运行时——它放弃了对 DX 的一些关注，以换取可配置性。这使得 Redux 生态系统蓬勃发展，但明显缺乏一个人性化的、有管理的框架。我们 Redux 社区准备好创建它了吗？

*感谢[马修·麦克维卡尔](https://www.freecodecamp.org/news/whats-so-great-about-redux-ac16f1cc0f8b/undefined)、[一堆苔藓](https://www.freecodecamp.org/news/whats-so-great-about-redux-ac16f1cc0f8b/undefined)、[埃里克·伍德](https://www.freecodecamp.org/news/whats-so-great-about-redux-ac16f1cc0f8b/undefined)、[马特·杜隆尼](https://twitter.com/Crimyon)，以及[帕特里克·汤姆森](https://twitter.com/importantshock)进行点评。*

*脚注:*

**[1]为什么要区分 react / JS 和面向对象编程？JavaScript 是面向对象的，只是不是基于类的。**

像函数式编程一样，面向对象编程是一种方法论，而不是一种语言特性。有些语言比其他语言更好地支持这种风格，或者有一个为这种风格设计的标准库，但是如果你足够专注于这项任务，你可以用任何语言编写面向对象风格的代码。

JavaScript 有一个数据结构，它调用一个对象，语言中的大多数值都可以像对象一样对待，也就是说，除了 T0 和 T1，你可以对每个值调用一些方法。但是在代理出现在 ES6 之前，对一个对象的每个“方法”调用都是字典查找；`foo.bar`总是会在 foo 或其原型链上找到一个名为“bar”的属性。相比之下，像 Ruby 这样的语言，`foo.bar`发送消息`:bar`给 foo——这个消息可以被*截获*和*解释*，它不一定要在字典中查找。

Redux 本质上是一个更慢但更复杂的对象系统，它基于 JavaScript 现有的对象系统，其中 reducers 和中间件充当 JavaScript 对象的解释器和拦截器，而 JavaScript 对象实际上持有状态。[ [后退](#6a79)