# 如何使用 Chromium 和 PyInstaller 将 Web 应用程序转换成桌面应用程序

> 原文：<https://www.freecodecamp.org/news/the-python-desktop-application-3a66b4a128d3/>

打包和分发你的应用程序听起来很简单。只是软件而已。但是实际操作起来，还是挺有挑战性的。

我一直在开发一个叫做 Sofi 的 Python 模块，它可以生成用户界面。它可以在使用标准的单页 web 技术的同时提供桌面的感觉。为了灵活起见，我设计了两种分发方式:浏览器内和可执行文件。

在浏览器中运行，它的功能很像一个普通的网页。您可以通过打开一个文件来加载它，或者从您的 shell 启动它。我还构建了一个可执行文件，作为打包的应用程序运行，独立且没有外部要求。

随着时间的推移，当我在 Atom——我最近选择的编辑器——中编写代码时，我想起 Atom 实际上是一个浏览器。它使用 Node.js 作为后端，使用电子框架作为用户界面。这启发我开始探究 Electron 的内部，希望找到他们如何解决桌面打包的例子和最佳实践。

没过多久，我就发现这一切都是建立在免费和开源技术之上的:Chromium 浏览器和 Chromium 嵌入式框架。这是一个易于集成的定制示例，能够满足我的需求。

有了这些，我开始工作。

#### Chromium 嵌入式框架

Chromium 是谷歌 Chrome 浏览器的基础代码。它集合了所有呈现界面、处理用户输入和编写函数脚本的元素。

Chromium 嵌入式框架(CEF)是一组可以控制浏览器的 C 函数。它还提供了有助于简化构建和编译过程的脚本。

Visual Studio Code、Slack、Mattermost、Curse、Postman 和 Kitematic 都是使用电子的桌面应用程序的例子。这些系统都有资格作为利用 CEF 浏览器的网站。

如果您认为 Python 可以与 C 绑定并利用这些特性，那么您是对的。只需看看 [pycef](https://github.com/cztomczak/pycef) 项目就可以直接调用 cef 包装函数了。然而，它确实附带了 Chromium 二进制文件作为附加的依赖项。因此，如果你担心管理复杂的支持声明，三思而后行。

在我的特殊情况下，Sofi 项目通过一个 websocket 管理所有的交互，提供一个跨不同类型平台(web、桌面、移动等)的一致接口。).这意味着我不需要手动命令或驱动浏览器。我只希望通过标准的 web 技术与浏览器显示的 DOM 交互。

我的目标是定制使浏览器看起来像浏览器的 UI 元素。我需要删除菜单、工具栏和状态栏。这样做的时候，我会让它看起来像是在全屏模式下——但是在一个应用程序窗口中。

考虑到我的简单要求，我觉得 pycef——或任何其他低级绑定——太多了。相反，我利用了来自 CEF 项目的一个预先构建的样本: *cefsimple* 。这个浏览器隐藏了我想要的所有视觉元素，所以如果我用它的 CLI 打开一个网页，用户并不知道他们实际上是在浏览器中。它看起来像任何应用程序的常规窗口。

当我浏览文档时，构建 cefsimple 并不太复杂。但是如果你同时构建 Chromium 的话，这将花费大量的时间。为了避免这种情况，项目本身提供了预构建的二进制文件，您可以定制并编译到 cefsimple 中。我发现最好利用这些。

步骤如下:

1.  快速浏览一下[如何用 CEF 从二进制文件构建](https://bitbucket.org/chromiumembedded/cef/wiki/GeneralUsage#markdown-header-using-a-binary-distribution)。
2.  从回购中获得一个二元分布。在选择一个包之前，一定要阅读工具提示，因为不是所有的包都包含相同的文件。我特意找了一个有`cefsimple`的。
3.  浏览`CMakeLists.txt`文件，确保安装了必要的构建工具。这是特定于平台的。
4.  执行构建。这在与上一步相同的文件中进行了解释，并且也是特定于平台的，但是它倾向于遵循以下过程:make 和 cd 进入构建目录，在指向父目录的同时为您的编译工具和架构运行 cmake。因为我在 64 位平台上使用了 OSX 忍者工具，所以命令看起来像`cmake -G "Ninja" -DPROJECT_ARCH="x86_64" ..`
5.  构建目录现在将包含输出文件。结构可能有点混乱，但在主`README`中有描述。作为参考，上一步在`build/tests/cefsimple/Release/cefsimple.app`下产生了一个 app 捆绑包。
6.  不要忘记，您必须这样做才能为您支持的每个平台和操作系统架构创建所需的二进制文件。

现在你有了一个可执行文件，从命令行运行它，并把`--url`设置为你想要打开的网页。这意味着通过`subprocess`模块可以很容易地将其合并到 Python 脚本中。

虽然不是必需的，但是如果您对编译 Chromium 本身感兴趣，可以看看 CEF 的文档。它会给你指明正确的方向。但是要注意，下载、编译和编译需要很多时间。良好的老式处理能力肯定有助于获得更快的结果。

#### 包装

既然我们可以提供桌面体验，我们必须考虑如何将它分发给我们的用户。传统的 Python 包分发是通过 Python 包索引(PyPI)完成的。然而，它要求我们的用户安装 Python 解释器和某种形式的打包工具，如`easy_install`或`pip`。

虽然这不是特别难，但是您应该考虑更广泛的用户。用单独的手动步骤管理安装过程变得相当复杂。特别是对于非技术观众来说——他们中的一些人不知道 Python 是一种大蛇。而其他人可能至少知道一只欧洲空载燕子的飞行速度。

如果他们知道这种语言，大多数人已经安装了他们自己的版本。这就是软件包依赖性、不同的操作系统、您从未听说过的浏览器(或者认为现在已经过时了)以及用户在设置虚拟环境方面的不同技能发挥作用的地方。这往往会转化为花费大量时间来支持不匹配的软件。

为了避免如此大的混乱，有一些工具可以将所有的依赖关系嵌入到特定于操作系统的可执行文件中。经过深思熟虑，我选择了 [PyInstaller](https://github.com/pyinstaller/pyinstaller) 作为我努力的方向。它似乎在支持的平台和格式中提供了最大的灵活性。

他们的 GitHub 库的一个简短摘录很好地总结了这些事情:

> PyInstaller 读取你写的一个 Python 脚本。它会分析您的代码，以发现脚本执行所需的所有其他模块和库。然后它收集所有这些文件的副本——包括活动的 Python 解释器！—并将它们与您的脚本一起放在一个文件夹中，或者放在一个可执行文件中。

这个工具实现了它的承诺。我将它指向我的示例应用程序的 Python 文件，它很容易地用:`pyinstaller sample.py`将它打包到一个目录中。当我想要一个可执行文件时，只需添加`--onefile`参数。

当您需要将非 Python 数据添加到您的包中时，事情变得有点棘手。构成 Sofi 基础的 html 和 js 文件就是这种情况，而 *cefsimple* 浏览器则展示了早期的应用程序界面。PyInstaller 实用程序提供了`--add-data`来实现这一点，允许映射到包中数据文件(或目录)所在的路径。然而，我花了一段时间才弄清楚如何从我的代码中正确地访问这些目录。幸运的是，文档给我指出了正确的方向。

事实证明，在运行 PyInstaller 捆绑的应用程序时，不能依靠`__file__`和类似的机制来确定路径。相反，PyInstaller 引导装载程序将包的绝对路径存储在`sys._MEIPASS`中，并添加了一个`frozen`属性，让您知道您正在包内运行。如果`sys.frozen`是`True`，那么根据`sys._MEIPASS`载入你的文件，否则使用正常的路径函数来确定东西在哪里。

我成功地创建了一个 OSX 捆绑应用程序和一个相同 Python 脚本的可执行 Linux 二进制文件。我验证了我可以用 Windows 可执行文件做同样的事情，但是还没有时间把 Windows 版本的 *cefsimple* 浏览器放在一起测试包路径。

#### 最终产品

关于基于浏览器的用户界面的例子，请看我在 PyCaribbean 2017 上的演讲。

与 CEF 和包装相关的演示是一个图像库，它出现在 18:15 左右。

关于我如何制作 Sofi 的附加阅读，请看一下[一条蟒蛇吃掉了我的 GUI](http://tryexceptpass.org/article/a-python-ate-my-gui/) 系列。

* * *

如果你喜欢这篇文章，并想阅读更多关于 Python 和软件实践的内容，请访问[tryexceptpass.org](https://tryexceptpass.org)。通过订阅[邮件列表](https://tinyurl.com/tryexceptpass-signup)，了解他们的最新内容。