# 如何利用本地存储构建快如闪电的应用程序

> 原文：<https://www.freecodecamp.org/news/how-leverage-local-storage-to-build-lightning-fast-apps-4e8218134e0c/>

尼基塔·科兹洛夫

用户喜欢快速响应的应用程序。他们不想听 API 调用如何耗费时间。他们只想立即看到更新。现在好了。作为开发人员，我们应该努力做到这一点。那么我们怎么能呢？

解决方案是:在本地存储这些更改，然后不时地将它们与您的服务器同步。但是当考虑到连接延迟等因素时，这就变得更加复杂了。

就拿中号来说吧。中型用户可以通过点击一个小绿心向他们的关注者推荐一篇文章(这个页面上也有？).通过第二次点击心脏，用户可以停止推荐它。

### 功能很简单，但是边缘情况会导致很多问题

我不知道 Medium 的应用程序内部到底发生了什么，但为了简单起见，让我们想象一下，第一次点击将一个项目添加到推荐列表，第二次点击将它删除。

让我们看看，如果我们决定在应用中添加类似的功能，这会给我们带来什么样的问题:

1.  我们应该考虑到用户可以开始疯狂点击。这种行为可能会导致一连串的事件。
2.  互联网并不总是很快。在糟糕的网络连接中，即使是最简单的 API 调用也可能需要几秒钟才能完成。在此期间，用户可以离开当前屏幕，然后返回。
3.  API 调用有时会失败，我们的系统需要能够从这种情况中恢复。
4.  用户可以在多个设备上使用同一个应用程序，也可以同时使用移动应用程序版本和相应的网站。无论是哪种情况，我们都应该有一个与后端同步数据以更新其状态的策略。

这不是我们面临的挑战的完整列表，但是这些是本文将重点解决的问题。

### 定义问题

![Hjb48bUy1QlA3xfQFwB96yKGdr8O7PlH-Iy8](img/6b680a022c2664d6c3a6d3acfbffe82a.png)

在我们开始讨论实现之前，让我们定义我们的接受标准。任务是开发一个功能，允许用户添加和删除某个列表中的项目。名单存储在我们的后端。

实施必须满足以下要求:

1.  用户界面对用户的行为立即做出反应。用户希望立即看到他们行动的结果。如果以后我们不能同步这些更改，我们应该通知我们的用户，并回滚到以前的状态。
2.  **支持多台设备的交互。**这并不意味着我们需要实时支持变化，但是我们确实需要不时地获取整个集合。另外，我们的后端为我们提供了用于添加和删除的 API 端点，我们必须使用它们来支持更好的同步。
3.  **保证数据的完整性。**每当同步调用失败时，我们的应用程序应该能够从错误中正常恢复。

幸运的是，我们不需要实现整个特性，而是开发一个允许我们实现它的存储机制。让我们研究一下满足这些要求的不同方法。

### 直截了当的方法

![oLDGe3QJgeliWCKWuLDgQQCdjPlubHuDZK91](img/257cf5b43cc2e1284b3df0c3a198afe9.png)

想到的第一个解决方案是存储列表的本地副本，然后在用户做出更改时更新它。

这种方法的大多数问题都与竞争条件或 API 调用失败有关，例如:

1.  **获取和更改列表之间的冲突。**让我们想象一下，我们开始从后端获取项目来更新我们的本地存储，并且用户在操作完成之前进行了更改。这将导致获取的列表和本地列表之间的合并冲突。所以我们需要区分，例如，一个还没有添加的项目和一个已经从网络或其他设备上删除的项目。
2.  **API 调用失败。**用户可以快速进行大量更改，也可以快速恢复。例如，用户可以向列表中添加一个项目，然后删除它们，再添加回来。如果第一次加法失败了，那么我们应该从中恢复过来。在这种情况下，我们需要从列表中删除该项目。但是这将破坏我们数据的完整性，因为该项目实际上应该在列表上，因为我们进行的最后一次调用是一个添加，它还没有完成。

即使有办法让这种方法可行，我还是认为本地存储应该保存比最终预期结果更多的信息。这将使我们从可能遇到的所有问题中恢复过来。

### 让我们记录下用户所做的一切

![lMQoXy6k3uoNG9h23dxkNilJYjvn390W2iEt](img/f36da8b8c884a3815f3d07f817b3d6f5.png)

这里有一种不同的方法:让我们保留从 API 获取的列表，并记录用户所做的一切。每个记录将匹配一个 API 调用(分别为“添加”和“删除”)。

一旦我们的 API 调用完成，我们可以更新我们的本地副本，并从我们的历史记录中删除记录。当我们想要同步用户的浏览器和我们的后端时，我们只需要获取列表的版本并替换我们的副本。

我们不再有任何 API 调用失败的问题，因为我们知道调用前的确切状态，并且可以从历史记录中删除该记录，而不会丢失数据完整性。

这样做的主要问题是性能。每次我们想要检查一个特定的条目是否在列表中，我们需要检查所有的记录来计算我们的用户应该期望看到什么。

当然，性能取决于我们的用户在一定时间内可以完成的交互量，以及数据存储的方式。再加上记住**过早优化是万恶之源**，所以如果你没有这个问题，那么大概这是一条路要走。

我认为，当用户在应用程序中创建内容时，这种方法非常好，因为它提供了许多处理同步问题的方法。但是我们的问题比这简单，所以我们应该能够进行一些优化，进一步提高性能。

### 中间立场

![uk9K56dmC1IhVJgyo0opNtr6nenHfsAThhrO](img/6212c6ece73a6f92c7edaa1c47bd1513.png)

有可能仅仅有*足够的*信息来从负面案例中恢复。有两个额外的列表——一个用于正在进行的添加，一个用于正在进行的删除——应该足够了。为了确保数据的完整性，您只需要应用一些规则:

1.  添加和删除的列表优先于主列表。例如，假设一个项目同时在移除列表和主列表中。当浏览器检查该项是否在列表中时，它应该返回 false。
2.  一个项目不能同时出现在两个列表中。如果用户对单个项目进行了多项操作，则最新的变更应具有优先权。例如，如果用户添加并移除了该项目，那么它应该在移除列表中。该项目是否在主列表中并不重要。
3.  只有在某个项目的最后一次 API 调用完成后，才能将其从相应的列表中删除。例如，在第一次通话结束之前，用户可能已经添加、移除了该项目，然后再次添加了该项目。在这种情况下，该项目将出现在添加列表中。但是只有在第二次添加完成后，才应该从那里删除它。这可以通过为这些列表中的每个条目分配一个 ID 来实现。稍后，在 API 调用完成后，将使用该 ID 删除该条目。
4.  在每次 API 调用之后，主列表应该被更新。主列表应尽我们所知反映后端的实际状态。因此，在连续添加和删除的情况下，即使从应用程序端看起来项目不在列表中，在第一次调用后，我们应该将其添加到主列表中。

### 关于 API 调用失败的一些话

API 调用失败有不同的原因。有些是暂时的，有些不是。有些是致命的，有些是可以恢复的。不管解决方案如何，即使失败的请求也应该返回一些关于问题原因的信息。

我认为 HTTP 状态代码非常适合这种情况。例如，如果状态代码是 *504 网关超时，*，那么重试可能是一个好主意，但是如果是 *400 错误请求，*，那么很可能一些客户端逻辑是错误的，简单的重试逻辑不会有帮助。其中一些，像 *401 未授权，*可能需要一些用户操作。在移除调用期间 *410 消失*或 *404 未找到*可能意味着用户从不同的设备移除了该项目，并且最有可能的是，我们甚至可以告诉用户操作成功了，因为用户的意图实现了。

如果由于某种原因，您的 API 没有使用正确的 HTTP 状态代码(我甚至不想知道为什么)，它仍然应该提供关于问题原因的信息。否则，您可能会遇到奇怪的问题。例如，如果移除调用失败，因为项目**不再是列表中的**，但是我们没有关于原因的信息，那么应用程序将认为项目**是列表中的**，直到下一轮获取整个列表。

### 结论

第一个解决方案是一个简单的列表。速度很快，但处理负面案例很困难。

在第二种方法中，我们创建了一个类似列表的数据结构，但是保存了所有更改的记录。这可以处理负面案例，但速度要慢得多。

我们的中间立场是一个解决方案——从外部来看——仍然像一个列表。但是它允许我们平衡性能和容易从错误中恢复。

本文提到的问题只是问题的一个方面。另一个是 API 调用的数量。如果用户执行大量类似的交互，我们可以尽量减少 API 调用的数量。这种优化也会影响我们本地存储的结构。

我将在下一篇文章中讨论这一点，并提出这些问题的其他解决方案。

感谢您抽出时间阅读本文。如果你喜欢，别忘了点击？下面。你也可以在推特上关注我。