# 使用 Kotlin 和 Jetpack Compose 创建 Android 应用程序

> 原文：<https://www.freecodecamp.org/news/create-an-android-app/>

Jetpack Compose 是 Android 用于构建原生 UI 的现代工具包。它简化并加速了 Android 上的 UI 开发。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一门课程，将教你如何用 Kotlin 和 Jetpack Compose 创建一个数独 Android 应用程序。

在此过程中，您还将学习图形数据结构和算法。

瑞安·m·凯开发了这个课程。Ryan 是一名非常有经验的开发人员和教师。

以下是本课程涵盖的部分:

*   应用程序设计方法:第三方库极简主义和 MV-无论什么架构
*   域包:存储库模式、枚举、数据类、密封类、哈希代码、接口
*   通用包:扩展函数和变量，开闭原则(OCP)，抽象类，单例
*   持久性(存储)包:干净的架构后端，带 Java 文件系统存储，Jetpack 原型数据存储
*   UI 包:Jetpack 组合 UI 基础，风格，排版，明暗主题
*   UI 组件包:修改器、可重用工具栏和加载屏幕
*   UI 动态游戏功能包:演示逻辑和 ViewModel，带有协程、Kotlin 函数类型
*   UI 活动游戏特性包:数独游戏，包含 UI 和活动容器
*   计算逻辑包:概述、设计和测试 n 尺寸*正方形*数独的图形 DS 和算法

观看以下全部课程或在 freeCodeCamp.org YouTube 频道观看[(3.5 小时观看)。](https://www.youtube.com/watch?v=bo_LP6QOUio)

[https://www.youtube.com/embed/bo_LP6QOUio?feature=oembed](https://www.youtube.com/embed/bo_LP6QOUio?feature=oembed)

## 副本

(自动生成)

在本课程中，您将学习使用 jetpack compose UI 库创建一个 Android 应用程序。

在此过程中，您将学习图形算法和数据结构。

瑞安·m·凯教授这门课程。

他是一个非常有经验的开发者和指导者。

大家好吗？我是 Ryan，欢迎您参加我的图形数独应用程序系列教程。

这是我编写的一个应用程序，主要是为了完善我对图形数据结构和算法的理解，以及 Android jetpack compose 上的新 UI 库。

在本系列的这一部分中，我将概述本系列的主要目标和主题，并讨论一些可能会让您大吃一惊的设计决策。

我会尽量保持项目源代码的公共版本是最新的。

如果有什么东西被弃用或停止工作，你有责任查看源代码。

本系列的格式是 code along 风格，这意味着最好的学习方法是在我解释的时候和我一起编写代码。

对于高级开发人员，完整的源代码可用于直接学习，但是您可以观看视频来清除知识中的任何漏洞。

我使用了 kotlin 语言的一些相当高级的特性和软件架构的永恒原则，所以您可能会学到一些东西。

对于初学者来说，非常重要的一点是，你要按照自己的节奏跟我一起写代码。

一开始你可能感觉不到自己在进步，但是要明白，即使你还不明白自己在写什么，你也在练习写代码的技巧。

我还会秘密地教你如何编写易于编写、阅读、修复、改进和测试的代码。

但是，我们不会要求您记住软件设计的永恒原则，您将在构建这个应用程序的过程中学习和使用它们。

有四个主题，本教程将演示图形数据结构和算法 jetpack 组成干净的 UI 架构，和 kotlin 语言的特点。

我们将探索有向着色图的主题，以及我在编写算法以生成已解决和未解决的 n 个数独谜题方面的实验。

我们将使用 jetpack compose 构建整个用户界面，它允许我们完全用 kotlin 创建 UI。

与 XML 视图和样式相反。

我将向您展示如何使用可靠和干净的架构中通常阐述的原则来连接一个简单的应用程序。

然而，我以我自己的方式教授这些主题，所以不要期望一堆术语或过度工程。

我还将演示如何以及何时使用这种漂亮的编程语言的基本和高级特性。

这部分视频主要面向中级和高级开发人员。

完成本教程并不要求理解这一设计决策。

在整个教程中，你会注意到，除了 compose 和 proto data store，我几乎不使用 Android jetpack 的库事实上，一般来说很少使用第三方库，通过依赖 kotlin 和 Java 标准库以及 Android SDK，我的代码变得更能抵抗库的弃用和更改。

这是因为 Android SDK 和标准库往往比第三方库(比如你看到的 Android jetpack)变化更少。

这也意味着像 jetpack viewmodel、jetpack、navigation 或 help 这样的库可能处理的一些东西必须由我们手工编写。

实际上我喜欢这样，但是你可能有不同的价值观。

如果你对这些工具感兴趣，我的目标不是阻止你学习它们。

话虽如此，您可能会惊讶地发现，在这样一个小应用程序中，没有视图模型导航或依赖注入代码，编写自己的视图模型导航或依赖注入代码是多么容易。

这个应用程序使用模型视图无论架构，这是我的方式说，我不跟随任何人的风格。

研究这个主题已经很多年了，我让我对优秀软件设计原则的理解中的项目需求来指导我的架构。

在这种情况下，我发现 compose 是为基于 MVVM 的方法设计的，但是我出于特殊原因添加了一个表示逻辑类。

这种原因被称为被动观或卑微观。

我没有让视图或视图模型管理每个屏幕的控制流，而是将该逻辑放入一个单独的类中。

这个类非常容易编写和测试，因为它没有第三方依赖。

并且它防止我的视图模型成为一个丑陋的上帝对象。

你应该找个时间试试。

我简单地通过应用软件架构中最重要的原则——关注点分离——来设计这个架构。

系列的这一部分到此为止。

现在我们开始编码。

域包表示两件事，最普通的信息，比如数据类、常量，以及程序必须虚拟表示的足够多的信息。

还有，这个程序必须做的最普通的事情，程序用函数和接口来表示。

本质上，它是我评估的任何新项目的基础，我使用可重复的过程来设计我的领域包或模块。

以获得对该过程的清晰而简单的介绍。

在我的频道上看看这个视频，如何设计信息系统和应用。

这个视频是我给埃及的一些软件工程师做的关于这个特定主题的演讲的录音。

不管怎样，这个包中的大部分代码都很简单，但是它包含了一个设计模式，我现在将介绍这个模式。

这个包包含几个接口，用于采用存储库设计模式。

这种模式也称为外观模式。

模式的一般目标比它的技术定义更简单。

facade 或 repository 模式的技术定义是隐藏子系统的细节，在这种情况下，是抽象背后的数据存储机制，在这种情况下是接口。

让我们看一个实际的例子。

为了使这个定义有意义，我们的表示逻辑类将保存对这些存储库接口的引用，而不是实现这些接口的类。

这给我们的表示逻辑类带来了几个好处。

它们可以彼此独立地构建而不会导致编译器错误，它们可以用接口的伪实现来测试，而不需要我们改变表示逻辑类中的任何代码。

此外，如果我们决定使用不同的接口实现，比如从文件存储切换到房间数据库，我们也可以这样做，而不需要对表示逻辑类进行任何更改。

这些好处是构建松散耦合的软件系统的结果。

存储库或外观模式是促进松散耦合的一种简单方式。

事实上，接口通常倾向于促进松散耦合。

现在不要觉得有必要到处使用这种模式。

一个好的通用规则是在重要的架构边界中使用它们。

在这种情况下，我将它们用作这个应用程序前端和后端之间的边界。

首先，右击域包，进入新的 kotlin 文件，创建一个名为难度的文件。

这将是一个枚举类。

kotlin、Java 和其他各种语言中的 enum 类对于创建一组有限的值非常有用。

正如我们将在后面看到的，您可以在 kotlin 中使用密封类来创建一组受限的类型。

无论如何，除了创建一组受限值之外，枚举的主要好处是可以极大地提高程序的可读性。

正如我们稍后将看到的，让我们添加枚举条目。

很明显，这个枚举将代表一个给定的数独难题的难度。

然而，在继续之前，我们还需要添加一件事，我们实际上将在算法中使用这些条目的一些值，以基本上规定数独难题的难度。

所以为了给 kotlin 中的枚举添加一个值，我们需要给它一个或几个属性。

如您所见，我们的条目现在已被读取，因此很明显，我们需要给它们一些 doubles。

这就是我们在这里需要做的一切。

右键单击主包，转到新的 kotlin 文件进行分类。

我们将创建一个名为 settings 的数据类。

settings 是我们的第一个数据模型，我喜欢称它为普通的 kotlin 对象。

正如我们马上会看到的，它将包含难度和边界，这是数独谜题的大小。

所以一个 4 乘 4 的数独游戏的边界是 4，一个 9 乘 9 的游戏的边界是 9。

当 data 关键字放在 class 关键字前面时，它基本上添加或生成了一些辅助方法，比如 equals hash code 或 copy。

我们以后肯定会用到 copy，也许不是在这堂课，而是在一些课上。

某些点上，我们还会利用生成的哈希代码函数。

不管怎样，这是一个非常简单的类，我们只需要给它添加两个属性。

仅此而已。

右键单击域包，转到新的 kotlin 类或文件。

这一次，我们将创建一个名为用户统计的类。

这将是一个数据类。

现在，这个类的目的是表示用户解决任何特定难度或大小的数独难题的最短时间。

所以我们基本上只是添加一大堆几乎相同的属性。

现在，你可以在 IntelliJ IDEA 或 Android Studio 中做的一件事是，你只需点击那里，然后按 Ctrl D，无论你需要多少次，这将复制到一个新的行。

这堂课基本上就是这样。

现在，你可能会想，为什么我们在这里使用 long，我们实际上是在存储用户完成一个特定游戏的时间，以毫秒为单位。

这就是为什么我们想要长整型值。

同样，右键单击域包，转到 New kotlin filer class，这将是一个名为 Sudoku note 的数据类。

现在，这是我们的数据模型变得更加复杂和有趣的地方。

所以我在这里做的是，我在一个图形数据结构中表示一个单独的节点，我们将在以后的教程中讨论更多关于图形数据结构的内容。

但只是给你一个概念，所以我们实际上要建立一个有向彩色图。

这里需要注意的重要一点是，在这种特殊情况下，颜色这个术语实际上只是指一个数字，它只是我们在某种节点中关联的一个值。

再次，给你一个预览，当我说图形数据结构时，一个更好的名字是网络数据结构，因为它本质上就是这样。

它是节点和边的集合，本质上就像节点之间的线，节点之间的关系。

不管怎样，我们数据结构中的这个特殊的节点结构将会有一个颜色或者一个值，它只是一个从 1 到 9 或者 1 到 4 的整数，包括 00，就像一个空的数独瓦片，但是这是前端更关心的。

这些笔记还会包含一个 X 和 Y 坐标，所以左上角是 X，0，Y，0，右下角是 X，8，Y，8，我们将使用基于 0 的索引。

所以我们不是从 x ^ 1 到 x ^ 9，而是减去 1。

序言到此结束，让我们开始编写代码。

所以我们从 x 和 y 值开始。

接下来，我们将添加颜色，这将是一个变量，因为它可以在整个执行过程中改变。

然后我们将添加一个名为 read only 的布尔值，我会在写完之后解释它是什么。

现在，只读布尔值的目的很简单。

当我们基本上生成并解决了一个数独谜题，换句话说，我们创建了一个新的数独谜题，然后删除了一定数量的线索，使游戏变得可玩和有趣。

数独板上或数独图形数据结构中的一些数字是只读的，这些数字就像是给定的提示，用户不应该能够改变自己。

我们稍后会看到。

这也将影响用户界面，因为我们将绘制只读的数独节点或瓦片，与用户可以编辑的不同。

现在，我们还没有完全完成，我们需要覆盖我前面讨论过的由数据类关键字提供的哈希代码函数，然后我们还需要添加一个函数来获得哈希代码。

好了，哈希代码将有一个默认的实现，它基于不同属性中提供的值，我们实际上只是要做一些不同的事情。

所以我们要输入 get hash，就像这样。

这实际上是我们将要创建的一个函数，我们将在这里为 x 和 y 添加两个参数。

好了，我们现在要添加 get hash 函数，它将是顶级的，这意味着它位于数独节点类的括号之外。

好的，让我们实现这个函数，然后我会解释我们在这里做什么。

好的，让我从解释什么是散列码或散列值开始。

所以它本质上是某种基于某种算法生成的密钥或唯一标识符。

在这种情况下，我有一个非常简单的算法，我所做的就是将 x 值乘以 100。

我不考虑 y 值。

我基本上只是把这两个值组合成一个整数。

现在，我将 X 乘以 100 的原因是，如果我没有在 9 乘 9 的数独游戏中这样做，会有某些边缘情况，即使 X 和 Y 的值在技术上不同，结果哈希代码对于几个不同的节点来说也不是唯一的。

简而言之，我将数字乘以 100，以使数独游戏中的每一个方块的散列码都是唯一的。

至于我们为什么使用哈希代码，一般来说，我会尽量保持简单明了。

基本上，我们将把图中的每个节点存储在一个链接的哈希表中。

因此哈希值将代表该哈希表的键。

哈希映射有键值对，如果你没有意识到，我们马上就会看到。

但是这被证明是非常有用的，因为我们的用户界面也将会以那种 X 和 Y 坐标的样式来表示事物。

所以请相信我的话。

在有大量元素的情况下，哈希代码非常方便，并且您不需要为每个单独的元素维护一个引用。

相反，我们可以通过获取哈希代码来检索引用。

哦，在我们走之前，我们需要在这里添加一个东西，我们要让这个东西实现序列化。

本质上，它允许我们读写数独节点和整个拼图到一个文件中。

因为我们一次只存储一个谜题，所以我并不真的想使用数据库之类的东西，使用文件系统更有意义，而且可序列化本质上使它更容易做到。

好了，我们在这个特定的包中还要创建最后一个数据模型，右键单击我们类的新 kotlin 文件，这个将被称为 Sudoku puzzle。

同样，这将是一个数据类。

我喜欢称之为数据模型的一个好方法是，它们是真实世界对象的虚拟表示，在本例中，是一个数独游戏。

我最初设计这个类的方式是通过问一些关于数独谜题的关键问题。

比如边界，每行或每列有四块瓷砖，还是有九块瓷砖，我们有困难。

最重要的是，我们有图形数据结构本身。

还有用户解决特定谜题所花费的时间。

让我们继续添加这些属性，然后我会解释其中的一些，这些需要在后面解释。

另外，在我忘记之前，让我们在这里添加可序列化的实现。

好吧，所以你可能想知道什么是建立新的数独。

所以我们要做的是，实际上我们要调用一系列顶级函数，这些函数将形成我们所有不同的算法，这些算法是构建和生成一个新的数独谜题所必需的，基于给定的大小，也就是边界所代表的大小和给定的难度。

另外，如果你想知道充满链表的链接哈希表是怎么回事，那是一种表示邻接表的方式。

我将再次详细介绍图形数据结构，以及表示它们的不同方式，或者至少在稍后的特定应用程序中，当我们讨论特定的包和主题时，我将如何表示它们。

但是暂时理解这代表了我们的虚拟数独难题，我们要做的最后一件事只是添加一个小方法，这只是使如何获得图形本身变得更加明显和清晰，至少在我看来是这样。

我们将使用单一表达式语法。

所以我要输入等于图。

让我们创建一个名为 I game repository 的新界面。

我喜欢使用这种命名惯例，即在接口前面加一个大写的 I。

正如我们稍后将看到的，在持久化包中，我将添加一个后缀 I MPL，它自然代表实现这个接口的类的实现。

当设计一个中小规模的应用程序时，你可以做的一件事就是从概念上考虑存储库接口中的功能。

作为用例本身，我们将在这里编写的东西将被称为保存游戏更新游戏更新节点，如果你在用例类型的应用程序设计中做用户故事，这是非常相似的。

所以我想把它放进去。

在一个更复杂的应用程序中，我需要对多个不同的数据源和存储库进行更多的协调，我可能会有一个交互器，或者一个用例，就像人们常说的那样，在 Martin Fowler 或 Robert Martin，Bob 叔叔之间。

但是在这种特殊情况下，在更简单的应用程序中，一般来说，用例作为一个类本身，通常是一个不必要的额外抽象层。

因此，在这里，我们只是与我们的演示者或视图模型或其他东西一起，直接与存储库对话。

对于这种规模的应用程序来说，这已经足够抽象了。

现在，接口是如何工作的，它非常类似于一个类，除了我们马上会看到，我们实际上不被允许实现或者给我们将要写的函数一个主体，我们只是写通常被称为抽象函数或者函数存根的东西。

这里有两个要点。

首先，这里应用了 suspend 关键字，因为这些函数实际上是从 co 例程作用域中调用的，它存在于引用这个特定接口的逻辑类或 presenter 中。

这就是我们现在建立并发性所需要做的一切。

现在，以防你不熟悉，我这里用的是所谓的函数类型。

所以我们要做的是，实际上我们会传入对两个函数的引用，这两个函数存在于逻辑类中，表示逻辑会传入这些函数。

然后在存储库实现中，实现这个特定接口的东西，这就是它们如何回调，并产生某种结果，要么是成功的结果，要么是失败的结果。

现在你可能会想，为什么我们有单位，然后它返回单位，这就是箭头的意思，在这个特殊的例子中？为了让 kotlin 编译器准确理解我们要它做的事情，我们必须这么做。

所以这就相当于传入一个 void，或者基本上没有任何东西到这个函数中，然后从这个函数中不返回任何东西。

但是它会发出类似 oncomplete 的信号，如果你对 RX Java 有任何经验的话，基本上我们只想在调用这个函数时成功地恢复应用程序。

但是这个函数实际上不需要返回任何东西。

稍后，我们将看到一些例子，当我们实际上需要通过我们的 on success 函数类型返回值时。

同样，你可能想知道保存游戏和更新游戏之间的区别是什么？实际上，在更新游戏功能中，我们将大规模编写一个完整的数独游戏，其中包括经过的时间，尽管有些情况下我们真正需要做的只是更新游戏的经过时间，比如当用户离开应用程序时。

因此，我在这里所做的是，根据我们希望从用户的角度实现的目标，创建一些专门的功能。

现在我要演示一下，我们什么时候想从这些特定的函数类型中返回值。

好的，所以对于 onsuccess，我们在这里有效地说的是，这个特定的函数必须用某种布尔值来调用，很明显，当它在这个特定的暂停函数的实现中被调用时，不是真就是假。

现在，基本上，我们在这里做的是，当用户更新一个数独游戏中的单个节点或方块时，有可能这是游戏中的最后一个方块。

在这种特定情况下，假设谜题是正确的，并且用户已经输入了最终的区块，这将表示增益完成。

所以这里可能会有点混乱。

但是 onsuccess 并不一定意味着游戏本身已经完成。

这就是我在这里求导的原因。

好的，现在，在这个特殊的例子中，我们正在做的是当用户返回到一个活动的游戏时，我们显然想要得到一个当前的游戏。

并且实际上存在一种边缘情况，即用户完成游戏后导航离开应用程序，然后重启应用程序。

这就是为什么我们还在传递这个完整的标志。

这里我们显然要返回一个设置对象。

让我们创建另一个接口。

它将被称为数据存储。

这显然是一个接口。

现在，在我们编写接口本身之前，我们要做一些稍微不同的事情。

我们将创建一个结果包装器，或者，让我们说它的灵感来自函数式程序员的一个广告，但是没有人真正关心函数式程序员在想什么或者谈论什么。

Seal 类确实是 kotlin 编程语言中我最喜欢的简单特性之一。

它允许我们在一组有限的类型中进行创建，这些类型可以包含特定的值。

基本上这将会做什么，我们马上会看到，它允许我们从一个游戏数据存储的特定函数中返回一个对象。

这个特殊的物体能够代表多种不同的状态。

就像我之前在 AI 游戏库中展示的那样，在这里，我们将错误状态和成功状态表示为两个独立的函数引用。

在这个例子中，我们将通过一个对象来表示这两种状态。

现在，在我们继续之前，最后一点，如果你有，例如，某种情况，你想表示一个成功的案例，所以相当于在成功时返回单元，你能做的是你实际上可以只使用一个对象，所以你可以说像对象完成，等等。

但是在这个应用程序中，我们实际上并不这样做。

所以你不需要把这个加进去。

现在，让我们完成界面。

创建另一个名为 I 设置存储的界面。

现在，我们还将在这里使用结果包装器。

所以我要把这个复制粘贴过来。

我们将重新命名一些东西。

好了，现在我们可以写接口了。

这个包还需要一个接口。

这个将被称为 pi statistics，如果我可以拼写为 repository 的话，显然，它将是一个接口。

现在，最后一点，再次，是记录将实际上影响用户界面中的东西，基于更新的统计数据是否是记录，即对于特定的边界或数独难题的大小，以及特定的难度，完成的最短可能时间。

公共包包含在各种不同的类和函数中重用的代码。

在教程的这一部分，我们将了解许多不同的 kotlin 语言特性，这些特性是为以智能和高效的方式共享代码而设计的。

涵盖的主题包括扩展函数和问题，这些抽象类，开/闭原则，对象，单例，和协同例程调度程序。

在我们写代码之前，先说一下开闭原理。

OCP 是一个相对令人困惑的概念，但我会尽可能用最清晰的方式来解释它，给你我自己的口头定义，稍后我们会详细解释。

任何通常被重用的软件实体，如果被期望改变，应该有一个固定的公共接口，以及改变其实现的方法。

为了让这个特殊的定义有意义，我需要解开一些东西。

首先，当我说软件实体时，我通常指的是一个类或一个函数，但也可以是其他一些东西。

因此，让我们来看看我所说的公共接口是什么意思，以及为什么我认为如果它经常被重用，那么它应该被修复。

对于公共接口，我不是特指 Java 或 kotlin 接口，相反，我指的是类或函数的任何公开可见的方面。

既然这是一个 Android 教程，那我们就以 activity 类为例。

一个活动符合我的要求，即经常被重用，并期望随着时间的推移而改变。

所以这是一个思考 OCP 的完美案例。

activity 的每个子类都必须包含 onCreate 函数，它是公共接口的一部分，对引用它的类可用。

我们希望这个公共接口不变的原因很简单。

假设 Android 平台开发人员突然决定从所有生命周期功能中弃用和移除保存的实例、状态包。

因为这个公共接口被几乎所有围绕这个平台的 Android 程序使用，所以更新会破坏每个人的代码。

我具体的意思是，所有代码库中的所有 activity 子类，如果没有移除这个参数，将无法编译。

因此，这就是为什么我特别谈论像 activity 这样的通用重用软件实体，以及为什么尽可能少地改变它们的公共接口是重要的。

因为我们已经确定了为什么固定的公共接口非常重要。

下一个问题很简单。

那么，我们如何提供一种机制或方法来实现公共接口的改变呢？事实证明 kotlin 给了你很多解决这个问题的选择。

我将教你如何在代码中使用它们，而不是口头上解释它们。

当我们构建这个应用程序时，右键单击 common 包，然后转到 New kotlin file 或 class。

这实际上是一个抽象类，这里没有给出选项。

所以我们要做的是键入基本逻辑，我们将添加抽象关键字。

不幸的是，我没有时间来解释抽象类和接口之间的区别。

在这门特殊的课程中，这是我在其他视频课程中深入讲解的内容。

但是我要做的是解释为什么我们在这里使用抽象类而不是接口。

我们想要使用抽象类的原因是为了我们想要共享行为的情况。

举个例子，我们将要写一个函数存根或者抽象函数，我想在任何类中共享，它继承自基本逻辑。

我也想共享一个变量，但是这个变量必须被保护，而不是公共的。

如果我们尝试使用一个接口来做这件事，那么这个特定的值必然是公共的，我们也将使用一个泛型类型。

所以我会告诉你怎么做。

所以泛型的语法是只使用尖括号。

然后你可以在这些尖括号之间任意选择。

但是我给你的建议是不要使用已经使用过的东西，这就是为什么我要使用这个全大写事件。

现在，如果我们在这里做的事情没有意义，那么当我们编写从基本逻辑继承的类时，它会更有意义。

让我们继续完成这个。

简单解释一下这个抽象类的意图。

基本上，我是说我想要一组类，从基本逻辑继承的类，所有的类都有这个函数。

换句话说，这些类将处理来自用户界面的事件。

然后，正如我们将看到的，我们将使用这个来自协程 API 的作业对象，作为取消子 co 例程的一种方式。

并且使这些逻辑类中的每一个成为它自己的协同例程作用域。

我会解释，当我们到达教程的特定部分时，右键单击 common 包并创建一个新的 kotlin 文件，它只是一个普通的旧文件，它将被称为 extensions。

gotlands 的扩展函数和扩展属性是我最喜欢的语言特性之一。

这里没有太多的技术，扩展允许你使用开放封闭原则，该原则声明软件实体应该对扩展开放，但对修改关闭。

如果这没有意义，不用担心，这是一个令人困惑的定义。

但是它允许我们向现有的源代码添加新的功能，而不必修改原始的源代码。

现在，这个特殊的文件扩展名. kt 有点像静态实用程序的替代品，我们可能在 Java 或类似的东西中使用过。

它实际上只是一个粘贴应用程序中使用的实用程序代码的地方。

让我们编写第一个扩展函数来看看这是如何工作的。

这个特殊的扩展函数的目的，很明显，它将在活动中使用，实际上只是语法糖，它的方式使我不必键入 toast dot make text 并提供此消息 toast dot length 长和 dot show。

相反，在我们将使用 activities 的活动中，我应该说我们将使用这个特定的扩展函数，我们可以只键入 make toast，给它我们想要显示的任何字符串，它就像这样被处理。

通过使它成为 activity 类的扩展函数，我可以在任何活动中无缝地使用它。

让我们再写一个难看得多的实用扩展函数。

这个丑陋的小函数的目的是获取用户当前正在处理的给定谜题的运行时间，并尝试将其转换为基于分和秒的值或基于分和秒显示的字符串。

现在，如果用户花费的时间超过一个小时，那么我们最终只会显示超过 5959。

如果你觉得这段代码很难看，用 kotlin，我挑战你用 Java 写。

对于初学者来说，这可能在直觉上没有意义，但是理解它指的是什么是很重要的。

这实际上指的是长对象，我们将两次调用它。

当我们真正开始使用这个特殊的扩展函数时，这可能会更有意义。

我们只需要添加一个扩展，这次它实际上将是一个扩展属性。

我现在要做的是按 alt 键，输入这个红色的东西，然后我要按添加剩余分支。

要再次输入我们的，这些显然是字符串资源。

这是一件事，我们不会手写。

因此，希望您已经完成的工作是获取起点的源代码，其中包括字符串资源等内容，再次右键单击公共包，我们将创建一个新的 kotlin 接口，它将被称为 dispatcher provider。

这个接口非常小，我们要做的是编写代码，然后我会简要解释它的作用。

现在，不幸的是，我不能简单地解释什么是协同例程上下文。

但我无法解释这个特殊课程的目的，以及我们将如何使用这些常规上下文。

因此，在大多数情况下，我们将在 co 例程中完成的大部分工作都将发生在主线程或 UI 线程上。

现在，也就是说，有一些像写文件这样的操作，我们实际上不希望发生在主线程上。

在这种情况下，我们将提供 IO 上下文。

现在，这个特定接口的实际用途是这里的关键。

我们要做的是，如果我们想在 JVM 环境中测试任何需要使用这些 co 例程上下文的类，而不是实际运行的应用程序，那么我们可以做的是返回特定类型的 CO 例程上下文，这允许我们在特定环境中进行测试。

我知道这有很多技术细节，但我真的不能再简单了。

然而，通过在这里使用这个接口，当我们想要在生产环境中使用我们的 co 例程时，我们可以为前端提供真正的 UI 主线程上下文，然后我们可以为 IO 线程提供真正的调度程序。

为了更简单，我们只是让代码更容易测试。

右击公共包，转到新的 kotlin 文件或类，这一次，它将是一个对象。

希望我能拼写出正确的生产调度提供者。

同样，我们要做的是在这里写代码，然后我会解释它是如何工作的。

我将再次按 alt 回车键。

在这里，我们将根据这个特定对象的名称返回我们将在生产中使用的实际调度程序。

我在这里使用 object 关键字有很多原因。

所以基本上 kotlin 中的对象在这种特殊情况下是 Singleton 的。

因此，这基本上意味着我们将永远只有一个生产调度程序，一个在特定时间在内存空间中浮动的提供商软件。

它们也是线程安全的，这一点很重要，因为尽管 co 例程不一定是线程，但我们的 dispatchers dot main 和 dispatchers.io 与线程有关。

对象可以做的另一件事是它可以从接口继承。

现在，我们实际上不会在这个特定的应用程序中编写任何单元测试，这需要调度程序，但只是向您展示，如果您想要对需要使用这些 co 例程上下文的某个类进行单元测试，您可以做的是返回 dispatchers dot unconfined，然后为 IO 上下文和 UI 上下文返回该值。

这就是你在 JVM j 单元测试环境中使用的东西。

持久性包包含类和函数，它们的作用是在 Android 进程的生命周期之外持久化或存储数据。

如果你不知道进程是什么，它仅仅意味着一个运行在设备上的程序。

实际上，我们将存储用户在当前数独游戏中取得的进展，以及该游戏的设置，以及用户的个人记录或统计数据，正如我所说的。

下面快速浏览一下持久性包的架构。

在这种情况下，游戏存储库充当两个数据源的后端决策者，协调数据源本身。

只需尝试执行 CRUD 操作，创建、读取、更新、删除，如果抛出异常，则报告成功或失败。

这里的一般原则是把东西放在一起，这是有意义的，把不需要放在一起的东西分开，也使用抽象或接口。

在任何实现可能改变的地方，我可能会决定停止使用本地文件存储或原型数据存储。

因此，对存储库隐藏这些细节并不是过度工程，而是经过计算的决定。

说到数据源或存储机制，我们将使用两种不同的机制来存储数据。

首先，我们将在 pro data store 中存储用户的首选游戏设置和他们的个人统计数据。data store 提供了一种使用协议缓冲区存储这种数据的轻量级和高效的方法。

Protocol Buffers 是一种类似于 JSON 的序列化语言。

但是，我发现它比 JSON 更容易阅读。

幸运的是，我们将使用的库也自带了 protobuf 编译器，它将生成一些样板代码，否则我们将需要自己编写这些代码。

我们还使用设备的文件存储来存储用户在当前活动游戏中的进度。

每个 Android 应用都被赋予了一些存储文件的内存空间，这就是我们将要使用的。

这是通过使所有的域模型实现可序列化来实现的。

并使用 Java 作为输入和输出流来读写 kotlin 语言中的对象。

因此，如果您没有按照教程进行操作，并且没有下载起点存储库，您需要做的是在主源代码集中添加一个名为 pro tau 的目录，起点存储库应该已经有了该目录。

所以只要继续，右键单击它，并转到新文件。

这个文件将被命名为“增益下划线设置”,“点原型”,并确保全部是小写字母。

继续并在文件的顶部键入这个。

所以协议缓冲区本质上就像一种序列化语言。

和 JSON 很像。

如果您想更深入地了解它，您可以了解一下使用 JSON 这样的东西的好处和利弊。

但就个人而言，这是我迄今为止唯一使用协议缓冲区的项目，我对此非常满意。

好，我们再加两行。

我会从那里解释更多。

好的，我们一会儿会详细讨论这个问题。

但基本上，这里要发生的是，我们要定义这个协议缓冲区消息，正如它的名字一样，它有点像一种数据类型，因为没有更好的术语。

我们能做的是，这个文件会被一个叫做协议缓冲编译器的东西使用。

在这种情况下，我们基本上要告诉它的是，我们将生成 Java 文件。

现在在生成的类文件中。

协议缓冲编译器将基本上添加我们放在 Java 包中的任何东西，作为生成的 Java 类文件的包。

不要混淆名称空间之类的东西很有用。

至于第二个选项，这里是 Java，多个文件。

如果您没有打开它，那么可能发生的情况是，基本上，生成的 Java 文件都在一个文件中。

我们并不真的希望这样，尽管我不确定这对于让这个应用程序工作是否绝对必要。

就像我说的，我们将非常实际地讨论这个问题，我不是协议缓冲区方面的专家。

好了，现在，我们要做的是 Line a message，这是一种主要的数据类型，因为在这种特定的语言中没有更好的术语。

好吧，让我们来谈谈我们刚刚做了什么。

因此，我们定义了一个消息，它在协议缓冲区中有点像一个数据类型或字段集合。

我们做了两件事。

所以在游戏设置消息中，我们有一个 32 位的整数，就像一个较小的整数来表示数独游戏的边界。

所以当我说边界的时候，我的意思是一个四乘四的数独游戏的边界是四，一个九乘九的数独游戏的边界显然是九。

我们在这里做的另一件事是，我们在协议缓冲区中定义了一个枚举。

现在当你创建这些枚举时，你需要一个未知的默认值。

然后你得到了枚举可能的其他值。

还要注意，在边界和难度中，枚举上面的字段我给了它默认值，很自然，这些值就像协议缓冲区预加载的值，就像你第一次访问它一样。

现在，这里需要理解的重要事情是，假设您已经将对协议缓冲区的支持添加到您的构建梯度配置中，proto buffer 编译器将实际上从这个特定的消息中生成一些 Java 文件或类。

好的，我在这里做的是我已经打开了完成的项目，我只是在看由协议缓冲编译器生成的文件。

我真正想让你注意的是，当你使用 proto data store 时，它会为你生成一个 Java 类。

显然，您可以看到我们在 camel 案例中设置了增益，这就是我们定义的信息。

然后我们还有下面定义的枚举。

那么这实际上对我们有什么作用呢，基本上，这将允许我们从 Java 序列化或翻译成协议缓冲语言，反之亦然。

这也意味着我们实际上不需要创建我们自己的普通 Java 对象来做到这一点。

图书馆会为我们生成那个。

但是我们仍然可以在我们的代码中使用它，我们一会儿就要这么做，我们要再添加一个原型文件。

所以继续打开 protobuf 目录，再次右键单击，进入文件。

这个将被称为用户统计点原型。

好了，我刚刚复制并粘贴了另一个协议的前三行，因为我们将重用它们。

我们将在这里创建另一条消息。

现在，当我说统计数据时，这有点像我谈论用户个人记录的方式。

那么，在一个特定的数独游戏中，用户解决特定大小和难度的问题的最短完成时间是多少呢？这很简单。

所以我们就写出来吧。

现在你知道了。

现在，你可能想知道为什么我在这里使用 64 位整数。

所以这些实际值将以毫秒为单位存储，这就是为什么我想要 64 位整数存储，而不是 32 位整数。

实际上，我不是 100%确定这是否有必要，但我这样做只是为了安全起见，实际上，它不会占用太多额外的内存。

好了，这就是我们的协议缓冲文件。

现在，我们将不得不创建一些协议缓冲区数据存储，这就是我们实际创建和访问协议缓冲区的方式。

继续，右键单击持久性包，转到新的 kotlin 文件或类，这将是一个名为数据存储的文件。

好的，在继续之前，您需要先构建并制作项目。

现在构建可能会失败，但是我们真正想做的是从协议缓冲区中生成适当的 Java 类。

但是如果因为某些原因，这对你不起作用，就跟着做，最终它会起作用的。

好的，对于每个基于协议缓冲区的数据源，我们需要提供一种方法来获得它或者从上下文中创建它，然后我们需要的另一件事是一个序列化器。

继续导入所有内容。

我们需要在这里的委托中添加两件事情。

好的，所以不要担心它显示为红色实际上会写这个序列化程序。

接下来，我想解释一下这里发生了什么。

因此，我们正在创建一个数据存储对象，它采用协议缓冲区生成的 Java 类，该类称为游戏设置。

本质上，它创建了一个引用，我们可以用它来存储或检索协议缓冲区。

现在，你可能想知道什么是游戏下划线设置。pb，为什么它有一个不同于我们的原型文件的文件扩展名，据我所知的游戏下划线设置。

PB 是编译器事后生成的东西，而 profile 是我们为编译器编写的东西。

但万一我在这点上错了，你可以在推特上炒我鱿鱼。

我们需要的另一件事是一个序列化器，它显然负责序列化。

之后，您只需点击这里，点击 alt insert，覆盖方法，我们只需要来自序列化程序接口的方法。

所以，让我们再次阅读代码，然后我会解释我需要解释的事情。

好的，所以我会尽量简化细节。

很明显，当我们创建数据存储时，它在这里被赋予了游戏设置序列化程序。

串行化器帮助我们从输入流中读取和写入。

换句话说，我们显然要从协议缓冲区文件中读取数据，然后将其序列化，或者说序列化为 Java，反之亦然。

所以基本上，Android 团队在这里为我们做的是，他们使处理错误处理和处理输入流等事情变得更加容易。

因为如果你曾经在 Java 中处理过输入流，那么你会发现，你可能熟悉很多样板代码。

所以基本上，我们在这里做了一点样板工作。

当我们实际上想要在后端使用这个特定的工具进行读写时，它会转化为一个非常简单的 API，我们马上就要这样做了。

好了，现在，很明显，我们需要为其他数据类型编写另一个数据存储和序列化程序。

因此，这将是那些罕见的场景之一，我实际上只是复制和粘贴，因为绝对没有什么新的东西，我们只是要改变几个词。

所以这是我鼓励你把完整的源代码放在一边的原因之一，这样，你可以做一点复制粘贴的动作，就像我现在要做的。

这就是我们完整的数据存储文件。

很明显，如果你有一大堆这样的文件，你可能会想使用单独的文件，但是因为我只有这两个文件，所以我决定把它们放在同一个文件中，右键单击持久性包，进入新的 kotlin 类。

这个将被称为本地游戏存储空间。

首先，我们要做一个常量，它代表我们将要读写游戏数据的文本文件的名称。

接下来，我们将创建构造函数。

因此，您可能想知道文件存储目录来自哪里。

当我们创建这个应用程序的构建逻辑时，这有点像我的控制依赖注入反转类型的东西，接下来会发生的是我们将这个函数调用到 Android 系统，它将从系统返回特定的目录，我们可以在那里读取和写入文件等内容。

让我们继续实现这个接口。

现在，我将试着相对快速地通过它。

但是我想解释的一件事是，你会注意到我相当广泛地使用了帮助函数。

这样做的原因只是为了避免编写多余的代码。

此外，与其他实现一样，我们将使用 width context co 例程生成器来完成主线程之外的这种 IO 工作。

所以我们要做的是调用一个名为更新游戏数据的辅助函数，并把它传入游戏数据中。

如果这个操作成功了，那么我们实际上会返回传入的游戏对象，因为它应该是一致的。

好了，现在我们可以创建助手了。

所以在这里，我们要抛出这个异常，这样它就会被函数中的 catch 块拾取，我们将调用这个 helper。

现在，我们将使用输入和输出流，它们是 Java 标准库的一部分，以便对进出文件的数据进行评级。

如果你想知道这个单词流是什么意思，最终，我们实际上在底层做的是，我们要把我们的游戏或数独难题对象，我们要把它序列化成一个流或一个很长的文本字符序列。

这就是我们实际要从文件中读取和写入的内容。

好的，那么两点，你总是想要关闭你的流。

另外，你可能会想，我们怎么能说点写对象并在数独游戏中传递，但是让我们检查一下这里的参数。

所以我将在参数括号内点击 Ctrl p，如你所见，它接受任何类型。

现在重要的是，如果我们不同的类，如 Sudoku puzzle 和 Sudoku node，没有扩展 serializable，那么我们就无法做到这一点而不出错。

对于更新节点，这有一点不同，我们只是更新一个单独的节点。

这将如何工作呢？我们将获取旧数据，然后我们只需更新单个节点。

然后我们将把结果重新写入存储器。

所以 get game 将是另一个助手，我们写道，我要做的是，我实际上要马上写那个。

否则，自动完成和错误处理的东西将到处都是。

好的，这就是我们需要做的。

现在，这里只是一个快速的提醒，当我们说颜色的时候，实际上，当任何人在图形数据结构中谈论颜色的时候，他们实际上只是在谈论一个数字。

因此，在这种情况下，数字代表放置在特定数独方块中的实际值。

所以它会像从 1 到 9，或者从 1 到 4，这取决于数独的边界，也会更新运行时间。

更新后，我们希望将结果写入存储。

只是为了保持前端与其他所有东西同步，然后我们将返回相同的游戏对象。

我刚刚注意到，我在编写这个函数的时候，忘记了给它添加一个名为 color 的整数，所以我们现在就来解决这个问题。

我们走吧。

我把最简单的留到了最后。

这就是这个文件。

右键点击持久包，进入新的 kotlin 类，这个类将被称为游戏库信息。

因此，如果您不太熟悉存储库模式，实际上我已经在构建域包的本系列第二部分中解释过了。

在任何情况下，让我只是重申，重申这个特定类的目的，它基本上就像是后端的桥梁和决策者。

现在，有时你会有多个不同的存储库或数据集。

在后端，将它们分开可能是个好主意。

我之所以没有这么做，是因为游戏存储和设置存储实际上是密不可分的。

它们本质上是密切相关的。

因此，基于这一点，以及这实际上不是一个非常大的应用程序的事实，我选择将它们放在这个存储库中。

接下来它将如何工作，存储库将协调这两个不同的数据源。

让我们从构造函数和存储库接口开始。

好的，如你所见，我们有自己的工作要做。

所以我要做的是，试着相对快速地编写代码。

写完之后，我会解释它的作用。

所以在这个函数中不应该有任何新的东西，除了我们在一个控制语句中做一个赋值语句，Val current game result equals 等等。

我们被允许这样做，因为 kotlin 是一种美丽而地道的语言。

这个其实很简单。

你知道，对我来说，我不明白为什么它一直在上面放空气。

我一会儿会解释这个函数。

所以 puzzle complete 实际上是一个存在于计算逻辑包中的函数，我们稍后会写，当然，它所做的就是它所说的。

但是它会根据谜题是否完成返回真或假。

因此是完整的。

好的，我在这里做的是复制并粘贴到描述这个特定功能的简单语言用例中。

现在，正如你所看到的，对正在发生的事情给出一个基本的解释是相当复杂的。

为什么当我们请求当前的游戏时，也就是当应用程序启动时，会发生很多不同的事情。

首先，用户可能有一个当前活动的游戏，他们只是想检索它。

这可能是该应用程序的第一次运行，所以目前没有游戏存在于存储中。

此外，在不同的情况下，可能会出现错误。

当您协调多个不同的数据源时，就会发生这种情况。

现在我有了自己的系统来跟踪这些不同的事件流，我基本上用字母和数字来表示步骤和不同的潜在事件流。

但是无论你做什么，我给你的建议是首先用简单的语言写下来，然后继续写代码。

这就是我做的，你看上面的注释，我在写代码之前写的。

不管怎样，我们开始吧。

好的，对于我们的第一个事件流，我们尝试检索当前游戏，并成功返回。

然后我们也想知道当前的游戏是否完整。

我们可以去掉 oncomplete。

又来了。

因此，这显然是用户首次加载应用程序的情况，我们希望创建一个全新的游戏。

看来这次我得手动完成了。

自动完成功能在这里对我没有帮助。

但是公平地说，我们还没有写那个函数。

好吧，我再确认一下我写的对不对。

现在，在我想继续之前，我想解释一下我对软件架构的看法。

虽然有时在一个简单的应用程序中，我们可以让演示者协调不同的存储库或后端数据源。

在这种特殊情况下，有足够复杂的后端逻辑，我想也有一个决策者类，这恰好是后端的这个游戏库 imple，这个类的部分目的是负责协调这些不同后端数据源的逻辑，以便我可以让表示逻辑类做它应该做的事情，管理表示逻辑，然后我让这个类处理这种混乱的几乎是业务逻辑类型的东西。

不管怎样，我们还没完。

好吧，我刚刚想到我在一个游戏库的界面中遗漏了一个功能。

所以让我们继续把它加进去。

所以我要做的就是复制更新游戏，粘贴到下面。

我们称之为创造新游戏。

它将接受一个设置对象，就这样。

这实际上是一个助手函数，我主要是为了易读性而创建的，让我们现在就把它添加进去。

这里还有一个简短的说明，你会注意到我喜欢对正在发生的事情使用非常长的描述性名称。

这主要是因为我对细节没有很好的记忆力。

因此，通过把这些东西做得超级长并且具有描述性，我实际上不需要记住它们，我只需要阅读我的代码，就可以很好地理解它做了什么。

即使在这些复杂的情况下，我们有所有这些不同的事件流和交互发生，好了，只剩下两个简短的函数了。

这就是我们的后端。

在 UI 包的顶层，我们有四个小文件，我们将使用它们来创建和应用样式、颜色、字体等等。

其中一个文件是我们应用程序的全局主题。

我将向您展示如何用几行额外的代码为应用程序创建明暗主题。

请继续关注这一部分的结尾，因为我将对不同的主题进行现场演示。

右键单击 UI 包并创建一个新的 kotlin 文件，该文件将被命名为 color dot Katie。

这个文件本质上是 colors dot XML 的替代文件，如果您习惯于使用基于 XML 的旧资源系统，让我们创建一个 color 对象。

确保导入合成颜色类。

好的，在我们继续之前，最重要的是理解如何读取这些特定的值。

这里的前两个字符是 0x。

这基本上是告诉编译器，也就是将要读取这段代码的程序，这实际上是一个十六进制数。

这里的后两位数字表示 alpha 值的百分比。

Alpha 是透明度或不透明程度的另一种说法。

剩下的三对是红色、蓝色和绿色或 RGB 值，同样是十六进制百分比，这就是关于这些不同颜色值的所有信息。

我已经复制并粘贴了其余的值，因为完全没有必要把这些都打印出来。

但也要记住，它们有一些预定义的值，例如 flack，您也可以在 UI 包中右键单击这些值，我们将创建另一个新的 kotlin 文件。

这个叫做形状。

所以在旧的视图系统中，当你想做一些事情，比如创建一个圆角背景，或者一个按钮或小部件之类的，你通常必须在 drawable 文件夹中创建一些东西，这是基于 XML 的。

同样，因为这是作曲，我们可以直接在 kotlin 中进行。

相反，嘿，我将只使用一些默认参数。

现在，这可能是您第一次看到. dp 扩展名，让我们快速浏览一下源代码。

如你所见，你可以把它附加到一个整型双精度数和各种数字上。

这里需要理解的重要一点是，这基本上是告诉合成框架我们想要使用密度无关的像素。

如果你想要更深刻的解释这些到底是什么，我强烈建议你研究一下，因为它有点复杂。

简单地说，这里的想法是允许框架创建高度和宽度的值，这样的事情可以在各种不同的屏幕尺寸和形状因素上工作。

右键单击 UI 包，我们将创建另一个 kotlin 文件，这个文件将被命名为 type。

现在，如果你想知道，当我们说类型时，我们不是真的在谈论一个类型系统，或与类型理论有关的任何东西，它与类型 Pog，Rafi 或文本有关，以及这些文本是如何设计或呈现的。

所以，这是我们过去经常做的事情，样式点 XML，我们基本上要创建一堆不同的文本样式，它们将在整个应用程序中使用。

然后我们会看到如何将它们包装在一个排版对象中。

然后我们将看到如何将字体对象添加到我们的全局排版主题中。

首先，让我们创建一个文本样式。

有时我们会遇到这样的情况，我们希望保留一组默认值，但我们可能需要一个或两个值，它们实际上是作为参数传入的，用于创建文本样式对象。

因此，我将向您展示使用函数创建这些文本样式的另一种方法。

我要在这里做一些快速复制粘贴。

然后我们可以覆盖颜色。

再说一遍，现在我们已经看到了这里要看到的所有内容，我要对其余的纺织品做的是复制并粘贴它们。

但是在这个特定的文件中，我们还需要创建一个新的东西。

好的，如你所见，我们这里有几种不同的纺织品。

所以我们需要做的最后一件事是创建一个排版对象。

因此，基本上，这意味着我们将分配我们在下面创建的一些文本样式，这些样式用于常见事物，如应用程序特定功能的正文文本、按钮、标题等。

如果这说不通。

我们就写代码吧。

确保您选择的是合成点素材，而不是 kotlin 点 txt。

好吧，我们还要做更多。

好了，我们需要做的另一件事就是设置我们的图形数独主题。

右键单击 UI 包，我们得到了，你猜对了，另一个 kotlin 文件。

它将被命名为图形数独主题。

因此，jetpack compose 的一个方便的小功能是，为亮暗模式创建主题非常容易。

一般来说，作为一个使用黑暗模式的人，几乎总是很欣赏 compose 的这个特性。

该过程的第一步是创建两个不同的调色板。

让我们从浅色调色板开始。

因此，这些属性中的一些对于大多数 Android 开发人员来说应该是熟悉的，比如拥有基色。

在旧的 XML 系统中，我们也是这样用颜色来命名的，或者至少这是一个通用的命名约定。

现在，我想指出的一点是，在某种程度上，这些更模糊的曲面，比如一次曲面上的一次曲面，等等，我用它们只是因为方便，它们不一定有什么特别的含义。

但是这里需要理解的重要的一点是，如果在浅色主题和深色主题之间有任何不同的颜色，我们确实想在这里的某个地方定义它，然后在 composable 中适当地使用它，我们将在后面学习。

好的，按照惯例，这里应该是大写的。

另外请注意，我复制粘贴了深色调色板，因为这里没有任何新的东西。

然而，下一步是非常重要的，我们将创建我们的主题，这实际上非常非常容易。

这是我从一个朋友那里学来的一个小捷径，如果你想创建一个可组合的函数，很快就可以输入 comp，然后按 enter 键，这样可以节省一点时间。

这个主题有两个参数。

所以在我们写函数体之前，我只想讨论一下这两个参数。

正如你所看到的，我们实际上是在黑暗主题中对系统进行函数调用，接下来会发生的是这个系统调用将返回一个布尔值，它将告诉我们用户是否指定了应用程序应该处于黑暗模式还是明亮模式。

然后，内容表示将被包装在该主题中的所有内容。

这里需要理解的重要一点是，我们放在这个可组合元素中的所有东西，即内容可以从主题本身访问所有这些不同的颜色、样式和排版信息。

当我们实际编写 composable 时，它的实际效用会更有意义。

最后，我们将创建一个可组合的材质主题。

我们不需要 lambda 表达式。

现在你有了它，只需要几分钟就可以创建颜色资源、样式和排版信息，这些都是渲染不同模式的深色调色板和浅色调色板所必需的。

我要做的是快速演示一下这在应用程序中的实际情况。

在这里，我将在 light 主题中启动应用程序。

然后，我将导航到操作系统设置，并将其设置为首选的黑暗模式。

返回后，我们立即看到应用程序现在正在使用黑暗主题。

我们现在准备开始构建我们的用户界面。

UI 组件包包含用户界面的可重用元素。

由于这是一个非常小的应用程序，仅有的两个这样的元素是一个工具栏和一个加载屏幕。

compose 的一个重要特性是我们可以用不同的方式重用我们的组件。

首先，如果一个组件需要根据它在不同的父可组合组件或父屏幕中的位置来定位，我们可以传入一个修饰符，而不是在子可组合组件中创建一个修饰符。

如果您还没有尝试过，这是值得一试的。

其次，可以将 composable 作为参数传入，这也允许重用和扩展功能。

在这个应用程序中，我们希望两个不同的 UI 屏幕有不同的工具栏图标。

我们可以通过传入图标堆肥来实现这一点。

从这些父 UI 屏幕中，稍后您将看到我们如何指定和处理不同的图标和不同的点击事件。

使用相同的工具栏也将创建这个可重复使用的加载屏幕，稍后，我会告诉你如何动画，右键单击 UI 包，并转到新包。

这个将被称为组件。

这里简单解释一下，我从组合样本库中采用了这个特定的约定。

因此，放入这个特定文件夹的内容是可组合的，最终可以在各种不同的 UI 元素和不同的屏幕上重用。

在这种情况下，我们将创建一个可重复使用的工具栏，以及一个可重复使用的加载屏幕，右键单击 components 文件夹，转到 New kotlin 文件，这将被称为 app toolbar。

让我们创建我们的函数存根，我要做的是键入 co MP，然后自动完成将创建一个可组合的函数。

这个将被称为应用程序工具栏。

首先，我们来写参数列表，我会稍微解释一下。

确保选择 compose.ui 修饰符。

让我们先来谈谈修饰语。

所以修饰符基本上就是你如何为一个特定的可组合体创建大部分的样式、大小和位置数据。

现在有两种不同的主要方法来做到这一点。

当然，我们可以创建这个修改器并在这个小部件中使用它。

但是这是针对小部件本身将决定这种信息的情况。

因为我们在这里使用了一个可重用的组件，一个应用程序工具栏，我们计划在多个不同的地方使用它。

在这种特殊情况下，我们将把修饰符传递到这个函数中，这基本上是说父 composable 将实际决定这个特殊 UI 元素的位置和大小。

这个标题很容易理解，但是稍微复杂一点的是图标。

同样，这将由父可组合组件中的某些内容决定。

这就是我如何使这个东西可重用，并允许它在被点击时处理不同的图标或不同的动作。

在我们完成这个特定的可组合组件后，我将向您展示我们将使用的实际图标的快速预览。

所以希望这能更有意义一点。

我们要做的第一件事是覆盖顶部的可组合应用程序栏。

让我们暂停一下，谈谈不同的颜色。

所以解决这个问题的一个方法是在这里硬编码某种颜色。

但是在本教程的前一部分，我们经历了设置明暗主题的麻烦。

所以我们现在要做的是，实际上我们要使用一种基于主题的颜色。

还记得在图形数独主题可组合中，有一个函数调用是他的系统和黑暗主题或类似的东西。

这实际上决定了我们选择哪种调色板。

因此，通过使用材质主题颜色点原色，它将根据我们是否处于亮暗模式自动继承适当的颜色。

这是避免在这里硬编码的一个原因。

在这种情况下，无论是亮模式还是暗模式，我们都有一个相同的颜色。

因此，我们将添加一个可组合的文本，这实际上是八个额外的视图。

但是如果你想在标题文本的前面或后面添加一些应用程序的标志，你可以在这里添加一行，然后只添加图标和可组合文本。

然后你就可以出发了。

继续导入它。

这可能是不言自明的。

但是当我们想要继承特定字体的样式数据时，我们可以这样做。

同样，这也是非常方便的。

你只会在 kotlin 中看到这一点，肯定不会在 Java 中看到。

因此，我们在这里做的是，我们明确询问应用程序当前是否处于光照模式，然后我们基于此选择文本颜色。

这实际上只是处理这种条件 UI 逻辑的另一种方式，而不必专门为主题分配一些东西。

接下来，我们将处理对齐问题。

这就是我们工具栏中可组合的文本。

所以动作栏可能是老一代 Android 开发者更熟悉的东西。

但基本上这就像工具栏中的图标。

一般来说，它们用于用户界面中非常重要的操作，比如导航到一个新的特性，表明你已经完成了一些事情。

重要的是要注意，这个特定的 lambda 函数属于行范围类型。

所以基本上，这意味着，如果你有几个动作按钮，你可以把它们放在这两个括号里，它们会自动排成一行。

现在我们所要做的就是键入 icon，然后在这里的括号里加上。

这是因为我们实际上将从父可组合组件中传递这个图标。

正如我刚才所说，我只是想给你一个图标本身的预览。

我们现在还不打算写它，但是我们以后会写的。

这里需要理解的重要一点是，我们正在决定如何处理点击，以及这个东西在父可组合中实际上是什么样子，我们实际上不是在工具栏中做这件事。

通过将这种责任从工具栏中分离出来，这就是我们获得我们想要的可重用性的方式。

右击组件包，转到新的 kotlin 文件，这个文件将被称为加载屏幕。

让我们创建可组合的加载屏幕。

我们首先需要一个曲面。

所以你可能会想，为什么我们在这里特别使用一个表面，在这种情况下，我真的只是想要一个 UI 的空间表面，它有特定的颜色和特定的尺寸。

在这里，我将 Phil max height 设置为 0.8f 的一部分，这基本上是说我希望它占据用户界面的大部分宽度，或者说，对不起，大部分高度。

但是我可能需要一些空间来放广告横幅之类的东西。

无论如何，我基本上想要一个图标或图像，是堆叠在一个进度条的顶部，这将是堆叠在一些类似文本的顶部。

所以在这种情况下，显然我们要用一根柱子。

很明显，我们会把事情摆到中心。

继续导入它。

现在，我注意到它没有不正确地导入我们的，我认为在 Compose 库中有一些东西，基本上模仿了我们的，所以在我们继续之前，让我先修复这些导入。

正如您在这里看到的，我刚刚将它复制并粘贴到我们的导入中。

现在我们可以走了。

那是我们的标志。

这是你的进度条。

好吧，你可能想知道这个画家的事情。

所以基本上，在 alpha 版本的 compose 中，我们必须指定它是矢量资源还是位图资源之类的东西。

所以我们可以使用这个通用的画师资源，把它指向我们 drawable 中的任何东西。

它实际上会判断出它是位图还是矢量资源。

另外，我想在这里指出复制功能。

假设你有一种颜色，你想稍微改变阿尔法值，或者你有一个纺织品，你想对它做一些改变。

复制功能非常方便。

在教程的这一部分，我们将为游戏功能的行为创建事件密封的类视图模型和演示者。

在此之前，让我们看一下该架构中涉及的一些设计决策。

我们的表示逻辑类的目的，我简称它为逻辑，正如它的名字所暗示的，它处理协调容器视图模型和后端存储库的工作。

如果通知一个非停止事件，它也将取消所有的 co 例程，它不拥有任何 Android 平台代码，这使得它松散耦合，非常容易测试。

我也可能会考虑在这个应用的桌面版本中重用它。

但是我们会看到的。

视图模型的目的也是做顾名思义的事情，它是视图观察的用户界面的虚拟表示。

简单来说，它是视图的模型，它公开了函数类型，这是观察者模式的一个非常简单和容易的表述。

在不需要多个观察者的情况下。

每次我们的逻辑类更新视图模型时，视图模型都会自动将新数据发布到视图中。

这个视图模型的另一个设计决策是它没有扩展 jetpack 视图模型。

做出这一决定有几个原因，有些很简单，有些相当专业。

原因很简单，使用 jetpack 视图模型创建了与 Android 平台的紧密耦合。

它有自己的一套样板代码和依赖项，我不太喜欢。

简而言之，在这个特定的应用程序中，它解决的问题并不比它产生的问题多。

我想练习创建可能适用于 kotlin desktop 或 kotlin 的视图模型。

j s。

技术上的原因是，在这个应用程序中，为了获得良好的用户体验，我们不需要跨活动实例或进程死亡来持久化数据。

相反，如果发生这种事件，我们只需对 Android 文件系统进行一次相当廉价的调用，并从那里重新加载数据。

现在，在您将这种推理应用于每种情况之前，请理解从文件系统重新加载数据在这个应用程序中运行良好，但是不应该被认为是您编写的每个应用程序中未保存的实例状态的合适替代物。

如果您喜欢保存状态句柄中的模型，请继续使用它。

我们还使用策略模式来清理我们的逻辑类暴露给视图中的容器的接口。

密封类的每个子类代表一个可以在视图或容器中发生的动作。

而不是每个 UI 事件都有一个函数。

我们有一个函数，它接受一个对象，这个对象可以表示多个不同的执行路径。

这就是策略模式。

右键单击 UI 包，转到名为 active game 的新包，右键单击这个新包，转到新的 kotlin 文件或类，我们将创建一个接口，它将被称为 active game container。

这个单词容器是一个技术术语。

我在这里使用它的方式是表示包含应用程序的大部分或整个应用程序的某种东西。

在我看来，容器通常不会处理太多应用程序的业务逻辑。

它基本上只是把东西连接在一起，构建东西，有点像一个切入点。

在本教程的下一部分，我将解释我们实际上将使用什么作为容器。

但是通过在这里使用一个接口，我基本上相当明确地声明，我可能会改变关于我们使用什么作为容器的想法。

不管怎样，它只包含两个抽象函数。

再次右击活动的游戏包，这次我们要创建一个密封的类。

它将被称为主动游戏事件。

所以正如我在上面的评论中解释的，活动游戏事件密封类表示给定功能的每一种用户交互，在这种情况下，活动游戏功能。

这是我使用的一个非常常见的模式，我们将看到它如何与我们在公共包中创建的基本逻辑抽象类一起工作。

好了，我们现在要创建我们的视图模型。

首先，让我们在这里创建一个小小的类，它就像是数独游戏中单个方块的虚拟表示。

很明显，x&y 代表特定数独瓦片值的 x&y 坐标，将代表我们在图形数据结构中讨论过的颜色，它实际上只是一个数字，我不知道为什么我们需要称它为颜色。

现在它已经聚焦，表明用户已经点击了特定的块，之后他们可以点击其中一个输入按钮来改变该特定的数字。

最后，一个只读的磁贴，你可以把它想象成一个磁贴，就像拼图中给定的线索。

因此，不允许用户实际改变任何只读区块。

所以在我们开始阅读这个视图模型之前，我想在这里提几件事。

正如本节介绍中所讨论的，我实际上并不想使用任何 jetpack 库来实现视图模型和视图之间的发布者/订阅者关系。

现在，事实证明，发布者、订阅者关系或模式实际上很容易实现。

但在这种情况下，我发现使用 kotlin 函数类型来实现我所说的穷人的发布者、订阅者模式或观察者模式更简单。

所以这实际上意味着一些简单的事情，尽管对于那些不熟悉函数类型的人来说，这看起来有点复杂。

我们的视图模型将拥有这些可空的函数类型引用。

正如我们马上会看到的，我们能做的是每次我们从表示逻辑类更新视图模型时，我们可以通过从视图模型中调用这些函数类型来扩展更新视图。

现在，我们在这里使用名人的原因是在视图模型中。

我永远不能 100%确定是否真的有什么在听。

但话虽如此，我觉得如果我花几个小时研究这个特殊的类，我可能会精简一点，也许会使这些内部变量私有或类似的东西。

所以，我在这里要说的是，你可以随意采用这个视图模型的一般想法，它与 Android jetpack 并不紧密耦合，但你也可以随意试验它，看看是否可以优化它。

好了，现在我们来创建一些函数类型。

因此，所有这些函数类型都将以 sub 为前缀，以确保良好的可读性。

活跃的游戏屏幕状态实际上是我们将在本教程的下一部分创建的。

所以继续吧，让它在这里发红光。

好，让我简单解释一下这些不同的函数类型。

所以棋盘状态基本上是数独棋盘的虚拟表示。

显然，内容状态基本上只意味着三种不同的状态。

因此，要么我们加载数据，用户有一个当前活动的游戏，他们正在解决，或者用户已经完成了一个特定的游戏，我们将使用这一点在用户界面的不同状态之间动画。

现在，计时器状态与计数计时器有关，它基本上记录了用户完成一个给定的数独游戏需要多长时间。

为了消除这里的任何混淆，定时器状态将是以毫秒为单位表示时间的实际长值，然后子定时器状态是我们在更新新定时器状态后实际更新用户界面的方式。

让我们完成剩下的变量。

这些显然是默认值。

接下来，我们将编写一个函数来初始化这个视图模型。

好吧，让我们暂停一下。

我们在这里所做的是，获取数据在存储中的状态，将其提供给视图模型，然后我们所做的是构建视图模型自己的虚拟状态表示。

现在，视图模型的内部表示将会有像 has focus 这样的东西，它们特别关注用户界面，而不一定是我会包含在原始域模型中的东西。

此外，如果您想知道，键值基本上是通过散列 x 值和 y 值创建的。

这是我们在本教程中很早就讨论过的内容，以防你已经跳过了。

同样，活动增益屏幕状态是我们将在教程的撰写部分创建的。

这里，我们将数据绑定到视图模型。

然后我们将调用我们的函数类型来更新视图，假设它正在监听。

这就是我们的 init 函数。

现在，我们还有几个函数，我们的演示者将调用这些函数来处理视图模型的状态。

所以在这里，我们只是更新一个单独的瓷砖。

我们在这里做的是，当用户点击特定的磁贴时，它会向演示者发送一条消息，该消息具有特定的 x 和 y 坐标，然后演示者会调用这个特定的函数。

它要做的是，根据 X 和 Y 值，寻找用户点击的瓷砖，并设置焦点等于真。

然后对于每隔一个图块，我们要将其设置为 false。

否则，我们可能会遇到用户选择了多个不同的图块的情况，这不是我们的应用程序应该被允许做的事情，这将是我们的后端已经确定当前拼图已经完成的情况。

右击活动的游戏包。

让我们创建一个新的 kotlin 类，它将被称为主动游戏逻辑。

好了，在我们继续之前，这绝对是我强烈建议在您继续这里的过程中，在一旁打开完整的源代码的情况之一。

很明显，我会尽最大努力不犯任何错误，但也有可能我会犯错误。

活动游戏逻辑表示应用程序这一特定功能的表示逻辑。

正如我们将看到的，它在容器和视图模型之间进行协调，然后扩展到视图，以及应用程序的后端。

让我们从构造函数开始。

好的，在我们继续之前，先回顾一下，目前容器实际上是一个活动。

但是在未来有一种可能性，我可能会转而使用片段作为容器，在这一点上，我并不真的想这样做，但是我们会看看这在未来是否有意义。

但这是我在这里包含一个接口的全部原因，这样我可以很容易地改变接口背后的内容。

视图模型非常清晰，我们刚刚编写了它。

游戏回购是我们存储游戏数据的地方。

因此，这包括游戏设置以及用户游戏统计的当前进展。

repple 是我们存储完成每个不同难度和大小的难题的最短时间的记录的地方。

如果您想知道 dispatcher 是什么，请返回查看我们创建时的通用包，我们创建了这个 dispatcher provider，我基本上解释了它的用途。

基本逻辑也是我们在公共包中创建的。

一会儿我们会看到我们从那个类继承的函数。

好的，让我们开始一会儿关于 co 程序。

因此，考虑作用域的一种方式，无论我们是在谈论 co 例程作用域，还是 dagger 或其他什么，都是真的只考虑它是一个生命周期。

现在，你可能想知道，为什么我们不做一些像视图模型或片段或活动的东西，我们的生命周期类？好吧，如果你现在还没有注意到，我不喜欢任何形式的与 Android 平台的紧密耦合，如果我可以避免的话。

还有很多其他原因。

但最主要的一点是，因为这个类包含所有的表示逻辑，在某种意义上，它是应用程序这一特性的主要决策者，那么，在我看来，让它负责取消任何 co 例程是有意义的，这些例程碰巧当前运行到这个 on event 函数，我们从基本逻辑继承而来。

嗯，基本上，这是策略模式的一个实现。

这里就不做长篇大论的技术性解释了。

这实际上是一个非常简单的模式。

但基本上，它提供了一个进入这个特殊类的切入点。

因此，对于每个事件，我们有一个函数，它接受一个参数，我们的活动游戏事件，它能够表示所有不同的事件，我只是发现它真正清理了不同类之间的接口，接口是在那个声明中的一般意义上使用的。

好的，首先，让我们实现我们的 co 例程上下文。

记住，jobtracker 存在于基本逻辑中，但是我们也需要初始化它好的，现在在我们继续之前，我们需要实现一个非常重要的东西，那就是 ko 例程定时器。

正如我之前提到的，活跃的游戏屏幕有一个计时器。

现在你们中的一些人可能会奇怪，为什么我没有使用 Java 定时器类或者机器人计数定时器或者其他什么东西。

基本上，我尝试过使用这些东西。

他们提出了不同的应用程序中断问题。

事实证明，最简单的方法就是创建这种 CO 常规计时器。

很明显，这需要一点解释。

所以我们会注意到这里有两个不同的关键字，你们有些人可能不熟悉，我们有内联和跨内联关键字。

所以每当你看到 inline 关键字，最简单的理解方法就是理解它的意思就是复制，粘贴。

如果你想知道这在代码中意味着什么，那么我建议你反编译一些 kotlin 代码，它使用了 inline 修饰符，你会看到 inline 函数实际上是如何被复制并粘贴到调用点的。

现在我们有了其他的东西，这是一个跨内联函数类型。

所以在我解释什么是跨内联动作之前，让我们来讨论一下这个函数实际上是做什么的。

这里我们有一个非常标准的自旋锁，虽然是真的。

所以这是一个循环，它会无休止地执行，它会调用那个函数类型，然后它会延迟 1000 毫秒。

现在，这里发生了一些不同的事情。

第一，你必须明白，我们将延迟这个 ko 例程，但它实际上不会阻塞它所在的线程，这当然是一个大胜利。

现在这里要做的另一件事是，action 将是一个 lambda 表达式，我们将把它传递给这个特定的函数。

实际上，crossing line 做的唯一一件事就是，在 lambda 函数中，我们将把它传递到这个函数中，我们不允许在这个函数中写一个 return 语句。

所以从最普遍的意义上来说，我们正在做的是采取预防措施，以避免我们可能从 lamda 内部意外返回，导致意外行为的情况。

现在，你可能想知道，既然我们有这个无限的循环，我们实际上如何停止这个特殊的核心例程？我们要做的是创造一份工作。

我们现在就开始吧。

我们接下来要做的是，将这个 job 变量赋给我们的 start co 例程计时器，这样我们就可以取消它了。

让我们写另一个快速扩展函数来处理这个定时器事务，然后我会解释它做什么。

在用户界面的实验中，如何使计时器最不容易出错或最准确，结果是，每次我们将值写到后端时，从值中减去 1，就创建了一个更一致的计时器。

但是一个特殊的情况是，如果值等于零，那么显然我们不想从中减去一。

否则计时器一开始会显示负一，这看起来不太好。

好了，所有这些都完成了，我们可以开始实现表示逻辑的其余部分了，所以当用户点击输入按钮时，我们可以有两种不同的情况发生。

在一种情况下，用户已经选择了将成为焦点区块的区块。

或者可能他们只是点击了一个输入按钮而没有真正聚焦一个磁贴，在这种情况下，我们真的不想做任何事情。

好的，如果你想知道游戏回购的细节，你可以回到教程中我们实际构建它的部分。

基本上，我们将创建一个 lambda 来表示成功的情况，然后创建另一个 lambda 来表示错误异常的情况，这样会更容易理解。

我将在这里添加一个评论。

好的，如果你又想知道如何取消计时器，这就是我们要做的，我们取消作业对象。

现在我们马上要写另一个函数。

基本上，如果它是一条新记录，那么我们希望呈现的用户界面与不是记录时略有不同。

但在此之前，让我们完成错误案例。

因此，为了实际知道它是否是记录，我们实际上需要将值传递回 stats repo，以便进行检查。

老实说，这个应用程序中的错误处理并不是最好的，也不是最差的。现在只是显示一条提示消息，解释发生了一些错误。

好吧，只是一个快速修复。

这实际上应该是经过的时间，而不是计时器状态。

接下来，我们点击了一个新游戏。

您会注意到这里有一个重复出现的主题，即我们希望在任何时候执行并发操作。

因此，无论何时我们使用后端，我们都将把它包装成一个启动 co 例程。

有许多不同的方法来处理 CO 例程。

这只是最简单直接的方法之一。

在我看来。

好的，我们现在要做的是首先询问视图模型用户是否完成了当前游戏，如果没有，我们实际上想要存储用户在当前游戏中的进度，当他们点击新游戏时，因为他们可能是偶然点击的，或者他们想要能够返回并完成游戏或者类似的原因。

没错，随时间更新功能。

同样，我们有成功和失败的案例。

希望这一点已经很清楚了。

接下来，我们将实现该函数。

接下来，我们将编写取消填充函数。

所以基本上，取消填充功能实质上取消了每个 ko 例程。

接下来，我们开始写。

我之前忘了说，我们在函数中加下划线的原因是完全的。

这只是 lambda 参数的一种约定，实际上并没有被使用。

在这种情况下，我们将使用它。

很明显，这是我们启动协程定时器的地方，我们只希望在调用 on start 时这样做。

现在，我觉得我本可以处理得更好一点，把应用程序的标准流程视为例外有点违背我的规则。

但基本上，我们在这里要做的是，如果我们请求当前游戏的存储，它实际上并不检索任何东西，一般来说，这种情况会在用户第一次运行应用程序时发生，因此，实际上不会存储任何数据。

所以在这种特殊情况下，我们会这样做。

现在，我们也可能因为某种合法的例外而在这里结束，但在这种特殊情况下，我仍然认为导航到新的游戏功能实际上仍然是一种处理好的方式，但可能不是最好的。

接下来我们有一站。

好的，所以 onstop 实际上是绑定到 Android 活动的生命周期或者它所绑定的片段上的。

所以当这个函数被调用时，基本上意味着我们想要保存用户当前的进度，然后关闭所有的东西。

最后，我们有一个焦点。

因此，这将是当用户实际选择一个特定的数独瓷砖。

这个函数非常复杂，所以做好准备。

好吧，唱首歌。

这实际上是我们需要做的一切。

在教程的这一部分，我们将为活动的游戏功能创建用户界面。

在继续之前，我强烈建议你看我的视频，题为如何理解 jetpack compose 一个初学者指南，以组成和阅读组成。

我们将会写很多可组合的东西，并且设置 re 组合。

但是那个视频是为刚开始作曲的人制作的。

它解释了什么是 composable，什么是 re composition，以及如何避免以错误的方式进行 read composition。

相信我，如果你不知道它是如何运作的，那么很容易把阅读作文搞砸。

我会在下面的评论中链接到这个视频。

这个视频充满了大量的信息，所以请看看下面描述框中的时间戳。

主题包括基本部件，如文本、文本、按钮、图像、图标、间隔和分隔线布局，如带约束的框列行框和我最喜欢的约束布局。

简单的过渡动画，以动画之间加载屏幕，积极的游戏和完整的游戏。

我还将向您展示如何使用函数类型和 lambda 表达式与我们的表示逻辑和视图模型进行通信。

不过，在我们编写组合代码之前，我将向您展示如何将一个活动设置为可组合的容器。

对于片段来说，这样做的过程几乎是相同的，如果您喜欢的话，我还将向您展示如何编写一个非常简单的依赖注入扩展函数，它对前端隐藏了后端的细节。

右键单击活动的游戏包，转到新活动并选择一个空活动。

并确保取消选中生成布局文件。

而这个活动将被称为主动游戏活动。

这将是启动器活动。

如果你想知道为什么我们使用这个向导而不是仅仅创建一个类文件。

原因很简单，通过使用向导，它将向清单中添加一个条目，因此我们不必这样做。

简单回顾一下此活动的目的，它是一个特定于功能的容器。

让我们从创建对活动游戏逻辑类的引用开始。

接下来，让我们实现活动游戏容器接口。

点击红色并按下 alt 回车键。

对于 show error，我们将使用我们在本教程前面创建的扩展函数。

继续导入。

如果你想知道，这是一个单一的表达式语法，它只是用等号代替了括号和返回语句。

新游戏点击下一个实现。

现在很明显我们还没有创建新的游戏活动，所以在我们创建之前它会显示为红色。

我们还需要覆盖另外两个生命周期方法。

这里将告诉逻辑类一切都准备好了，然后我们也将覆盖 stop。

这显然会向逻辑类发出信号，是时候取消一些东西了。

最后，我们只需要在创建时添加几行代码。

首先，创建视图模型。

现在，这是一个非常重要的部分，我们接下来要做的是将我们将在本教程的下一部分创建的可组合组件锚定到这里的活动。

这也是你可以在片段内部调用的东西。

继续导入它。

很自然，我们会将所有内容都包含在我们的作曲主题中。

现在，这是一个需要理解的非常重要的事情，也是一个非常重要的模式。

因此，当我们创建活动游戏屏幕时，我们将传入一个函数类型，它将作为我们的事件处理程序，这基本上是我的说法，这是我们转发事件的方式，onClick 事件和类似的东西，发生在可组合到我们的表示逻辑类中。

所以一定要注意我在这里说的话，因为这是一个非常重要的部分，即使你不使用主持人的木材，或任何东西。

函数类型是处理点击事件的一种很好的方式，特别是如果你把它们和策略模式结合起来，我们在上一节已经讨论过了。

好的，现在，如果你从未见过函数引用，我相信它叫做基本上我们在这里做的是，我们指向逻辑类的 on 事件函数。

这确实是一个函数引用。

所以希望你能理解我在这里说的。

我们还将传入视图模型。

最后，我们实际上需要构建我们的逻辑类。

所以我们要做的是，在一个扩展函数中写代码，但是我们首先要做的是在这里读它。

这就是我们在活动中需要做的一切。

右击激活的游戏，进入新的包，这个包将被称为构建逻辑。

右键单击该包并转到新的 kotlin 文件或类将是一个文件。

它将被称为建立积极的游戏逻辑。

如果你已经看了我的频道或直播一段时间，你会知道我谈论了很多关于依赖注入服务定位器的内容。

我一直在说的一件事是，在一个小的应用程序中，你真的不需要使用 di 容器，像刀柄，匕首，无论什么，你都可以使用它。

但是我总是建议初学者先写这些东西为你自己生成的代码，这样你才能明白这些框架在为你做什么。

所以这正是我们要做的。

我们将编写这些框架为您生成的东西。

在一个小的应用程序中，它实际上是非常简单的代码。

当然，它会返回主动的游戏逻辑。

好吧，让我们暂停一下。

因此，如果您想知道我们如何获得这个应用程序可以使用的存储目录的路径，您可以调用上下文点文件 dir 点路径。

最后，我们的调度员。

这就是我们需要做的。

右键单击当前游戏特性，创建一个名为当前游戏屏幕的新 kotlin 文件。

首先，让我们创建一个枚举。

该枚举表示用户界面的该特征可以拥有的不同状态。

实际状态保存在视图模型中，但是我们将看到如何通过绑定到我们在本教程的上一部分中创建的视图模型函数类型来更新我们的可组合 UI。

活动的游戏屏幕代表根组件。

在这个可组合的层次结构中，它负责设置 UI 的核心元素，并在它们之间制作动画。

事件处理函数类型引用是我们回调表示逻辑的方式。

当用户与应用程序交互时，它必须被传递给任何有这种交互的可组合组件，我们也传入视图模型，这就是我们如何将数据传递给我们的 UI。

用非常简单的语言来说，每当我们有某种可能在运行时改变的数据或状态时，我们都希望将该数据包装在一个记住的委托中。

这告诉幕后的 Compose 库注意变化，并在发生变化时重绘 UI。

现在可变转换状态在这里专门用于动画，所以不要到处使用它。

稍后我们会看到一个更通用的记忆状态的例子。

记住，delegate 为更新准备了 compose，但是我们还需要一种方法来实际更新值。

我们通过将一个 lambda 表达式绑定到视图模型拥有的一个函数类型来实现这一点。

当在视图模型中调用其中一个函数时，程序会自动跳转到我们的 composable 中并执行这段代码。

这实际上触发了 re 合成。

我们有一个记忆的转换状态和一种从视图模型更新该状态的方法。

现在我们需要设置过渡动画本身。

在这里，你可以尽情发挥创造力。

在这个应用程序中。

每个内容状态都有自己的相关组合。

我们简单地通过改变 alpha 值或透明度来在它们之间制作动画。

现在它真的像刚才一样红了，我解决的方法是手动导入 Compose 运行时。

所以转换规范告诉合成动画应该是什么样子的细节。

从本质上说，这意味着我们不必编写自己的数学指令，这对像我这样算术很差的人来说很好。

compose 的一个选项是使用可组合的支架作为 UI 的框架。

我个人更喜欢自己做这件事，因为它并不真的那么难，而且对我来说没有任何隐瞒。

首先，我们有我们的应用程序工具栏。

让我们继续创建新的游戏图标。

这些图标来自作曲素材库，我强烈推荐你使用它。

这就是我们实际触发点击事件的方式。

正如在教程的前一部分所解释的，通过在这里创建我们的工具栏图标，并将其传递到可组合的应用程序工具栏，我们使应用程序工具栏可重用。

工具栏下面是这个屏幕的主要内容，有三种不同的状态。

每次发生重组时，这条语句将被再次执行。

当过渡动画出现时，alpha 值的动作将改变，从而淡出先前的内容状态并淡入新的内容状态。

显然，我们将在一会儿创建这些。

这就是我们的可组合路线，我们 UI 中最复杂的部分来自一个活跃的数独游戏。

一个九乘九的拼图有 81 个不同的文本可以组合，这是一个很大的部件数量。

我编写这个可组合程序的方式是将数独游戏的每一部分看作一个特定的层或元素。

一定要避免通过使用助手函数来编写 God composable，这些函数将 UI 分解成最小的合理部分。

带约束的盒子有点像一个可组合的包装器，它给我们关于高度、宽度和其他尺寸的信息，我们可以在它的 lambda 表达式中使用这些信息。

我们需要知道屏幕的宽度来决定数独板应该有多宽多高。

这里我们要求这个约束布局的最大宽度。

这里我们要求这个布局组合的最大宽度。

但是我们需要这个值是与密度无关的像素，并且它还需要与当前屏幕的密度相关。

这就是双 dp 扩展功能的用武之地。

它使用局部密度来确定该值。

纸板的边距也需要根据屏幕密度而变化。

我只是通过使用模拟器在不同密度下测试应用程序来得出这些值。

接下来，我们将编写一个约束布局，这是一个管理动态布局的非常棒的方法。

现在，为了约束可组合组件之间的相互关系，我们需要一种方法让它们相互引用。

这相当于为 XML 视图设置 id。

首先，我们创建这些引用，稍后您将看到如何绑定它们。

让我们为拼图板创建一个布局容器。

好的，这很重要，看看我们如何在约束参数中传递引用。

这就是我们如何将一个特定的可组合对象与一个特定的引用关联起来。

这个可组合的盒子将与名称板相关联。

接下来，我们将创建数独板本身。

同样，边界就像拼图的大小。

所以要么是四乘四的拼图，要么是九乘九的拼图。

所以边界要么是 4 要么是 9。

这应该是说尺寸。

因此，这里的偏移量用于平均分配每个数独、平铺和网格线的屏幕空间。

这里有一种方法可以创建一个与某种过渡动画无关的可变状态。

所以这是更通用的方法。

因此，这里的第一个参数 view model dot board state 可以被认为是初始值，never equal 策略确保即使状态发生微小的变化，如焦点实际上会触发重新合成。

同样，这也是视图模型更新后我们实际更新值的方式。

正如你所看到的，在这里，我再次使用了许多辅助函数来分解事物。

在这里，我们呈现了表示拼图中瓷砖的文本字段，它们可以是只读的，也可以是可变的，这意味着我们需要稍微不同地呈现它们。

所以在这里，我们说，如果用户设置一个特定的瓷砖值为零，我们实际上只是想把它作为一个空瓷砖。

这里的主要思想是，我们使用每个单独图块的 x 和 y 值以及偏移量来均匀地定位每个图块，这样当用户选择一个图块时，它将成为焦点，我们希望渲染该图块与未聚焦的图块明显有一点不同。

现在我们将渲染只读方块。

接下来，我们将创建电路板网格。

所以 Sq RT 是一个扩展，实际上是在计算逻辑中定义的。

回想起来，我可能应该在公共包中定义它，但是它的作用是很明显的。

这个函数，我们将画出分隔数独谜题的网格线。

为了让用户更清楚哪些是子网格，我们绘制了不同的边界来分隔 4 乘 4 或 9 乘 9 的子网格。

这就是为什么我们在这里使用模。

这将画出垂直线和水平线。

好的，所以我们跳回游戏内容组合来结束它。

在我们的数独板下面，我们有一些不同的图标来表示这个难题的难度。

接下来，我们需要一个用于倒计时的布局容器，它很棒，计时器文本是可组合的。

现在默认值，只是空的。

好了，我们回到了游戏内容可组合。

我们需要做的最后一件事就是为输入按钮添加一个布局容器。

现在我们要在这里硬编码一些值，这是一种不好的做法。

但原因是 Compose 团队弃用了 flow row，我仍然对此感到不安，它在这种情况下工作得非常好，我自己也懒得实现 flow。

嘿，至少我是诚实的。

如果你想知道，0.4 和 5 点 9 将发出一个包含这些值的范围。

让我们创建一个不言自明的可组合的间隔，它只是在布局中占据了一些空间。

接下来是按钮本身。

这个文本按钮包装器允许我们设计一个好看的按钮，而不仅仅是点击一个文本组合。

好了，这就是增益内容。

现在我们需要做游戏完整内容屏，这显然是当一个用户完成一个游戏的时候。

所以这基本上只是两张叠加在一起的图片，但是如果它实际上是用户创建的新记录，我们将只呈现其中的一张。

因此，由于我们实际上没有创建表情符号事件图标，我们可以使用这个颜色过滤器来改变它的颜色。

非常方便。

接下来，我们有两个可组合的文本。

仅此而已。

恭喜你。

