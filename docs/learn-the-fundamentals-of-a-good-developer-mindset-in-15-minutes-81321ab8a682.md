# 在 15 分钟内学习好的开发人员心态的基础

> 原文：<https://www.freecodecamp.org/news/learn-the-fundamentals-of-a-good-developer-mindset-in-15-minutes-81321ab8a682/>

*“即使是很小的改变也很难”*

*“通过更改破坏软件的功能”*

*“通过修复另一个 bug 引入一个新 bug”*

*“实现不必要的代码”*

*“由于代码复杂，几乎不可能添加新功能”*

*“永不发货产品”*

*“扔掉代码，从头开始重写”*

以上说法大家都熟悉吗？

每一分钟都有来自世界各地的开发人员说出(或想到)上述任何一句话，并且想哭。为什么？

这些是开发人员经常谈论的常见问题。这些故事是每个开发团队都经历过的。

有很多小因素会慢慢地、逐渐地伤害一个开发者的项目。它们不会立即造成破坏。大多数只会造成长期伤害。一些你在一年或更长时间内看不到伤害的东西。因此，当有人提出这些建议时，它们听起来往往是无害的。

甚至当你开始实施它们的时候，它们看起来很好。但是随着时间的推移，特别是随着越来越多的这类事件堆积起来，复杂性变得越来越明显，直到你成为这个司空见惯的恐怖故事的又一个受害者。

为了避免成为受害者之一，您应该接受软件的基本法则。你要养成每个开发者都应该有的心态。这种心态将帮助你在日常编程旅程中做出更好的决定。你可以让你的软件尽可能简单。您可以防止它成为一个难以管理的复杂系统。

以下是每个开发者必须掌握的要点。

### 1.构想软件的目的

首先你要明白软件的用途。事实上，所有软件都有一个单一的目的:帮助人们的**。**

> ******记住:软件的目的不是炫耀你有多聪明。****——[麦克斯·卡纳特-亚历山大，代码简洁](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)**

**不能理解软件用途的开发人员会写出糟糕的软件。什么是坏软件？一个对人们没多大帮助的复杂系统。**

**当你在做关于软件的决定时，你应该始终牢记这一点来指导你自己:*我们如何帮助你？*您甚至可以通过这种方式对功能请求进行优先级排序。**

### **2.软件设计的目标**

******每个程序员都是设计师。******

**当软件很难创建或修改时，开发人员将大部分时间花在使事情“正常工作”上，而较少的时间花在帮助用户上。软件的设计旨在使开发人员的工作尽可能简单，这样他们就可以专注于重要的事情。你将创建能帮助用户的软件，而你的软件将会长期帮助他们。**

**然而，如果你设计了一个糟糕的系统，你的软件的生命周期将会很短。**

**这让我们想到了软件设计最重要的目标:**

> **设计开发人员可以尽可能容易地创建和维护的系统，这样它们就可以——并且继续——尽可能地有所帮助。——[麦克斯·卡纳特-亚历山大，代码简洁](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)**

**所以这里有两个关键点:你的设计应该对你自己容易，对别人有帮助。**

### **3.(错误)理解**

**不完全理解自己工作的开发人员倾向于开发复杂的系统。这可能会成为一个恶性循环:误解导致复杂，从而导致进一步的误解，等等。**

**实际上，提高你的设计技能的最好方法之一是确保你完全理解你正在使用的系统和工具。**

> ******理解是一个坏开发者和一个好开发者的关键区别。****——[麦克斯·卡纳特-亚历山大，代码简洁](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)**

**坏的开发者不明白自己在做什么，好的开发者明白。真的就这么简单。**

### **4.简单**

> **简单是最复杂的。—莱昂纳多·达芬奇**

**编程是化繁为简的行为。“糟糕的开发人员”就是那些不能降低复杂性的人。一个“好的开发人员”会尽其所能让代码对其他程序员来说尽可能简单。**

**一个好的开发人员会创建易于理解的东西，这样就很容易解决所有的问题。**

**现在，开发人员一般都是聪明人，他们都不喜欢被当成白痴。具有讽刺意味的是，这导致他们有时会创造出有点复杂的东西。他们基本上是这样想的:**

**哦，其他开发者会理解我在这里所做的一切。我应该写一些很难理解的聪明的代码，让他们觉得我很聪明。**

**错误的思维方式导致的错误——不一定是缺乏编程技能。大多数编程失败都是因为这种心态。**

**炫耀自己聪明对他们没有帮助。**

**不熟悉您的代码的开发人员对此一无所知； ****他们必须学习。******

**所以，你应该问这样一个问题:“*我是希望人们明白这一点并感到快乐，还是希望他们感到困惑和沮丧？***

**事实是，如果阅读你的代码的其他开发人员可以很容易地理解它，这意味着你做得很好。**

> **复杂与智慧无关，简单才是。—拉里·博西迪**

**问题是:“你得有多简单？”**

**下面是你的答案: *****笨，笨的简单。*******

### **5.复杂性**

> **控制复杂性是计算机编程的本质。—布莱恩·克尼根**

**许多软件失败的根源是复杂性。你从一个可以在一个月内完成的简单项目开始。然后你再加上复杂性，这个任务最多需要三个月。然后，您开始添加满足其他目的的功能。事情变得非常复杂，因为你毫无理由地扩展了你的软件用途。这些任务需要六个月的时间。**

**但这并不是结束。**

**然后你把每一个特征都变得更加复杂，这个任务需要九个月的时间。然后，由于代码的复杂性，你开始引入许多新的错误。很自然地，你开始修复它们，而没有考虑这些修复会如何影响其他部分。最后，即使是很小的改变都变得很难。当 bug 修复开始引入新的 bug 时，你就会来到一个最流行的编程恐怖故事:*从头重写代码*。**

**那么，你是如何成为这个恐怖故事的受害者的呢？不，谁在乎。最好是问:你如何避免成为受害者？**

**嗯，很简单。首先，你将确切地知道你的软件目的和它的定义。第二，你写的每一段代码都会尽可能的简单。第三，当一个新的特性或变更请求出现在讨论桌上时，你将根据你的软件目的对它们进行评估并提出问题。**

**作为开发人员，你的第一个行为应该是抵制(不必要的)变更。这将防止您在软件中添加不必要的代码。当你确信这种改变是一种需要时，你就可以实施它。**

**有许多因素会增加复杂性，但这些是最常见的。抛开一切不谈，只有一条规则你应该遵守:**

******你的主要目的是控制复杂性，而不是创造复杂性。******

### **6.维护**

**维护是软件开发中最重要的事情之一。不幸的是，开发者通常忽略了它的重要性。快速编码和快速发货看起来比代码维护更重要。这是他们犯错误的地方——忽视未来的代码维护。**

**总会有一些改变的实现。你不仅要实现它们，而且还要长期维护它们。作为开发人员，考虑变更的未来维护是您的主要职责之一。**

> **所有的变化都需要维护。**

> **简单和复杂是影响代码维护的两个主要因素。任何软件的易维护性都与其单个部分的简单性成正比。维护工作与软件的复杂程度成正比。**

> **关于维护，您应该遵循的一条规则是:**

> ******减少维护的工作量比减少实现的工作量更重要。******

> **— [马克斯·卡纳特-亚历山大，代码简单](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)**

### **7.一致性**

> **一致性是简单性的重要组成部分。如果你在一个地方用一种方式做某件事，那么在每个地方都用那种方式做。例如，如果你把一个变量命名为 thisIsVariable，那么你所有的变量都应该这样命名(otherVariable，anAnotherVariable，等等。不是 other_variable)。–[Max Kanat-Alexander，代码简单性](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)**

**不一致的代码变得更加难以理解。不要总是强迫开发人员在每次看到一个新的部分时重新学习系统的工作方式。**

> **在任何团队运动中，最好的团队都具有一致性和化学反应。——罗杰·斯陶巴赫**

### **8.优先处理**

**你如何对你的软件做决定？**

**当你面对许多可能的方向时，你如何决定哪一个选项是最好的？关注什么，应该实现哪些特性？**

**要回答这些问题，有三个重要因素可以帮助你做出更好的决定。这个等式在[代码简单性](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)一书中有很好的解释:**

*   ******改变的可取性(D):**** 你有多希望改变发生？**
*   ******变更的价值(V):**** 变更提供了多少价值？对你的用户有多大帮助？**
*   ******执行变更所需的努力(E):**** 你需要做多少工作来完成这个变更？**

**方程很简单: ****D=V/E******

> **任何改变的可取性是 ****与改变的价值成正比，与做出改变的努力**** 成反比。–[代码简单性](https://books.google.com/books?id=Rgz6Qd-u7p8C&pg=PA10&lpg=PA10&dq=The+desirability+of+any+change+is+directly+proportional+to+the+value+of+the+change+and+inversely+proportional+to+the+effort+involved+in+making+the+change.&source=bl&ots=wHr7P9wmmS&sig=ACfU3U2e8gccv3dI9dLceJk1_E1sfK5bsQ&hl=en&sa=X&ved=2ahUKEwjQoOrw9pXoAhUhoFsKHRWaBkIQ6AEwAnoECAoQAQ#v=onepage&q=The%20desirability%20of%20any%20change%20is%20directly%20proportional%20to%20the%20value%20of%20the%20change%20and%20inversely%20proportional%20to%20the%20effort%20involved%20in%20making%20the%20change.&f=false)**

**当你优先考虑你的工作时，你应该遵循这条规则:**

**那些会给你带来很多价值而需要很少努力的改变，要比那些带来很少价值而需要很多努力的改变更好。**

### **9.解决问题**

**第一步是理解。确切地知道被问的是什么。大部分难题之所以难，是因为你不懂。写下你的问题，试着向别人解释。**

> **如果你不能用简单的术语解释某件事，你就没有理解它。—理查德·费曼**

**第二步是规划。不要采取行动。睡一觉。给你的大脑一些时间来分析问题和处理信息，但不要花太多时间在计划上。**

******三思而后行。******

**第三步是划分。不要试图解决一个大问题。当你从整体上看问题时，它会吓到你。把它分成更小的任务，逐个解决每个子问题。一旦你解决了每个子问题，你就把这些点连接起来了。**

### **10.足够好就可以了**

> **完美是好的敌人—伏尔泰**

**无论是创建一个新项目还是向现有系统添加一个特性，开发人员都倾向于从一开始就详细计划好一切。**

**他们希望第一个版本是完美的。他们不关注他们要解决的问题以及他们的软件将如何帮助人们。**

**他们从能想到的每一个小细节开始思考。然后假设和预测随之而来，接着是“如果…会怎样”的句子。他们必须预测未来，因为他们现在被脑海中的项目想象迷住了，他们的项目必须像他们想象的那样完美。**

**事实上，他们并不知道等待他们的是什么，也不知道追求完美会让他们付出多大的代价。**

**让我告诉你会发生什么:**

*   **您将编写不需要的代码**
*   **添加不必要的代码会增加复杂性**
*   **你太普通了**
*   **你将错过最后期限**
*   **您将会处理由复杂性引起的许多错误**

**你希望这一切发生吗？我想没有。**

**你应该怎么做？**

******从小处着手，改进它，然后扩展。******

**增量设计应该是你的指南。下面是如何用它来设计一个计算器:**

1.  **计划一个只做加法不做其他的系统。**
2.  **执行它。**
3.  **改进现有系统的设计，以便您也可以添加其他操作。**
4.  **计划减法，重复步骤 2 和 3。**
5.  **计划乘法并重复步骤 2 和 3。**
6.  **规划除法，重复步骤 2 和 3。**

### **11.预言**

> *****“预测就是对未来将要发生的事情的预测。它可能是基于某种客观数据的事实，也可能是基于一种假设。”*****

> **当面对他们的代码将来会改变的事实时，一些开发人员试图通过设计一个通用的解决方案来解决问题，这样(他们相信)它将适应每一种可能的未来情况。–[代码简单性](https://books.google.com/books?id=Rgz6Qd-u7p8C&pg=PA28&lpg=PA28&dq=When+faced+with+the+fact+that+their+code+will+change+in+the+future,+some+developers+attempt+to+solve+the+problem+by+designing+a+solution+so+generic+that+(they+believe)+it+will+accommodate+to+every+possible+future+situation.&source=bl&ots=wHr7P9wpuX&sig=ACfU3U1P13XqQr5-_UpYhkSDYMXOU-lSdw&hl=en&sa=X&ved=2ahUKEwjn-Mqo-JXoAhXL854KHRSaBooQ6AEwAHoECAgQAQ#v=onepage&q=When%20faced%20with%20the%20fact%20that%20their%20code%20will%20change%20in%20the%20future%2C%20some%20developers%20attempt%20to%20solve%20the%20problem%20by%20designing%20a%20solution%20so%20generic%20that%20(they%20believe)%20it%20will%20accommodate%20to%20every%20possible%20future%20situation.&f=false)**

**过于一般化包含了许多不需要的代码。**

**您无法预测未来，因此无论您的解决方案有多通用，它都不足以满足您未来的实际需求。最有可能的是，这一时刻永远不会到来，您为解决未来问题而编写的代码将增加复杂性，使代码片段难以更改，最终它将成为一个负担，可能会摧毁您的软件。**

**不要预测未来。只做你现在知道你需要做的普通事。**

### **12.假设**

**假设是什么？**

> *****“一个** *****假设***** **就是你接受为真或者假设为真的东西，虽然你没有确凿的证据。”*****

**软件项目的最大杀手之一是假设。让我们看看一个假设是如何扼杀一个软件项目的。**

**一个开发人员知道他们必须开发一个系统来做 x，然后他们认为系统将来会要求他们做 Y，他们也实现 Y。他们写了几千行代码来设计 y。**

**将来，开发人员意识到当前的需求与他们所想的完全不同。但现在，该软件有不必要的代码，很难扔掉，因为一切都交织在一起。重构代码需要几个月的时间，现在他们想从头开始重写整个软件，这将导致他们损失几个月的时间。**

**为了避免像这位开发人员一样成为受害者，请遵循以下简单规则:**

> ******代码的设计应该基于你现在知道的，而不是你认为未来会发生的。****——[代码简洁](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)**

### **13.停止重新发明**

**例如，如果你发明了你自己的垃圾收集器，而一个完美的垃圾收集器已经存在，那么你将会在垃圾收集器上花费大量的时间，而你只需要在你的软件上工作。**

**只有当下列任一情况成立时，才可以重新发明轮子:**

*   **你需要一些还不存在的东西**
*   **所有现有的“轮子”都是糟糕的技术，或者无法满足您的需求**
*   **现有的“车轮”没有得到适当的维护**

**简单规则:**

******不要多此一举。******

### **14.抵抗**

**作为开发人员，您对更改请求的第一反应应该是“不”。**

**永远不要添加更多的代码，更多的特性，直到你确信它们是必需的，并且有必要实现它们。因为不必要的改动会增加你软件的缺陷。**

**你怎么知道他们有存在的必要？**

**回去记住你的软件目的。然后记住优先排序部分的简单等式。**

```
`From: rsc@plan9.bell-labs.com (Russ Cox)Subject: Re: [9fans] design clairvoyance & the 9 way
Date: Thu, 8 May 2003 04:05:31 GMT
> What does tomorrow's unix look like?
I'm confident that tomorrow's Unix will look like today's Unix, only cruftier.
Russ`
```

### **15.自动化**

**不要把时间花在重复性的任务上。把他们安排好，然后忘掉他们。他们可以在你睡觉的时候工作。当你意识到自己在反复做某件事的时候，只要记住这条规则:**

******能自动化就自动化吧。******

### **16.代码测量**

> *****用代码行来衡量编程进度，就像用重量来衡量飞机制造进度。***
> ***—比尔·盖茨*****

**我看到开发人员根据代码行来衡量他们的软件质量。他们认为更多的代码行意味着他们做得很好。该软件包含数十万行代码，这意味着他们工作的软件非常大。**

**这里弹出的问题是:真的有那么大，还是那里有问题？**

**答案是他们的设计很可能有问题。大多数简单的解决方案不需要很多代码。您可以用少量代码实现简单性并解决问题。**

**我不是说代码行越少越好。虽然您希望避免代码更少，但是您很容易陷入一个陷阱，这将导致您编写出他人难以理解的聪明代码。你应该找到一个平衡点。**

**最佳代码是一小段易于理解和阅读的代码。**

### **17.生产力**

**你如何衡量你的生产力？**

**通过写更多的代码行还是扔掉数百行代码？！**

**你的主要目标应该是保持你的代码库尽可能的小。问题不是“我怎样才能写出更多的代码？”相反，它应该是“我怎样才能删除更多的代码？”**

> **“我最有效率的一天是扔掉了 1000 行代码。”—肯·汤普森**

### **18.测试**

**何时应该将日志记录和错误处理添加到项目中？**

**您应该在很早的阶段就添加日志记录。这将帮助您轻松找到问题，并节省您的时间。**

**在测试代码时，我看到了许多错误。我给你举个例子。有两个条件，一个简单的 if-else 块。开发者给软件输入，它将进入 if 块内部。他们对它进行了测试，并将代码提交给源代码控制。搞定了。**

**但是 else 块呢？当软件交付生产时，这导致了许多错误。当你测试你的代码时，你必须至少执行一次所有的新代码行，并且你应该在测试整个代码之前先测试部分代码。**

**当你有一个 bug 时，首先你应该复制它。您不应该猜测错误的来源，并根据您的假设应用修复程序。很可能，你会错。在应用修复之前，您应该亲眼看到它。**

**你应该是可靠的。当团队中的其他开发人员看到您向源代码控制提交了新代码时，每个人都应该知道您的代码已经过测试，并且可以工作。**

******未测试的代码就是行不通的代码。******

### **19.估计不足**

**开发者的估计烂透了。**

**通常，他们低估而不是高估事物。他们低估了开发少量代码或功能所需的时间和精力。最终，这种低估会导致错过最后期限。**

**解决办法:把大事化小。越小越容易估计。你可能仍然会犯错误，但是你会比估计一个大项目少犯很多错误。**

**请记住:**

******一切都比你想象的要长。******

### **20.逃避重写**

**我相信，当你接受了那篇文章中提到的软件开发的基本原则，你就不会走到这一步了。然而，如果你不知何故犯了这些错误，并发现自己在考虑重写代码，你应该知道以下主要的事情:**

******重写代码往往是开发人员的错觉，而不是大多数情况下的解决方案。******

**为什么是妄想？**

**嗯，因为*读代码比写代码难*。这就是重用代码如此困难的原因。这就是为什么当我们阅读另一个开发人员的代码时，我们的潜意识会悄悄告诉我们“*扔掉它，重新开始*”。**

**有很多情况下你应该考虑从头开始重写你的代码，你可以在这里阅读它们[。但是，给你一个简单的建议:](https://medium.freecodecamp.org/lessons-learned-in-my-10-years-as-a-developer-3d33c8702828)**

******重构应该是第一选项。******

### **21.文档和注释**

**关于注释的一个常见误解是，开发人员添加注释来说明*代码正在做什么*。这是不对的。通过阅读代码，这应该是显而易见的。如果不明显，就说明不可读，应该做得更简单。**

**当你不能使代码更简单时，你应该添加注释来解释这种复杂性。**

> **注释的真正目的是解释*【为什么】*你做了某件事，而不是**代码在做【什么】*。如果你不解释这一点，其他程序员可能会感到困惑，当他们去改变你的代码，他们可能会删除它的重要部分。–[代码简单性](https://books.google.com/books?id=Rgz6Qd-u7p8C&pg=PA46&lpg=PA46&dq=The+real+purpose+of+comments+is+to+explain+%E2%80%9CWHY%E2%80%9D+you+did+something,+not+%E2%80%9CWHAT%E2%80%9D+the+code+is+doing.+If+you+don%E2%80%99t+explain+this,+other+programmers+may+be+confused+and+when+they+go+to+change+your+code+they+might+remove+important+parts+of+it.&source=bl&ots=wHr7P9xnmU&sig=ACfU3U0qqYekJFrcrNUQfL9TzOR443NcpA&hl=en&sa=X&ved=2ahUKEwi56KH--pXoAhWFoFsKHYKoChoQ6AEwAHoECAoQAQ#v=onepage&q=The%20real%20purpose%20of%20comments%20is%20to%20explain%20%E2%80%9CWHY%E2%80%9D%20you%20did%20something%2C%20not%20%E2%80%9CWHAT%E2%80%9D%20the%20code%20is%20doing.%20If%20you%20don%E2%80%99t%20explain%20this%2C%20other%20programmers%20may%20be%20confused%20and%20when%20they%20go%20to%20change%20your%20code%20they%20might%20remove%20important%20parts%20of%20it.&f=false)***

*******写评论是为了解释“为什么”，而不是解释“什么”。*******

***另一件事是记录。有文档来解释你的软件架构和每个模块和组件是很重要的。这是查看您的软件的高层次图片所必需的。***

***当一个新的开发人员加入你的团队时，他们会更容易从整体上理解软件。当开发人员对软件的其他部分没有任何线索时，他们很容易在自己的部分犯错误，这也会影响到其他部分。***

### ***22.拣选技术(工具、库等。)***

***首先，永远记住这条规则:***

*******不依赖外部技术**。但是当你不得不这样做的时候，试着**尽可能多地减少你对他们的依赖****。*******

***这是为什么呢？因为它们是复杂性的另一个常见来源。它们会扼杀你的积极发展，让一切变得更加困难。***

***当你如此依赖外部技术时，你就不自由。如果该技术存在重大缺陷，该怎么办？你必须等待开发人员来修复这个 bug，如果这项技术是你项目的中心，基本上你就被卡住了，你不能前进。这就是为你的项目选择正确的技术如此重要的原因。***

***在开始使用某些技术之前，您应该考虑几个因素:***

*   ***背后是否有积极的发展？***
*   ***还会继续保持吗？***
*   ***从这种状态转换过来有多容易？***
*   ***社区对此有什么看法？***

***如果你能找到这些问题的正确答案，你就能降低选择错误技术的风险。***

### ***23.自我发展***

***不断学习。尝试不同的编程语言和工具，阅读软件开发方面的书籍。他们会给你另一种视角。每天小小的进步都会让你的知识和技能发生真正的变化。***

***思想要开放。不要执着于一种技术。使用所需的技术来解决特定的问题。不要陷入像微软 vs Linux 这样不必要的讨论:)***

*******知道每一个具体问题都有自己具体的解决方法。*******

### ***24.不要逞英雄***

***很多时候做一个半途而废的人比做一个英雄要好。正如杰森·弗里德解释的那样，***

> ***例如，假设你认为一项任务可以在两个小时内完成。但是四个小时后，你仍然只完成了四分之一的路程。本能的想法是，“但是我现在不能放弃，我已经在这上面花了四个小时了！”***

> ***所以你进入了英雄模式。你下定决心要让它成功(并为它还没有成功感到有点尴尬)。你抓起你的斗篷，把自己与世隔绝。–[杰森·弗里德](https://books.google.com/books?id=U77um_h_dgcC&pg=PA118&lpg=PA118&dq=For+example,+let%E2%80%99s+say+you+think+a+task+can+be+done+in+two+hours.+But+four+hours+into+it,+you%E2%80%99re+still+only+a+quarter+of+the+way+done.+The+natural+instinct+is+to+think,+%E2%80%9CBut+I+can%E2%80%99t+give+up+now,+I%E2%80%99ve+already+spent+four+hours+on+this!%E2%80%9D+So+you+go+into+hero+mode.+You%E2%80%99re+determined+to+make+it+work+(and+slightly+embarrassed+that+it+isn%E2%80%99t+already+working).+You+grab+your+cape+and+shut+yourself+off+from+the+world.&source=bl&ots=F_kaZpwxMf&sig=ACfU3U36TIXkJt-Lk2NtH_kzw5A7q_99_w&hl=en&sa=X&ved=2ahUKEwjXkqO--5XoAhUIJDQIHZZhDWYQ6AEwAHoECAkQAQ#v=onepage&q=For%20example%2C%20let%E2%80%99s%20say%20you%20think%20a%20task%20can%20be%20done%20in%20two%20hours.%20But%20four%20hours%20into%20it%2C%20you%E2%80%99re%20still%20only%20a%20quarter%20of%20the%20way%20done.%20The%20natural%20instinct%20is%20to%20think%2C%20%E2%80%9CBut%20I%20can%E2%80%99t%20give%20up%20now%2C%20I%E2%80%99ve%20already%20spent%20four%20hours%20on%20this!%E2%80%9D%20So%20you%20go%20into%20hero%20mode.%20You%E2%80%99re%20determined%20to%20make%20it%20work%20(and%20slightly%20embarrassed%20that%20it%20isn%E2%80%99t%20already%20working).%20You%20grab%20your%20cape%20and%20shut%20yourself%20off%20from%20the%20world.&f=false)***

*******不要执着。知道什么时候退出。不要犹豫去寻求帮助。*******

### ***25.不要问问题…寻求帮助***

***当你有事情要做，但对解决方案没有把握时，不要问别人如何去做…至少不要马上去做。相反，尝试你能想到的任何事情。你对一个概念或语言越不适应，这一点就越重要。***

***当你自己想不出什么的时候，就去搜索！找到答案并尝试它们。修改这些答案，看看你是否能理解为什么它们会起作用，把它们应用到你的代码中。***

***…但一定要寻求建议。***

***当你已经尝试了一切，最好是在你有了一个可行的解决方案之后，现在是寻求建议的最佳时机。让同行和高级开发人员来评审你的代码。***

***在这篇文章中，我试图解释一个好的开发人员心态的基础。我使用了《代码简单性》一书中的部分内容，这本书对我作为开发人员的思维过程有很大的影响。当我读这本书的时候，有很多时候我会反应“哦，我犯了这个错误，我也犯了那个错误。”我提到了书中的一些重要部分，并结合我的经历。***

***我强烈推荐你阅读 Max Kanat-Alexander 的[代码简单性](https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848)。***

***感谢阅读！希望这个指南帮到你了！***

****你可以在*[*https://*](https://huseyinpolatyuruk.com/fundamentals-of-a-good-developer-mindset/)[*huseyinpolatyuruk.com*](http://blog.huseyinpolatyuruk.com/fundamentals-of-a-good-developer-mindset)*阅读更多我的文章。****