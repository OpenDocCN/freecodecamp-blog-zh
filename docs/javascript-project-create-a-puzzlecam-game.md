# JavaScript 项目:创建一个 PuzzleCam 游戏

> 原文：<https://www.freecodecamp.org/news/javascript-project-create-a-puzzlecam-game/>

创建游戏是提高 JavaScript 技能的好方法。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个 JavaScript 教程，它将教你如何创建一个益智游戏，从你电脑的摄像头获取拼图的图像。

Radu Mariescu-Istodor 开发了这个课程。Radu 拥有计算机科学博士学位，并创建了非常有创意的编程教程。

这是一个非常独特的教程。这个项目建造起来很有趣，玩起来也很有趣。

该项目主要是用 JavaScript 创建的，但它在后端使用 PHP 和 SQL。

以下是本课程涵盖的主题:

*   接入摄像头
*   裁剪图像
*   拖放
*   游戏元素
*   标志设计
*   声音
*   MySQL 数据库
*   PHP web 服务器
*   高级作物
*   高级点击测试

观看 freeCodeCamp.org YouTube 频道的全部课程(2 小时观看)。

[https://www.youtube.com/embed/HS6KHYIYdXc?feature=oembed](https://www.youtube.com/embed/HS6KHYIYdXc?feature=oembed)

## 副本

(自动生成)

这是一门非常酷的课程，教你如何使用 JavaScript 和 HTML。

为了创建一个使用摄像头视频的益智游戏，您还将学习一点 HTML 和 sequel。

Raju 有一种独特而有趣的风格，使得学习概念变得非常有趣。

大家好，我是 Raju，今天我将教大家如何制作一个使用摄像头的益智游戏。

整个项目只用了普通的 JavaScript 和 HTML canvas，以及其中的一小部分。

这里的这个是使用 PHP 和 MySQL 从数据库中保存和加载分数。

这款游戏可以在台式电脑上运行，也可以在手机和平板电脑等移动设备上运行。

通过看这个，你会学到很多有用的东西，以后可以应用到其他项目中。

尽管有些东西已经很先进了。

我会尽可能简单地教他们。

我会把最复杂的两件事留到最后。

好消息是它们也是可选的，这意味着没有它们你也能得到一个完整的游戏。

所以不要害怕。

会很有趣的，我保证。

此外，特别感谢来自自由代码营的 Beau 允许我与你们分享这些。

我希望你会喜欢它。

如果你有任何问题，请通过我的 YouTube 频道联系我。

现在我们开始吧。

我们从编写 HTML 页面开始。

在页眉中，我们给页面一个标题。

这将改变我们在浏览器选项卡中看到的内容。

我们还将链接两个外部文件，一个用于 JavaScript，另一个用于 CSS。

这些文件暂时是空的。

那么我们文档的主体部分将会非常简单。

现在，我们只是在页面加载时运行一个名为 main 的函数，并在这里添加 canvas 元素，这是我们主要用来构建游戏的元素，它将是一个 Canvas 应用程序。

如果我们刷新页面，现在我们看到选项卡显示正确的标题。

我们还在控制台这里得到一个错误。

如果您在浏览器中看不到控制台，请尝试按 F 12。

在大多数浏览器中，这是开发者工具的快捷方式。

我正在使用谷歌浏览器，我认为它有最有用的工具。

但这真的只是个人喜好。

他们中的任何一个都会工作得很好。

现在错误说这个主函数不见了。

所以让我们转到 JavaScript 文件并实现它。

现在，我只是让它将字符串 main 输出到控制台，以测试它是否工作。

确实如此。

每当你做出改变时，这样调试是非常好的。

否则，错误会越积越多，一次处理很多错误会非常混乱。

但现在让我们看看如何访问摄像机。

我们将使用承诺来访问我们的媒体设备。

我们只对来自摄像机的视频感兴趣，我们在这里指定了这一点。

现在的情况是，浏览器会要求玩家允许使用摄像头。

当他们给它时，代码将会转到这里，在这里我们定义一个回调函数，在这个函数中我们可以访问摄像机信号。

如果玩家不允许相机或有其他一些错误，我们会抓住它，并显示在屏幕上。

当一切正常时，我们初始化视频对象。

我们将为此使用一个全局变量，我将用大写字母写出来。

为了弄清楚什么时候变量是全局变量或者不在代码中，我们接下来创建 video 元素。

将它初始化为来自摄像机的信号，并在视频数据可用时播放它，我们可以开始在画布上更新它。

这个更新画布函数是我们接下来要实现的。

但首先让我们也在这里全局定义画布，并添加对画布上下文对象的引用。

我们用之前在 HTML 页面中定义的画布来初始化画布。

这为画布的上下文提供了我们构建游戏所需的所有绘制方法。

我们的画布将感受到整个窗口，现在更新画布功能需要将视频绘制到画布上。

因此，我们将使用 draw image 方法和 canvas 上下文来实现这一点。

我们还需要在这里指定我们要从左上角开始绘制，左上角的坐标是 00。

现在，当我刷新时，发生了一些事情，它显示了来自我的相机的图像。

我的相机此刻正对着这里的墙壁。

但是现在还没有任何动静。

我们需要每秒多次更新画布才能看到这种情况。

我们将使用请求动画帧方法来使它工作。

这个方法每秒会递归调用函数很多次，如果计算机足够快，它会尝试每秒更新 60 次。

现在我们得到了实时图像。

让我把赤壁先生放在这里让它不那么无聊。

现在你会注意到这里有一个白色的边框。

有点奇怪，因为我们说要画 00 的视频。

但是 body 元素有一些默认的边距。

这就是我们实际看到的。

我们将在 CSS 文件中删除它，并通过将边距设为零来改变 body 元素的样式。

现在好点了，但是我们仍然可以看到滚动条，这并不是真正必要的。

因此，我将通过将溢出设置为隐藏来删除它们。

现在滚动条不见了，但是视频实际上在屏幕之外。

我们不想那样。

我们需要记住，一般来说，有许多网络摄像头或手机摄像头具有不同的分辨率、宽高比等。

因此，我们需要一种方法来调整视频的大小，使其适合屏幕的中间，最好在它周围留有一些空间，以便我们有足够的空间稍后移动这些片段。

我们将使用这个缩放器来指定图像将使用多少屏幕空间。

并且它们还将跟踪这个大小变量中的其他相关信息。

当关于视频的元数据可用时，我们在这里更新这些值。

首先，我们使用一个辅助变量来找出屏幕尺寸和视频尺寸之间的最小比例。

然后我们相应地设置大小属性。

注意，这里这些事情中的一个将会简化。

所以我们适当地保留了长宽比，没有任何东西被拉伸。

对于 x&y 坐标，我们从屏幕中间开始，向左移动一半宽度，向上移动一半高度。

然后，为了真正影响图像，我们必须在这里更新 draw image 方法。

在我们指定左上角之前，可以用不同数量的参数调用这个方法。

但是现在我们也增加了宽度和高度。

好的，它起作用了，我们现在看到了来自相机的完整图像，它在右边被稍微裁剪了。

我们也得到了这个安全百分比。

如果我们改变这里的值，我们会得到不同大小的边距。

我们也可以通过按下这个按钮来查看应用程序在不同尺寸屏幕上的外观。

我们甚至可以从这个列表中选择一些特定的设备。

但是每次我们改变一些东西，我们需要刷新页面来看到它发生。

看起来不错。

在风景模式下怎么样，需要再次刷新。

我们实际上可以通过使用一个事件监听器来自动调整窗口大小。

然后，我们需要将这段代码移到回调函数中，还需要在这里调用这个函数，以便代码像以前一样执行。

我也应该把这些线移到这里。

这样，画布也将调整大小，而不仅仅是相机流。

好吧，让我们看看是否改变方向。

是的，它有效。

无论屏幕大小如何，这次我们都会得到合适的尺寸。

但更重要的是，无论你的相机输出的大小和长宽比如何，它都可以工作。

我将通过强制我的网络摄像头输出特定大小来演示这一点。

请注意，并不是所有的网络摄像头都支持这种方式调整大小，它可能不适合你，但你可以尝试，你可以看到它在方形纵横比下工作得很好。

接下来让我们尝试一个垂直纵横比。

好的，工作正常。

我将删除这些额外的参数。

现在，因为我们想看到来自摄像机的整个视频。

这只是一个实验。

我将注释掉这个事件监听器。

因为我们在应用程序中并不真正需要这个功能。

用户不希望像这样调整屏幕大小。

我制作它是为了更好地展示事物是如何工作的，以及虚空一直在刷新。

另外，您可能需要在您的某个项目中使用它。

我们现在定义 piece 类，并在构造函数中指定一个行和列索引。

我们将有一个这些片段的数组，并在这里对其进行全局定义。

我们还需要指定有多少行和列。

我会把这些放在这里。

现在，为了初始化片段，我们从一个空数组开始，使用 I 变量遍历行，使用 j 变量遍历列，并将使用这两个索引定义的新片段添加到数组中。

为了能够绘制片段，我们将实现 draw 方法，该方法将上下文作为参数。

让我们先在这里画一个简单的矩形，看看我们目前所做的是否有效。

现在我们需要根据行数、列数和屏幕上视频的大小来确定这些片段的位置和大小。

我将在这里输入这些占位符，并在构造函数中计算确切的值。

每块的宽度和高度就是该区域的宽度和高度分别除以列数和行数。

我在这里设置 x 和 y，这样每一个部分都被定义在正确的位置。

尽管这是一个益智游戏，玩家需要找到正确的位置，但在开发游戏时从软配置开始会有所帮助。

你会明白的。

我现在意识到，x 和 y 实际上可以在我们有了宽度和高度之后定义，然后用宽度和高度来定义它们，就像这样。

这样代码就很清楚了。

我们现在需要一种绘制碎片的方法。

在这里，我们通过遍历所有这些方法并使用全局上下文调用 draw 方法来实现这一点。

好了，我想我们可以开始调试了。

哦，这里忘记调用 stroke 方法了。

没有它，什么也画不出来。

让我们看看，我会刷新，还没有什么不同。

这是因为 pieces 数组是空的，我们需要调用初始化 pieces 函数。

我们现在将在控制台中完成此操作。

好了，现在有事发生了，看起来不错。

三行三列。

但是还没准备好。

这些只是画在视频顶部的空矩形。

看，如果我注释掉在这里画视频图像，你可以看到网格。

每一部分都需要裁剪视频的特定部分并显示出来，我们通过在这里添加一个对 draw image 方法的调用来实现。

我们使用另一个版本的 draw image 方法，它更复杂，接受九个参数。

在我们指定了视频之后，我们需要告诉左边的部分裁剪发生在哪里。

然后是顶部，然后是宽度和高度，这些值是相对于视频的。

在我们指定了从哪里获取图像数据之后，无论它现在的分辨率和纵横比如何，我们都需要说明在哪里绘制它。

这很简单。

只是片段的 x 和 y 位置，我们需要使用它的宽度和高度好的，现在看起来和以前一样，但是每个片段显示的是视频负责的部分我们可以在这里参数化这个函数以支持任意数量的行和列，我们在这里用默认值调用它开始时我们可以在控制台中使用不同大小的网格进行测试，让我们随机化片段的位置。

接下来，我们将编写一个函数，遍历所有这些元素，并为每一个元素生成一个随机位置。

我们在这里分别设置 x 和 y，我们称之为控制台。

这不是我们所期望的。

随机值介于 0 和 1 之间，这意味着它们几乎都在左上角。

我不打算深入研究半像素是如何工作的。

所以让我们继续，按画布的宽度和高度来缩放。

好了，好多了。

但是你可以看到有些部分超出了屏幕。

我们可以通过在缩放时减去此处的宽度和高度来防止这种情况。

好的，很好。

现在，我们之所以看到重复的部分，曾经随机分布，而其他部分在它们后面的正确位置，是因为我们在重画每一帧之前没有清理画布。

如果我们在这里这样做，并再次随机化这些片段，我们会得到我们所期望的。

让我们测试不同的网格大小。

很好，我实际上想知道这些部分需要放在哪里，这将使调试更容易。

也许我们可以把它作为一个简单的模式或类似的东西。

因此，我将把这个 clear rect 调用移到顶部，设置 50%的透明度，并取消对之前视频的注释。

然后我重新设置了透明度，这样只有视频是半透明的，但在那之后，这些部分会正常绘制。

通过这种方式，背景上的视频显示了我需要将这些块移动到哪里，但它被淡化了，所以它不会与实际的块混淆。现在为了实现这些块的拖放功能，我们需要向画布添加一些事件侦听器。

我们在这里实现了它的函数，并从添加一个鼠标按下事件监听器开始，我们需要定义一个回调函数。

那么还需要另外两个鼠标移动和鼠标抬起的事件监听器。

为了处理鼠标按下事件，我们首先通过获取用户在界面中按下的部分来标记出什么是选中的部分。

我们将很快定义这个函数。

但是让我们先把顶层逻辑弄下来。

我们将把选中的棋子存储在全局变量中，这个变量在开始时用 normal 初始化，或者如果没有棋子被按下。

然后，如果选择了一个棋子，我们计算这个棋子到左上角的偏移量，就像这样。我们将在拖动时使用这个偏移量，这样棋子就不会像这样贴紧鼠标位置。

这将有助于顺利互动。

然后在鼠标移动时，如果选择了一块，我们将位置更新到新的鼠标位置，并考虑偏移量。

鼠标抬起事件将暂时保持为空。

那么我们如何发现玩家是否按下了一个棋子呢？我们需要做的就是遍历所有的片段，检查点击位置是否在其中任何一个的范围内。

我们需要检查 X 是否大于 X，小于 X 加上。

如果 y 大于棋子高度，那么我们就返回这个棋子。

如果没有符合这些条件的，我们只是返回 No，这意味着没有按下任何东西。

好的，让我们测试一下，我把鼠标移到左下角，点击并拖动。

很好，但是现在我就像这样卡住了，我需要实现鼠标抬起事件，这样我就可以放开这个片段了。

现在，我们需要做的明显的事情是设置选择的部分知道。

但在此之前，我们还需要做一件事。

我们检查棋子是否接近它应该去的正确位置。

如果是这样，我们就把它扣到位。

我们需要实施这些新方法。

但首先，让我们讨论一下我们为什么要这样做。

第一个原因是它给出了适当的反馈。

当玩家放开棋子时，如果它跳回原位，这意味着这一步棋是正确的。

玩家可以继续下一个游戏。

第二个原因是，稍后，我们将需要评估棋子是否在正确的位置。

玩家不太可能以像素完美的方式丢下所有的棋子。

所以这个抓拍也会有所帮助。

最后一个原因是，我认为这让游戏更有趣。

所以为了实现这个功能，我们回到 piece 类并添加两个新方法。

首先，我们检查棋子是否靠近正确的位置。

我们只需计算到正确位置的距离。

并检查它是否低于阈值。

或者在这里使用一个与作品大小成比例的阈值，大约 33%。

我只是做了一些尝试和错误，我认为这样感觉很好。

如果距离更小，那么它被认为是接近的。

否则，它不应该存储在某个正确的位置。

我将在构造函数中这样做，因为我们已经同意，这些片段将在正确的位置初始化。

要测量距离，我们只需利用勾股定理的一个推论。

我很确定你已经知道了。

但是如果你不知道或者不想了解更多，可以看看我最近制作的关于它的视频。

我认为我在解释、证明和给出各种应用方面做得很好。

你们觉得怎么样？抓拍法真的很简单。

它只是把棋子放到正确的位置上，就这样。

现在让我们调试，我可以点击一个片段，拖动它，然后释放。

我可以把它放在任何我想放的地方。

如果我把它放在正确的位置附近，它会自动到位。

这适用于每一件作品。

但有一个问题是，被选中的部分有时会被画在其他部分的下面。

这可不好。

这取决于我们画碎片的顺序。

因为左上角的是数组中的第一个。

所有其他的将被画在它的上面。

但是右下方的没有这个问题。

它总是在最上面。

我们需要通过将选中的部分移动到数组的最后一个索引来解决这个问题，我们首先找出它当前所在的索引。

然后，即使它不应该丢失，我在这里检查只是为了确定，然后我使用拼接方法将其删除，并使用推送方法将其再次添加到数组的末尾。

现在，无论我选择哪一块，它都会像预期的那样被画在所有东西的上面。

但是还有一个问题。

当我点击这里多块重叠的地方，它选择了最下面的一块。

我们通过以相反的顺序迭代片段数组来解决这个问题。

这样，我们就停在了用户点击的最顶端。

现在一切正常。

但我们需要考虑的最后一件事是移动设备。

到目前为止，我们所做的实际上对那些还不起作用。

你看，即使我用这种模式调试，我试着四处拖动，什么也没发生。

这是因为移动使用触摸事件而不是鼠标事件。

所以我们也需要支持他们。

我们回到添加事件侦听器的函数，复制所有三个事件侦听器，并根据需要重写。

接下来需要定义触摸开始触摸移动和触摸结束回调函数。

但这很容易做到，因为我们将重用之前的鼠标事件回调函数，我们只需要以稍微不同的方式获取位置。

然后我们可以像这样调用另一个回调函数，我们复制这个回调函数并实现另外两个。

现在，当我们调试它的工作，但错误发生在触摸。

那是因为那时没有可用的位置。

我是说，如果你不碰，你还能碰哪里。

所以我们实际上省略了这些论点。

现在，当我在这里调试时，一切都正常了。

但是一些移动设备有一个内置的功能，当向下拖动时会刷新页面。

我们不希望每次玩家向下拖动棋子时都出现这种情况。

因此，我们在 CSS 文件中通过将 over scroll behavior 设置为 none 来禁用它。

拖放到此为止。

让我们看看它是否也适用于不同大小的作品。

接下来，我们添加游戏元素，如菜单和显示运行时间，我们需要在 HTML 页面中定义更多的结构，一个包含所有这些新元素的 div。

一个显示菜单的 div 和一个显示时间的 div。

该菜单将包含一个选择组件来设置难度，将有四个不同的选项。

当用户改变这些时，我们将调用一个名为 Set difference 的函数，我们需要用 JavaScript 来定义它。

我们还需要这个按钮来开始游戏。

按下它将调用一个名为 restart 的函数，该函数也需要在 JavaScript 中定义。

所以让我们转到 JavaScript 文件。

接下来，我们添加两个新的全局变量来跟踪开始和结束时间。

然后我们首先实现设置难度函数，我们得到我们在 HTML 中定义的 select 组件的值。

在此基础上，我们用不同的行数和列数调用初始化的块函数。

我在这里使用 switch case 结构来避免许多 if else 语句。

这是我的学生常犯的错误。

我在这里使用的值基本上只是猜测。

但是对于疯狂的变体，我想要正好 1000 块。

所以我使用 40 和 25，它们的长宽比最平方，然后重启函数会将开始时间变量设置为当前时间戳。

结束时间设置为“否”,因为我们刚刚开始播放，我们也在这个阶段随机化片段。

如果我刷新，我们在任何地方都看不到菜单。

实际上，在页面加载之前，它会快速闪烁。

但是它去了哪里，我们可以使用开发人员工具来检查元素，并看到它们被画布推到页面底部之下，我们实际上可以在这里尝试不同的样式来让它工作。

用 Xero top 设置一个绝对位置就可以了。

所以我将把它添加到我们的 CSS 文件中。

刷新现在它的工作。

我可以按开始键，每次都会随机播放。

如果我改变难度，我们会看到不同大小的网格出现。

我认为疯狂模式一开始会占用太多处理器，但至少在我的电脑上运行良好。

我确信一些设备将会陷入困境。

接下来，我们显示时间，我将定义一个名为 Update time 的函数，它首先从系统中获取当前时间。

然后，它使用前面定义的 div 来保存这个值，并将内部 HTML 设置为现在和开始时间之间的差值。

我们需要在某个地方调用这个函数。

因此，我将转到在每一帧上调用的 update Canvas 函数，并在此处输入它。

我们还注意到这个名字不再合适了，因为现在我们更新的不仅仅是画布。

因此，我将在刷新时对其进行一点重构。现在，我按下“start ”,它在这里显示时间，但它是以毫秒为单位的，我们应该正确地对其进行格式化。我首先将毫秒的整数部分转换为秒，然后除以 1，000，我想考虑这种格式。

所以我们需要知道 0 和 59 之间的秒部分，我们会得到这样的结果。

也可以这样得到 0 到 59 之间的小数部分。

我们的部分在 0 到 23 之间。

我们这样得到它，我怀疑任何人会花超过一天的时间玩这个。

然后将它们格式化成最终的字符串。

我取出每个组件，如果需要的话，用零填充左边。

我在每个部分之间用一列，然后我们返回这个最终值，就这样。

现在我们可以在这里使用它来格式化差异开始感觉像一个真正的游戏了，你不觉得吗？但是当我们结束的时候什么都没发生。

我们需要以某种方式检测所有的部分是否都在正确的位置。

我们通过在这里添加一个属性来保存位置是否正确。

最初，这应该是因为片段被定义在正确的位置。

但是当我们随机化的时候，我们立刻把它设置为假。

然后，当一个片段被捕捉到正确的位置时，我们再次将其设置为 true。

有可能有人从正确的位置拿走了一块。

所以我们需要在鼠标按下时将它设置回 false。

然后检查是否所有的部分都是正确的，我们像这样写函数。

它穿过所有的碎片。

如果其中一个不正确，该函数将返回 false。

否则，我们返回 true。

我们在鼠标应用回调函数中检查这一点。

因为只有当玩家释放一个棋子，即最后一个进入正确位置的棋子时，游戏才能完成。

这里，我们还需要检查结束时间是否为否，因为原则上，玩家可以在游戏结束后继续移动棋子。

我们不想再更新时间了。

之后，我们只需将这里的结束时间设置为当前时间。

我们还需要更改这里的显示，以便前端时间可用，显示与前端时间的差异，而不是与当前时间的差异。

好，让我们看看，计时器开始计时，和我们玩游戏之前一样。

现在计时器停了。

现在我们将使这部分看起来更好。

首先，让我们像这样把按钮放在下面。

现在我们可以移动到 CSS 文件，并将它们放置在屏幕的中央。

我们说项目应该是 50%从左边开始，50%从上面开始。

如果我们像这样放着，这些东西会移到这里。

所以它们的左上角在屏幕中央。

但是我们希望他们在这里。

所以我们需要加上 transform translate 减 50%减 50%。

现在我们得到了这个。

现在的文字并不清晰易读，让我们像这样在这里添加半透明的背景。

更好的是，现在我们可以像这样将项目居中对齐，我们可以通过设置填充值来给项目留出一些间距。

我在这里使用的值是 5 分钟，这意味着间隔将是窗口宽度和高度之间最小值的 5%。

我还在这里设置了黑色半透明边框。

现在我们可以让按钮看起来更好。

我们会给它更大的字体，蓝色的背景色和白色的文字。

很好。

当鼠标悬停在按钮上时，我们可以通过改变它的属性来使按钮更加用户友好。

在这种情况下，我将使它有一个橙色背景和黑色文本。

好的，现在当我悬停的时候它会改变样式。

出于某种原因，你现在看不到我的鼠标，但它在那里，它看起来像默认的箭头，使它看起来像一个手光标。

我们可以在这里改变它和 CSS。

如今，在设计元素样式时，你可以选择许多新奇的特性，比如你可以用 transition 属性轻松地添加动画。

通过在这里设置 0.3 秒的持续时间，我们将在悬停时获得从一种风格到另一种风格的简短动画。

我觉得真的很好。

我不喜欢这里的边界。

所以我将删除它，这将通过设置一个小的半径使按钮角变圆，除了这个按钮的字体大小相当小。

所以我们接下来会继续努力。

首先，我把它改成 Arial，我认为 Sarah stone 在这种情况下看起来很好。

好吧，现在我把它放大。

与按钮上的字体大小相同。

我想现在没问题了，让我们看看它在手机上是什么样子。

绝对是读球，我觉得还可以大一点。

但是现在这也可以了，select 组件上的文本还没有受到影响。

所以我们需要特别添加字体大小。

好了，现在切换回全屏，我将改变鼠标，当悬停在这个选择组件时看起来像一个指针，并将这个元素的样式设置为更符合按钮。

所以没有边界，一个小半径，我们需要删除这里的轮廓。

好吧，我们来测试一下这个游戏。

现在。

我按下开始，这不是我们想要的，真的，这个菜单在这个阶段应该消失，只有计时器应该保持可见。

所以我将返回 HTML，从这里取出这个元素。

然后在 JavaScript 文件中，我们转到 restart 函数并将菜单项的显示设置为 none。

现在我刷新，按开始键，菜单就没了。

但是计时器也不见了。

应该在那里。

我们来调试一下。

我切换到元素面板。

它就在那里。

它就在画布下面。

所以我们需要改变它的风格和 CSS。

我希望它出现在屏幕上方。

所以我会把定位改成绝对。

设置零顶，让我们把它放在屏幕中央。

所以我把左边设为 50%。

我再次使用了 Transform translate 方法，但是只在左边。

现在我刷新，按开始，计时器就在那里。

接下来，我将向您展示如何使用 PowerPoint 绘制徽标。

你可以使用许多不同的软件来做到这一点。

我使用 PowerPoint 只是因为它安装在大多数学生的电脑上。

所以希望你也有。

我用圆角矩形工具开始画一个相机，我可以这样调整圆角半径。

现在，我通过按住 Ctrl 键并将其拖动到一个新位置来复制该项。现在，我将对圆形做类似的操作。

我将把圆圈的颜色改为黑色和白色。

我将使用对齐工具来确保它们是我想要的样子。

我把之前画的矩形的颜色改成了黑色，并把圆形移到了上面。

PowerPoint 的新功能有这些帮助线出现，我认为它们很有用，但是如果你没有它们，并且想要正确对齐，就使用我们之前使用的对齐工具。

现在我对这个样子很满意。

所以我将复制并粘贴它作为一个图像，我们将需要使用这种格式。

但是现在我想画一个小拼图。

所以我从这个大小的矩形开始。

我在这里也画了一个椭圆形。

我将塑造这个椭圆形，看起来更像拼图的连接部分。

我通过编辑这个形状的点来完成。

右键单击编辑点。

如果你理解贝塞尔曲线在这个阶段是如何工作的，这是很有用的。

好吧，我对此很满意。

我复制它，旋转它，通过合并形状和联合将这三个项目合并成一个形状。

现在，我将把它放在我们相机的图像副本的上面，对齐得更好一点，并复制右边的两个对象。

对于第一个副本，我们首先选择相机图像。

然后按住 Shift，按下拼图块以及去合并形状和减去。

第二份拷贝。

同样先选择相机图像。

然后按住 Shift 键的拼图块，以及去合并形状和相交。

我现在把这一块移动到适当的位置，这样看起来我们就完成了拼图。

现在选择这两个对象复制并粘贴他的图像。

此时，我们不再需要所有其他项目。

我们只保留这个作为图标，我们将用它来制作一个标题。

接下来，我在这里创建了一个文本框和右拼图，全部大写。

我将字体设置为 Arial Black，以类似于 HTML 页面中的字体，并增加字体的大小。

然后我把 P 放大，我希望它和相机一样大。

所以这里有一点尝试和错误。

当我们满意的时候，用同样的尺寸让她看，我们就差不多完成了。

我们现在可以复制所有内容并再次粘贴为图像。

但是你会看到图像在这里有一些奇怪的透明边缘。

不幸的是，当涉及到文本框时，PowerPoint 就是这样工作的，但是我们可以使用裁剪工具将其裁剪掉。

将图像调整到我们想要的大小。

右键单击并另存为图片。

然后我将它命名为 title dot png，并将其添加到与我们的代码相同的目录中。

说到这里，我们现在可以像这样将新图像添加到 HTML 文件中。

我在这里将它的宽度设置为 90%,因为我不会添加其他样式，然后刷新使图像出现。

我认为如果我们在 CSS 中做一个小的改变会看起来更好，我会像这样使整个菜单更宽。

通过这种方式，标题图像明显大于其他文本，难度下拉列表与标签移动到同一行。

我认为这样更好，让我们接下来添加一些声音。

首先，我将使用之前录制的 mp3 文件定义一个，就像这样，我将音量设置得很低。

因为每当我们把一个棋子放到正确的地方，它就会播放。

我认为如果它以最大音量播放会很烦人。

现在，让我们将它添加到 snap 方法和测试中。

我刷新页面，按下开始键，耶，成功了。

但是完成游戏时没有声音。

那里肯定需要一些东西。

而不是简单地在这里添加另一个 mp3 文件，这将使本教程非常短。

我要提醒你，用 JavaScript 合成声音是可能的。

为了生成声音，我们需要定义一个音频上下文，这样做可以让它在大多数浏览器上工作。

然后我想创作一段简单的旋律，由钢琴键上弹奏的三个音符组成。

我在这里写下它们的频率，我们需要创建一个函数来播放一个音符，它将有一个指定的键和一个给定的持续时间，该键应该被按下多长时间。

接下来我们定义一个振荡器。

这将负责产生给定频率的声音。

我们将频率设置为这里作为参数的值。

我们现在这样启动振荡器。

我们还可以告诉它在指定的持续时间后停止。

最好同时断开振荡器。

否则，在一些浏览器上仍然可以听到一些不明显的背景噪音。

为此我使用了设置超时。

我也在这里指定了持续时间。

现在有一个问题，因为 set timeout 要求持续时间以毫秒为单位，而 stop 方法要求持续时间以秒为单位。

所以我决定单位是毫秒，需要除以 1001。

在测试之前，我们需要做的更多事情是将振荡器连接到目的地，在本例中是您设备上的默认扬声器。

好吧，我们来测试一下。

我通过在控制台中调用 play note 来实现这一点。

我们得到一个错误，好像我不知道如何拼写振荡器。

让我尽快解决这个问题。

你可以听到一秒钟简单的声音。

现在我们开始把它做成听起来更像钢琴的样子，我将使用一个信封来控制游戏，你可以把它想象成音量。本质上，我把信封和目的地连接起来。

我把这里的振荡器连接到这个包络，而不是形成一种链，这样钢琴声音就有了强大的攻击，这意味着它需要从零到最大增益非常快。

在这里，它发生在一秒钟的第一点，我把这里的最大值设置为 0.5，而不是 1，这样就不会太大，然后游戏会在给定的持续时间内逐渐减小到零，同样，这里以秒为单位指定。

现在让我们刷新并测试另一个错误。

我今天确实做了很多，看起来问题是，在我定义它之前，我把振荡器连接到了包络。

所以把它移到这里应该可以。

你现在可以听到声音在一秒钟内逐渐减弱。

通过将波形类型从默认符号改为三角形，您可以获得更好的声音。

如果你在理解这些事情上有困难，请查看我的可视化 web 开发课程。

在那里，我用慢得多的速度，解释我制作增强现实钢琴所需的所有不同技术。

现在让我们谱写旋律本身。

它将从一个简单的音符开始，先演奏 300 毫秒，然后我将在 300 毫秒后演奏一个不同的音符。

在那之后的 300 毫秒，或者说从起点开始的 600 毫秒。

我们得到的是这个。

现在，这可以作为旋律，但你可以自由地让它听起来像你喜欢的任何方式。

例如，当完成拼图时，它可能听起来像这样，我们在这里调用这个函数。

这听起来有点糟糕，因为它与片段咬合到位时的最终爆音重叠。

我通过在函数调用中增加一点延迟来解决这个问题。

为了存储分数，我们需要使用某种数据库，我推荐你去下面的链接下载 XAMPP，它带有 MySQL 和 PHP myadmin，这是一个很好的管理数据库内容的用户界面。

示例还包括 Apache 服务器，我们将需要它来编写后端 PHP 代码。

安装完 sample 后，我们转到控制面板并启动这两个服务。

然后我们前往管理页面。

从这里我们可以打开 PHP myadmin 并开始构建我们的数据库来保存分数。

我们通过点击左边的 new 按钮来创建新的数据库，我们给我们的数据库命名，现在我们需要为列创建一个表。

姑且称之为分数吧。

现在，每个 MySQL 表都应该有一个 ID 字段，我们将其保留为整数类型，并将其标记为主键。

勾选这个复选框，它会自动递增。

这意味着每次我们添加新的分数时，我们再也不用担心它的 ID，它会自动由 MySQL 决定。

接下来，我们需要在这里存储玩家的名字，它将是一个字符串，所以我们将使用 var char 作为数据类型。

把 255 个字符的最大长度放在这里可能有点太多了，但是永远也不能知道人们想出了什么名字。

接下来将存储时间，它可以是一个整数，因为我打算存储秒数。

我还可以在这里添加注释，以澄清格式，这样我就不需要在以后记住它。

最后，让我们存储难度级别，以便我们稍后可以基于此对分数进行分组。

现在我们按 Save，我们可以在这里看到表格结构。

让我们添加一些示例数据来使用。

现在会有一些假的占位符数据，我们去插入并开始在每个字段中输入值。

但是正如我前面所说的，我们不需要担心 id，它将由我的 SQL 自动生成。

我就在这里加上我的名字。

比方说，我花了 50 秒来完成简单难度的拼图。

然后，我将再次添加拉多和 100 秒，同时播放一个中等和 200 秒的努力。

最后是疯狂模式的 4000 秒。

所以现在看起来我已经玩过所有难度的游戏了。

让我们在这里增加几个人，比如约翰，20 秒轻松，1000 秒疯狂，戴安娜，100 秒努力，而不是 400 秒用心。

迈克尔有 400 秒的中等成绩，利奥有 10 秒的中等成绩。

现在，我们按 go，所有这 10 个条目都已添加到表中，我们可以单击 Browse 选项卡来检查它。

现在，我们可以在这里看到输出整个表的 SQL 查询。

它说从分数中选择一切。

我们稍后需要用 PHP 编写类似的查询，以便在我们的前端游戏和数据库之间进行通信。

例如，这里的这个查询可能对加载分数很有用，但是它并不是很好，它混合了所有的难度级别，并且没有以任何方式排序。

像这样很难看出谁是赢家。

因此，让我们继续搜索，并说我们只需要那些难度较低的条目。

我们可以看到这里的 SQL 查询是如何更新的。

我觉得这个 PHP myadmin 工具对于学习 SQL 语法非常有用。

你也可以通过点击编辑来练习自己编写语法。

例如，我们可以在这里添加一个 ORDER BY 子句，以便按时间对结果进行排序。

现在很容易看出，当在简单模式下玩时，约翰是赢家，我们可以类似地获得其他难度级别的结果。

我们只需要每次改变这里的难度。

我们稍后将在 BHB 使用这个查询来获得高分。

现在，为了添加新的结果，我们使用 Insert 关键字。

我们指定将接收数据的表名和列，然后指定进入其中的实际值。

这里注意名称和难度都是字符串。

所以需要用引号来指定它们，否则会出错。

然后我们按 go，得到一行被插入的反馈。

如果我们再次浏览表格，我们会看到一个新条目，用于我们的“做一个疯狂的困难”。

现在我们将使用 PHP 练习这些查询。

因为这是我第一次教它，我会慢慢来。

我已经把到目前为止构建的游戏的所有项目文件都移到了 SAP 的 HT docs 目录下。

现在我将创建一个名为 server . PHP 的空文件。

接下来，我们在文本编辑器和浏览器中打开这个文件。

但是这里注意，地址是 local host slash puzzle cam slash server dot php，你需要这样写，因为然后 PHP 代码是由 Apache 服务器执行的，我提醒你，你需要在这个阶段安装 samp，同时运行 Apache 和 MySQL。

PHP 代码与 JavaScript 有很大不同，语法是这样开始和结束的，所有代码都在两者之间。

如果您想在这里打印一些东西，您可以使用关键字 echo，后跟您想打印的内容。

如果你刷新页面，你会得到完全一样的结果。

现在我将教你如何连接我们之前创建的 MySQL 数据库。

因为它也在我们的计算机上本地运行，所以我们将使用 localhost 作为主机。

默认用户是 root，密码为空。

当然，如果你要把这个放到网上的某个地方，你会想增加一些更好的安全性，但我不会在这个视频中关注这个。

然后，为了连接到数据库，我们使用 MySQL y connect 函数并提供这些信息。

如果链接没有建立，我们并不认为连接失败了。

DI 函数也会终止 PHP 脚本。

如果代码通过了 If 语句，它将转到这里，我们只是回显连接成功。

我会刷新并连接成功。

但是如果我指定一个不同的主机，PHP 会产生一些警告信息，程序会在这个 dies 语句之后终止。

如果我们使用了错误的用户或密码，我们也会收到一条错误消息。

现在有了一个成功的连接，我们可以继续像这样选择数据库。

如果失败，我们可以使用 or 关键字来调用 DI 函数。

如果代码到达这里，它将输出成功消息，我们可以测试并看到它是成功的，因为拼图凸轮数据库确实存在。

例如，如果我们在这里搞砸了并使用了不同的名称，代码将会因错误而终止。

现在让我们将 SQL 查询定义为一个简单的字符串。

我将使用我们之前使用 PHP myadmin 得出的查询，轻松地从 Scores 表中选择这些条目。

我们可以使用 MySQL I 查询函数来执行这个查询。

这个函数实际上并不返回结果。

但是一个我们可以用来迭代结果的对象，我会给你看，我们首先初始化一个空数组。

然后如果结果包含任何行，我们将使用 while 循环在 RS 对象上使用 MySQL I fetch Asok 函数逐个获取每一行。

我们使用数组 push 函数将每一行添加到结果数组中，然后使用 print our 函数打印数组，如下所示。

我们得到一个错误。

我在这里忘了一只眼睛，它应该是我的 SQL I num 行。

现在我们把数组打印出来了，但是它没有按照分数排序，在这个例子中也没有按照比赛时间排序。

正如我们前面看到的，我们可以使用 ORDER BY 子句来实现这一点。

我还将把这个查询的格式设置得更好一些，这样它就不会超出屏幕。

请注意，在 PHP 中，停止符号用于连接，而不是像 JavaScript 和其他编程语言那样使用加号。

现在，因为我们将重用这段代码来获得其他难度级别的结果，所以将这段代码编写为返回结果数组的函数是有意义的。

然后我们可以用 easy 作为参数调用它，得到同样的结果。

让我在这里代替使用这个论点的困难，并且几乎忘记需要在这里指定链接。

现在我们刷新，得到与先前相同的结果。

但是我们也可以通过再次调用这个函数得到其他结果。

让我快速添加其他难度等级。

现在让我们将所有这些打包到一个函数中，以获得所有的分数。

我们不再需要这些 print 语句，我们可以返回一个包含每个结果的关联数组。

关联数组就像 JavaScript 对象，我们可以给键命名。

现在我们调用这个函数并像这样打印结果。

或者更熟悉一点，可以使用 Echo 将这个结果数组转换成 JSON 字符串，如下所示。

PHP 无需安装任何库就能支持所有这些功能，这真是太好了。

我会把这个注释掉，然后专注于创建另一个函数，我们需要把新的分数添加到数据库中。

我会把信息作为第一个参数传递。

现在，我将把查询写成一个带有硬编码值的简单字符串，然后用 info 中的元素逐个替换每个值。

如果你像这样写你的查询，它不太可能出错。

否则，很容易搞砸并忘记某处的单引号或双引号。

现在我们再次调用我的 SQL like 查询，如果不成功，由于某种原因，我们将返回 false。

否则，我们返回 true 来表示成功。

现在，我们可以通过定义一些信息并使用它调用 Add score 函数来测试这个函数。

我们可以像这样用 if 语句包装它，看看插入是否成功。

它声称已经奏效。

现在让我返回这个函数调用来获取所有的分数，看看它是否真的有效。

确实如此。

太好了。

现在我们要改变这个 PHP 服务器，使其支持添加分数和读取所有分数这两种功能。

让我先删除这个测试代码。

现在，我将使用一个名为 info 的 get 参数向页面发送一些附加信息。

我们先读到这里，看看效果如何。

所以我需要在这里设置一些信息。

让我们先打个招呼。

你可以看到它确实印在这里。

我现在将更改信息，以包含添加分数所需的信息。

我会把它写成 JSON 字符串。

现在，为了解析这个字符串，我调用 Jason decode，get info 是这里的一个对象，我可以将它传递给我们之前编写的 ad score 函数，并像之前一样处理结果。

现在，我们可以通过访问这个带有一些参数的地址来插入分数。

我现在要做的是，如果我们不发送任何信息，它会列出所有的分数。

这样，我们就可以用这个脚本同时支持对数据库的读写。

现在，让我来解决房间里的大象。

是的，这个代码不是很安全。

任何人都可以通过这个链接，发送一些数据到我的分数数据库。

更糟糕的是，这些数据不会以任何方式进行转义。

所以他们甚至可以在这里通过 SQL 注入进行一些破坏。

所有这些问题都不容易解决。

如果我现在花时间在它上面，它会偏离项目太多。

我们正在建立一个益智游戏，而不是世界上最安全的东西。

但是因为你们中的许多人对安全性感兴趣，所以下面是你们应该做的。

首先，逃离这里的信息或者更好地使用 prepared statement change get here into post，这样更安全。

我自己没有做，因为我需要像 postman 这样的东西来测试。

我不想在这里安装更多的工具。

Post 也是发送数据时的常见做法，所以您肯定应该在这里使用它。

然后，你会想在这里添加一些认证，以便不是每个人都可以提出这样的请求，你需要要求人们注册并通过向他们发送确认电子邮件来确认他们的帐户。

我通常不会为我的小项目这样做，我觉得我会对那些访问我网站的人要求太多。

他们发现被黑了。

所以我这里没有任何敏感信息，我有点喜欢这种关注。

所有这些步骤并不能使系统防弹。

但是每一个都让破解变得更加困难。

你甚至可以添加一个验证码，因为如果有人真的想要的话，他们可以自动认证，并用一堆假账户和假分数淹没你的数据库。

捕捉让事情变得更加困难，但并非不可能。

你可以在这里设计一些有效性检查系统，也许可以记录开始时间和时间以及每个动作。

如果结果不包含在合理的时间间隔内一个接一个移动的棋子，这就是不公平的迹象。

当然，也可以通过弄清楚有效性检查器是如何工作的并生成看起来像真的假数据来破解。

但我只有这些了。

如果你有更好的安全建议，请告诉我。

我很想知道你们的想法。

但现在让我们继续前端部分。

让我再把赤壁先生的儿子放在这里。

在 HTML 中，我现在将创建一个结束屏幕，它将显示分数，并允许用户在这个输入框中输入他的名字。

还将有一个按钮来保存点击将需要在 JavaScript 中实现这个保存分数功能的分数。

我还将在这里添加一个按钮，显示需要定义的另一个函数的分数，并添加另一个按钮返回到菜单。

我还将创建分数屏幕。

它将包含一个空的 div，最终将保存分数和一个返回到结束屏幕的按钮，我们还需要定义这个 JavaScript 函数。

现在，我将在这两个屏幕中复制这个标题图像，使它们看起来一致。

说到外观，我将定义一个名为 menu 的 CSS 类，并将其应用于所有这些项目。

这个类将与我们之前应用于带有 ID 菜单项的 div 的样式相同。

所以我们在 CSS 中改变它。

现在我们刷新，我们可以看到所有三个屏幕相互重叠，我们需要在课程开始时隐藏结束屏幕和分数屏幕。

现在让我们开始定义 JavaScript 中缺少的函数。

首先，他们想要显示结束屏幕，我将简单地使用播放时间作为分数，并将它放在 ID score 值的元素内。

我们还需要将这个时间计算为结束时间减去开始时间，我们需要确保结束屏幕元素像这样变得可见。

然后，显示菜单的功能将通过关闭结束屏幕开始，然后在此处创建菜单。

现在，如果我刷新并按开始，菜单会像以前一样消失。

但是，如果我在控制台中调用 show and Screen 函数，最终屏幕会出现，看起来不错。

但是分数现在变得有些奇怪了，因为我们实际上并没有完成这个谜题来得到最终时间的真实值。

真正玩游戏的时候会没事的，我们不需要担心这个。

现在按菜单不起作用。

哦，我把母论文忘在这里了。

我们需要在点击时调用这个函数。

很抱歉。

让我们解决这个问题，并刷新控制台中的开始呼叫显示和屏幕功能。

按下 menu，是的，它现在工作了，让我们继续显示下一个分数。

我将复制这一行，以便结束屏幕消失，让我们让分数屏幕出现。

现在，我将使分数容器最初显示文本加载，因为它可能需要一些时间来加载分数。

我们想让玩家知道有事情发生了。

然后我们用下一步要实现的函数得到分数。

这个 get scores 函数使用 fetch 从 server dot php 获取数据，这里我提醒位于同一个目录下，fetch 返回一个 promise。

当响应可用时，我们将其转换成 JSON。

这返回了另一个承诺。

所以我们需要再写一遍。

在这里，我们可以访问实际数据。

让我们登录到控制台测试，我刷新，按开始，在控制台调用显示和屏幕，按显示分数。

现在我们的数据在这里。

它仍然显示加载，因为现在我们必须将分数格式化并放在这里。

相反，format scores 函数将生成 HTML 格式的表格。

这个我就不多解释了。

我觉得如果我那样做，这个教程就变得太长了。

如果你能追踪到这里，我相信你会很容易理解这是什么。

然而，我要说的是，现在当我将结果格式化为 easy 时，我将把这个功能提取到它自己的函数中。

写类似的代码而不使用函数，真的是一个很不好的习惯。

我的很多学生都有这个问题。

所以我想我也指出了这一点。

我现在为每个难度级别调用这个函数来一个接一个地显示所有结果。

最终的名单太长了。

我将这里的固定高度和溢出设置为自动，这样滚动条就会出现。

我觉得这样更好。

现在我按 back，我想是时候定义 close scores 函数了。

这个很容易做到，它会让 N 屏可见，隐藏分数屏。

现在我刷新了一下，一切似乎都很好，除了还没有实现的保存功能。

保存分数功能将计算分数，作为玩游戏所花的时间，并从输入字段中获取玩家姓名。

如果没有输入名字，我们会给出一个警告，并在这里停止该功能。

否则，我们从 select 元素中获取难度，并使用 info 参数获取 server dot PHP，在这里我们传递名称播放时间和难度级别。

为了向用户提供反馈，我将把保存按钮上的文本改为“好的”,在获取过程中，我禁用了这个按钮，这样玩家就可以错误地多次按下它。

当再次打开结束屏幕时，我还重置了保存按钮上的文本，以防玩家第二次播放，他们也需要重新启用该按钮。

让我们为禁用的按钮添加灰色样式，并使光标成为默认箭头，指示它可以被单击。

现在我们来看一个错误。

当然，看起来我忘记了右括号。

在我测试之前，让我们在拼图完成后调用显示结束屏幕函数，这次是真正的测试。

好的，效果很好。

但是我的分数是以毫秒计的，而不是以秒计。

但经过进一步考虑，我认为最好以毫秒为单位，这样我们可以更好地区分几乎同时演奏的人，我都将分数格式化以显示秒数，但我在数据库中保留毫秒，以便排名列表的排序由此而来。

好了，现在分数显示为秒数。

对于那些零分的人来说，比分稳定看起来不错，因为我们现在认为他们在 20 和 50 毫秒内完成了比赛。

但是当我们清空数据库，人们开始玩这个的时候，这个问题就会消失。

还有一点让我很困扰的是，保存按钮在下一行，但是后来说好了就变小了，跳起来。

我将通过缩小输入来解决这个问题，这样按钮就总是在同一行上。

我还会将它设计成与其他项目更一致的样式。

好极了。

现在，我们要做一些微调，并努力使这些部分看起来像真正的拼图。

为了做到这一点，我们去初始化 pieces 函数，并像这样遍历片段网格，片段按照从上到下从左到右的顺序存储在一个列表中。

所以我们可以通过简单地像这样计数来得到每一块的指数。

现在我们一个接一个的取每一块，i n j 会指向它所属的行和列。

我们现在需要给每一部分添加关于这些东西的信息，我们称之为标签。

对于每个标签，我们需要知道它是内部标签还是外部标签，我们将像这样以相等的概率随机决定。

所以这个符号要么变成了-1，要么变成了+1，告诉我们这是一个内部还是外部的标签。

我们需要决定的第二件事是标签在边缘的位置。

如果我们认为这是从零开始，以 100%结束，让我们允许 tab 在 30%和 70%之间的任何地方。

离角落太近不是个好主意。

我现在将设置 bottom 属性来编码底部选项卡的信息。

它将是一个介于 0.3 和 0.7 之间的单一数字。

如果它是一个外部标签，并且在负 0.7 和负 0.3 之间。

如果它是一个内部标签，注意我们是如何用这个简单的技巧存储两条信息的。

如果我们在最后一行，这里没有任何底部标签。

所以我们将它设置为否。

我们现在对右边的选项卡做同样的事情，确保我没有在最右边的列添加选项卡。

顶部的标签不再是随机的了，因为它们需要从上面连接各个部分，我们需要将顶部设置为减去直接在它上面的部分的底部值。

如果我们在第一行，顶部没有标签，我们现在以类似的方式处理左边的标签，我们使用减去右边的前几个标签的值。

现在，让我们刷新一下，让这个控制台变大，并在这里检查棋子阵列的外观。

所以第一部分在这里有一个正值，这意味着它应该是一个外部标签。

右边的值是负值，意味着它是一个内部选项卡。

我们没有四个左和顶部。

目前看来不错。

对于第二个片段，我们需要检查左边的值是否是这个数，但是被翻转了。

让我们来看看。

是的，看起来不错。

让我们再检查下一块。

很好。

现在我们得到右等于零，因为我们在最右边的一列。

现在下一块在下一排。

所以陀螺已经不正常了。

而且应该是第一块底部的反面。

这是好事。

现在让我们看最后一块。

它的底部和右侧没有值，而左侧和顶部的值看起来还好。

是的，我想我们很好。

现在让我们使用这些额外的信息为这些部分绘制新的形状。

我们在这里不再使用 rect 方法，但是现在我将使用 move two 和 four line two 命令重新实现。

让我在这里添加一些注释来解释每一行的走向。

现在刷新并不能改变什么。

碎片仍然是长方形的。

但是现在我们对这幅画有了更多的控制。

我需要知道这件衣服的最小长度，并用它来定义与它相关的标签的一些视觉特征，如颈部、标签宽度和高度。

现在，让我们首先像这样在去右上的路上绕道。

制表符的位置由 top 参数的绝对值给出。

我们在垂直轴上移动标签高度，其方向由符号 top 值给出。

让我们现在刷新一下，看看会发生什么。

所以基地看起来有点像有某种屋顶的房子。

对一些人来说，他们的屋顶像这样向内倾斜。

让我暂时禁用视频的绘制。

我觉得这很混乱。

所以现在你只是看到了这些碎片的形状，但是你实际上可以分辨出那些平屋顶的碎片属于顶部。

所以我们开始看到棋子的形状确实有助于玩游戏，并使整体体验更好。

我们继续。

我将为其他方面添加类似的弯路。

我们重新审视这一点。

我们现在有了一个有趣的分工，我认为这实际上可能是游戏的另一个版本，如果需要的话，我认为它看起来很独特。

多么大的错误，这是从哪里来的？啊，我明白了。

看起来就像我在作品外点击时发生的一样。

这在这里被认为是在作品之外，因为我们仍然使用矩形形状进行点击检测。

但是每次我点击这里的时候都会出现错误。

不敢相信我错过了。

在检查它是否接近之前，我们需要确保所选的棋子不为否。

好了，不要再出错了。

还要注意每次刷新时，我们会得到不同外观的片段。

我觉得这真的很好。

但是现在让我们创建选项卡。

我会多绕两个弯，一个在这点之前，一个在这点之后。

我们使用之前定义的颈部值。

现在让我也为另一方写一下。

我现在刷新，它看起来没问题。

但是你可以看到有些部分有一些奇怪的线条突出来。

不是所有的电脑都有。

这个没问题，因为它四周都有标签。

问题是我们增加了这些新的弯路。

即使一条边没有标签，我们也需要检查是否需要绘制标签。

否则，我们就一直排到边缘的尽头。

仅此而已。

我会很快地把它添加到另一边。

现在情况看起来相当不错。

请注意，因为我们使用与棋子大小相关的值，所以当大小改变时，它将在每个难度级别上正常工作。

这里根本不需要做什么特别的事情。

现在这个形状仍然不完美，我们需要添加一些曲线将这里的这条线替换成贝塞尔曲线。

相反，我将借助两个控制点来定义它。

之前的同一个端点看起来有些不对劲。

我想我漏掉了这个右括号。

不过还是让我把这段代码安排好一点吧。

令人耳目一新，现在你可以看到这里发生了什么。

它画了一条曲线，而不是一条直线。

我会在右边做同样的事情。

我只是以相反的顺序复制这几行，把这里的减号变成加号。

还有这里。

我们基本上让它对称。

让我们测试一下，看起来没问题。

我想如果你想让它看起来不一样，你可以在这里改变这些值。

就像你能让脖子变窄一样。

例如，您也可以将选项卡变宽。

如果你愿意的话，你甚至可以让每件作品都有不同的属性。

这不是太麻烦，但我认为这是矫枉过正，我很高兴这是硬编码在这里。

请注意，这现在也影响了其他选项卡。

他们更瘦更长。

接下来，我将通过在每个部分添加类似的代码来使它们都弯曲。

这是我通常会说我们应该提取像 Draw tab 之类的函数的地方，但我想不出好的参数名称，而且它实际上会使函数内部的一些事情变得更复杂。

所以我决定就这样放着。

但是这个建议仍然有效，仅仅因为我不知道如何很好地完成它并不意味着它不能完成。

好吧，让我看看这里。

很好。

同样，它可以在任何尺寸的作品上工作，现在我们需要做的就是将视频添加回来。

我会把代码移到这里。

在这之前我调用了上下文的 clip 方法。

我保存剪辑前的状态，并在调用 draw image 后恢复它，这样它就不会以奇怪的方式影响后面的片段。

现在，一些片段看起来很棒，就像这个一样，但是那些有外部标签的片段丢失了里面的视频。

我们通过在视频的两边加一些填充来解决这个问题，一个等于标签高度的填充就足够了。

因为拼图的大小和视频的大小不匹配，我们需要缩放前四个参数的标签高度，就像这个注释，它们实际上在这里除以大小。

所以本质上，我在这里简化了，只存储百分比值会更好。

但在编辑视频时才注意到这一点，所以现在为时已晚。

反正这个不管用。

看起来我这里多了一个括号。

它应该在这里的 main 方法之后关闭。

现在它工作了，看起来很棒。

剩下的唯一事情就是处理用户在标签中点击的时候。

外部的标签是不可点击的，内部的标签选择了不应该选择的部分，你会认为这不是什么大问题。

但是如果碎片像这样重叠，你就不会得到它下面的那块。

而且很讨厌。

你现在不想打扰你的玩家。你想解决这个问题吗，我们将重新实现我们选择棋子的方式，我将使用不同的策略。

在我实现一些看似无关的东西时，请耐心等待一会儿。

首先，让我们做一个函数来生成一个随机颜色，它将首先生成 0 到 255 之间的随机红色分量。

我们用 floor 把它变成一个整数。

我们对绿色和蓝色值做同样的处理，并使用 RGB 语法将其作为字符串返回，如下所示。

现在我们将为每一个部分生成一个随机的颜色。

我们真的希望颜色是独一无二的，重复出现的可能性非常小，尤其是当游戏只有几个棋子的时候。

但是一个疯狂的模式项目并不比抱歉更安全，并且检查一种颜色以前是否被使用并且在那种情况下重新生成。

我们将把这个颜色传递给每一块，现在在 piece 类中，我们将它作为一个属性存储。

然后在 draw 方法中，我们将指定第二个参数，它告诉我们是否使用相机，默认设置为 true。

如果为真，这里的代码保持不变，但如果不是，它将使用它们的颜色来绘制这些部分，就像这样。

我在这里使用 Fill rect 方法并添加一个制表符高度的填充，这样外部的制表符也是彩色的。

现在让我们通过将 use cam 设置为 false 来测试一切是否仍然正常。

但现在的作品更加丰富多彩，不再使用摄像头输入。

你实际上可以根据形状来玩这个游戏。

至少在简单模式下很简单。

现在我们做了这个改变，因为我想用点击的颜色来检测我是否点击了某个部分。

就像这里，它不应该检测到点击，因为那里什么也没有。

这里应该会激活，因为我按的是粉色。

我点击的颜色应该开始拖动。

我们通过 onMouseDown 回调函数来实现这一点。

从我们在画布上单击的位置获取颜色信息，我们在事件点 x 和事件点 y 处获取图像数据，这是一个包含四个元素的数组。

第一个是红色，第二个是绿色，第三个是蓝色。

第四个是透明度，我检查第四个元素是否为零，所以是透明的，并返回在这种情况下，我们没有点击任何东西，那么这不是白色的，实际上，它是透明的黑色。

但是如果我们通过了这一部分，我们将颜色格式化为 RGB 字符串格式，并检查它在片段中的位置。

我们需要为此实现一个新的功能，但这真的很简单。

我将使用另一个函数作为引用，并将颜色作为第二个参数传递到这里。

现在我们像以前一样浏览这些作品。

如果颜色匹配，我们就退回那块。

就这么简单。

现在，如果你想让代码更有效率，你可以把代码块存储在一个字典里，关键字等于颜色值，然后用常数时间代替线性时间进行查找。

但是这个方法很好。

即使在疯狂模式下我们也没有那么多作品。

好了，我们来刷新测试一下。

它工作了。

但是现在你会说但是拉多。

所以，如果它的工作，我们想在这里看到网络摄像头的图像，而不是一些随机的颜色。

我说的是多重画布。

我们将在这里添加另一个画布。

我称之为助手画布。

现在在 JavaScript 中，我也将引用它，就像我们引用另一个一样。

然后，我们将它的宽度和高度也设置为相同。

现在在更新游戏中，我也将像这样清除辅助画布，然后用相机沿着主画布正常绘制棋子，但是使用辅助画布上的颜色。

诀窍是，现在在鼠标按下时，我们不从主画布中获取颜色数据，而是从辅助画布中获取，让我刷新一下，您马上就会得到它。

或者几秒钟。

它不起作用。

忘了在这里改 ID 帮她画布了。

好了，现在我的元素在下面的某个地方显示了助手画布。

让我像这样把它移到屏幕上。

我会把它变小，这样就不会重叠太多，我会把它放在这个角落里。

现在，当我单击主画布上的某个位置时，相应的颜色值来自这个辅助画布。

因此，选择作品现在可以像预期的那样工作了。

两个画布同时更新，使辅助画布成为我们作品的可靠点击检测器。

这个辅助画布不需要可见。

实际上，它甚至不需要添加到 DOM 中。

但是它也可以在那里。

这对于调试很有用，我想我只要把这里的显示设置为 non 就行了。

让我们做最后一次测试。

就这样，我希望你从中学到的东西是值得的。

如果你看过，请喜欢这个视频并与你认为感兴趣的人分享。

你可以从我的网站下载源代码。

它被分成几个部分，所以如果你愿意，你可以一步一步来。

此外，让我知道你是否能想到一个好的策略来玩这个游戏。

我花了一个半小时，用 1000 块解决了疯狂模式。

一定有更聪明的方法来做这件事。

不管怎样，谢谢收看，再见。