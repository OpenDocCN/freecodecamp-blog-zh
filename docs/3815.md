# 让你成为英雄的五大开发者技能(提示:涉及乐高)

> 原文：<https://www.freecodecamp.org/news/the-hero-developer-who-knew-how-to-build-lego-bricks/>

编程就像用乐高积木搭建东西。任何开发者都可以挑选一套全新的乐高玩具，并按照说明进行组装。这很容易。把它当成编码学校作业或者入门教程。

真正的软件项目是不同的。这就像建立一个非常大的城堡。只不过它在过去已经建成了。然后有人野蛮的一脚把它撕成了碎片。较大的部分保持在一起。但是较小的部分被完全压碎了。一些元素被抛弃了。

你会得到一个盒子，里面装着剩下的东西，但也有成千上万来自其他组的碎片。当然，说明书也不见了。你只能靠一张图片知道城堡是什么样子。

这才有趣！让我们看看在这样的环境下我们能做些什么来有效地工作。

## **1。接受未知**

任何开发任务的第一步都是了解你需要做什么。听起来很明显。然而，任务越大，未知的变数就越多。这是设定明确期望的时刻。

如果你不知道如何开始，思考和概念化太长时间是没有意义的。开始思考你需要的关键要素。然后再想想。如果有人问你预估或最后期限，开诚布公。系统中你不知道或者可能不理解的部分。这没关系。

想想像脸书、网飞或甲骨文这样的平台。或者任何更大的企业软件。很少有人能掌握全部范围。那些建造了它或者花了数年时间研究它的人。所以首先，给自己一个不是什么都懂的喘息机会。更重要的是，接受你不会知道所有的事情。

> 有经验且高效的开发人员并不是更好的程序员。他们更善于评估他们需要做什么。以及选择正确的策略来应对未知。

**乐高类比**:想想我们要重建的城堡布景。假设有人给你一张城堡和盒子的图片，并问你“你需要多少时间来建造城堡？”对此没有好的答案，除了“我还不知道。让我开始吧，让我们看看一两天后我在哪里”。

完成这项任务的终极“我害怕未知”方法是把盒子里的所有元素放在地板上。尝试根据颜色和形状将它们分成它们所属的集合。然后看图，做一个如何组装砖块的思维导图。

这种方法不是很有效，原因有二。首先，如果城堡太大，你可能永远也到不了那里。第二点也是最重要的一点:你无法评估进展。你可能是在正确的轨道上，也可能根本没有。你没有反馈回路。

另一种方法是开始建造城堡。当你走的时候，你会知道找到你需要的东西是否容易。你会知道图片是否显示了所有细节，或者结构是否比看起来更复杂。

根据这些信息，你将能够对完成这项工作所需的时间和精力做出更有根据的猜测。如果值得做的话。

如果你需要为明天早上建造它，也许去商店再买一个同样的城堡是一个更好的解决方案？这可能不是您要做的决定，但是问题的解决方案并不总是来自更多的代码。

## **2。**接受妥协****

开发者往往会称赞和看重“对细节的极大关注”。每个工作机会都有这样或那样的形式。那都很好。但是不要把对细节的关注和固执、完美主义混为一谈。

当开始一项大任务时，你必须定义它的两个版本。第一个版本是您验证事情是否会按照您认为的方式运行所需的最低要求。

这就是我所说的“横向工作”。你更大任务的每一部分都是垂直的。不需要深入研究就能得到第一批结果。首先关注主要的用例或场景。从那里开始。

在第一版中你可以留下的东西:

*   错误处理
*   边缘案例
*   干净的代码
*   配置

不要想那么多，只要写出你需要的代码，就像它从你的手指中流出一样。您应该很快达到高功能覆盖率。当然，从这第一个简单的版本到最终版本需要很多时间。那么重点是什么呢？

这是一种更安全的进步方式。你想验证你的假设。尽管你可能聪明能干，但设计和概念化只能带你到此为止。弄脏你的手。它会给你比任何“想通”更多的知识和洞察力。

这个原则同样适用于商业中新产品或新功能的 MVP。这种方法还有一个好处，那就是你可以展示你的第一个版本并获得反馈。或者提问。在现有代码上进行头脑风暴比在一张图纸或概念上更容易。

**乐高类比:**你在建城堡的塔。在图片上，高塔的墙是由灰色和白色的砖块交织而成的。有一个公主被锁在塔里，屋顶上有一条龙。

你找到了公主和龙，但是要找到你需要的灰色和白色的砖块却需要很长时间。正确的方法是用任何砖块建造墙，并放置公主和龙。你可以留下一个类似“改善墙砖”的 TODO。

这个想法是你已经发现了一个问题:建造一堵完美的墙是很困难的。让我们接受这一点，并继续去发现所有其他我们还不知道的障碍。接受妥协可以防止你陷入困境。

即使你从来没有做过，你也可以告诉你的顾客:“这是完整的城堡。我们知道我们必须改善塔壁，但它已经建成了”。这比“我们被严重耽搁了，因为我们花了很长时间才找到合适的塔砖”好多了。但是你看，这座塔很完美，和你发给我们的照片一模一样。现在我们要去城堡的其他地方了”。

> 重要提示:不要混淆妥协和草率。

这座塔的主要元素是公主和龙。不要把一个农民放在塔里，把一只猫放在屋顶上，并认为这是一个可以接受的妥协。行不通:)

## **3。从外界开始**

有很多事情你可以控制。和你不能做的事情。十年前，作为一名开发人员，我在第一次任务中就学到了这一点。任务是集成外部 API 并处理数据。我有一周时间。这是一个非常合理的时间表，即使对像我这样没有经验的人来说。

以下是我所做的(以及你不应该做的):

现在是星期一早上。我看了 10 分钟的 API 文档。这似乎很容易。我创建了一个测试数据集，然后继续编写代码来处理它。一旦完成，我将使用真正的 API 进行测试。

周三早上，我就快完成了。我认为我的代码是干净的，设计良好的，一切(它不是)。现在我只需要集成 API，我可能会提前完成。我不禁觉得“我很牛逼”。

我很快就谈到了 API 部分。我正试着用我的代码达到它。只是我不能。有点不对劲。我浪费了一整天的时间仔细检查所有的东西。使用不同的 API 客户端。没有进展。一天过去了，现在是星期三晚上。

我被卡住了，我感觉和棒极了完全相反。

我周四去上班，向一位同事寻求帮助。他告诉我，对 API 的访问可能受到知识产权的限制，我必须联系公司，将我们的知识产权列入白名单。很好，我有办法了。

我给拥有 API 的公司发了一封电子邮件。好像是早上 8 点。我愚蠢地期望在几分钟内得到快速的回答和解决。我整个早上都在流汗，到了中午，我终于拿起电话，拨打了支持电话。我解释了我的问题，并尽我所能强调这是一件多么紧急的事情(事实并非如此)。

电话另一端的人向我解释说，白名单的发布时间通常是 1 到 2 天。现在我很沮丧。1 天还是 2 天？这怎么可能呢？我的任务是世界上最重要的(当然只对我来说)，他们告诉我“1 或 2 天”？

突然间我不再领先了。我迟到了。我失败了。我去找我的老板，告诉他我搞砸了。我应该在周一早上检查空气污染指数。然后，我会在同一天请求访问，同时编写我的代码。他只是回以微笑，表示“是的，你应该这样做”。

我终于在星期五得到了机会，不得不熬夜完成工作。我使我的代码适应 API 数据带来的许多惊喜。再见了，设计良好且干净的代码。稍后我会证明这一点，说“没有时间那样做”(有时间)。

在我天真的时候，我觉得访问的事情和错误的文档是非常坏的运气。现在我可以说一切如常。

教训就是从你控制不了的开始。确认你对环境的每一个假设。尽早使用手动和低成本的方法进行尝试。

**乐高类比**:想象你正在建造城堡，事情进展顺利。你现在已经混合盒子大约 100 次寻找碎片。你会忍不住想“我从来没有在图片上遇到过坐在塔上的那条巨大的橙色龙”。

你忽略了这些信息，专注于你已经取得的进步。那是人类。前进比处理问题更令人兴奋。最后你必须承认龙不见了。很晚才告诉你的顾客，那套中较大的一件不会出现。这可不好。

相反，要做的事情是追踪那个暗示:“龙在哪里？”。花时间 100%确定它不在那里。马上提出这个问题。告诉你的顾客“嘿，盒子里没有龙。我不能用其他的砖块拼出一条龙。我们该怎么办？”

当人们足够早地知道问题时，他们会出奇地接受。尽早发现问题会带来更多可能的解决方案。"我们能继续知道没有龙吗？"“我们可以单独买龙吗？”“我能看见盒子里有一只恐龙。我们可以用它来代替吗？”

## **4。**划清界限****

当您开始为现有系统开发新特性时，首先要定义它如何与现有代码交互。当然，你应该试着遵循坚实的原则等等。但关键部分比这简单。只要尽量让触摸面尽量低就行。

明确定义切割的简单过程将改进您的解决方案。它会迫使你解决关键问题:*用户或系统将如何使用我的代码？* *我会得到什么投入？我应该产生什么输出？*这有助于你保持注意力集中在球上。

如果你还不太了解你正在使用的系统，那就更是如此。这是一个探索未知的好机会，然后再深入你已经知道的东西。

它还可以很容易地打开或关闭该功能。您可以使用布尔标志或更高级功能切换机制。

**乐高类比**:假设你需要建造城堡的延伸部分。要求是相当高的水平，所以有足够的空间来创造。但是你不能触摸现存的城堡。

你可以去建一个很大的扩建工程，却发现没有地方可以把它连接到城堡上。真不幸。你必须快速修改你的扩展名，使它以某种方式适合。

正确的方法应该是首先考虑接触表面。城堡的扩建部分会在哪里？我可以把它贴在什么砖块上？它们有什么形式？把连接城堡的延伸部分的几块砖拼在一起。验证它们是否牢固连接。从那里你可以自由发挥你想要的任何扩展。

## **5。不要太干**

干代表不要重复自己。这可能是最容易遵循的规则。一旦你看到重复的代码行，你就做了一个抽象。它可以是一个基类，一个帮助器方法，等等。

接下来会发生什么？下一个人来了，通用代码需要修改以覆盖更多的情况。他们添加了参数和 if 语句来应对新出现的复杂性。很快，最初简单的 5 行变成了 30 行，很难弄清楚发生了什么。

可读性差不是代码重复的好交易。

保留重复的线条会更好。然后，您可以随意更改每个实例。

下一次当你想到“抽象胜过重复”的时候，问问自己:你见过多少次有人从抽象中走回来？比如删除一个基类并将公共代码放回继承类。我打赌答案是永远不会。

原因是抽象和设计模式通常很酷，也很复杂。如果存在，那么“一定有一个好的理由”。所以一旦你引入了抽象，它很有可能会永远留在那里。

这是否意味着你永远不应该使用抽象？不。当用户抽象符合需求时。比如:

*   “我们希望记录对该方法的每次调用以及输入输出”
*   "我们想记录每一个带有数据 a、b、c 的 HTTP 请求. "
*   “每次创建用户时，我们都需要做这做那

这些都是很好的抽象对象，还有很多例子。但是请注意，这些需求更多的是技术性的，而不是与业务相关的(日志、安全性、分析等)。).抽象友好的需求很少是你的业务领域的一部分。

为什么？因为商业领域接近真实世界。我们无法控制。在项目开始时所做的假设往往很快就会落空。不要为了避免重复而修改代码。

**乐高类比**:无。乐高积木没有干的概念。

# **外卖**

聪明地工作并不意味着更好的代码。它是关于弄清楚需要做什么，并朝着目标安全地前进。

大型的、具有挑战性的开发任务会带来未知。拥抱它。学会和它一起工作。

如果你让事情变得简单，并与你的团队、老板、客户，最好是每个人的结果保持一致，你会更有效率。

感谢阅读！

最初发表于[火词博客](https://fire.ci/blog/the-hero-developer-who-knew-how-to-build-lego-bricks/)。