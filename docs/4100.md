# b 树自平衡搜索索引数据结构解释

> 原文：<https://www.freecodecamp.org/news/b-tree-self-balancing-search-index-data-structures-explained/>

## 什么是 B 树？

b 树是一种自平衡搜索树。

在大多数其他自平衡搜索树(如 AVL 树和红黑树)中，假设一切都在主存中。

为了理解 B 树的使用，我们必须考虑到大量的数据无法放入主存。当键的数量很大时，数据以块的形式从磁盘中读取。与主内存访问时间相比，磁盘访问时间非常长。

使用 B 树的主要思想是减少磁盘访问的次数。大多数树操作(搜索、插入、删除、最大、最小等)需要 O(h)次磁盘访问，其中 h 是树的高度。b 树是一棵胖树。

通过在 B 树节点中放置最大可能的关键字，B 树的高度保持较低。通常，B 树节点大小与磁盘块大小相等。由于 B 树的 h 较低，因此与平衡的二分搜索法树(如 AVL 树、红黑树等)相比，大多数操作的总磁盘访问次数显著减少。

B 树的属性:

1.  所有叶节点都在同一级别。
2.  B 树由术语最小度‘t’定义。t 的值取决于磁盘块的大小。
3.  除了根之外，每个节点必须至少包含 t-1 个键。根目录可以包含至少 1 个密钥。
4.  所有节点(包括根节点)最多可以包含 2t–1 个键。
5.  节点的子节点数等于其中的键数加 1。
6.  节点的所有键都按升序排序。两个键 k1 和 k2 之间的子键包含 k1 和 k2 范围内的所有键。
7.  b 树从根部开始生长和收缩，这与二叉查找树不同。二分搜索法树向下生长，也向下收缩。
8.  像其他平衡二分搜索法树一样，搜索、插入和删除的时间复杂度是 O(Log(n))。

### 搜索:

搜索类似于二叉查找树的搜索。设要搜索的键为 k，我们从根开始，向下递归遍历。对于每个被访问的非叶节点，如果该节点有 key，我们只需返回该节点。否则，我们将返回到该节点的适当子节点(正好在第一个更大的键之前的子节点)。如果我们到达一个叶节点，在叶节点中没有找到 k，我们返回 NULL。

### 遍历:

遍历也类似于二叉树的有序遍历。我们从最左边的子元素开始，递归地打印最左边的子元素，然后对剩余的子元素和键重复相同的过程。最后，递归打印最右边的孩子。

### 插入

首先，我们搜索并找出这个键应该属于哪个节点，然后将它插入到这个节点中。然后我们寻找并解决这些问题:如果键的数量太多(大于 t - 1 ),那么我们把中间的键移到父节点。我们递归地这样做，直到根。如果根中的键的数量太多，那么我们将中间的键作为整个树的新根，并将其连接到它之前所在的节点。

### B 树的时间分析:

假设 B 树有 n 个元素，M 是一个节点可以拥有的最大子节点数。树的最大深度是多少？树的最小深度是多少？

*   B 树的最坏情况深度(最大深度)是:logM/2 n。
*   B 树的最佳深度(最小深度)是:logM n。