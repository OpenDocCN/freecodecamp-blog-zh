# 为什么 Elixir 使用链表

> 原文：<https://www.freecodecamp.org/news/elixir-why-linked-lists-aa6828b6b099/>

爱迪生·叶

# 为什么 Elixir 使用链表

![1*L8v2RUaCgJ2O1YiWqQTGwQ](img/0eb7da5494a2cdd2bb3a8590eca8c804.png)

我一直认为数据结构很酷，但你知道什么更酷吗？在野外看到它们！

在浏览 Elixir 的文档时，我看到 Elixir 使用链表作为其线性数据结构。我认为这很酷，但我突然想到了什么；我理解数组和链表，但我不知道它们与编程语言有什么关系。从那以后它就一直困扰着我，我*需要*去找出*为什么要使用*链表…因此有了这篇文章！

所以回到文章:根据我目前的发现，有三个原因可以解释为什么 Elixir 会这样(我可能完全错了，请随时纠正我！).让我们一个一个来看:

### 不可变数据

在 Elixir 中(实际上是大多数函数式语言)，数据是不可变的。这是理解为什么使用链表的重要的第一步，所以让我们来探讨一下。

> *不可变意味着一旦数据被声明，它*就不能再*被改变。*

假设你知道数组是如何工作的(如果你想复习一下，可以看看我的另一篇文章)，让我们看看如果我们试图用数组实现不变性会发生什么！

数组被定义为一个连续的内存块。这样做的问题是，一个包含 5 个元素的数组仍然只是一个数组，当我们添加/删除一个元素时，我们是在改变它。那么我们如何对数组使用不变性呢？这不是不可能的，但是让我们看看为什么这不实际。

如果我们想在数组中实现真正的不变性，这意味着每次我们想在数组中添加/删除数据时，我们都需要制作旧数组的完整副本。

这意味着，如果你有一个大小为 5 的数组，如果你想向数组中添加一个新的项，你的内存使用量会瞬间翻倍(因为你需要保持旧数组不变，还需要做一个相同元素的新数组)。这只是空间复杂性，我们还需要考虑时间复杂性！

链表没有相同的约束，因为节点都单独存储在内存中，这意味着我们在添加/删除列表中的节点时，不需要担心空间/时间的复杂性。

这给了我们为什么使用列表的第一个原因，然而这并不是全部。这就是递归结构/尾部共享的切入点，一切都变得有意义了。

### 递归结构

你注意到链表根据定义是递归的吗？

比如`A -> B ->` C - > D 是一个链表，b `ut so is B` - & `gt; C` - > D，C - > D 等等，每个链接 *ed* list 只是另一个链表的子结构！

这本身并不令人兴奋，但这对下一个谜题至关重要！

> 有趣的事实:递归的本质加上数据必须是不可变的这一事实(所以你不能有循环计数器)是函数式语言通常与递归联系在一起的原因——它们必须这样！

### 结构/尾部共享

所以，我们知道链表本质上是递归的。结合语言的不可变特性，我们知道数据永远不会改变。

这很有趣，因为现在我们可以自信地说`A -> B ->` C - > D 是不同的 l `ist from B` - > C - > D(即使一个递归包含另一个)。因为我们有这样的保证(以及列表不能改变的事实)，我们不必定义相同的数据两次，我们可以重用现有的链表！**这叫做结构共享。**

太棒了，不是吗？让我们看一个例子。

例如:

现在我们有三个不同的列表！`list`、`list_one`和`list_two`，但它们都共享同一个引用(尾部)，它们之间唯一的区别是头部指针。

这意味着内存中总共有 6 个元素。添加到列表具有较低的内存开销，同时保留了我们所期望的不变性。

可重复使用的宝贝！

![1*b31hiO4ynbDLRrXWEFF4aQ](img/3c7ad3512959eeec5aac8aca1daf900b.png)

如果你想读得更多一点，你可以看看 [Trie 树](https://en.wikipedia.org/wiki/Trie)，它们有完全相同的共享数据/前缀的概念！

### 垃圾收集和缓存？

这两个我不太确定，但是我听说链表对 GCs 有好处，并且尾部共享是引用/缓存局部性的一个很好的候选(我不知道怎么做，因为它们不存储在同一个地方)。如果有人想插话，我将不胜感激！

### 结束语

补充说明:实际上，它并不是关于灵药的，因为它可以编译成 Erlang。但这也不是关于 Erlang 的，因为所有的函数式编程做的都差不多……但这是激发我好奇心的原因，也是与 Elixir 的联系。

在写这篇文章的时候，我发现我必须先深入写数组是如何工作的，然后才能深入研究灵丹妙药部分，所以我把它作为另一篇文章发表在这里。请务必阅读这篇文章，以便更好地理解什么是折衷！

[**数组的工作方式数组的工作方式**](https://dev.to/edisonywh/how-arrays-work-the-way-arrays-work-3bpg)
[*在计算机科学中，有线性数据结构的概念，这意味着数据是以…* dev.to](https://dev.to/edisonywh/how-arrays-work-the-way-arrays-work-3bpg) 的方式构造的

我也没有真正谈论大 O 符号，因为我觉得它可能会给文章增加不必要的阅读时间和 T2 复杂度，但是它对计算机科学来说是非常重要和基本的，所以我建议你稍微复习一下。

如果你是播客一类的人，有 CodeNewbie 的 [BaseCS](https://www.codenewbie.org/basecs) ，由 Vaidehi Joshi 和 Saron 共同主持。

如果你想读的话，Vaidehi Joshi 的 blogpost 版本(我相信这是播客的灵感来源)在 BaseCS 媒体上也很棒。

至于视频，[my deschool](https://www.youtube.com/playlist?list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P)是超越惊人的，几乎是我现在所知道的一切的地方，强烈推荐！

除此之外，希望你们都像我喜欢写这篇文章一样喜欢它！

### 来源

[https://elixir-lang . org/getting-started/basic-types . html # linked-lists](https://elixir-lang.org/getting-started/basic-types.html#linked-lists)——这篇文章的灵感来源

*最初发布于[开发到](https://dev.to/edisonywh/-elixir--why-linked-lists--1e9d)*