# HTTP 缓存的深入介绍:Cache-Control & Vary

> 原文：<https://www.freecodecamp.org/news/an-in-depth-introduction-to-http-caching-cache-control-vary/>

### 导言-条款的范围

本系列文章讨论 HTTP 环境中的缓存。如果处理得当，缓存可以将应用程序的性能提高一个数量级。相反，当被忽略或完全忽略时，它会导致一些由行为不当的代理服务器引起的非常不希望的副作用，这些代理服务器在没有明确的缓存指令的情况下，决定无论如何都要缓存并提供陈旧的资源。

在本系列的第一部分中，我们认为从页面加载时间来看，缓存是提高性能最有效的方法。在第二部分中，是时候将我们的重点转移到我们可以使用的机制上了。换句话说:HTTP 缓存实际上是如何工作的？

为了回答这个问题，我们决定考虑一个空缓存开始逐渐缓存和服务资源的情况。随着它逐渐接收传入的 HTTP 请求，我们的缓存将开始相应地运行。当新副本可用时，从高速缓存中提供资源，在多个表示上变化，进行有条件的请求...这样，我们可以根据需要逐步引入每个概念。

首先，我们的空缓存别无选择，只能将请求转发到源服务器。这将允许我们了解源服务器如何指示我们的缓存如何处理资源，例如是否允许存储资源，以及存储多长时间。为此，我们将检查每个缓存控制指令，并澄清其中一些已知具有[冲突含义](https://www.google.com/search?q=must-revalidate+vs+no-cache&oq=must+revalidate+vs+&aqs=chrome.1.69i57j0l3.3140j0j4&sourceid=chrome&ie=UTF-8)的指令。

其次，我们将看看当我们的缓存收到对它已经知道的资源的请求时会发生什么。我们的缓存如何决定它是否可以重用先前存储的响应？它如何将给定的 HTTP 请求映射到特定的资源？为了回答这些问题，我们将学习 Vary 头的表示变化。

本文将关注从 web 开发人员的角度来看最有价值的知识。因此，条件请求只是简单讨论，将是另一篇文章的重点。

事不宜迟，让我们从概述我们将要探索的内容开始。

## HTTP 缓存决策树

从概念上讲，一个缓存系统总是至少包含三个参与者。对于 HTTP，这些参与者是客户机、服务器和缓存代理。

然而，在学习 HTTP 缓存时，我们强烈建议您不要将客户机视为典型的 web 浏览器，因为现在它们都带有自己的 HTTP 缓存层。很难清楚地将浏览器与缓存区分开。出于这个原因，我们邀请您将客户端视为一个无头命令行程序，如 cURL 或任何没有嵌入式 HTTP 缓存的应用程序。

抛开所有的预防措施，现在让我们通过看下图来深入研究这个主题:HTTP 缓存决策树。

![4wnpOGgUnR2bJxcKqsUruzDIQrdmd5o956v85GGUARZKQYG77olAVBslIc_ZL1d0FZLVwlCuLLFeUzlSBYKaE-ALN-dWjijBbkzoVDuoTVQvG_GEAGABdZDXfl8TvBw2NdAgsnxk](img/fba6931ac6ea013bfeded9a2b5d88c14.png)

这张图片展示了每次客户端向缓存系统后面的源服务器请求资源时，请求可能采用的所有路径。仔细研究这个例子可以发现只有四种可能的结果。

在我们的头脑中清楚地分离这些结果实际上非常方便，因为每个重要的缓存概念(缓存指令、表示匹配、条件请求和资源老化)都映射到其中的每一个。

让我们通过引入与 HTTP 缓存术语相关的两个重要术语来简洁地描述每一个:缓存命中和缓存未命中。

### 命中和未命中

第一种可能的结果是缓存找到匹配的资源，并被允许为其提供服务，这在缓存世界中确实是两件截然不同的事情。这种结果就是我们通常所说的缓存命中，也是我们首先使用缓存的原因。

当发生缓存命中时，它会完全卸载源服务器，从而显著降低延迟。事实上，当缓存命中发生在浏览器中时，HTTP 缓存延迟为零，请求的资源立即可用。

不幸的是，缓存命中只占四种可能结果中的一种。其余的属于第二类，也称为缓存未命中，发生这种情况的原因只有三个。

高速缓存未命中通常发生的第一个原因是当高速缓存在其存储中找不到任何匹配的资源时。这通常表明该资源以前从未被请求过，或者已经被从缓存中逐出以释放一些空间。在这种情况下，代理别无选择，只能将请求转发到源服务器，完全下载响应并在响应头中寻找缓存指令。

发生缓存未命中的第二个原因实际上也是有害的，缓存检测到一个匹配的表示，一个它可能使用的表示。然而，资源不再被认为是*新的*——我们将在本文的缓存控制部分看到具体情况——而是被认为是*旧的。*

在这种情况下，缓存向源服务器发送一种特殊的请求，称为*条件请求*。条件请求只允许缓存检索与本地存储中的资源不同的资源。因为只有源服务器有给定资源的最新表示，所以条件请求*总是*必须通过整个缓存代理链到达源服务器。

这些特殊请求只有两种可能的结果。如果资源没有改变，则通过接收 304 Not Modified 响应以及更新的头部和空主体，指示高速缓存使用其本地副本。这个结果，我们列表中的第三个，被称为成功验证。

最后，最后一个可能的结果是资源发生了变化。在这种情况下，源服务器发送一个正常的 200 OK 响应，就像缓存为空并且已经转发了请求一样。换句话说，空缓存和验证失败导致的缓存未命中会产生完全相同的 HTTP 响应。

为了更好地形象化这四条路径，在时间线中描绘它们是有帮助的，如下图所示。

![eV4YKvBdmE_SD0dSlu7Gt4oQKW9IpekfHv5R_odd4m4Hq4HO71cgGez9MtxtGBd5ghP36tfWoj8OTMzE-N0iWiMI5WgOusUl7dOXUtLQM7MvywGqSaYuBRbS4oH-rbXdpdwTWW6h](img/e702371da99046a24e0285c2f6f4bd30.png)

一开始，缓存是空的。请求流从缓存未命中(空缓存结果)开始。在返回途中，缓存将读取缓存指令并存储响应。对该特定资源的所有后续请求都会产生缓存命中，直到该资源变得陈旧并需要重新验证。

在第一次重新验证时，资源可能没有改变，因此，将发送 304 未修改。

然后，资源最终被客户端更新，通常是通过 PUT 或 PATCH 请求。当下一个条件请求到达时，源服务器检测到资源已经改变，并且用更新的 ETag 和 Last-Modified 报头回复 200 OK。

了解缓存命中和缓存未命中以及每个可缓存请求可能采用的 4 种路径，应该会让您对缓存的工作原理有一个很好的了解。

虽然概述只能让你到此为止。在下一节中，我们将详细解释源服务器如何传递缓存指令。

### 源服务器如何传递缓存指令

源服务器通过在它们的响应中添加缓存控制报头，将它们的缓存指令传递给下游缓存代理。这个头是 HTTP/1.1 的附加部分，它取代了不推荐使用的 Pragma 头，Pragma 头从来都不是标准的。

Cache-control 头值称为指令。该规范定义了很多，有不同的用途和[浏览器支持](https://www.mnot.net/blog/2017/03/16/browser-caching)。这些指令主要由开发人员用来传达缓存指令。但是，当出现在 HTTP 请求中时，客户端也可以影响缓存决策。现在让我们花点时间来描述一下最有用的指令。

### 最大年龄

需要了解的第一个重要的缓存控制指令是 max-age 指令，它允许服务器指定一个表示的生存期。它以秒表示。例如，如果一个缓存看到一个包含头 Cache-Control: max-age=3600 的响应，则允许它在接下来的 3600 秒内为该资源的所有后续请求存储和提供相同的响应。

在这 3600 秒内，资源将被认为是新鲜的，并将发生缓存命中。超过这个延迟，资源将变得陈旧，验证将接管。

### 无存储、无缓存、必须重新验证

与 max-age 不同，no-store、no-cache 和 must-revalidate 指令是关于指示缓存不缓存资源的。然而，它们在细微的方面有所不同。无店铺是不言而喻的，事实上，它甚至比名字暗示的还要多一点。当存在时，符合 HTTP/1.1 的高速缓存必须不试图存储任何东西，并且还必须采取行动来删除它可能具有的任何副本，无论是在内存中还是存储在磁盘上。

另一方面，无缓存指令可以说是不言自明的。该指令实际上意味着，在没有首先与源服务器进行验证的情况下，永远不要使用本地副本。通过这样做，它可以防止缓存命中的所有可能性，即使是新资源。

换句话说，无缓存指令要求缓存必须向源服务器重新验证它们的表示。但是接下来出现了另一个指令，笨拙地命名为…必须重新验证。如果这开始让你感到困惑，请放心，你并不孤单。如果你想要的不是缓存，那就必须使用无存储而不是无缓存。如果想要总是重新验证，就必须使用无缓存，而不是必须重新验证。

确实令人迷惑。

至于 must-revalidate 指令，用来禁止缓存为陈旧资源服务。如果资源是新的，必须重新验证完全允许缓存为其服务，而不需要强制任何重新验证，这与无存储和无缓存不同。这就是为什么这个头应该总是与 max-age 指令一起使用，以表明希望缓存一段时间的资源，当它变得陈旧时，强制进行重新验证。当谈到这最后三个指令时，我们发现描述它们的词语的选择特别令人困惑:no-store 和 no-cache 是负面表达，而 must-revalidate 是正面表达。如果用同样的方式表达，他们的差异可能会更明显。

因此，思考它们中的每一个用什么是不允许的术语来表达是有帮助的:

*   **不存储:**从不存储任何东西
*   **无缓存:**从不缓存命中
*   **必须重新验证:**不要过期

从技术上讲，这些指令可以出现在同一个缓存控制头中。将它们组合成逗号分隔的值列表并不罕见。许多流行的网站似乎仍然表现得非常保守，发送回带有以下标题的 HTML 页面:

Cache-Control: no-cache，no-store，max-age=0，must-revalidate

当您偶然发现这一点时，其背后的意图通常非常清楚:web 开发团队希望确保资源永远不会过时。

然而，这样的缓存破坏行可能不再需要了。[过去在 2017 年完成的工作](https://github.com/web-platform-tests/wpt/pull/5137)已经表明，浏览器在缓存控制响应指令方面确实相当符合规范。因此，除非您计划用几十年前的软件建立一个缓存栈，否则只使用您需要的指令就可以了。最流行的组合将在另一篇文章中分析。

### 公共、私人

我们还没有讨论的最后一个重要指令有一点不同，因为它们控制允许哪些类型的缓存来缓存资源。这些是 public 和 private 指令，如果没有指定，private 就是默认的指令。

![kiq8Sq0igyLzRFkX4qddKF4y6xdltA1rXwjBOaqvWlqD1mJbaQe2WuLIparaOSfQ36iUT4kaHSKxzBY4TVbaVXtq7w3W6Hhq7QllsTf6WD2rAFq9MRG2AFNMI-EmUNmLn1TfmKnC](img/7b5575b9c171a979029c7c6b3638bdfd.png)

私有缓存是应该由单个用户使用的缓存。通常，这是 web 浏览器的缓存。相反，CDN 和反向代理处理来自多个用户的请求。

为什么我们需要区分这两种类型的缓存？答案很简单:安全性，如下例所示。

许多 web 应用程序公开便利的端点，这些端点依赖于来自 URL 以外的其他地方的信息。如果两个用户在[https://api.example/com](https://api.example/com/)通过请求/users/me 来访问他们的简档，并且他们的实际用户 id 隐藏在一个授权中:Bearer 4ja 23 42…令牌，缓存将不能告诉这实际上是两个非常不同的资源。

![48yzQ_RyKvQoWxgPmvvwijI74hSD_NNfjViTUDHeNvkmd-U-2wCqgCZWnmjRyTYNqwRGJPZJ-GuIoFbflCT_x6CCB6wIJGdHluEBK9BahnkL7pdzEmV9kwinkwJibC5JTLKAAGct](img/649ee4f2e065541342366e8a76e2feb3.png)

事实上，当构造缓存键时，缓存不检查 HTTP 头，除非特别指示这样做，我们将在下一节看到。

### s-maxage

s-maxage 指令类似于 max-age 指令，只是它只适用于公共缓存，公共缓存也称为*共享*缓存(因此有 s 前缀)。如果两个指令都存在，s-maxage 在公共缓存上将优先于 max-age，在私有缓存上将被忽略。

使用该指令时，一般规则是始终确保 s-maxage 值低于 max-age 值。这个规则背后的推理是，你离原点越近，就越适合经常检查最新的表示是什么。

假设您在代理中缓存一天，在浏览器中缓存一小时。

每次浏览器向上游服务器请求资源时，我们可以在 *提前*知道*代理至少一天不会联系源服务器。因此，为什么不把相同的 TTL 直接放在浏览器中呢？作为结论，最佳做法是在 max-age 中始终省去比 s-maxage 中更长的 TTL。*

这两个指令在技术上并不是原始规范的一部分，而是一个扩展的一部分，该扩展在几年前就被首次描述了。虽然他们的浏览器支持有限，[一些](https://www.fastly.com/blog/stale-while-revalidate-stale-if-error-available-today)流行的 cdn 已经支持他们超过 5 年了！

尽管 stale-while-revalidate 非常有用。顾名思义，它允许缓存到 *"[...]立即返回过时的响应，同时在后台重新验证它，从而对客户端隐藏延迟(在网络和服务器上)。*

事实证明，这种缓存扩展对于图像之类的东西非常有用，在这些地方，减少延迟对于用户体验至关重要，拥有几秒钟的陈旧版本通常比痛苦地下载图像要好。

至于 stale-if-error，如果原始服务器返回 5xx 状态代码，它允许缓存提供过时版本。这给了开发人员一个机会，在宽限期内修复潜在的问题，在此期间，客户不会看到恼人的错误页面。

考虑一下 meteo 第三方脚本的情况。如果气象服务器在几分钟内无法访问，最好在这段时间内显示稍微过时的预报，而不是看到页面的一部分空白(或者如果代码不处理第三方脚本加载失败，则显示整个空白页面)。

### 我们还不知道的是

在研究了这些缓存控制指令之后，我们现在理解了分布在 web 上的应用程序是如何根据它们的需要以多种方式利用 HTTP 缓存机制的。

尽管我们还不知道缓存软件实际上是如何处理它们收到的响应的。他们很可能必须将它存储在某个地方，以便以后检索。毕竟这是任何缓存系统的核心思想。

在正常情况下，这当然看起来像我们所说的实现细节。仅仅知道资源确实以某种方式存储就足够了。然而在这种情况下，多学一点实际上是至关重要的。

忽略管理缓存软件如何将对象从 HTTP 响应空间映射到它们的存储空间的机制，可能会产生意想不到的后果，例如，为不懂中文的用户提供 brotli 编码的中文文档，使用无法解码 brotli \_(ツ)_/的浏览器

## 缓存如何存储和检索资源

尽管这不太可能发生，因为大多数浏览器都可以解码 brotli——而且大多数人都知道如何解码說中文——之前的情况还是很容易发生的。为了理解为什么会这样，我们必须考虑一下*缓存是如何存储它们的表示的。*

凭借他们试图实现的目标，大多数缓存软件应该能够快速检索简单的文本文档。为此，一个非常简单而强大的策略是使用键值存储。这种策略非常适合内存中的表示。因此，设计时必须回答的问题如下:如何从 HTTP 响应构造缓存键？

我们在这里寻找的是一种唯一地*识别*一个*资源的方法。*很方便，这正是为什么 [URI](https://tools.ietf.org/html/rfc3986) s -统一资源标识符-首先被发明出来！

但是 URIs 没有说出资源的全部真相。他们从来没有完整地描述过它们，即使仅仅是因为资源会随着时间的推移而变化。

网站更名，新内容发布，用户更新个人资料。当然，不是因为同样的原因或同样的频率，尽管所有的资源最终都会改变。事实上，整个条件请求规范都是基于这个唯一的观察:*除了* [*改变*](https://en.wikiquote.org/wiki/Heraclitus) *之外，没有什么是永久的。*

然而，撇开哲学引语不谈，还有另一个与时间无关的原因来解释资源的变化。事实上，在任何时候，资源都可能以多种表现形式存在。这就是为什么我们有内容协商。

HTTP 请求头 Accept、Accept-Language、Accept-Encoding、Accept-Charset(以及其他一些严格来说不属于内容协商的头)增加了另一个表示可能不同的维度。因此，找到一个好的缓存键的问题变得更加复杂。由于所有这些表示都共享相同的 URI，缓存必须有办法区分它们，以便在每个客户机上提供正确的表示，支持内容协商。

并且因为只有源服务器知道哪些不同的表示可用，所以源服务器再次负责向高速缓存指示它将基于哪些报头生成不同的表示。为此，源服务器必须添加一个 Vary [头](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Vary_response_header),其中包含请求头的值，这将导致生成不同的表示。

当缓存看到来自源服务器的响应时，例如，报头 Vary **:** Accept-Language，它将检查Accept-Language 报头的值，例如 fr-FR **，**，并使用该值来构造更具体的缓存密钥，可能像 https://example.net/home.html_**FR*****。***

实际的实施策略对我们来说并不重要。改变缓存键可能并不是最好的方法。它不得不使用头部的*值*来区分表示。

当资源在多个表示中可用时，Vary 头实际上可以指向多个头。当涉及多个头时，选择缓存键并不比只有一个头复杂多少。多维度变化的真正问题是组合[爆炸](https://en.wikipedia.org/wiki/Combinatorial_explosion)。

不幸的是，这是没有办法的。如果您要在多个表示中缓存和提供您的资源，您必须支付大容量存储的成本。如果您决定降低 vary 基数，一些用户将会收到与他们的请求不匹配的响应的缓存命中。

另一方面，如果您在所有方面都做了适当的改变，并且没有足够的存储空间，那么您的用户很可能不会很快看到缓存命中。

现在，重要的是要知道，如果您决定使用公共缓存，这只是一个问题，因为来自两个不同用户的两个不同请求在代理级别上运行相同的代码。如果您决定只利用浏览器的缓存，那么您可以完全跳过 Vary 头，并在任意多的表示中提供资源。这是因为每个浏览器的缓存将只缓存符合用户偏好的表示。这是好消息！

但是我们先不要高兴得太早。正如我们所说的，缓存使用头部的*值*作为其输入来生成更具体的缓存键。但是怎么说所有这些值都是格式良好的呢？绝对没有！这是 RFC [父亲](https://tools.ietf.org/html/rfc2468)的[健壮性原则](https://en.wikipedia.org/wiki/Robustness_principle)相当不方便的后果。HTTP 服务器在接受什么方面确实非常自由。

然而还是有希望的。

考虑到源服务器只能产生两种不同语言的表示，缓存必须能够重组传入的接受内容值，如 fr、fr-FR、fr_FR *..*变成 FR 之类的东西。否则，就像之前的组合爆炸一样，表示的数量会爆炸，但在这种情况下，是出于一个被误导的原因。

所有这些表示重新组合的过程被称为*规范化*，通常在缓存中完成。许多缓存提供配置实用程序或它们自己的语言来处理这些情况。有时，函数甚至已经写好了，或者可以很容易地在互联网上找到代码片段。下图说明了臭名昭著的用户代理头的过程。

![YjJ67y4VX8-kzzVY78G6ICtdafwsx_M6_n9ce30Qv9jVYU3LrBXQrrxb13VkPjpm9WpBNs6JParrx5VEbtuKwKr5cTSUmMiXcayum2RTwRKho3c6R5iqmYj0lYqM5f6Klb2leIAo](img/c8856b2753b446f0f4d45bd30ea27a85.png)

Fastly，一个流行的 CDN，[对](https://www.fastly.com/blog/best-practices-using-vary-header) 100 000 个请求进行了采样，发现 Accept-Encoding 报头有 44 种不同的表达方式！至于用户代理标题，他们发现了大约 8000 个不同的标题！如果没有规范化，缓存可能永远看不到任何命中。

这就结束了关于表示变化的部分。至此，我们知道了如何指示缓存来存储我们的资源，并且学会了利用 Vary 头来防止在使用公共缓存时发生意外。我们现在已经涵盖了足够的规范，能够有效地缓存资源。

### 常见的误解

到目前为止，您应该对 HTTP 缓存的工作原理有了透彻的理解。新鲜度控制、资源表示和缓存命中对你来说不再是神秘的概念。如果你开始觉得所有这些知识都赋予了你力量，我们有一些好消息要告诉你:我们已经涵盖了规范的大部分，你现在已经知道了启动和运行所必需的几乎所有东西。

但是不要搞错了。缓存*是*一个复杂的话题。

经验告诉我们，除非你每天都在处理它，否则今天可能非常清晰的东西在几周后会很快变得模糊不清。因此，我们决定通过消除两个很容易犯的常见错误来结束第二篇文章。

### 新鲜度控制和验证

在阅读了前面的章节之后，这似乎是显而易见的，但是值得重复多次。新鲜度控制和验证(*我们在开始*中已经稍微讨论过)是两种截然不同的机制，服务于两种截然不同的目的，并且涉及不同部分之间的 HTTP 请求。

*   新鲜度控制总是发生在高速缓存**中，且完全基于时间**
*   验证总是发生在原始服务器中，并且基于**时间和标识符(etag)**

我们发现提醒自己这一点很重要。这意味着一旦高速缓存接收到临时指令，它就可以——并且最好相信它会——服务资源，而无需联系源服务器，直到定时器到期。

例如，如果您的 web 应用程序的 HTML 文件到达浏览器，而 HTTP 响应恰好包括头 Cache-Control: max-age=86400，浏览器将很乐意在一天内为您的应用程序提供相同的版本。在这种情况下，如果有人决定刷新浏览器的缓存，浏览器将在一天内为其提供服务，而您或除用户之外的任何人都不会采取任何可能的行动。

如果你认为每个人都会犯错，而且有一天还不算太糟糕，那么，请做好准备:最大年龄值是… 31536000 秒！也就是说，*一年。*这就是 HTML 文件这样缓存非常危险的原因，一般应该用 Cache-Control: no-cache 声明。

### 新鲜度和最近的表现

另一个误解是认为缓存命中和新鲜度与拥有资源的最新可用版本有任何关系。这是我们都想达到的目标，但是我们永远无法真正知道从缓存中获得的资源是否是最新的版本。事实上，即使在没有缓存的情况下也是如此。这与分布式应用的本质有关:其他人的行为可以随时改变我们正在交互的事物。

当查询应用程序的状态时，必须始终使用 ETag 头来让服务器知道我们当前对应用程序状态的理解。如果它与服务器的不匹配，409 冲突预计将在客户端接收。

## 结论

在这篇文章中，我们描述了缓存实际上是如何工作的。现在是启动本地开发服务器并摆弄这两个核心头文件的好时机:Cache-Control 和 Vary，看看它们的运行情况。

我们首先概述了缓存的工作原理，举例说明了请求可能采取的四种路径:满意路径(缓存命中)和缓存未命中的三种可能方式:空缓存、失败的重新验证和成功的重新验证。仅这一概述就有可能理解复杂的缓存拓扑是如何组合在一起的。

然后，我们深入研究了所有最有用的缓存控制头，并阐明了一些容易被忽略的细微差别。

我们还查看了 Vary 头以及资源和表示之间的根本区别，以避免将错误的*表示*提供给正确的客户端。

最后，我们花了一些时间从你可能遇到的常见误解的角度来回顾一下，希望能帮助你避免这些误解。

在下一篇文章中，我们将应用所有这些知识来建立一个本地实验室环境，在这个环境中，我们将使用负载测试工具让一个无辜的 node.js 应用程序着火，然后在一个流行的缓存软件的帮助下拯救它。

敬请期待！

### 为了更进一步:

关于我们覆盖的材料(和其他东西)的官方说明
[https://tools.ietf.org/html/rfc7234#section-5.3](https://tools.ietf.org/html/rfc7234#section-5.3)

Google Web 的基本面
[https://developers . Google . com/Web/fundamentals/performance/optimizing-content-efficiency/http-caching # defining-optimum-cache-control-policy](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#defining-optimal-cache-control-policy)

关于 Cache-Control 头:
[https://developer . Mozilla . org/fr/docs/Web/HTTP/Headers/Cache-Control](https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Cache-Control)

关于 Vary Header:
[https://www . smashingmagazine . com/2017/11/understanding-Vary-Header/](https://www.smashingmagazine.com/2017/11/understanding-vary-header/)
[https://www . fastly . com/blog/best-practices-using-Vary-Header](https://www.fastly.com/blog/best-practices-using-vary-header)
[https://www.fastly.com/blog/getting-most-out-vary-fastly](https://www.fastly.com/blog/getting-most-out-vary-fastly)
[https://www . fastly . com/blog/understanding-Vary-Header-browser](https://www.fastly.com/blog/understanding-vary-header-browser)