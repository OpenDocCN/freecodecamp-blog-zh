# 面向 Android 开发人员的函数式编程—第 1 部分

> 原文：<https://www.freecodecamp.org/news/functional-programming-for-android-developers-part-1-a58d40d6e742/>

作者:阿努普·考库尔

# 面向 Android 开发人员的函数式编程—第 1 部分

![M092QxbVAURS49mtvuj93LXIJQkLIdrgydzs](img/e1fd4a51b0e3197dfa01f4fdc39447be.png)

Credit — julian255 on reddit

最近，我花了很多时间学习 [Elixir](http://elixir-lang.org/) ，这是一种非常棒的函数式编程语言，对初学者来说很友好。

这让我想到:为什么不在 Android 编程中使用一些来自函数世界的概念和技术呢？

当大多数人听到术语*函数式编程时，*他们会想到喋喋不休地谈论单子、高阶函数和抽象数据类型的黑客新闻帖子。这似乎是一个神秘的宇宙，远离普通程序员的辛苦劳作，只为来自努曼诺尔王国的最强大的黑客保留。

嗯，*去他的*！我在这里告诉你，你也可以学习它。你也可以用它。你也可以用它创建漂亮的应用程序。应用程序拥有优雅、可读的代码库，错误更少。

欢迎来到面向 Android 开发者的函数式编程(FP)。在这个系列中，我们将学习 FP 的基础知识，以及如何在优秀的 Java 和新的优秀的 Kotlin 中使用它们。这样做的目的是保持概念的实用性，尽可能避免学术术语。

FP 是一个庞大的课题。我们将只学习对编写 Android 代码有用的概念和技术。为了完整起见，我们可能会访问一些不能直接使用的概念，但我会尽量保持材料的相关性。

准备好了吗？我们走吧。

### 什么是函数式编程，我为什么要使用它？

好问题。术语 *Functional programming* 是一系列编程概念的总称，这个名称并不恰当。其核心是，这是一种编程风格，将程序视为数学函数的评估，避免了*可变状态*和*副作用*(我们很快就会谈到这些)。

其核心是，FP 强调:

*   **声明性代码** —程序员应该担心*什么*，让编译器和运行时担心*如何**。***
*   **显式** —代码应该尽可能显而易见。特别是副作用要被隔离以避免意外。数据流和错误处理被明确定义，并且避免了像 *GOTO* 语句和*异常*这样的构造，因为它们会使你的应用程序处于意外状态。
*   **并发**——默认情况下，大多数功能代码都是并发的，因为有一个被称为*功能纯度*的概念。普遍的共识似乎是，这一特点尤其导致函数式编程越来越受欢迎，因为 CPU 内核不再像过去那样每年都变得更快(参见[摩尔定律](https://en.wikipedia.org/wiki/Moore's_law))，我们必须让我们的程序更加并发，以利用多核架构。
*   **高阶函数** —函数是第一类成员，就像所有其他语言原语一样。你可以像传递一个字符串或一个整型数一样传递函数。
*   **不变性** —变量一旦被初始化就不能被修改。一个东西一旦被创造出来，就永远是那个东西。如果你想改变它，你就创造一个新事物。这是明确性和避免副作用的另一个方面。如果你知道一个事物不会改变，当你使用它时，你会对它的状态更有信心。

声明式、显式和并发代码，更容易推理，旨在避免意外？我希望我激起了你的兴趣。

在这个系列的第一部分，让我们从 FP 中一些最基本的概念开始:*纯度*、*副作用*和*排序*。

### 纯函数

如果一个函数的输出只依赖于它的输入，并且没有副作用，那么这个函数就是纯函数(我们将在这之后讨论副作用)。让我们看一个例子，好吗？

考虑这个简单的将两个数相加的函数。它从文件中读取一个数字，另一个数字作为参数传入。

**Java**

```
int add(int x) {    int y = readNumFromFile();    return x + y;}
```

**锅炉**

```
fun add(x: Int): Int {    val y: Int = readNumFromFile()    return x + y}
```

这个函数的输出不仅仅依赖于它的输入。根据 *readNumFromFile()* 返回的内容，对于 *x* 的相同值，它可以有不同的输出。这个功能据说是*不纯*。

让我们把它转换成一个纯函数。

**Java**

```
int add(int x, int y) {    return x + y;}
```

**锅炉**

```
fun add(x: Int, y: Int): Int {    return x + y}
```

现在函数的输出只依赖于它的输入。对于给定的 *x* 和 *y，*函数将总是返回相同的输出。这个功能现在被说成是*纯*。数学函数也以同样的方式运行。一个数学函数的输出只依赖于它的输入——这就是为什么函数式编程比我们习惯的通常编程风格更接近数学。

注:空输入仍然是输入。如果一个函数没有输入，每次都返回相同的常数，那么它仍然是纯函数。

P.P.S .对于给定的输入，总是返回相同的输出的特性也被称为*引用透明性*，你可能会在讨论纯函数时看到它的使用。

### 副作用

让我们用同一个加法函数例子来探讨这个概念。我们将修改加法函数，也将结果写入文件。

**Java**

```
int add(int x, int y) {    int result = x + y;    writeResultToFile(result);    return result;}
```

**锅炉**

```
fun add(x: Int, y: Int): Int {    val result = x + y    writeResultToFile(result)    return result}
```

这个函数现在将计算结果写入一个文件。即它现在正在修改外部世界的状态。这个函数现在据说有一个*副作用*，不再是一个纯函数。

任何修改外部世界状态的代码——改变变量、写入文件、写入数据库、删除某些东西等等——都被认为有副作用。

在 FP 中避免使用有副作用的函数，因为它们不再是纯粹的，而是依赖于*历史背景*。代码的上下文不是独立的。这使得他们更加难以理解。

假设您正在编写一段依赖于缓存的代码。现在，代码的输出取决于是否有人写入了缓存，缓存中写入了什么，何时写入的，数据是否有效等等。你不能理解你的程序在做什么，除非你理解它所依赖的缓存的所有可能的状态。如果你把它扩展到包括你的应用所依赖的所有其他东西——网络、数据库、文件、用户输入等等，就很难知道到底发生了什么，也很难一下子记住所有的东西。

这是否意味着我们不使用网络、数据库和缓存？当然不是。在执行的最后，你希望应用程序做一些事情。在 Android 应用程序的情况下，这通常意味着更新用户界面，以便用户可以从我们的应用程序中获得有用的东西。

FP 最伟大的想法不是完全放弃副作用，而是控制和隔离它们。我们没有让我们的应用程序充满有副作用的函数，而是将副作用推到系统的边缘，使它们的影响尽可能小，使我们的应用程序更容易推理。当我们在本系列的后面为我们的应用探索一个*功能架构*时，我们将详细讨论这一点。

### 排序

如果我们有一堆没有副作用的纯函数，那么它们的执行顺序就变得无关紧要了。

假设我们有一个函数在内部调用了 3 个纯函数:

**Java**

```
void doThings() {    doThing1();    doThing2();    doThing3();}
```

**锅炉**

```
fun doThings() {    doThing1()    doThing2()    doThing3()}
```

我们肯定地知道这些函数并不相互依赖(因为一个函数的输出不是另一个函数的输入)，我们也知道它们不会改变系统中的任何东西(因为它们是纯的)。这使得它们的执行顺序完全可以互换。

对于独立的纯函数，可以重新调整和优化执行顺序。注意，如果 *doThing2()* 的输入是 *doThing1()* 的结果，那么这些必须按顺序执行，但是 *doThing3()* 仍然可以被重新排序为在 *doThing1()之前执行。*

这种有序属性给我们带来了什么呢？*并发，*那是什么！我们可以在 3 个独立的 CPU 内核上运行这些功能，而不用担心会搞砸任何事情！

在许多情况下，像 [Haskell](https://www.haskell.org/) 这样的高级纯函数语言中的编译器可以通过正式分析您的代码来判断它是否是并发的，并且可以阻止您用死锁、竞争条件等来搬起石头砸自己的脚。理论上，这些编译器还可以自动并行化你的代码(据我所知，目前还没有任何编译器支持这一功能，但研究仍在进行中)。

即使您的编译器没有查看这些东西，作为一名程序员，能够通过查看函数签名来判断您的代码是否是并发的，并避免试图并行化命令性代码的讨厌的线程错误，这可能充满隐藏的副作用，这是非常好的。

### 摘要

我希望这第一部分引起了你对 FP 的兴趣。纯粹的、无副作用的函数使得对代码进行推理变得更加容易，并且是实现并发性的第一步。

然而，在我们讨论并发性之前，我们必须了解*不变性*。我们将在本系列的第 2 部分中这样做，看看纯函数和不变性如何帮助我们编写简单易懂的并发代码，而不需要借助锁和互斥体。

#### 接下来阅读

[**面向 Android 开发者的函数式编程—第二部分**](https://medium.com/@anupcowkur/functional-programming-for-android-developers-part-2-5c0834669d1a)
[*如果你还没有看过第一部分，请在这里阅读:*medium.com](https://medium.com/@anupcowkur/functional-programming-for-android-developers-part-2-5c0834669d1a)

*如果您喜欢，请点击？下面。我注意到了每一个人，我感谢他们中的每一个人。*

如果你想了解更多关于编程的想法，请关注我，这样当我写新帖时你会得到通知。