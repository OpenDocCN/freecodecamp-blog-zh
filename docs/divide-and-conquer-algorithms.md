# 分治算法的含义:举例说明

> 原文：<https://www.freecodecamp.org/news/divide-and-conquer-algorithms/>

## 什么是分治算法？(不，不是“分而治之”)

分而治之是一种算法范式(有时被错误地称为“Divide and Concur”——一个有趣而贴切的名字)，类似于贪婪和动态编程。典型的分治算法使用以下三个步骤来解决问题。

1.  **划分**:将给定的问题分解成同类型的子问题。这一步包括将问题分解成更小的子问题。子问题应该代表原问题的一部分。这一步一般采用递归的方法来划分问题，直到没有子问题可以进一步划分。在这个阶段，子问题本质上变成了原子问题，但仍然代表了实际问题的一部分。
2.  **征服**:递归求解这些子问题。这一步接收许多要解决的更小的子问题。一般来说，在这个层次上，问题被认为是自行“解决”的。
3.  **组合**:适当组合答案。当更小的子问题被解决时，这个阶段递归地组合它们，直到它们形成原始问题的解决方案。这种算法方法递归地工作，并且征服&合并步骤工作得如此接近，以至于它们看起来像一个步骤。

这种方法通常允许我们在很大程度上降低时间复杂度。

例如，冒泡排序使用的复杂度为`O(n^2)`，而快速排序(分而治之的应用)将时间复杂度降低到`O(nlog(n))`。线性搜索有时间复杂度`O(n)`，而二分搜索法(分而治之的一个应用)将时间复杂度降低到`O(log(n))`。

以下是一些标准算法，是分治算法的变种。

**二分搜索法**是一种搜索算法。在每一步中，该算法将输入元素(x)与数组中中间元素的值进行比较。如果值匹配，则返回中间的索引。否则，如果 x 小于中间元素，则算法递归到中间元素的左侧，否则递归到中间元素的右侧。

**快速排序**是一种排序算法。该算法选取一个透视元素，重新排列数组元素，使所有小于所选取的透视元素的元素移到透视的左侧，而所有大于透视元素的元素移到右侧。最后，该算法对 pivot 元素左右的子数组进行递归排序。

**归并排序**也是一种排序算法。该算法将数组分成两半，对它们进行递归排序，最后合并排序后的两半。该算法的时间复杂度为`O(nLogn)`，无论是最好情况、一般情况还是最坏情况。它的时间复杂度可以很容易地从递归等价于:`T(n) = 2T(n/2) + n`来理解。

**最近的一对点**问题是在 x-y 平面的一组点中寻找最近的一对点。通过计算每一对点的距离并比较这些距离以找到最小值，可以在`O(n^2)`时间内解决该问题。分治算法在`O(nLogn)`时间内解决问题。

**斯特拉森算法**是两个矩阵相乘的高效算法。两个矩阵相乘的简单方法需要 3 个嵌套循环，并且是`O(n^3)`。斯特拉森算法在`O(n^2.8974)`时间内将两个矩阵相乘。

**库利–图基快速傅立叶变换(FFT)算法**是 FFT 最常用的算法。这是一种在`O(nlogn)`时间内有效的分治算法。

**Karatsuba 算法**是第一个比二次“小学”算法渐近更快的乘法算法。它将两个 n 位数的乘法运算减少到至多 n^1.585(以 2 为基数的 3 的对数的近似值)个位数乘积。因此，它比需要 n^2 个位数乘积的经典算法更快。

### 分而治之(D & C)与动态规划(DP)

两种范式(D & C 和 DP)都将给定的问题分成子问题并解决子问题。对于给定的问题，如何选择其中的一个？当相同的子问题没有被多次评估时，应该使用分治法。否则应该使用动态编程或记忆。

例如，二分搜索法是一个分治算法，我们不会再计算同样的子问题。另一方面，为了计算第 n 个斐波那契数，动态编程应该是优选的。