# 揭秘 ES6 可迭代程序和迭代器

> 原文：<https://www.freecodecamp.org/news/demystifying-es6-iterables-iterators-4bdd0b084082/>

提哥·洛佩斯·费雷拉

ES6 引入了一种与 JavaScript 数据结构交互的新方式— **迭代**。让我们来揭开它的神秘面纱。

有两个核心概念:

*   **Iterable** —由一种数据结构描述，这种数据结构提供了一种向公众公开其数据的方式。这是通过实现一个键为`Symbol.iterator`的方法来实现的。`Symbol.iterator`是迭代器的工厂。
*   **迭代器** —由包含指向迭代中下一个元素的指针的结构描述。

### 草案

iterable 和 iterator 都遵循使对象成为 iterable 的协议:

*   一个**可交互的**必须是一个带有函数迭代器的对象，它的键是`Symbol.iterator`。
*   一个**迭代器**必须是一个带有名为`next`的函数的对象，该函数返回一个带有关键字的对象:`value` —迭代中的当前项；并且如果迭代已经完成，则`done` — *真*，否则*假*。

#### 迭代性

可迭代性遵循*数据源*和*数据消费者*的思想:

*   数据源是数据消费者获取数据的地方。例如，`Array`如`[1,2,3]`是保存数据的数据源结构，数据消费者将通过它进行迭代(例如，`1, 2, and 3`)。更多的例子有`String`、`Maps`和`Sets`。
*   **数据消费者**——消费来自数据源的数据的人。例如，`for-of`循环是一个能够遍历`Array`数据源的数据消费者。更多的例子是`spread operator`和`Array.from`。

对于一个要成为数据源的结构来说，它需要允许并说明它的数据应该如何被消费。这是通过**迭代器**完成的。因此，*数据源*需要遵循上面描述的迭代器协议。

然而，让每个*数据消费者*都支持所有*数据源*是不现实的，尤其是因为 JavaScript 允许我们构建自己的数据源。所以 ES6 引入了接口 **Iterable** 。

*数据消费者*通过 **iterables** 消费来自*数据源*的数据。

#### 在实践中

让我们看看这是如何在一个定义好的数据源— `Array`上工作的。

### 可迭代数据源

![1*tqsRBISIOIoXcCAYp7V1Lw](img/ff1b091abc9473bacb63b513c390f7e2.png)

我们将使用`for-of`来探索一些实现了**可迭代协议**的数据源。

#### 简单的物体

在这个阶段，我们需要说普通对象是不可迭代的。Axel Rauschmayer 在[探索 ES6](http://exploringjs.com/es6/) 中做了很好的解释。

一个简单的解释是，我们可以在两个不同的层次上迭代 JavaScript 对象:

*   **程序级**——这意味着迭代表示其结构的对象属性。例如，`Array.prototype.length`，其中`length`与对象的结构有关，而不是它的数据。
*   **数据级**——意味着迭代一个数据结构并提取它的数据。例如，对于我们的`Array`示例，这意味着迭代数组的数据。如果是`array = [1,2,3,4]`，迭代数值`1, 2, 3 and 4`。

> 然而，将迭代的概念引入普通对象意味着混淆程序和数据结构——[阿克塞尔](http://(https://twitter.com/rauschma)

普通对象的问题是每个人都有能力创建自己的对象。

*在我们 Hugo 的例子中，JavaScript 如何区分数据级，即`Hugo.fullName`和程序级，即`Hugo.toString()`？*

虽然可以在定义明确的结构上区分两个层次的迭代，比如`Arrays`，但是不可能对任何对象都这样做。

这就是为什么我们在`Array`(也在`String`、`Map`和`Set`)上免费得到迭代，但在普通对象上却没有。

> 然而，我们可以实现我们自己的 iterables。

### 实现可迭代的

![1*PZBEg-i1BCHKA-sPsVoMJg](img/075fd3baeb3f9a28a421d9258c23f429.png)

我们可以构建自己的可迭代对象，尽管我们通常使用生成器来实现。

为了构建我们自己的 iterable，我们需要遵循迭代协议，该协议规定:

*   如果一个对象实现了一个键为`Symbol.iterator`的函数并返回一个`iterator`，那么这个对象就变成了一个**可迭代的**。
*   `iterator`本身是一个对象，内部有一个名为`next`的函数。`next`应该返回一个带有两个键`value`和`done`的对象。`value`包含迭代的下一个元素，而`done`是一个标志，表示迭代是否已经完成。

#### 例子

我们的可迭代实现非常简单。我们遵循了**可迭代协议**，在每次迭代中`for-of`循环将向迭代器请求`next`元素。

我们的迭代器将在`next`返回一个包含以下内容的对象:

请注意，为了方便起见，我们交换了属性`next`和`done`的顺序。首先使用`next`，这会破坏实现，因为我们将首先弹出一个元素，然后对元素进行计数。

知道默认情况下`done`是`false`是有用的，这意味着在这种情况下我们可以忽略它。当`done`是`true`时`value`也是如此。

我们马上就会看到。

#### 迭代器作为可迭代的

我们可以将迭代器构建成可迭代的。

请注意，这是 ES6 内置迭代器遵循的模式。

**为什么这是一个有用的？**

虽然`for-of`只对 iterables 有效，对迭代器无效，但是相同意味着我们可以暂停`for-of`的执行并继续 afterwords。

#### 回抛

有两个可选的迭代器方法我们还没有探索:

**返回**

`return`给迭代器机会**在它意外中断时清理**房子。当我们在迭代器上调用`return`时，我们指定不再计划调用`next`。

**投掷**

`throw`仅适用于发电机。当我们玩发电机时，我们会看到这一点。

### 结论

ES6 带来了迭代，这是一种迭代 JavaScript 数据结构的新方法。

> 为了使迭代成为可能，有包含数据的*数据生产者*，和获取数据的*数据消费者*。

为了使这种结合顺利进行，迭代是由一个协议定义的，该协议规定:

*   一个`iterable`是实现一个键为`Symbol.iterator`的函数并返回一个`iterator`的对象。
*   一个`iterator`是一个内部有一个叫做`next`的函数的对象。`next`是一个带有两个键`value`和`done`的对象。`value`包含迭代的下一个元素，而`done`是一个标志，表示迭代是否已经完成。

普通对象不是`iterable`，因为没有简单的方法来区分程序和数据级迭代。

这就是为什么 ES6 提供了一种通过遵循`iterator`协议来构建我们自己的迭代器的方法。

![1*IwfjCQMFHLP5iswRC7dLyg](img/9ec02648753163392ca11e40e54b4a98.png)

### 感谢:

*   [阿克塞尔·劳施迈尔](https://twitter.com/rauschma)为他的[探索 ES6——迭代](http://exploringjs.com/es6/ch_iteration.html)
*   [尼古拉斯·贝瓦夸](https://twitter.com/nzgb)的 [PonyFoo — ES6 深度迭代器](https://ponyfoo.com/articles/es6-iterators-in-depth)
*   致所有辛普森一家的粉丝