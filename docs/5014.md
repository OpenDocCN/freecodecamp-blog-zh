# 安全是库伯内特人的标准。

> 原文：<https://www.freecodecamp.org/news/security-as-standard-in-the-land-of-kubernetes-50bfad74ca16/>

克里斯·库尼

# 安全是库伯内特人的标准。

![UukU0-DINu9i3ozgvXcCN2a8uIYoUQD-HnRT](img/365b104212a9b1dfd156b5f4a6f6ff16.png)

Kubernetes 中的安全性需要一些工作，但是团队可以采取一些明确的步骤来确保他们的信息安全。

我写 Kubernetes 已经有一段时间了。我每天都在工作的地方使用它。在过去的几个月里，我们的任务是创建库伯内特斯集群的诺克斯堡。如果攻击者通过了网络层、防火墙和 WAFs，他们会发现自己的选择非常少。它源于我从 LearnK8s 的先生们那里得到的一条建议。

> Kubernetes 将自动为您处理高可用性、部署、配置和机密，但它不会自行加强安全性。那需要一些工作。

这并不是说 Kubernetes*不安全*，这只是一种对待软件的不同方式。一种有利于持续交付、零停机部署和高可用性的方式。Kubernetes 会帮你做这些事情，不费吹灰之力。另一方面，安全需要自愿的努力。这是我过去几个月的工作，我想我应该分享一下我学到的经验。首先，我们心目中的首要理想。

### 作为标准的安全性

这很简单。确保他们的应用、部署和配置的每一层都是安全的，这不应该是每个工程师的工作。想想这其中涉及的返工量。

*   漂移的绝对可能性，支持引入的复杂性。
*   这就产生了筒仓和脱节的架构，因为每个人基于他们的经验都有稍微不同的方法。

目的是要求*最小的开发人员努力*和*最大的自动安全性*。

### 那么我们如何实现这一点呢？

这将构成本文的核心。我整理了一个工具和实践的列表，可以用来帮助培养一个技术生态系统，为工程师创造一个安全可靠的工作环境。

这绝不是一份详尽的清单。更像是初学者工具包。有一些基本的想法和一些更具实验性的想法。诀窍是找到适合您的方法，但是要记住两个标准——最少的开发人员工作量，最大的自动安全性。

### Kubernetes 网络政策

我毫不怀疑，大多数阅读这篇文章的人都会了解 Kubernetes 中的`[NetworkPolicy](https://kubernetes.io/docs/concepts/services-networking/network-policies/)`。当您从 Kubernetes 集群中的安全性开始时，这就是黄金。简而言之，它允许工程师锁定哪些其他服务可以与这个 pod 对话。例如，您可以像这样创建一个`NetworkPolicy`:

```
kind: NetworkPolicyapiVersion: networking.k8s.io/v1metadata:  name: api-allowspec:  podSelector:    matchLabels:      app: my-app  ingress:  - from:      - podSelector:          matchLabels:            app: my-other-app
```

我们在这里陈述了一些非常具体的东西。我们已经说过，应该只有一个东西能够与我们的应用程序对话。那是一个标有`my-other-app`的吊舱。如果在您的集群中创建了一个流氓容器，任何与`my-app`通信的尝试都将受阻。然而，我们可以更进一步。

网络策略不仅链接到应用程序，还可以连接到整个名称空间，创建一些管理所有应用程序的基本规则。因此可以创建一个`default-deny`规则。这实际上会将所有流量列入黑名单，并且需要另一个`NetworkPolicy`将通信列入白名单。

但是我们有一个问题。不是每个人都会创建和使用一个`NetworkPolicy`。它们有时很不方便，也很棘手，人们会偏向容易的一边，去找一个开口的容器。到目前为止，我们已经有了很高的开发效率和安全性。这就提出了一个问题。我们如何让工程师的生活更轻松，同时保持高度的安全性？答案，是*掌舵人*。

### 利用舵保持一致性

Helm 允许你将大量的 Kubernetes 资源捆绑到一个单独的*图表*中。它最常见的用例是让第三方软件的部署变得琐碎——你可以在闲暇时细读大量的[稳定掌舵图](https://github.com/helm/charts/tree/master/stable)。每个人都有一个图表，当你想在你的 kubernetes 集群中使用一些开源工具时，它应该是你的第一个选择。

灯泡现在应该亮了。如果我们可以创建自己的舵图，并包含一个`NetworkPolicy`作为标准，会怎么样？我们可以把各种各样的东西放在里面——比如说`PodDisruptionBudget` 或者 `HorizontalPodAutoscaler`。如果您可以确保您的工程师使用您的导航图进行部署，那么您也可以确保他们只需付出最少的努力就能获得正确的资源。您只是减少了开发人员的工作量，并保持了相同的安全级别。得分！

所以，现在你的应用程序正在限制谁可以和谁不可以说话，但是你如何知道确保你的应用程序不能运行一堆破坏性的命令给它周围的其他应用程序呢？

### 基于角色的服务访问控制(RBAC)

RBAC 是库伯内特斯星团中非常常见的特征。我强烈建议打开它。我们通常将它用于第三方应用程序和开发人员访问，但我们也可以以`ServiceAccount`资源的形式将它用于我们的软件。我们可以将它们与特定的`Role`或`ClusterRole`关联起来，这样一来，您的集群中就不会再有应用程序失控的风险了。

Kubernetes 文档很好地帮助您理解了这一点。[读了就开悟了。](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions)我的一点建议是，一旦你理解了它的本质，就把它写进你的掌舵图。不要强迫工程师这样做，因为他们迟早会避免这样做。或者恨你。或者两者都有。请记住，最少的开发人员的努力。

### 在使用 Kubescore 部署之前验证您的 Yaml

所以你已经为你的应用程序准备了一个强大的掌舵图，但是并不是所有的东西都是应用程序。有很多东西，Nexus 服务器和 CI 工具，不会通过典型的方式部署。通常，来自工程师机器的厚颜无耻的`kubectl`命令会打开最大的漏洞。

一个技巧是使用一个名为 [kube-score](https://github.com/zegl/kube-score) 的工具来提供一个简单、一致和客观的服务质量评估。这里需要信任的元素——您可以编造一些东西来防止任何 yaml 应用失败，但是在第一种情况下，简单地让您的工程师知道这个工具就足以让您继续工作。

### 使用 kube-bench 测试您的集群配置

有一个叫做 [kube-bench](https://github.com/aquasecurity/kube-bench) 的出色工具可以分析你的节点配置。这将测试您是否禁用了特权容器，以及您的 kubelet 是否正在与 HTTPS 的主节点通信。

和所有事情一样，你不太可能通过每一项指标——这是很严格的。关注大问题，工具突出显示为关键的任何问题。这是您可以在幕后完成的工作，不会中断工程，如果您的集群与其他地方的漏洞发生冲突，从长远来看，这将使您受益。

### 创建一组标准的基本 Docker 图像

所有这些的一个漏洞是应用程序容器本身。漏洞无时无刻不在其中蔓延，这种未知的数量为难以诊断的错误和漏洞创造了一个奇妙的小藏身之处。

然而，并没有失去一切。谷歌的好伙计们一直在开发[发行版](https://github.com/GoogleContainerTools/distroless)，这是一组 docker 图像，使 docker alpine 看起来像 Windows 10。这些东西非常非常有限，不会给入侵者太多回旋的余地。

也就是说，你不需要使用无发行版映像。如果你对你的集装箱有信心，你可以自己打包。这里的目的是限制自定义 docker 图像的范围和规模，并将其引入一组可管理的已知工具，并使需要它们的每个人都可以使用它们。

#### 并留意最新的标签

确保部署到集群中的所有 docker 映像都被*固定到一个版本。*`latest`标签确实是一个危险的游戏——你完全不知道每次回收后会运行什么软件。

### Istio 相互 TLS

如果你一直在关注 Istio，你会知道它最近发布了 1.0.0 版本。就是这样，他们已经准备好投入生产了。Istio 提供了大量的监控、跟踪和恢复能力。它还有一个很棒的特性，支持 Istio 管理的应用程序之间的相互 TLS。如果你的应用程序有一个特使代理，你就赚钱了。

#### 但是什么是相互 TLS 呢？

互助 TLS 有点像 HTTPS。它涉及一方验证另一方的存在，并随后建立加密的通信信道。然而，HTTPS 是建立在客户端验证服务器的基础上的。在相互 TLS 中，*两个客户端将相互验证*。

#### 它会影响应用程序吗？

这是最酷的部分。Istio Mutual TLS 发生在应用程序之外，在与应用程序耦合的 envoy 代理内部。你的应用程序可以通过 HTTP 发送请求，Istio 会自动验证来源并为你加密流量。开发者的努力？完全没有。安全优势？在群集内传输的强大加密功能，以及针对中间人(MITM)攻击的强大拦截器。一点也不差。

### 争议:禁止`LoadBalancer and NodePort` 服务类型——坚持 ClusterIP

这一个倾向于分裂房间一点。我们看到`LoadBalancer`服务类型在服务中无处不在。这通常是许多试图允许来自群集外部的流量进入的舵图表的默认配置。这有一些严重的缺点:

*   负载平衡器是要花钱的，包括传输成本和运行时间。工程师会使用最简单的方法，而且你可以确定，在任何合理的规模下，这些费用都会增加。这不会太糟糕，但完全可以避免。
*   每个负载平衡器将在不同的端口上与您的节点通信。你打开的端口越多，攻击面就越大。
*   谁知道那些负载平衡器和它们的目标节点之间正在进行什么配置。这完全取决于你安装的控制器。

#### 那么我们能做些什么呢？

开一条路进去。一个负载平衡器。对我们来说，我们用的是 [AWS ALB](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html) ，但是你也可以用 [NLB](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html) 或者经典 [ELB](https://aws.amazon.com/elasticloadbalancing/) 如果你愿意的话。这个游戏的目的是只创建一条路由和一组端口供流量流入。这使你的攻击面最小化。您的所有应用程序都作为`ClusterIP`实例运行，不需要额外的端口暴露，路由由 Kubernetes 为您完成。剩下唯一要做的就是选择一个入口控制器作为`NodePort`运行，也许是 [NGINX](https://github.com/nginxinc/kubernetes-ingress) 或 [Traefik](https://github.com/helm/charts/tree/master/stable/traefik) ，嘿，很快！你有一个简单的网络和一个微小的攻击面。

### 非常有争议:控制构建和部署过程

我把这一篇作为观点文章。这比我讨论过的其他问题更有争议。团队通常喜欢拥有自己的持续交付(CD)管道。这是他们每天都需要处理的事情。工程师们对于使用哪种 CI/CD 工具有着典型的分歧。

#### 这就打开了一个攻击媒介，一个很大的媒介。

除非您知道，不是思考或猜测，而是知道您的工程师正在利用已经到位的自动化，否则所有这些努力都可能被一个不可靠的配置所抵消。你的舵轮图可能会用钢丝绒包裹服务，并喷洒圣水，但如果它不被使用，那就没用了。

通过创建统一的 CI/CD 流程，您可以确保使用正确的检查。这有一些重要的好处。如果你想引入一个新的工具，你可以在一个地方构建它，每个人都可以立即得到它。最少的返工，最少的努力，最大的安全效益。以团队间的一致性为顶点。

我们选择的是詹金斯的全球共享图书馆。这允许我们创建一个单一的代码库来定义所有服务使用的管道。如果你想更深入地了解这个话题，我已经为[写了另一篇文章](https://hackernoon.com/simplifying-jenkinsfiles-c97cfee13f83)。(警告，语言强烈。)

#### 但是提醒一句…

仔细考虑一下这个问题。您将承担巨大的维护和可靠性负担。如果您构建的 CI/CD 工具不可靠，它会立即影响每个开发人员。这是一个单一的失败点，你的一生都将用于救火。肩负这个之前好好想想。

#### 通常信任和教育是最好的解决方案…

除了接管 CI/CD 流程，您能做的最好的事情就是参与每个团队的工具集的创建。回答问题，谈能力。让自己能够给团队提供建议。让人们知道什么是好的，让他们对自己的解决方案有自主权和责任。这种方法不提供保证，但是它提供了一个更易于管理的操作开销。

### 好吧，我刚出来。

我避免讨论我们使用的具体网络技术，我回避了如何以更安全的方式编写我们的应用程序。这里的诀窍是获得一些快速的胜利，这将大大缩小任何 Kubernetes 集群的攻击面，而只需要您的软件工程师付出很少的努力。

旅途愉快。Kubernetes 是一款出色的工具，只要稍加爱护和关注，它就可以为您的工程团队搭建一个令人惊叹的平台。

我全身心地投入到了 Kubernetes 列车上，并且一直在我的推特上大喊。