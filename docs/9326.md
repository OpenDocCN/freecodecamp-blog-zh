# ES2015 已经到来，只是分布不均匀

> 原文：<https://www.freecodecamp.org/news/start-writing-modern-javascript-code-f98eccb4841/>

2015 年，ECMA 国际敲定了 [ECMAScript 6 规范](http://www.ecma-international.org/ecma-262/6.0/)，并更名为 **ECMAScript 2015 (ES 2015)** 。这意味着我们在编写 **JavaScript** 代码方面有了新的标准。

#### 听起来很酷，我能用它吗？

ES2015 附带了一系列很酷的新功能，我们将在稍后简要讨论。既然这些特性在这次迭代中基本上被冻结了，那么可以安全地开始在全面生产应用程序中使用它们了。

更重要的是，我鼓励你尽快将你的旧代码移植到新标准，因为*你用以前的 ES5 标准写的任何一行代码从第一天*就过时了。

> “未来已经到来——只是分布不均匀。”—威廉·吉布森

正如你在[兼容性表](https://kangax.github.io/compat-table/es6/)中看到的，ES2015 正在被所有浏览器快速采用，甚至是 [Safari](https://kangax.github.io/compat-table/es6/#safari9) 和[微软 Edge](https://kangax.github.io/compat-table/es6/#edge13) (他们为新版 IE 想出的花哨名字)。虽然还没有实现所有的功能，但是你已经可以在浏览器中直接使用很多新功能了。

但是，我不建议你编写 ES2015 代码，然后直接在浏览器中运行。[向**巴别塔**](https://babeljs.io/) **问好。**

![1*XmHUL5DeySv_dGmvbPqdDQ](img/668dd9bd83fcbc4e5beef5d62bcb0e42.png)

**Babel.js** 是一个 [**transpiler**](https://en.wikipedia.org/wiki/Source-to-source_compiler) ，你可以非常容易地将它集成到你的 JavaScript 构建过程中。

如果你想了解更多关于如何为你的 JavaScript 应用程序使用 babel 或者如何实现一个构建过程——我鼓励你阅读这篇文章。然后让你自己熟悉像 [grunt](http://gruntjs.com/) 和 [gulp](http://gulpjs.com/) 这样的任务运行器，以及像 [webpack](https://webpack.github.io/) 和 [Browserify](http://browserify.org/) 这样的模块捆绑器，因为它们正在缓慢但肯定地成为行业标准。

因此，我们今天编写 ES2015 代码，代码被转换成 ES5，这在大多数现代浏览器中几乎 100%受支持。一旦 ES2015 提供的大多数主要功能在现代浏览器中实现，我们就可以从我们的构建过程中摆脱 babel transpiler 了。因此，只需一步，我们就能让我们的实时代码符合 ES2015 标准。

### 有什么新鲜事？

我记得我被 ES6 承诺带来的大量新东西迷住了，所以如果你想要新功能的完整指南，我可以建议你遵循这些“教程”:

*   [http://es6-features.org/](http://es6-features.org/)
*   [https://github.com/lukehoban/es6features](https://github.com/lukehoban/es6features)
*   [https://babel js . io/docs/learn-es 2015/](https://babeljs.io/docs/learn-es2015/)

现在让我们来讨论一些我最喜欢的新功能。

#### 箭头功能

箭头函数允许你以一种更加简洁的方式编写匿名函数，去掉许多样板代码。这为函数式编程铺平了道路，并允许程序员在阅读他人编写的函数式代码时保持理智。

使用箭头函数最酷的一点是，除了在实际需要一个命名函数的情况下，你永远不用编写函数*—*。然后你读到了新的[增强的对象文字符号](https://github.com/lukehoban/es6features#enhanced-object-literals)，你意识到单词 ***函数*** 可能很快就会被遗忘。**

#### **块范围的变量**

**函数范围内的变量行为一直是所有 JavaScript 访谈的高潮。ES2015 让那些来自基于 C 的编程语言的人的生活变得更加轻松，在基于 C 的编程语言中，变量的作用域是声明它的代码块。有了“ **let** 和“ **const** ”，你的代码就更有表现力了。让我们看几个例子:**

**您现在可能已经明白了，“**let”**与“**var”**是等价的，但是它是块范围的。，这意味着它不存在于定义它的块之外。**

**另一方面，“**const”**允许你定义一个有固定值的变量。它只能在创建时获得一个值，任何后续对“**常量”**的赋值都无效。这在表达性方面非常重要，因为你可以用" **const"** 声明你在代码中没有修改的所有变量，用" **let** 声明所有其他变量。通过这种方式，任何有可能在代码中变异的值从一开始就很容易被跟踪。如果你所有的变量都是常量(没有双关语)，你就不需要担心副作用或不必要的状态突变。**

#### **解构**

**谈到表现力，析构提供了大量用更少的代码行表达更多的方法。这个特性基本上在对象和数组上做**模式匹配**，允许你快速访问它们的一部分。**

**有了析构，你不再需要创建指向函数参数的某些属性或子对象的变量，就像上面的 *fullName()* 例子一样。此外，从一个函数返回多个值也更容易，无需编写太多行代码。当析构与处理函数参数的新方法结合起来时，它很有趣:默认参数和 rest 及 spread 操作符。**

#### **函数参数-默认、静止、扩散**

**默认参数非常简单，并且已经出现在许多编程语言中，所以这里没有什么特别的。然而， **rest** 和 **spread** 操作符允许你以任何你想要的方式处理函数参数。**

#### **发电机**

**好了，我们一直在玩语法，我们制作了一些很酷的函数式编程片段，让我们深入挖掘 ES2015 提供的最有趣的功能之一，即**生成器**。简单解释一下，生成器是**迭代器**的工厂函数。还在迷茫？我也是，但是让我们看一个例子**

**这里发生了什么？生成器基本上是一个可以随时停止并在之后恢复的功能。当执行 **yield** 语句时，生成器停止，它返回我们放在 yield 语句旁边的任何值。我们使用 **next()** 函数调用一次进行一步，收集生成器生成的值。**

**作为一个附加特性，您可以将一个参数传递给 next()函数，该参数被视为生成器中 yield 语句的返回。所以我们基本上有一个发电机功能和外界的双向沟通。**

**生成器的重要之处在于它们有可能被用于处理异步调用的代码部分。想象一下这样一种情况，您需要以特定的顺序执行 3 个不同的 api 调用，总是使用一个调用的结果作为下一个调用的参数。想象一下，如果有回调或者承诺，代码会是什么样子。**

**如果我们可以做这样的事情呢？**

**已经有一些可行的解决方案允许你用生成器和承诺来编写连续的异步调用。作为一个例子，你可以看看这篇[文章，它展示了一个类似的解决方案](http://blog.mgechev.com/2014/12/21/handling-asynchronous-calls-with-es6-javascript-generators/)。**

**当然，还有许多其他很酷的特性，如字符串模板、原生承诺、AMD 风格的模块、在数字、字符串、数组和对象的原型上添加的新功能等等。但是我在这里提出了我认为在常规编码任务中最有用的方法。然而，我想讨论的新特性中有一个黑暗的转折。**

#### **班级**

**我敢打赌，阅读说明书的人中有 50%对此很期待，而另外 50%的人会说:“但是……为什么呢？？?"我在这里属于第二类。**

**ES2015 带来了一个 sugaring 语法，它在后面使用原型对象创建。这里有一个例子:**

**不要想这些，JavaScript 的**不是**有类。JavaScript 没有实现基于类的面向对象编程，也永远不会实现。JavaScript 中的继承模型是原型的，对象是基于其他对象的原型创建的。你在类片段中看到的所有这些语法元素，比如:构造函数、get、set、static，都是在后面作为常规函数或简单值添加到原型中实现的。**

**在 JavaScript 中添加类可能是最大的错误。想想有多少人曲解了“**这个**的意思。将这个数字乘以 10，你就会得到误解“**级**”含义的人数。**

**所有这些构造都来自基于类的面向对象的世界。人们只需要放弃这些做法，因为它们不符合 JavaScript 中实现的范例。此外，他们比以往任何时候都更迷惑新来者。**

> **来到 JavaScript 问怎么做古典继承，就像拿起触屏手机问旋转拨盘在哪里。当然，当你说的下一句话是“如果它没有旋转拨号盘，那它就不是电话”时，人们会觉得很有趣— *Eric Elliott，编写 JavaScript 应用程序***

**我的标准面试包含以下一系列我会连续问的问题:**

*   **" OOP 中的类是强制性的吗？"**
*   **" JavaScript 是面向对象的语言吗？"**
*   **“它有课吗？”**

**想象一下，我可能会浪费多少时间向人们解释他们在 JavaScript 中看到的“类”实际上并不是类。**

### **拥抱函数式编程**

**从好的方面来看，ES2015 拥有所有这些新功能，使我们能够编写更好、更干净、在一定程度上更快的代码。我认为现在是时候接受函数式编程作为 JavaScript 的基本范式了。更好的是，你再也不用写一个循环语句了，除非在一些罕见的情况下。**

**有了 **const** 和 **let** ，你就能给所有变量增加另一个层次的表现力。从现在开始，你可能会避免使用**变量**。箭头函数与经典的迭代器函数相结合，可以让你编写函数式反应式编程，基本上就是创建功能流。**

**你的代码变得更简洁，功能更多，状态更少。这也意味着你的代码更容易测试和维护，也更不容易出错，并且具有纯函数和不可变数据的特性。关于函数式编程的好处有很多内容，我认为在本文的范围内重复这些内容没有意义。**

**与 Babel 一起工作并不困难，我鼓励你今天就开始做。请记住，您现在使用 ES5 语法编写的代码已经过时了。公平而简单。**

### **下一步是什么？**

**ES2015 是一个巨大的版本，有很多变化。TC39 委员会从一种不同的方法开始，他们将每年标准化新功能，基本上将最初打算作为 ES7 实现的功能分成更小的块。**

**JavaScript 的一些未来特性将包括:异步函数、对象/函数装饰器以及 SIMD(单指令、多数据)操作等。**

**通常所有未来的特性都被统称为 ESnext，以防你在任何地方看到它。有了 Babel，你甚至可以今天就玩这些未来的功能！**

**以下是我推荐阅读的一些关于 ESnext 特性的文章:**

*   **[http://www.2ality.com/2015/11/tc39-process.html](http://www.2ality.com/2015/11/tc39-process.html)**
*   **[https://medium . com/Google-developers/exploring-es7-decorators-76 ECB 65 FB 841 #、hrg2xk5q1](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.hrg2xk5q1)**
*   **[https://www . twilio . com/blog/2015/10/asynca wait-the-hero-JavaScript-rewed . html](https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html)**
*   **[https://github.com/tc39/ecma262](https://github.com/tc39/ecma262)(官方状态特征)**