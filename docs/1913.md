# 了解排序算法

> 原文：<https://www.freecodecamp.org/news/understanding-sorting-algorithms/>

每种编程语言都使用排序算法。虽然编程语言有易于使用的排序方法，但理解它们是如何工作的会很有帮助。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一门课程，将教你一些最流行的排序算法！

Haris Iftikhar 开发了这个课程。Haris 聪明地运行通道编码，他在创建有用的教程方面有很多经验。

在本课程中，您将学习选择排序、冒泡排序、插入排序、合并排序以及它们的复杂顺序。本课程使用 C++，但其概念适用于任何编程语言。

以下是本课程中涉及的算法和主题:

*   简单排序算法
*   选择排序
*   图解说明
*   冒泡排序
*   气泡排序的图形解释
*   插入排序
*   图形实现
*   合并排序
*   详尽的解释
*   算法的差异

观看以下课程或 freeCodeCamp.org YouTube 频道上的[(1 小时观看)。](https://youtu.be/l7-f9gS8VOs)

[https://www.youtube.com/embed/l7-f9gS8VOs?feature=oembed](https://www.youtube.com/embed/l7-f9gS8VOs?feature=oembed)

## **完整文字记录**

(注:自动生成)

排序算法在计算机科学和编程中经常使用。

在本课程中，您将通过图表和代码了解最流行的排序算法是如何工作的。聪明地编码时间，但这一次，我们在一个不同的频道。没错，聪明地编码是自由代码营的特色。

这个视频将讲述一些不同的排序算法，这些算法几乎可以应用于任何编程语言。

本视频中重点介绍的语言将是 c++，但是，正如我所说，您可以将这些概念应用于您选择的任何其他语言，如 Java、Python、C 等等，您至少需要了解编程的基本核心概念，尤其是基本的编程结构，如序列选择和迭代。

为了理解这个视频，也请务必检查我的频道编码巧妙，在那里我已经涵盖了几乎每一个概念，从编程基础，面向对象编程的所有方式，数据结构和算法等等。

好，让我们从编写一个简单的数组排序算法开始。

因此，首先，让我们包括我们的 iostream，并鼓励你和我一起打字，以获得最大限度的实践。

所以 ash 包括 iostream。

然后我们有了名称空间标准。

然后我们有整数主线。

这里也是我们的零点。

所以我们将从一个非常简单的算法开始。

我们将看看它的视觉实现。

假设我们有一个包含四个元素的数组。

这是四条边，我们有 231，和 5。

基本上，这是一个数组，它的索引值从 0 一直到 3。

所以我们的工作是按升序排序，我们知道这不是升序。

所以我们要用一个非常简单的算法。

我将创建，实际上是这里的实现。

然后在那之后，我们回到代码编辑器，我们会跟着打字，这样会更有意义。

假设我们有两个变量，我们将有一个变量，它将被列在最上面，所以我们将它命名为 AI。

这是第一个，零位置。

然后我们有 j，这将是第二个，这将是 I 加 1。

在 AI 变成 J 之后，我们将玩 apply，实际上是一个嵌套的 for 循环。

所以首先 for 循环要有一些条件，虽然在里面之后，会有一个预感，说 j 小于 I。

所以在这里，它的意思是 j 的数组，j 的值小于 I 的值，这就是我说的数组 sub j 和小于 j 的绝对值的数组小于 I 的值，这是我们的条件，它将在我们的嵌套 for 循环内部。

这是一个条件，如果它为真，我们将创建一个临时变量，我们将存储 I 的值，所以无论里面有什么，在这种情况下，都是 2。

所以 2 将被存储在 temp 中，然后我们将使用 swift 交换它，同样的交换方法是 j，j 等于 temp 变量。

所以不管临时值实际上是多少，如果值是 2，那就在 j 中。

实际上，我们刚刚在这里实现了一种交换方法。

在那之后，我们要检查这个条件。

所以在这种情况下，我们有 2 和 3，所以值 3 实际上大于值 2。

所以在这种情况下，条件不会为真，也不会执行。

所以这将跳过这个值。

我们现在要让 j 递增到下一部分。

所以我们要跳过这个。

所以我就把这个划掉了。

现在我把下一个指针放在这里。

现在你可以看到，j 的值变小了，现在我们有一个，我们有一个和两个的比较。

所以 g ^ 1 小于 2。

这个条件现在为真，你可以看到，一号和二号将要讨论这些值。

既然这里的条件会令人满意。

我们在这里看一下，temp 等于 I，然后我们有了值 I，那么 I 是什么，所以它将在那个 temp 变量中等于 j，现在 j 实际上是 1，所以 I 等于 1，所以我们在这里 I 等于值 1。

在这之后我们有 j，所以 j 等于现在 temp 的值。

现在 temp 值实际上是 2。

现在你可以看到这个交换后的值。

所以我们有 I，现在是 1，除了 2，现在是 2，现在在 J 位置，而不是 1。

现在我们有了值 2。

现在，您可以看到它被换出，Jays 的值将会增加。

所以你可以看到指数不再在这里了。

现在它将位于第五个区间，实际上是最后一个区间，也就是第五个值所在的位置。

我们会再次检查，我们会说 I 和 j 会说 j 小于 I，不，不是 j 大于 I。

所以现在嵌套 for 循环的这一部分将被终止。

接下来会发生的是我们的眼睛会变大。

所以我加上，我们会有我知道，加上一个。

所以最初 j 是对的，所以现在这里，就是我要去的地方。

实际上，我们在这里看到的是，j 总是 I 加 1，就像我们之前提到的，这是我们需要的排序算法过程。

所以它会并排，或者说它们一开始会相邻，然后之后，它们会递增。

就像松鸦的位置一样，这里有 j，还有 I 和 j。

如果我看这里，我们有 I，也就是 3，和 J，用来检查条件。

现在又是这样了。

所以将要发生的是 j 小于 I，这是真的。

我们要处理这个 temp，它等于，现在你可以猜到这里发生了什么。

现在 temp 等于 I 的值，现在是 3，所以这里要放 3。

好了，三号。

然后在那之后，我们有 I 等于现在 j 的值，j 实际上是 2，所以我们在这里有 2，I 等于 2。

最后一个，j 等于 10 加 10，再加 3，所以位置在这里，现在我们基本上又交换了一次。

所以不是三个，而是两个，不是两个，而是三个。

现在你可以看到，j 将会增加，再次增加到最后一个，我们可以看到 I 也在同样的位置，0 将会比较 2 和 5。

这个条件不满足，所以我会再次递增这个过程，I 和 j 现在会比较，比如三和五，而这个条件对于要执行的 while 循环也不成立。

现在我和 j 用红色表示。

所以你会发现没有什么需要改变的。

所以我们实际上，我们的算法是有效的。

我们看到 123 和 5，看到 123 和 5，有升序排列。

这就是我们的算法应该如何工作。

所以这个算法的可视化实现帮助了我们，现在我们可以把它映射到我们的代码中。

所以我们现在要打字了，所以我鼓励你和我一起打字。

所以让我们开始吧。

好的，这里的事情是，我们必须创建一个数组，我称它为数组，我假设它有一个大小。

所以我可以在顶部定义一些东西。

所以我说哈希定义，我说最大，我说那是 100。

好，这是最大值，所以把 max 放在这里。

我在这里可以说的是，我可以让用户输入一个数字，这就是大小，应该在 0 到 100 之间。

所以它会被输入，然后会是 N 现在我需要在这里定义一个 N，所以我就说 integer。

这是一个整数，现在在一个数组中输入值。

所以在用一个新的 for 把值放到数组里，不要说 int i 等于零小于 n，我会说 i plus 加真的很简单。

然后我们有 RAND 函数，它会把值随机放入每个索引中，所以我们可以说 array sub，我会说，只是 RAND 函数。

仅此而已。

所以这将给出一个介于 0 和 RAND Max 之间的数，不管整数 Max 是多少。

所以我们可以放在这里，现在我们只需要为 RAND 函数多包含一个头文件。

所以叫 C 标准库。

给你。

所以 C 标准库不知道我们在里面有值，让我们输出数组。

所以输出未排序的数组，未排序的数组，我们基本上可以说对于 int，I 等于零，I 小于 n，然后我们有 I+plus，然后我们说 console，输出数组 sub sub i，我们把这个空格。

希望我们会得到一个数组，只要在最后放一条线就行了。

现在我保存我的代码。

所以我要用我的 G+plus 编译器来运行它。

所以在这里，我要写 g+加上我的名字，这是第一部分，我们有 CPP，希望它会被编译。

现在我们只要说 a 来运行它，并通过一个数 n。

所以基本上，我可以说是 10 个。

现在它将为我的 8 数组提供 10 个随机数。

所以它有 41 个，这个，这个，这个，一直到 10 个。

所以你可以看到这些是 10。

让我们再运行一次。

现在我要输入 20。

现在它应该给我 20 个随机整数。

所以现在，你走吧。

有 50 个 50 个随机整数怎么样？

现在你明白我的意思了。

它正在创建一个随机数组。

放入一些随机值。

但是你可以在这里看到，这些没有按照任何顺序排序。

它们不在上升节点，或者在下降节点。

这是我们的工作。

所以是 41。

你可以看到这是一个更大的数字，但之后你会看到一个更小的数字。

这到底是什么意思？

所以我们需要一个适当管理的数组。

因此，让我们创建一个适当管理的数组。

我们能做的就是在这之后，让我们创建一个排序算法。

所以排序和数组。

那么我们如何对这个数组进行排序呢？首先，我们去打开一个 for 循环。

假设对于 int，I 等于零，I 小于 n，然后我们说 I 加。

然后在这之后，我们可以放上另一个输入数组。

所以我们可以说，这是另一个循环，它将嵌套在开始的循环中，所以它将是 j。

但这很小心。

这是数组后的下一个值。

而且我会告诉你，这背后的原因是什么，说 j 小于 n，我们说 j 加 plus。

这里面基本上是我们的概念，适用于数组 j 小于数组 I。

这意味着什么？我会告诉你这一切。

假设我们有一个数组。

这表示如果数组 sub j 小于数组，因为看这里，这是一个数组，你会看到这是一个顺序。

你可以看到这是从零开始的 I 值，这是开始的 j，它比我想要的大一倍，所以你会看到 j 是这样的。

这是现在，如果我有一个随机或加注，哦，让我们在这里说五。

所以你可以看到这不是升序，基本上是 10。

然后是五，为什么五在这里，更大的东西应该出现了。

所以这里的条件是擦除子 j 小于数组子 I。

这意味着如果数组 j 小于数组 I。

事实就是如此。

现在我们要做的是，交换值。

所以我们可以通过交换值来做，所以 var 应该在这里，而原始值 10 应该放在这里。

我们如何做到这一点，因为 510 30 和 40 将被排序。

事情是这样的，我们必须创建一个输入整数，临时的，什么的。

所以我们要把它放入赋值 I 中。

现在，一旦我们有了 I，现在我们可以做的是，我们可以改变人工智能的种族。

我们可以对 j。

所以我们用数组 sub J 的值给一个比赛眼赋值。

现在我们可以进行一场 J 值的比赛。

我们想把它作为一个临时值。

所以这将使我们的数组以一种有序的方式随机应变。

它将按照升序排列，sc n di，nd，或 der。

所以这将是升序排列。

所以它会检查，然后，它会这样做，它会进入我们的下一次迭代，这将等于 1。

所以加号会增加到这个值，所以会是这个值，然后会用这个值检查。

它将查看是否是不正确的情况，将它替换掉，只需进行下一次迭代，直到数组检查完毕。

一旦完成，你就可以打破这个循环了。

一旦你休息，就像你的自由，所以一旦你自由了，你就回到零。

这将给我一个升序排列的数组。

但是现在我们没有展示它的任何东西。

让我们展示这个数组。

所以我要写短数组的注释，现在我们要显示，所以就说排序后的数组吧。

显示排序后的数组，我们只做一个基本的 for 循环，I 等于零，我说 I 小于 n，我们说 I 加。

然后在这里，我们可以添加基本上是控制台输出，我们说数组子 I。

然后我们说这个。

现在让我们在这里画一条线。

现在让我们运行代码。

所以基本上回到我们的 G plus plus 编译器。

我们将运行我们的代码。

但首先，我们来编译一下。

我将给出一个连字符 o 标志，表示这是一个新的可执行文件，我将把它命名为 run。

我将点击编译按钮，编译成功。

现在我们要跑了。

现在你会看到输入一个数字，输入一个数字，这意味着我们只需输入一些随机数，它将创建一个数组，每个索引中有一些随机值，所以我们有 20 个。

这是 20 个随机数。

你会在这里看到 2041 年，所有这些都是未分类的。

它以随机的顺序进行。

之后，它会对其进行分类。

你可以看到我的排序算法成功了，并按升序排序。

这真是太神奇了。

好，现在让我们做另一件事，让我们有一个降序方式。

这里我想做的另一件事是，我想告诉大家，这将是一种，所以我可以只写一个控制台输出，我会说排序。

如此分类。

在这里显示排序后的数组。

我想做的另一件事是，我想向你们展示下行是如何工作的。

所以这个小于号，也就是 J 的数组，小于 I 的数组，会变成大于 I 的 J 的数组。

所以如果它大于 swap，那基本上就是降序，所以我要把这个升序改成 d，e，s，e，N，di，N，g。

所以现在是降序排列。

所以它会再次运行。

所以我只打算编译这个。

然后我们要运行它。

现在让我们有一个像 22 这样的值。

现在你有了这些值，41。

所有这些都是随机排列的。

然后在那之后你调用排序基本上是在终端屏幕上提示出来的。

然后，你把它们按降序排列，看看这有多棒。

这一次就这样了。

现在让我们继续其他排序算法。

下一个排序算法叫做选择排序，是世界上最常见、最著名的排序算法之一。

所以我们将如何实现它，基本上是第一种类型，我们将一个接一个地解释，并在最后给出一个简短的解释。

所以继续跟着我打字吧。

所以散列包含，我们将有输入输出流，然后我们将有使用命名空间标准。

然后我们还有整数 main。

我们也有返回零点。

现在，我们要做的基本上是，首先我们要创建一个交换函数。

所以我要实现的基本上是一个交换函数，所以 void，然后我们有 swap。

然后我们基本上有了一个数组，它将会被交换。

我会给你们看它有一个 x 值，还有一个 y 值。

所以它将实现我们一直在做的著名的交换函数过程。

基本上，integer temp 的第一个值是 sub x，所以 sub x 等于 sub y，然后 sub y 等于 10 次方。可变。

这就是我们交换东西的方式。

假设里面有一个数组，我们称之为数组。

我们会赋予它一些价值。

所以说一些随机值吧。

我们想要做的基本上是，我们想要在这里交换过程，如果我们有一些不匹配的随机值，我们想要交换它们，我们可以使用交换函数，就像我们在开始时在基本算法中做的那样，我们做升序排列。

所以基本上，我们实现了选择排序。

所以我们创建了第一个函数，它是 swap，我们要做的第二个函数基本上是选择剑。

所以接下来我们会有一个空白。

我们称之为选择排序。

它有两个输入参数。

第一个是数组，第二个基本上是数组的大小。

这里有一个位置索引，它是零，它总是从零开始数组从零开始，就这样，然后它会循环遍历，所以它会是 I 小于 n-1，我们会循环到最后一个元素，所以 n-1 是最后一个元素， 然后我们要找到一个比我们指定为 0 的值小的值，这就像交换函数一样，所以我们要在这里指定一个 j。

它将被称为，我们将使用另一个函数，它将被称为最小位置。

别担心，我会教你这是什么。

所以基本上，我们有一个 sub i，我们有 n-1。

所以我们只有三个输入参数，这里，我们要传递数组，你知道，这是通过引用传递的。

所以不管你去哪里，都是同一个数组。

然后我们有铁，这将是当前位置，它总是会增加。

这里将会是零，它将会改变。

这里是终点。

这是最后一个元素的结尾。

所以这里要实现 swap。

它将有三个输入参数，就像我们之前做的一样。

所以它会有一个小 a 的数组，然后它会有眼睛的大小，它会有这个 j。

所以基本上，我是索引，所以它是第一个元素和第二个元素，想要交换它们。

所以它将实现交换函数，它将在这里递增 i plus。

这是它将要做的，我们需要最小函数的位置。

所以不在这里。

所以我们要做的是，在最小的位置，有一个返回类型。

你好，因为它将返回 j 的值。

所以你可以看到 j 是整数，所以最后需要一个返回类型。

这里是最小的位置，我们有一些输入参数，第一个输入参数是数组。

第二个参数是 s。

第三个输入参数是结束点。

你可能会问我为什么这么做。

你可以在这里看到，起点是 I，终点是 n-1。

所以最后总是要检查的。

所以它会遍历整个数组，试图找到最小的。

当它从 I 中找到最小值时，它会在交换函数中交换值。

这就是我们如何实现这个选择排序算法。

所以如果我要在这里创建一个人工智能，我只需要创建中间变量。

一个是艾萨克的，所以我是。

所以 AI 将作为起点，然后我们将有 j，它基本上等于 I 而不是 s，所以我们将实现它，我们将说无论它是什么，它都将在 j 中，这里的 I 是起点。

然后我们在这里做的是，基本上，我们将再次有一个循环。

所以当我们让 I 小于或等于 E，这是终点，现在，如果 A 有一个 sub i，这是第一个元素，如果它小于 sub j，如果我们找到某种更大的东西，那么 sub j 就更大。

所以我们会说是 j 等于，我只是想交换一下，我们想定位它。

然后在那之后，我们要做的就是用 I 加 1 来增加它，对，所以它会增加。

然后我们要返回值对象。

别担心，我会用图形来解释。

所以你这是怎么做的。

我们有三个函数，一个交换函数，还有一个最小函数的位置。

我们还有一个选择排序函数，让我们创建一个显示函数来显示数组的内容。

所以它将被称为 display，它将有一个整数数组，数组的大小为 n。

你现在要做的基本上是从零开始。

它将如何实现，基本上是当 I 小于 n 时，然后我们将通过使用 sub i 来显示数组的内容。

这里有双引号，是空格，它会一直把它们列出来。

然后它会在这里打印一个结束行，让格式看起来更漂亮一点。

在那之后，我们要做的就是在这里指定一个数组，我们创建一个数组，叫做 arr。

它会有一些随机值。

所以它将有 100 到 12 个，我只是在这里给出随机值，它只是随机格式，需要使用我的选择排序函数进行排序。

所以我要把这个传进去。

所以你可以看到这是随机的。

现在我要做的基本上是计算大小，如何计算大小，我要使用的一个过程基本上是操作符的大小操作符的大小将被传入，它将有一个数组，然后它将有基本上是整数变量的大小。

所以基本上，你会看到这是数据类型，它是数组的全部。

所以我们会看到 1234567 和八和九，九乘以四，基本就是 36。

现在 36 基本上会被这个整数整除，也就是 4。

所以 36 除以 4 会得到这个值，就是 9。

所以 9 就是这里的答案。

一旦这是大小，我就在这里写注释，说大小等于 9。

我们为什么不想在这里做基本上是我们想实现我们的选择。

所以首先，我们就展示一下吧。

所以我们只显示，我们只传入变量和大小。

所以它会自动显示，因为它是一个空函数，它的目的是显示它。

紧接着，这被称为我们的选择函数。

它会要求数组和大小。

然后在那之后，我们将显示我们的选择，使用数组排序数组，然后当你有大小。

所以一旦我这么做了，我就执行并运行。

所以基本上，我将终端屏幕移至这里，我将写 g+plus，我将使用选择排序点 cpp。

我们所知道的是，默认情况下，它是 a，所以我要运行它，我要说，哦，我要说选择排序。

现在它已经编译好了，我正在进行选择排序。

现在你会看到这里，我们有一些随机发生的事情。

好的，有些地方出错了，为了破解代码，这段代码中有些地方出错了，让我们来看看是什么地方出错了。

这有什么不对的。

所以我们有 iOS，然后我们有它的增量。

这就是流程。

负一是可以的，这是一个无限循环，它是用选择或者数组，然后是大小创建的。

让我们看看这里。

好的，我忘了增加这个 I+了。

所以就在这里，我没有承诺。

现在它要开始工作了。

基本上，我们已经完成了，让我们再次运行这段代码，选择排序。

现在让我们调用这个数组，我们有这个数组，它是未排序的，是 102 12 193 90，或者 32。

现在，我们所做的是在选择排序中传递，它为我们排序了数组，我的意思是，11 1239，按升序，现在是升序，那是什么，就像，如果你有相同的值，它可能是相等的，或者要求更大。

以防万一，如果我有一个值，比如 11，和 11，它们会在相同的相邻位置。

在那之后，它可能是一个更大的值。

所以就这么定了。

在选择剑，我真的希望你喜欢，你明白，所以我想做的是，另一件事基本上是向你展示如何实现了。

假设内存中有这样排序的数组。

所以我们有某种指数。

我们有五个，四个，三个，七个，九个。

所以我们想按升序排序。

默认情况下，我们要做的是选择，排序，它把这个眼作为零的索引，它会检查 j。

我的过程是这样的，最小的位置叫做。

你会在我的代码中看到，基本上就在这里，所以我会在这里给你看，我在这里看到的是位置是 0，Y 不小于 n 减 1，最后一个元素，我们做的是我们得到 J，我们把它放在传递 a 的最小的位置，我们有 I 变量，它基本上是 0 和 n 减 1，这是最后一个元素，它将是最小的位置。

所以最小的位置就是变量的位置，就是这个最小的变量，即使 I 小于等于 E，如果它小于等于。

所以如果它找到了，它会把它排序为 j，并返回那个值。

所以你可以看到它找到了最小的。

你可以看到这里最小的是 3，所以 j 会指向这里。

然后，它将应用排序算法，这将减少交换。

你可以在这里看到，它将会交换，这里有三个。

最初五个会在这里。

但是我们想在这里看到的是，在这个文本编辑器中，这基本上是显示的，所以我们有一个选择排序。

当我们回到选择排序算法时，我们有一个交换函数 swap，它会根据从这里返回的能量得到这个值，然后交换它。

简单的交换算法，就是交换这两个值。

然后在那之后，它会增加，它会去我们的下一个位置。

所以你可以看到这里的地方将会不，不，它不会再指向这里了。

它会指向这里。

现在这个 j 不会在这里。

所以我想指出这个 j 将会指向其他地方。

所以我们在这里实现了这个。

所以我会在这里递增。

现在这里将成为它的基地。

我们现在要检查的是，因为这不是用 3 排序的。

所以现在我们基本上都在这里。

所以现在我们要寻找一个小于 4 的值。

所以基本上，有没有小于 4 的东西，我们不只是增加，我们说我会在这里。

现在是 5，如果有外来的东西，没关系，所以它会检查所有的，并且会遍历整个循环，直到整个数组被排序。

所以我希望你们通过这个图形实现理解了选择排序的概念。

现在我们将进入下一个排序算法。

让我们朝着它前进。

好，现在让我们看看另一种排序算法。

这被称为冒泡排序算法。

它将如下进行。

所以基本上，你必须包括你的输入输出流，你必须做你的命名空间标准。

让我们直接写样板代码。

好的，那么，这个冒泡排序也将处理交换。

所以我们必须包括这个交换方法，基本上就是交换，然后我们有一个整数数组，一个 x 值，一个 y 值。

基本上，当我们到这里时，我们实际上有一个临时的，它将被赋给第一个值，然后我们有第一个值，它是一个 sub x 将被赋给 a sub y 值，然后 a sub y 值将等于第 10 个值。

这就是互换的运作方式。

现在让我们来一个泡泡过程。

所以泡泡的过程有点不同。

不同的是，从我们已经讲过的选择排序，我们实际上是从右上角开始，所以我们从顶部开始，然后到底部。

所以在 bubblesort 中，我们将从底部到顶部，所以我只解释一下。

所以首先，跟着打字。

所以这将是一个不寻常的时刻。

然后这个过程要做的是，它要做一些特定的过程，它要得到一个数组。

它还会得到数组的大小。

我们稍后会回到这个话题。

所以让我，我刚刚写了一个签名。

我要去讲一下空泡过程。

所以冒泡排序实际函数，这是实际的冒泡排序函数。

我们要做的基本上是，它将有相同的整数数组，就在这里，然后我们有大小。

现在在这里，我们要做的基本上是从我刚才说的 bubblesort 将要采用的部分开始。

所以冒泡排序会说，integer I integer i 等于零。

我们需要的是，当 I 小于 n-1 时，最后一个元素，我们会有气泡过程。

所以 BB，BB le 气泡，它会有速率和终值，n 会是速率，它会增加到重量。

所以它会继续递增。

所以在气泡中，我们将要拥有的东西在这里，现在我们要打开它，我们要开始，所以气泡过程将从 I 开始。

所以要从最后一个元素开始。

这就是我所说的，n 减 1 是最后一个元素。

它会持续一段时间，基本上 I 大于 0，所以 I 大于 0。

这里面有一个条件，如果 sub 现在是 sub，I 应该小于 sub i 减 1。

这意味着有一个 A sub II，如果它的顶部更大。

所以你要做的是，如果 sub i 小于 ACI，你要做的是交换它，所以我们要用这个已经有的交换函数来交换它，它需要一个 AI 元素，它需要 I-1。

这就是它交换的方式。

我们会有一个通用的,,因为我们从 n-1 开始，一直到 0。

所以这个过程应该行得通。

所以现在之后，我们应该有我们的显示功能。

我们准备好出发了。

这里显示的是一个数组。

我们还有数组的大小，这是某种大小，我就这样称呼它。

现在在它里面，我们需要一个输入。

所以我只会说某种等于零的整数。

然后是循环过程，从 I 小于 n 开始。

然后很快 go，所以基本上小于 n，你想处理它。所以阵列。然后我们有 ISO 值。

我们就这样一直走下去，直到到达终点。

这里是控制台输出。

是的，只是为了让它和上一个更相似一些，我会把这个改成 just and，因为这个在这里匹配。

现在让我们在这里创建一个数组。

我把它叫做整型数组。

我会给它一些随机的元素。

所以就这么说吧。

然后是然后是那个，这个，这个和 33 之类的。

好吧，这只是一些随机的东西。

现在我想对它进行分类，所以我先展示一下。

所以我要显示，我要说数组和交替我的大小数据类型。

所以实际上我的尺寸变量。

所以我在这里有一个大小为 n 的数组，我说大小为 n，我有一个数组，我说大小为，我有一个 INT，它会给我大小。

现在我能做的基本上是调用显示函数，然后调用排序函数，所以它被称为 bubblesort。

所以我把它命名为 bubblesort。

我要传入我的数组，我要传入我的大小。

我将再次展示。

所以我要显示数组，然后传入大小。

现在，我应该工作了。

让我们来看看这里的 c++编译器，只需输入 bubblesort bbls o r t，我们就说 dot cpp。

我们就把它命名为类似连字符 o bl s o r t。

我们开始写，编译。

给你。

哇，这里发生了什么，我想我们犯了同样的错误。

所以让我们回到这里，看看我们错在哪里。

好的，我们只是忘记了在野生循环中增加，以记住这样做。

这真的很重要。

好的，我在这里加上。

所以这只是循环，并不会导致无限循环。

所以在这里，让我们回到这里编译它，重新编译它，然后再运行一次。

你可以看到，我的原始数组是 102，然后是 293，然后是 1939，所有这些，然后我们传入了我们的 bubblesort，实际上从 1138，102 中整理出了 sum。

一直到最后一个元素。

所以这很酷。

呃，用冒泡排序选择排序对数组进行升序排序，因为，方法基本上有点不同。

所以我想向你们展示这是如何在一个图形化的等待中实现的。

所以，冒泡过程的实现，基本上类似于我们对选择排序所做的。

但实际上以相反的顺序，我们有这个正在进行的交换功能，但我们有这个可视化，可以帮助我们理解这个过程是如何工作的。

假设我们有一些随机值，这里，我们有三个，五个，一个，四个，假设是三个。

现在，气泡过程是这样进行的。

让我来看看这里。

现在让我们看看。

所以它会从底部开始，比较这两个值。

现在它看到 3 和 4，你是说基本上是冒泡的，意思是它的液体部分在底部，液体部分基本上比气泡重，气泡轻，气泡使它在顶部流动。

所以当你比较液体和气泡时，气泡更轻，所以气泡应该在上面。

所以这不完全是一回事。

他们在谈论重量。

因为重物比三个重物重，所以四个重物应该在底部，三个重物应该在顶部。

这是一个实际的过程，这里发生的是交换函数将被调用，这将变成三个。

而这个要改成四。

然后这个气泡会上升一个台阶，从这里开始。

现在它会从这里过去。

所以现在要比较三和一。

所以三，一，实际上，现在有什么不同。所以这里基本上是你说的一和三，所以实际上，没关系，所以三比一重。

所以没事的时候，再来一次，我们是五分之一。

所以五更重。

所以基本上五个在底部，一个在顶部。现在。

现在在这里，现在三分之一。

所以基本上三更重。

所以三个会放在底部。

所以只有三个在底部，一个在顶部。

这是一个真实的气泡过程。

你会看到 1353 和 4，现在，我们基本上在这里完成了一个过程，我们排序到这一部分，有更多的过程。

你需要再做一次起泡过程。

所以，再一次，你必须从底部开始。

所以你要像这样检查。

所以基本上，我们将再次开始，我们将再次看到这些值。

所以请原谅我的写法，四，然后我们有三，我们有五，然后我们在这里又有三，我们有一，所以现在四和三，哪个更重，没关系，到这里，比较这两个值。

现在是第三和第五。

所以三和五，实际上，五更重。

所以有五个人会垫底。

五在这里，把这个划掉，这部分就有三个了。

现在三和三，嗯，实际上是一样的相等，所以会好的，所以一，好的，所以好的，所以 13354。

现在，还有一个过程。

在一个过程之后，我们还会有一个过程。

让我把这些都擦掉，我们将会有一个更好的过程。

而现在，这应该是我们最后的泡泡过程了。

所以我们再看看这些值，这里，然后这里，然后这里，然后这里。

这是一个，然后是三个，现在也是三个。

现在这是五，这是四，所以它将从底部开始，你会看到五和四，嗯，五和四，这是不同的，这是更重的，所以更重的部分应该在底部，更轻的部分应该在顶部。

所以四个会在这里，然后五个会在这里。

所以五，四，然后是 3311 英寸。

好的，这就是我们精确排序的数组。

这就是我们在 bubblesort 中排序数组的方式，一种更慢的方式，它取决于输入的数量。

所以它会随着输入的增加而变化并呈指数增长。

这就是气泡过程。

好，现在让我们进入插入排序。

所以这和我们刚才提到的另外两个非常不同，一个是选择排序，另一个是冒泡排序。

所以我会鼓励你和我一起打字。

和解释，我们将一起做。

让我们把这个 main 包含进去，然后我们回到这里，然后返回 0。

好吧好吧。

现在，这里要发生的是，我们不会有一个交换函数，就像我们之前做的那样，我们要做的基本上是一些不同。

现在，不同之处在于，我们将有一个插入排序函数，插入排序基本上有一个数组，数组中还会有一个东西。

所以首先要考虑的是尺寸。

这是非常相似的。

这里的一件事是，它将从 1 开始，而不是从 0 开始，像其他的那样，因为我们假设了一些东西，假设基本上是速率的一部分已经预先排序了。

我们只需要把元素 B 插入到排序后的数组中，这就是我们的过程。

所以我们要去，我们要有一个 while 循环，这样我就可以告诉你，它要去 while 循环，它要去结束，它会说 insert Insert ight。

现在这个函数将会被调用。

这个函数将接受一个数组，它将接受大小，它将接受元素，这将是我将要谈到的部分。

然后这个会继续增加，对吗？像在其他语言中，像 I 等于，I 加 1，不管是什么，伙计，我得不到加号。

没错。

好吧，就这样。

所以我加上加号，不管它是什么。

现在，让我们插入 ICT 元素，我们如何插入，我想是的，让我们看一下这里。

在这之后，让我们来谈谈插入它。

这实际上也是空的，它将有插入元素，所以就在这里，现在在它里面，我们将有数组，我们将有，基本上我们将有整数 n 大小，我们将有整数大小，这在这里指定，我们将有这个关键变量媒体中间变量，它将存储我们的位置，或者基本上我们眼睛的值。

现在它要写 int j，这个 j 将是那个排序数组的最后一个元素。

所以这个排序方式的最后一个元素是 I 减 1，因为我实际上在排序后的数组中，I 减 1，这将是最后一个元素，所以我们又要有一个循环，我们有两个条件。

对于这种情况，我们有 j 大于等于，我们有 j 大于等于零。

我们还有一个条件，j 应该大于密钥。

所以如果 j 大于键，我们就继续循环，所以不是 G，j，或者任何键。

一个 sub j，所以让我有这个 8，然后这里有一个 J，不只是玩 J，好的，所以 sub j 应该更大，然后 J 应该大于等于，所以这里要发生的是 8 sub J 加 1，这将被实现，它将等于 J，等等，我只是要教你这个，别担心。

所以现在我们要让 j 等于 j 减 1，现在它会继续递减，到顶部，就像一个气泡排序会不断上升，直到你达到小于等于零，或者如果一个 sub j 是 gate，基本上，大于如果它小于，如果它小于，那么它会小于键。

很自然，这里会发生的是，如果这个条件为假，我们会有一个 sub j 加上一个或两个我们要实现的，我们会把那个失去值的关键东西放在里面。

现在我们有了这个显示功能，它将在这里，我们就放在这里。

所以虚空，让我们来一个展示。

让我们有一个整数数组。

然后让我们看看它的大小。

然后我们有一个 AI，它从零开始，基本上从 while 开始，它只检查是否小于 n。

然后它会说我们的控制台输出会说 AR AR，实际上，它不是 AR AR，它会是 sub i，它会是 AI。

然后就是这里，这里会有一个逗号。

然后这里会有一条 N 线，分号。

实际上不是这个，我不想要这个，我只想要一个分号。

这将会增加。

就这样了。

然后我们会在这里有一个比较结束线。

给你。

让我们从之前的排序算法中获取一些数据。

所以像一个 bubblesort 一样，让我们只获取一些数据，只获取数组部分，不要其他任何东西。

所以就把这部分拿过来。

我们复制这个，它会传到这里，然后粘贴。

所以我就在这里，我们就在这里粘贴它。

所以我要改变的唯一一件事就是一切正常。

我只想用我的函数来整理一下。

所以我打算用插入排序来调用它。

所以插入排序将被调用。

好的，插入排序应该在这里。

让我们看看。

对，插入排序就在这里，它会调用这个 insert，对吗？它会，它会执行一些操作，然后它会返回加号，它会继续这样做，它会继续调用这个 insert 它很多次，直到这个东西被排序。

在那之后，我们只是展示它。

让我们运行这段代码。

我将在这里查看我的 ci plus plus，让我们清空此屏幕。

我们来编译一下，g+plus 是短插入排序点 cpp。

然后我们可以说，连字符的标签，然后说是短的。

好的，它应该在工作，正在编译。

这里有一个警告，25 个不返回语句，函数返回非 void。25.让我们看看。25.

你在哪里？25 号在这里。

这里应该有插入排序，没有返回类型。

哇，我们应该有一个空的地方吗，我们就在这里空一个吧。

让我们回到这里。

现在让我们编译它，重新编译它。

给你。

现在我们有一个 ins short，所以插入排序，如果我运行这个，你会得到这个排序。

So 192 290-319-3918 32 我我我 1138 102 293 311。

这也是按升序排列的。

现在让我们来看看实现。

所以这基本上是一个数组，只是一个随机样本，我们有 379 个。

不知何故，这基本上是从这里排序的，这是怎么发生的，只是随机的，它只是事先排序的。

现在我们的会在这里。

在这之后，排序，然后 J 实际上会在这里，记住，我说过它会是 I 减 1，所以这是 J，第一个过程会发生。

所以如果我回到我的代码，我的代码在这里，如果我看到这将是一个进程插入，如果它有一个数组，它有内部，它有一个元素 I，它说一个 key 等于一个 sub i，所以会有一个变量被存储，j 等于 I-1，它会说 j 大于等于 0，sub j 大于 key。

所以应该是这样的。

让我们看看我能否在这里实现。

所以我们有一个关键变量。

这里有一把钥匙。

所以键 k，e，y，把这个值存储在里面，这个值就是里面的某个东西。

那么它会是什么，它会是的值，它会是一个 sub i。

所以是四个。

四号在这里。

现在忽略它。

现在，你要做的基本上是，你要检查条件，条件为真，为什么？因为 sub j 大于等于零。

实际上，如果我，如果我回到这里，我在哪里？好的，你可以看到 j 大于等于零，这是完美的。

然后 sub j 大于 key。

现在，如果我说一个 j，如果我说这个，让我想想，j 基本上就是这个 9。

我们有一个键，是 4，所以 j sub j 更大。

所以不，我们还在工作的地方没有粉丝。

好吧，所以这工作，这东西还是会工作的。

如果我回到这里，我们会有一个 sub j 加 1 等于 sub j。

这意味着我们将要实现一些东西，所以 sub j 会在这里。

所以我们要去那边。

这意味着 j 加 1 是这部分，它等于它，它在这里画这条线。

接下来会发生的是它会减一，所以 j 不会再在这里了。

不，它会在这里。

这是这个循环的一个过程。

这是其中的一个过程。

我们再来一次。

所以一个比这个大的 sub j 是大于 j 大于等于零，一个 sub j 大于键，因为键是给 nj 的。

所以那是完美的。

现在让我们回到这里。

我们看到一个 sub j 加 1 等于一个 sub j，我们有 j 减 1，这又是一个过程，所以不管那个值是多少，我们在这里有 7，那 7 现在会在这里。

好的，那么 J 现在会上升到这里，它会把它去掉。

所以你可以看到这个位置还有。

你可以看到 4 被删除了，所以我们不再有那个值了。

刚刚改成九点了。

看这里，这是九。

九是从哪里来的？它来自这里。

七辆露营车从这里出发，所以这是正在发生的，所以我们把最后一个值存储在我们的键里。

这就是这把钥匙的用途，不是漂亮的钥匙。

所以现在我们要做的基本上就是到这里。

我们会看到一个 j+1，它会看到这个条件，j 大于等于 0 吗？

嗯，那倒是真的。

如果我看这里的位置，它在这里，它大于或等于零，但它等于零。

所以是真的。

但第二个条件不成立，为什么 sub j 大于 key。

实际上，并没有更好。

它怎么会不大于，它小于，因为它在这个键上是真的，大于。

这就终止了循环。

接下来要发生的是，密钥将在这里排序，这部分是 j 加 1。

所以那个键值，也就是 4，会在这里。

现在，这四个会在这里，3479。

嗯，这是排序。

现在它将要，它将要继续前进，这是我知道我的一个新的位置，这将是一个新的过程。

这就是它的开始，如果我回头看这里。

所以你可以看到一个 j+1 键，然后这个过程又开始了，如果你想做的话。

这就是我们如何对它进行排序插入排序，它将再次增加它的 I 值，这将是一个新的 PlayStation，然后在那个位置之后，然后我们插入它，然后这个过程一次又一次地开始，直到整个该死的数组被排序。

然后我们得到这个升序。

所以我希望你理解插入排序的概念。

真的，如果你接受了这个概念，并且总体来说，比如说，实践一下，我肯定你能做到。

接下来，我们将进入另一个算法。

让我们深入研究合并排序算法。

所以让我们只键入 iostream 名称空间标准 main。

和返回零分号。

好的，让我们在这里创建一些函数。

让我们按照我们的方式来解释。

首先，让我们找到合并排序的方法。

所以我们首先要有一个合并排序函数。

这是如何工作的，基本上我们要说 void，g s o r t 先生，我们要说我们要在里面放一个数组，我们要有它的大小。

好的，这里面会有另一个函数，它会调用另一个函数。

这个过程叫做，实际上，这叫做包装函数，它会传递给一个辅助函数。

这是一个包装函数。

好的，我们要说的是，这是一个合并排序，它里面有一个数组，它有这个数组的大小。

它还有一个额外的参数。

所以额外的事情是，它将有大小，但在此之前，它将有另一个东西，它应该有第一个元素的索引，所以它将是数组，第一个元素的索引，然后是大小，基本上，大小减 1。

这就是合并排序的方式，我们要调用这个辅助函数。

所以在顶部，我们可以指定我们的辅助函数，一个 UXILY 函数。

这里我们要说的是，我们有相同的空值，Mr，g，s，o，r，t，现在有相同的输入参数，这里有一个数组。

所以我们有了这个输入数组，我们基本上有了起始值，我们有了结束值。

好的，这些是基本的索引。

我们称之为辅助函数，或者我们也称之为辅助函数。

这些是我们将要使用的一些名字。

因此，让我们有一个基本情况。

是的，我不知道什么是合并排序，对吧？现在，我们基本上把这个东西画出来。

所以我们让这个函数调用另一个函数。

这里的另一个场景基本上是一个相同的阵列。

不知怎么的，它被分类了。

所以你有第一部分，已经排序了，第二部分也排序了。

我们在这里的工作是，不要认为这只是两个数组，这是一个单独的数组。

不知何故，我们把第一部分排序了，我们把第二部分排序了。

我们的工作就是把这些分类放在一个洞里。

我们如何做到这一点是合并的过程。

所以我们要用归并排序算法来做这件事。

所以我们能做的是，我们必须事先知道第一部分是如何排序的，或者第二部分是如何排序的，我们必须信任，我们必须信任一个过程。

这个主题的过程叫做递归。

这就是我们将要应用的。

所以你要检查一下，过程是这样的。

所以我们有第一个元素 2，我们要检查第三个元素，在这里。

首先，这两个子阵列中的第一个，我要说 2 和 3，哪个更大，我的意思是，哪个更小，所以基本上 2 是更小的，所以这里要种 2。

然后这个会递增。

所以这个子数组的索引将会递增。

所以它是正 1，现在是 7，这部分保持不变，现在 3 和 7 将被比较。

我们可以看到 3 更低，所以 3 将放在这里。

现在它将增加到 4。

所以你可以看到四和七会被比较，我们这里有四个。

所以四会增加到五，所以五，七，五会加起来。

所以五号会在这里。

现在是 15，7，所以 7 会在这里，所以 7 会在这里 11 和 15，你会看到 11 更小，所以 11 会在这里。

所以会增加到 19。

所以我们有 15 和 19。

所以现在我们这里有 15 个。

所以 15 会在这里。

然后我们有这个比较 15 将致力于加号+。

所以我们有 18 和 19。

那到底是什么？

现在你可以看到，我们假设这部分已经满了。

现在我们该怎么办？好了，现在我们要做的基本上是，这，这最后一部分，我们只是要追加到末尾。

这就是我们的过程，我们要做的是把这 19 和 21 加到后面，我们要怎么做。

你可以看到这是按照升序排列的。

这就是我们所要求的。

我们如何做到这一点？你可能会问我，如果是这样措辞的话，为什么不直接用一个预先存在的排序算法，比如合并，比如插入排序选择排序？这个过程需要更长的时间，而这个过程相当短。

这就是归并排序的症结所在。

这就是为什么它会更快。

与我们到目前为止讨论过的任何排序算法相比，它要快得多。

现在让我们回到代码中。

现在开始打字。

首先，让我们进行这个合并排序，在这个排序里面有一个数组，我们有这个 int s，我们有这个 int E，我们有一个 helper 函数，我们有一个基本情况，现在我们有这个 s 大于等于 E。

这是一些不真实的情况。

这不可能是真的。

在这种情况下，它将返回。

这是我们的基本情况。

你可以说这不是真的，因为 start 永远不会大于或等于 eat。

这意味着它只是一个逻辑，总是有一个起点，小于等于 E，我说的是这里的指数，不是值。

所以你有一个开始，比如，我们在这里有一个开始，在这里有一个结束，很明显，这些是索引，索引从零开始一直到 n，对，而 C，从 n-1 开始，它从来没有反过来。

所以这是不合逻辑的。

现在我们要实现 Harry，我们要找到数组的中点值。

这是我们的函数。

这里我们要做的基本上就是，让我把这些图放回去，好的，我们的过程是，我们要找到中点值，就在这里。

所以你可以在这里看到，如果我在这里观察，我有 1-234-567-8910 10 个元素，如果我，如果我从这里开始，就像开始的值是零索引，最后的值是 9，如果我这样除以 2，我会得到 4.5，对，我会得到它的整数部分。

所以我会得到一个 4 的部分，小数部分会被排除。

所以我们有 401234，这是我们的第四个指数。

这是我们的第四个指数。

我在这里要做的是把这个值。

所以基本上，这是我们的四个指数。

我们要，我们要在这里分开。

这是现在，你可以看到这是我们的中间 m，外面，这是我们的 m，而之前的东西将会成为东西。

所以 0123 是 4，然后是 01234。

这里是 5，这里是 4，这是我们的中点。

现在，假设我们添加了一个奇数，那么我们会有偶数的情况，但在这种情况下，我们没有，但这仍然是我们的过程。

这就是它的实现方式。

回到这里，我们有这个 mid。

这是一个简单的函数，我们要做的是 s 加 e。

现在，这将是起始索引和最后一个索引，我们除以 2，就像我们讨论的那样。

我知道这很简单，因为这是我在这里告诉你们的 n-1，这是最后一个元素表示最后一个元素，它将除以 2，得到 4.5，它将是 4，因为它是一个整数除法。

好，现在让归并排序用递归调用你，这就是我刚才说的。

所以它将从 a 开始，这是我们的起点。

现在，小心这里，这是数组，起点是 S，但终点是 m。

为什么，因为现在我们要尝试分成两个子数组，用排序的过程。

所以我们打算再打一次。

第二次我们会有一个数组，它会从 m 开始，n 会一直到最后。

所以不是 m，而是 n 加 1，因为现在我们要增加这个过程。

在这里，我们有我们想要排序的这部分，我们想要排序这部分。

所以我们现在只是在讨论，这个部分，不是这个，不是这里的这个，不是现在的这个，我们只是在看顶部。

所以我希望你能明白，我们想在这里按升序排序，在这里按发送顺序排序。

好的，回到这里，我们有这个 m+1。

现在我们又调用了一个函数。

这个函数基本上是组合函数。

组合函数大概是这样的，我们有一个 A 数组，S 是开始，我们有中间值，m 是最后一个值，这是 e，这个组合将在这里定义。

让我们来定义这个组合。

所以现在我们要做的基本上就是说无效合并。

如果我在这里指定了，我会说 int a，我们有这个数组，我们有一个 int 的起始值，我们有一个 int，它是中间值。忘了那个权利吧。

然后我得到了最后一个元素，也就是 end。

我们在这里可以做的是，我们需要一个临时的缓冲区。

我来告诉你为什么等一下。

让我们在这里创建一个缓冲区。

它将要做的基本上是从堆中获取一些值，或者将要获取一些值。

所以它将能够，它将是我们从堆中得到的一个数组。

基本上，这将代表合并后数组的总大小，也就是我们所说的。

这里我们要做的是让 kz 到 S，我们要说 while，所以 while 在这里，因为 I 小于或等于 E，我们在这里做的是 buffer，我们说 buffer sub k 等于 sub k。

我们可以说 k 等于 k 加 1。

你这么说是什么意思？现在，我告诉你这意味着什么。

事情是这样的，我们正在创建一个临时缓冲区，从堆中分配。

然后我们将使用 Delete 关键字取消分配它。

但在此之前，我们要使用它，因为我们不想在现有阵列中重新分配它。

所以我们希望它被储存起来。

然后我们想要这边的东西。

所以我在这里只说这部分，b，u，s，s，e，r，这是缓冲区，这部分，这整个东西，我说的是整个东西。

这是缓冲区，这将是我们的输出数组。

这将是一个排序后的数组，我们在做两件不同的事情。

因为如果我们只改变一个数组，就会导致复杂性，比复制元素要复杂得多。

假设我们有这个数组。

所以就忽略这部分吧，因为现在还没有排序。

我们刚刚创建了一个包含所有值的重复数组。

所以它从 K 开始，一直到，所以它说，从零到值。

最后一个。

如果我回到这里，你可以看到这个例子从一个初始值开始，它小于等于 n 的值。

它只是说 buffer sub k 等于 buffer sub k。

所以一个 sub k，不管值是什么，它都要把它存储在缓冲区的什么地方，所以它初始化了所有的值，一直到最后都是 k 加 1。

所以只是复制，做了个复制品，对吧。

在那之后，我们可以做的是在这里指定一些东西，就在这之后。

所以一旦它被复制，砰，I 等于 s。

现在这里有一个东西，就是 J，我们说 m 加 1。

现在，我来告诉你我们为什么这么做。

我们还有 k。

我们说作为 S，I 等于 S，回到这里，我们有这个 IO。

它会在这里，这是初始值，在这里给我另一种颜色，我会变得更暗一点。

好的，我这里有，就在这里。

第二个，我们得到的是这个 mid，我们知道，好的，我们得到的另一个是 j 等于 n 加 1。

所以如果我回到这里，我们有这个 j 在这里。

我们知道这里是端点，所以你可以看到这个 AI 必须一直提交到 M，这是它的最后一个元素。

这个 j 必须一直递增到这里的末端。

这就是我们如何比较 2 和 3 的值，哪一个类似于这里的 planted，去提交 2+7。

然后我们说 7 和 3，哪个更小，3 个更小的种在这里，然后把其余的放进去。

这就是我要实现的编码过程，我必须把它映射出来。

这就是为什么我要用这个图表。

这就是我们正在做的。

所以我们要用 s 来表示，让我们有一个 while 循环。

这个过程是这样进行的，I 就是那个值，我告诉过你，这里的值小于等于 m，j 小于等于 E，这个过程会继续。

所以如果 I 小于等于 m，我们有 j 小于等于 E，我们希望有一些过程在进行。

如果缓冲区是 E ^ I，那么我们有小于等于 buff er sub ^ j，如果这个过程完成了，如果缓冲区 sub ^ I 小于等于缓冲区 sub ^ k，那么我们要做的就是 sub ^ k，这个过程就是我刚才说的，如果它小于等于，就把它复制到里面，Kate，然后这里的数组，我们要把它分类，所以我们要通过 buffer 复制到这里。

所以这是阿布 FF，er sub i

所以在这种情况下，如果它更小，对，如果它更小或者等于，然后我们就增加等于 I 加 1，就像我们在那边做的那样，就像我们在那边做的那样。

如果不是这样的话，我们就再来一个。

当我在这里放东西时，让我放在这里，这里的情况是，一个 sub k，一个 sub k 在这里，它等于 buffer。

所以它将是 buffer，然后我们在这里有 sub j。

所以我们把这个 j 放在这里，它是一个 sub k，因为如果不是这样，它会变小，对吧。

这意味着如果它小于，但如果它大于，J 会在那里。

显然，我们会让 j 递增，而不是中断。

所以我们有这个，我们有 k 等于 k 加 1。

让我吃那个。

给你。

现在我们有了条件。

这是这边的这个箱子。

这是 while 循环。

这个条件之后还有一段时间。

现在，我来告诉你这背后的原因。

所以我们有这个 while 循环，在这之后，我们有两个 wild 循环。

另外，我会告诉你我们需要这两个的原因。

问题是，如果我们比较这两个，就像，假设我们有这个工具，我们有这三个，我们比较它是更少的。

然后我们增加了。

我们只是在做加号，我们没有做，但是情况一，我们在 19 和 21 来到这里，这些是怎么来的，这个数组已经满了，所有这些都是完全记住这一部分，但是我们只是在这里面附加了最后两个，我们如何做自动过程，自动过程将通过两个野生循环来完成，我们将包含，那个条件就像如果小于好，或者如果 j 小于等于吃。

这是两个条件，仔细看。

所以当我们说 I 小于或等于 m 时，如果这个条件像是，还在，像是真的，像是爆发了。

所以这里的过程是，这两个永远不会一起变成假，它总是其中之一，而不是另一个。

没错。

所以如果像松鸦听，他来了，然后我们仍然小于等于 m，我们可以在这里做的是，一个 sub k，这是相同的场景，我们做的例子，一个 sub k 等于我们要说，缓冲区，所以我们从缓冲区得到的东西，我们说，作为 j。

我们要做的基本上是，实际上，我们要用 I 设置，因为它的眼睛在这里。

我们要用 eye 来设置，然后我们要做的是，我们要增加 I 加 1，我们要增加 K 等于 K 加 1。

如果在其他情况下，当 j 小于等于 E 时，我们会有一个 sub k 等于 buffer。

我们把它命名为 j。

潜艇，给你。

我们让 Jay Z 去 j+1。

我们有 K 等于 K 加 1，它只是增加 K 值。

你已经知道 k 从哪里开始了。

这里是 k。

所以这部分是 k。

j 会选择 1-234-567-8910。

一切都结束了。

所以它一直递增，你可以看到 j 在这里，在那里。

这就是背后的过程。

然后一旦我们用完了，我们就不想要这些额外的内存了，我们就删除它。

所以我们只需要删除我们的缓冲区，使用这个删除语法，基本上我们要从内存中释放它。

仅此而已。

现在让我们有这个额外的功能，我们需要的基本上是，我想，所以它是一个打印的，所以哦，我忘了我的主要逻辑。

我的意思是，这是卑鄙的，也许我把它留在了上面，是的，这是一个常见的错误。

好了，把这部分删掉。

让我们在底部有一个显示功能。

所以在底部值，就在这里，让我们有一个显示函数。

它将被称为 void，我们将有一个显示，我们所做的基本上是有一个数组，就像其他的小数组一样，大小为 n。

我们将有一些要实现的东西，就像我们有临时的，我们将有一个与 sub 相关联的。

我在做什么，实际上我不等于零，我爸。

所以当 I 小于 n 时，我们会有，然后我们会说，控制台，输出数组值，数组 sub i，把逗号放在这里。

然后我们让它一直递增。

是的，这里有恒定的输出。

给你。

现在我们要做的就是在这里运行代码。

所以再次得到一个随机数组。

让我得到这个数组，就在这里，复制到这里，复制粘贴到这里。

让我们改变一下这里的东西，是插入还是剑，我们会有 G 先生，G 先生，G 先生排序，合并排序。所以还是回到我们的 c++编译器，c++，G 先生，s，o r t dot cpp，Ivan Oh，G 先生，G 先生，s，o r t，还有一个编译好的 G 先生 s.o RT。

给你，维奥拉，110，然后 100 到 293，然后所有的，按升序排列。

这就是归并排序。

与我们迄今为止所做的任何排序算法相比，这要快得多。

所以即使是选择排序，冒泡排序，插入排序，甚至是我们一开始做的问题，因为它们都有时间复杂度，旧的 n 的平方比 n 的平方比 n 的平方比 n 的平方。

但是这种合并排序更快，因为它的时间复杂度更高。

在 n 的所有 n 个 log 中，所以哦，然后我们有 n，然后我们有 log，然后我们有 n 在里面。

与其他排序算法相比，这要快得多。

现在，如果你从一个文本文件中得到一组数组，我可能会在我的其他视频中这样做，请继续关注。

在我频道的下一个视频中，你会看到我们将有一个文本文件，我们将比较它与其他排序算法相比的速度。

因为如果我们有这些 O/n 的平方，排序算法，这些将花费更多的时间，随着输入值的增加，它将呈指数增长。

但是相比之下，归并排序将会快如闪电，因为它在所有的 n 个对数中，无论有多复杂。

所以希望你喜欢这个视频，希望你喜欢它。

请一定要访问我的频道，它叫做聪明地编码，在那里我有很多 c++的内容，我做过数据结构和算法。

我做过面向对象编程，做过基础、初级、过程编程，我的目标是完成数据结构。

之后，我学习了其他基于项目的视频以及新的语言和技术。

所以一定要订阅那个频道。

是的，非常感谢您的收看。

我真的很感谢你的支持。

非常感谢你们，也感谢自由代码营把我的视频放在他们的频道上。

真的很感激。