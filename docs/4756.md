# 《斯威夫特》中一个母亲和两个儿子的故事:价值型与参照型

> 原文：<https://www.freecodecamp.org/news/the-story-of-one-mother-two-sons-value-type-vs-reference-type-in-swift-6e125af2d5d0/>

斯威夫特是母亲？它有两个儿子？-

*   价值类型？？‍♀️
*   参考类型？‍♂️

但是他们的特点是什么呢？？‍♂️

他们的行为是相同的还是相反的？？‍♂️

Swift 是苹果为 iOS、macOS、watchOS、tvOS、Linux 和 z/OS 开发的多范式编程语言。？

就像其他面向对象的编程语言一样，Swift 将类作为构建模块，可以定义方法、属性、初始化器，可以符合协议，支持继承和多态。？

但是，等等等等等等…？？？

Swift 也有结构，它可以定义方法、属性、初始化器，并且符合协议，只有一个继承例外。？

什么？现在我很迷茫！！！？？？

现在让我们增加你的困惑:结构不仅仅是 Swift 中的值类型。元组和枚举也是值类型。类也不是唯一用作引用类型的。函数和闭包也是引用类型。但是作为一种解脱的象征，我们至少知道了这些类型使用的主要焦点&专门化。？

至此，我们只剩下一个关于结构和类的用法的大困惑。？

所以，让我们去澄清周围的混乱。？‍♂️

### 存储位置

有三种类型的存储可用:

*   注册？
*   斯塔克·☄️
*   堆？

寿命较短的对象存储在寄存器或堆栈中，寿命较长的对象存储在堆中。？

值类型将其内容存储在堆栈中分配的内存中，因此我们可以说在 Swift 中值类型是在堆栈中分配的。？

但是对于值类型有一个普遍的误解，你听说过吗？？‍♂️

误解是大多数人认为值类型总是存储在堆栈中。

❌❌，等一下——情况并不总是这样。❌❌

当值类型是临时变量或局部变量时，它们可以存储在堆栈中。但是如果值类型包含在引用类型中呢？

在这种情况下，它可以存储在堆内存中。？

哇…太酷了！！！？

因此，值类型可以存储在寄存器、堆栈或堆中，这取决于它们的寿命，无论它们是短期的还是长期的。如果它是一个局部变量，它可以存在于堆栈中，如果它是类的一部分，那么它也可以存在于堆内存中。✅

另一方面，引用类型将其内容存储在堆内存中分配的内存中，而变量只保存对存储实际数据的内存位置的引用。？？

对于引用类型，它是如何工作的？？

所以对于引用类型，有几个变量保存对同一个内存位置的引用是很常见的情况。⚔️

当值类型实例被赋给变量或传递给函数时，该实例被复制并赋给该变量。但是对于引用类型，只有引用被复制，新变量保存对相同内存位置的相同引用。？

### 可变性方面的差异

一个变量可以有两种状态:

*   ？‍♀ ️Mutable？‍♀
*   不变？️‍♂️

如果一个值类型实例被赋给一个不可变变量，那么该实例也变成不可变的。因此，我们不能对该实例进行任何更改。？‍♂️

如果一个值类型实例被赋给一个可变变量，那么只有它使该实例可变。？‍♂️

但是对于引用类型，情况完全不同。变量和它被赋给的实例是完全不同的。如果我们声明一个不可变的变量持有一个类的引用，这意味着它持有的引用永远不会改变。我们不能改变引用，它将总是指向同一个引用。？

### 结构类型

结构类型的值根据它们的属性或元素进行相等性比较。当且仅当所有对应的属性都相等时，我们可以说一个值类型等于另一个值类型。？？？

嗯…太多激烈的言辞…你是什么意思？？？

比方说，我们有一个 *****人***** 值类型，该值类型具有类似于 *****名***** 和 *****姓的属性。*****

```
struct Person {
   var firstName: String
   var lastName: String
}

var person1 = Person(firstName: "foo", lastName: "bar")

var person2 = Person(firstName: "foo", lastName: "bar")
```

这里的*****person 1*****&*****person 2******实例都对*****first name*【foo】****和*****last name(" bar】******持有相同的值。因此根据我们的理解，我们可以说这两个实例彼此相等，因为它们的属性(*****first name*****&*****last name*****)具有相同的值。**

*但不仅限于此:在未来，任何两个人实例持有相同的 *****名字***** & *****姓氏***** 的值，都将彼此相等。*

*因此，根据我们到目前为止的理解，我们可以说:*

> *******值类型不具有同一性，所以不可能有对它们的引用。值类型是匿名的。？*******

*什么？你怎么能这么说？？？？*

```
*`var myAge: Int = 21
var friendAge: Int = 21`*
```

******myAge*****&*****friendAge******都是值为 21 的整型变量。**

*******我们能区分它们吗？？*******

**不，因为他们持有相同的价值。？**

**值为 21 的整数变量不能与另一个值也为 21 的整数变量不同。就这么简单。？？？**

**没有身份给了值类型另一个优势:如果你实际地思考，那么你可以想象如果你没有身份，那么任何具有相同特征的人都可以取代你。？？？**

**同样的，我们也可以认为我们是人类。如果我没有身份，那么任何具有相同特征的人都可以取代我？？？。对我们来说，拥有一个身份是件好事，否则我们的存在将面临巨大的风险。？**

**但是对于值类型来说，他们没有身份，这对他们来说是一个优势。？**

### **使用值类型有什么好处？**

#### **？没有竞争条件和死锁:？**

**对于多线程环境中的值类型，一个线程不可能在另一个线程使用实例时改变它的状态。因此，我们可以说，将不会有竞争条件或死锁。**

#### ****不保留周期:****

**当有两个引用类型实例彼此持有强引用，并阻止彼此从内存中释放时，这称为保留周期。因为值类型不作为引用，所以我们可以说值类型没有保留周期。**

#### **？‍?‍?‍?自动引用计数:？‍?‍?‍?**

**对于引用类型，Swift 使用自动引用计数来跟踪所有活的或活动的对象，并且仅当不再有对实例的强引用时才释放实例。如果我们稍微思考一下，那么我们可以说这是一种繁重的操作，因为 Swift runtime 需要始终跟踪对象。但是由于值类型是在堆栈中分配的，所以不需要 ARC。所以更便宜更快？？。**

**但是等等...它是如何为数组、字典和字符串管理内存的？？**

**因为我们无法知道数组、字典和字符串在编译时的实际大小，所以在编译时没有为它们分配空间。虽然它们在内部是值类型，但不能在堆栈中分配。它们需要在堆内存中进行分配，为了管理这一点，Swift 提出了写 时复制 *****。？*******

**但这是什么？？**

**当我们说一个实例是另一个实例的副本时，这实际上意味着它们是相同的，它们包含相同的值。但是在 Swift 中，对于上面的这些类型(数组、字典、字符串等)，只有当一个实例发生变异时，才会在堆上进行实际的复制。这被称为值类型的性能优化技术。？？？**

### **结论**

**没有硬性的规则来定义什么时候使用值类型，什么时候使用引用类型。值类型比引用类型有一些独特的优势，反之亦然。他们都有自己独特的方式。这真的取决于你的要求和你想要达到的目标。你应该知道你的代码的语义，因为你只知道你的代码最好，所以这取决于你的选择。你有充分的自由。**

**因此，与其为值类型和引用类型争论不休，不如明智地使用它们。**

*******？？？干杯！！！感谢您的阅读！！***** *？？？***

*******✅✅✅You 可以在***** [*****推特上找到我*****](https://twitter.com/_boudhayan_)*****。✅✅✅*******