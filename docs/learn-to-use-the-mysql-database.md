# 学习使用 MySQL 数据库

> 原文：<https://www.freecodecamp.org/news/learn-to-use-the-mysql-database/>

MySql 是最流行的数据库之一。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个 MySQL 数据库课程。

Bharath Ram Manoharan 从 Execute on Command 创建了这个课程。他是一名高级数据库工程师和优秀的教师。

本课程从 SQL 基础开始。然后，它还介绍了关键的数据库概念，如数据建模、锁、索引、SQL 解释等。

以下是本课程涵盖的主题:

*   如何创建 AWS EC2 实例
*   如何安装 MySQL 数据库
*   数据建模
*   SQL 基础知识-创建表
*   SQL 基础知识-插入数据
*   SQL 基础知识-更新和删除数据
*   SQL 基础知识-读取数据(Select 语句)
*   sql 连接
*   事务隔离级别
*   表级锁
*   行级锁
*   数据库死锁
*   聚集索引
*   SQL 解释

观看以下或 freeCodeCamp.org YouTube 频道的完整课程(2 小时观看)。

[https://www.youtube.com/embed/ER8oKX5myE0?feature=oembed](https://www.youtube.com/embed/ER8oKX5myE0?feature=oembed)

## 副本

(自动生成)

MySQL 是最流行的数据库之一，在本课程中，向一位高级数据库工程师学习如何使用它。

欢迎来到 MySQL 基础课程，首先我想感谢你尝试学习一项新技能。

让我自我介绍一下。

我叫 Barbara，是 Salesforce 的一名高级数据库工程师，我有超过 12 年的各种数据库经验，Oracle 是主要的数据库，我有与 Chase、PayPal、Wells、Fargo、StubHub 等公司合作的经验。

我先回答你几个基本问题，那就是谁，什么，为什么。

那么，谁应该学习这门课程呢？这门课程是为那些希望扩展自己技能的数据库专业人员开设的。

如果您是一名软件工程师或全栈开发人员，并且希望深入了解 MySQL 数据库，那么本课程就是为您准备的。

如果你是一名大学生，或者计算机科学专业的学生，或者刚毕业的学生，这个课程会给你一些关于数据库内部的知识。

所以你为什么要学习 MySQL，MySQL 是最流行的开源数据库，当然还有 Postgres。

SQL 绝对在上面。

随着公司将数据从内部迁移到云，他们通常喜欢迁移到云原生数据库或开源数据库，如 MySQL 或 Postgres sequel，以节省成本。

假设您是 Oracle 数据库专家。

如果您获得了关于 MySQL 等数据库的知识，那么您可以帮助公司将他们的数据从 Oracle 迁移到 MySQL，这将非常有价值。

现在，我们来看看本课程涵盖了哪些内容。

首先，我说的 MySQL 是指贯穿本课程的 MySQL InnoDB 存储引擎，它被用于任何商业网站、银行或金融机构等的背后。

MySQL 提供了各种存储引擎，my I Sam，in memory 存储引擎，或者一些流行的存储引擎，这些都是可用的，我们将了解 MySQL InnoDB，我不涵盖任何其他类型的存储引擎。

这些是我在这门课中将要涉及的话题。

请注意，这是一门数据库管理课程。

所以 80%是数据库管理。

对于完全不熟悉数据库的人，我已经介绍了 SQL 基础知识。

因此，您将学习数据库安装、MySQL Workbench、数据库索引、数据库日志，还将学习一点性能调优，即 SQL explain。

所以这些是我将要讲述的一些有趣的话题。

那么你到底需要什么来开始这个课程，你需要一台个人电脑还是一台苹果电脑。

因此，如果您正在使用 PC，那么我建议您实际查看描述中所附的工作表或补充材料。

如果您有一台 Mac 笔记本电脑，那么您就处于学习本课程的最佳位置。

因为这样你就能看到我在打什么了。

你可以输入同样的命令，从头到尾跟着做。

最重要的是，这是主要的要求，我希望你创建一个 AWS 帐户，这是正确的，令人惊讶的 Web 服务帐户。

所以，如果你不知道我在说什么，请看看我的工作表，它可以在描述中找到，我已经附上了一些资源，它将向你展示如何创建一个 AWS 帐户，我将在整个课程中使用 AWS EC two 实例。

我将向您展示如何创建一个。

但是我想让你们记住的一件主要事情是，在你们的每个学习环节之后，你们可以关闭你们的 ec2 实例。

这样你就不用支付任何不必要的费用。

请记住，您不必让您的 EC 实例全天候运行。

因此，一旦您创建了一个 AWS 帐户，并登录，您将登陆这个仪表板，或这个页面。

你可以去这里的服务菜单。

然后在“compute”下，您可以选择“easy to ”,在左侧，您可以选择“instances”。

然后，我们将在这里创建一个实例，作为我们的实验室环境。

因此，单击启动实例。

然后让我们为我们的实例选择一个图像。

因此，我将选择 Red Hat Enterprise Linux version 864 bit，我的实例类型将是符合自由层条件的 T two micro。

您需要选择一个合适的子网。

如果您刚刚创建了一个 AWS 帐户，您可以离开。

保留为您显示的任何默认子网。

对我来说，我要选择我是一个特别的人。

然后确保启用此自动分配公共 IP 选项。

因为这将为您的实例分配一个公共 IP，您可以使用该 IP 从您的笔记本电脑 SSH 到您的实例，并保留所有其他设置不变。

让我们为数据库或整个实例分配 25g 内存。

您可以将剩下的 ISIS 留下，转到下一页阅读，您可以为您的实例创建一个标记。

所以我把它叫做我的 SQL 实例。

第一，转到安全组页面。

在这里，重要的是您需要能够 SSH 到实例中。

你需要，你需要为任何人创建适当的防火墙规则，基本上，世界上的任何人都可以通过端口 22 登录到这个实例。

这一点也不安全。

我会处理这件事的。

因为一旦我完成录制，我通常会删除它。

所以我知道怎么处理这件事。

但是，当您创建规则时，请确保将您笔记本电脑的 IP 放在那里，这样更安全，然后现在您可以查看您的配置，然后单击启动。

但是如果你愿意，你可以创建一个新的密钥对，然后给它一个名字。

然后在创建实例之前下载它。

对我来说，我将选择一个现有的密钥对。

也许是这个，我说的是知识，也许是另一个。

好吧，这个。

和启动实例。

现在您的实例正在创建中，创建这个实例可能需要几分钟时间。

好了，这就是如何创建一个 ec2 实例。

现在，我的实例已经启动并运行，我可以看到公共 IP。

稍后，我将在这个实例上安装 MySQL。

这就是我想在这节课上向你们展示的。

所以你看到的基本上是我的 sequel 文档，显示了所有这些不同的安装指南，比如 Windows 和 Mac，等等。

所以我们感兴趣的 Linux 安装基本上都是 MySQL 安装在 Linux 上。

实际上有几本指南。

这基本上是安装 jannettek 二进制文件，我们将跳过这一步，转到这里。

甚至在 Linux 上安装 MySQL，也有一堆指南。

所以推荐的安装方法是使用 Oracle 的 RPM 包。

但是我们将使用这个基于 MySQL yum 存储库的安装。

这其实很简单。

所以对于这个安装，我们需要去 MySQL comm 和 downloads。

我们正在下载社区版并转到 yum repository。

如您所知，我们创建的实例运行 Archie l8、Red Hat、Enterprise Linux。

所以我们需要下载这个 rpm。

但是接下来我们需要在我们创建的实例上下载 RPM。

因此，让我们实际登录到实例中。

所以我将使用 SSH，我们将使用我的私钥。

登录很容易，用户可以选择默认用户，基本上可以获得我的实例登录的公共 IP，然后切换到 root 用户。

因此，我们需要将这个 RPM 下载到这个 Linux 实例的一个东西是 W get 包。

所以让我们先安装它。

好了，现在 w gate 已经安装好了，我们需要下载刚才看到的 RPM。

因此，要获得这个 RPM 的链接，我们需要进入这个下载。

我们必须右键单击此处并复制链接。

如果你安装在不同的操作系统上，你需要点击相应的按钮。

好了，我们得到了链接，让我们继续把链接粘贴到这里，就像我们得到了链接一样。

该命令下载此软件包，现在我们将使用 RPM 命令来安装此软件包。

正如我之前提到的，这个包将把这个 MySQL yum repo 添加到您的本地系统 repo 列表中。

在 Red Hat Enterprise Linux 安装中，默认情况下您会得到一个 MySQL 模块。

所以让我们禁用那个。

如果你不禁用它，那么这将干扰我们的 MySQL 安装。

因此，让我们继续使用此命令禁用它。

不要担心写这些命令，我会在描述中放一个到我的 Git repo 的链接和所有这些注释。

所以这些都被禁用了。

现在让我们继续使用 yum install MySQL community server 安装 MySQL community Server Edition。

让我们在这里输入-y，然后接受所有的提示。

那就是安装所有这些软件包。

好了，我的 SQL 已经安装好了。

让我们继续使用 system CTL 启动 MySQL 数据库。

命令。

让我们检查一下状态。

现在，我的 SQL 数据库已经启动并运行了。

好了，那么这个 MySQL 数据库软件的日志文件在 var log 下。

然后，如果您从这个日志文件中抓取 temp，您将获得 root 用户的临时密码。

你可以用它登录 MySQL 数据库。

你如何登录，你使用这个命令 my sequel 减 u，这将是根和减 P 是基于密码的登录。

然后我们登录 MySQL 数据库。

所以让我们使用这个密码，看看它是否登录。

我们进去了。

如果您在此时运行任何命令，我的 sequel 将要求您使用 alter user 语句重置密码。

我们可以用不同的方式来做这件事。

于是就有了一个叫 MySQL admin 的可执行文件。

这是对它的命令。

MySQL admin，减去你的用户名和 p 密码。

我们将重置 root 用户的密码。

让我们首先提供当前密码，这是一个临时密码。

让我们提供新的密码。

好了，密码已经被接受了。

现在让我尝试使用这个新密码登录，使用前面的命令 my SQL 减去 u proved 和减去 p MySQL。

让我把刚才我说的密码输入进去。

因此，让我们继续运行一个简单的 show databases 命令，它显示了作为安装一部分的所有默认数据库。

因此，要完成安装，我们需要做的另一件事是加载时区文件或时区表，如下所示。

因此，如果我选择星号，这基本上是一个从这个表中读取的 SQL 查询，您可以看到这个表现在是空的。

因此，让我们退出并运行另一个命令。

加载时区相关数据。

所以这是命令。

让我们继续运行它。

我将继续输入我的密码，这将加载大量数据，您可以忽略所有这些警告。

让我们回到我们的 MySQL 数据库。

因此，如果您从 MySQL 点时区选择星号，它会再次显示一堆数据。

所以现在，你没事了。

这就完成了 MySQL 数据库的安装。

好了，朋友们，在这一部分，我们将讨论数据建模。

好的，所以数据库设计，数据建模，模式设计，这些都是可以互换的词，数据库设计的术语是一个持续的过程。

所以当你想创建你的应用程序时，你有了一个基本的设计。

然后，随着应用程序增加新的功能、增强和改进，你基本上要迭代这个设计，对，你要不断地在你的设计中加入新的东西，等等。

因此，当您进行数据库设计或数据建模时，首先要做的是理解业务数据。

一旦理解了业务数据，就必须对数据库进行逻辑设计。

我这么说是什么意思？嗯，基本上，你必须设计你的表，进入这些表的列，索引，约束，像主键约束，唯一键约束，非空约束，默认值，外键，这些都是你需要创建的各种东西。

当你想出你的模式的逻辑设计时，一旦你实际上有了这个基本的表设计或模式设计，那么你可以寻找数据冗余，也就是说，你基本上可以看到你的数据在哪里重复。

然后你开始通过规范化你的表格来消除它。

这是因为数据冗余会导致数据异常。

我的意思是，当相同的数据多次出现时，比如说，当你更新某些数据时，你必须在许多地方进行更新。

如果你忘记更新甚至一个地方，现在你在你的数据库中有相同数据的两个版本。

这就造成了数据异常，数据不一致实际上也是如此。

所有这一切都是因为数据冗余。

所以我们看到的基本上是一个电子表格，电子表格基本上是一个巨大的表，一个大表，对吗？我们要做的基本上是为电子商务网站设计一个表格，一个电子商务网站基本上就像一个神奇的区域，或者 E Bay，或者其他什么，像在线商务，像在线电子商务网站，像阿里巴巴，或者其他什么，对吗？比方说，这个数据库中只有一个表，对吗？当订单进来时，通过这个网站，你开始把数据输入这个表格，对吗？你知道，让我们看看你将在这个表格中记录的一些事情，对，你显然需要像你的订单计数。

所以你可能想给你的订单编号，然后看它是如何产生的，你知道，是桌面还是移动？或者是什么产品？比如，你知道，我这里有几本书，书名，还有产品的价格。

然后客户是谁客户详细信息，付款详细信息，交货详细信息，等等。

基本上，这些都是电子商务词汇的一部分。

对吗？你有一张大桌子。

如果你看看这里的数据，对吗？所以，你知道，在这里，我有几个客户在购买两种不同的产品。

你可以看到数据是重复的。

我的意思是，每次我购买相同的产品，我都必须重复这些数据，就像第一个订单是通过出生时带来的 web 桌面网站，然后您可以看到该客户的所有详细信息，以及关于产品和付款的所有详细信息。

然后，第二个订单来自不同的人，但是，你知道，订单是相同的产品，你必须重复产品信息。

没错。

第三封是前一个客户的。

但是然后这次他买了一个不同的产品，他的信息，客户信息实际上重复了。

所以有大量的数据冗余数据被重复。

因此，这基本上是一个非规范化的数据库，其中只有一个表或几个表，我们将所有来自您网站或您业务的信息备份到这几个表中。

实际上，这是你的数据库的非规范化版本，让我们看看你还能做什么。

所以你可以做的基本上是，你可以从这个基本的反规格化表开始，然后你可以开始从你的数据库或你的表中取出所有冗余信息。我做的第一件事是，我取出客户信息，他们把它放在一个单独的表中。

我这里只有顾客的详细资料。

我开始为每个客户 ID 或客户号加上一个 ID 号，不管你叫它什么。

一旦我取出客户信息，我就有了订单表，初始表，我现在调用订单表就像这样，对吗？您可以看到，我在这里有一个客户 ID 栏。

这个客户 ID 列是什么？你的猜测？对吗？所以这个客户 ID 栏和你在这里看到的是一样的。

对吗？为什么我有这个，因为我需要一种方法来关联这些行。

如你所知，比如，你知道，这些是列，这些是行，这些行，我需要能够与客户联系起来，对吗？如果我拿出客户信息，我该如何联系？你知道，这张桌子和那张桌子？它是通过一个普通的列，或者一堆列。

实际上，在这种情况下，它只是一个列。

客户 ID，对吗？我只是把身份证号码放在这里。

我们还能从这张桌子上得到什么。

所以这是标准化的一个层面。

对吗？所以让我们继续规范化，就像去掉产品细节一样。

对吗？所以产品细节也在重复。

所以在这里，你感觉不到太多痛苦，因为这个表中只有三条记录。

如果这个表有一百万条记录，对吗？这就是为什么我们需要规范化这个表。

现在，您实际上取出了产品信息，并将其移动到不同的表中。

然后，我有一个产品 ID 列，只是为了编号，实际上就像标识产品一样，您的订单表将像这样，然后您将支付信息取出到另一个表中。

您的订单表将如下所示。

这基本上是从非规范化模式或数据库到规范化数据库的过程。

当您将数据放在单个表中时，就不需要进行任何连接。

所以你可能会问，实际上，什么是关节，当你运行查询时，比如使用 SQL，SQL 是一种语言，对吗？一种结构化查询语言，当你在数据库中运行命令时，你可以从这个表中得到所有数据，如果你的表数据库是完全非规范化的。

然而，如果你有很多表，你需要合并或者连接这些表，然后你必须取出数据。

这就是所谓的连接表。

所以当你有一个反规格化的数据库时，你不需要做很多关节。

这在某种程度上是一件好事，因为你的数据库不需要考虑太多就能得到数据。

你说我要这个数据，这个数据在这个表里面。

所以这很简单。

然而，就像在一个规范化的数据库中，当您连接许多表时，您的数据库引擎会调用优化器，在 Oracle 或大多数数据库的大部分磁带中。

因此，这个数据库引擎必须更多地考虑，好吧，我应该首先扫描哪个表？以及我应该如何过滤这个表中的数据。

然后，我从那个表中取出结果集，并与其他表连接。

因此，无论数据库在哪个服务器上运行，都会有更多的处理工作要做。

没错。

正因为如此，表演会有点弹性。

右下角将会消耗大量资源，并且所有这些操作都在大规模发生，因为许多操作同时发生，所以性能实际上很慢，或者至少低于非规范化数据库中的性能，但与此同时，我们删除了大量重复数据，数据冗余非常低，因此，规范化数据库中所需的存储要低得多。

所以，你不能一概而论，说一个规范化的数据库总是很慢，或者反规范化的数据库会很快，这完全取决于实际上你必须查看数据，看看有多少重复发生，等等。

所以，但一般来说，这是怎么回事，当你通过这个设计过程，对，你知道，看看我们实际上做了什么，对。

所以，我们已经决定，我们需要的表，像你知道的，我们有订单，表产品得到客户和付款，我们决定列名。

不仅是每个表，你还需要决定什么是主键。

我所说的主键是一个唯一的键，不能为空，这一点非常重要。

所以使用这个主键，你应该能够识别这个表中的任何记录，这个表中的任何一行。

例如，如果我在这里说，主键是订单号，那么我可以，任何时候如果我有订单号，那么我可以查找这个表，假设订单号等于 2，我可以从我的数据库中得到这个记录。

实际上，你还需要一些独特的密钥。

所以唯一键很像主键。

正如我提到的，唯一键现在可以是主键，不能为空。

然后你的表上也可以有索引。

所以索引是更快选择一天数据的方法。

比方说，我经常根据客户的电子邮件搜索这个表，那么我需要客户电子邮件列的索引，对，你需要决定。

您需要决定哪些列可以为空。

对吗？这里，任何列都不能为空。

假设您有另一个名为 preference a 的列，即客户首选项，如首选哪种运输方式、哪种电话号码等。

所以这可以是一个空列，对吗？所以你可以没有列。

否则，将列定义为 not null。

比方说，在您的订单表中，有一个“已交付”列，当客户在您的网站上购买产品时，订单基本上就创建好了。

当然，它不是立即交付的，在订单创建时，交付的列将总是没有或 n，一个 n 值，对吗？我们正在讨论的所有这些事情，所有这些决策都是模式设计的一部分。

一旦你搞清楚了这一切，你就可以把这些信息放进你的设计工具实体关系设计工具。

在下一部分，我将向您展示我是如何在 sequel workbench 上做到这一点的，我的 sequel world workbench，基本上，您实际上可以获得数据库逻辑设计的图形表示。

这就是所谓的 ER 图。

当然，你可以谈论两个表之间的关系，比如说你可以说哦，这个表中的这个表，它们是一对多的关系，比如说，每个客户可以下很多订单。

这实际上是一对多的关系。

但是，你知道，一个订单只能由一个客户完成。

对吗？诸如此类的事情。

因此，表之间存在一对一关系、一对多关系或多对多关系。

其实这些都是数据建模的一部分。

但是你不需要太担心这个，只要你清楚地知道什么样的数据会进入你的数据库。

在此过程中，您需要定义列的数据类型。

事实上，这非常重要。

你的名字会变成一个通配符。

你知道，电话号码可以是数字，然后电子邮件又像一个手表图表。

你的 ID 列或者数字列将会是 int 或者 number。

这些都是你在数据建模任务中要做的一些决定，实际上，这就是我想说的关于数据建模的大部分内容，然后我们还可以讨论更多。

就像原子性，就像你，你把所有的地址，有点像属性都放在一列，我们，我们也需要把它分开。

这就是所谓的原子性。

你可以有单独的地址，单独的城市，单独的州，你知道，单独的邮政编码，对吧。

因此，这些事情，有细微差别，使您的数据库越来越有效。

当然，我们不会在这里详细讨论。

但这是您需要理解的基本数据建模。

正如我之前说过的，在下一节，我将向您展示如何在我的 sequel 工作台上使用它，然后输入它。

快速回顾一下我在上一节所做的，我基本上创建了一个电子商务网站的逻辑设计。

所以你现在看到的是我开始做的表格。

这是一个反规格化的表，我们基本上把这个反规格化的表，规格化了。

如您所见，该表有四个版本，我称之为订单表。

所以有四个不同的版本。

在每次迭代中，我都取出重复的数据。

最后，除了最初的 Orders 表之外，我们得到了四个表。

所以现在我们也有客户产品和支付。

在这个视频中，我将展示所有的马厩，然后展示结构，我将创建一个逻辑设计。

好的，让我们转到 MySQL Workbench，我已经连接到一个数据库，我要做的是转到文件并转到新模型。

所以这里我们可以添加一个新的 ER 图，一个实体关系图。

让我们称这个数据库为 eecom。

商店之类的。

所以让我们开始创建我们的表。

现在，我不会创建所有四个表，这可能需要更多的时间或更长的时间，我将创建几个表。

这应该足以让你明白我们是怎么做的了。

所以让我们从客户表开始。

因此，客户表有五列，这是用于创建新表的图标，您可以拖放，或者您现在可以尝试绘制双击，然后创建一个名为 customer 的表，在这里我们可以开始将该表的列名为 customer ID，然后它将由您的序列填充。

所以序列是一个数据库对象。

它将是一个整数。

所以我们可以让它保持原样。

我们可以将它作为主键，这很好，主键必须被填充，现在不能。

因此会自动选中它。

下一个是客户姓名，我们可以将其拆分为名字，然后我们可以选择查看我们的，也许可以在姓名的长度上给多一点空间，然后是姓氏，我可以查看 100，然后所有这些现在都不能，所以我们可以选择非空约束。

这些是不同的约束条件。

让我们继续下一个地址。

如果你记得我讲过原子性。

所以你希望你的列，你知道，是原子的，在这里，基本上整个地址被打包到一列。

好的做法是实际上把它分成原子列，分别是地址、城市、州、邮政编码。

所以这些我们都有，当然这些现在都没有了还有什么呢？因此，客户电话号码，电话号码将全部是数字。

但后来我想使得到 10 个数字，当然不是空的和客户的电子邮件。

所以我可以只说电子邮件 id 100 好的，不是空的。

因为 I Id 是这里的主键或客户 Id，所以我想确保我们有一个约束来避免重复客户信息。

例如，如果您有一个 Id 为 1 的客户数据，我不希望相同的客户、客户数据重复用于不同的 ID，例如，ID 为 2。

因此，我实际上要为这里的每条记录创建唯一的电子邮件 id。

然后可以是或者也可以是电话号码。

所以这些都是唯一键约束，或者唯一约束。

就是这样。

因此，我们创建了 Customers 表。

所以我们回去看看还有什么。

现在让我们来创造，我会说是产品。

然后你基本上做同样的事情，选择这是为了创建一个新的表。

现在在这里，你可以画这个，我把它叫做乘积。

我们希望经历相同的过程，然后将产品列名放入其中。

如果您想知道，这是我们在这里添加的同一个客户 ID 列。

我们马上就要把它变成一个外键。

所以让我们把它分成多列。

因为，同样，所有内容都被打包到一列中，这不是一个好的做法。

假设我们称之为信用卡号。

如果客户使用 PayPal，那么我们需要该电子邮件。

所以可以在这里使用电子邮件 id。

因此，根据使用的付款类型，这可以为空或不为空。

所以没关系，到期日是一个日期列。

所以让我们来改变这一点。

因此，如果您不确定，可以点击下拉菜单，然后为每个选项选择合适的数据类型。

我提到的另一件事，基本上是关于外键的，这个客户 ID 与我们在这里添加的相同。

因此，让我们实际上使该客户 ID 成为一个外键。

所以我们可以称之为客户 ID 外键 1。

然后要引用的表是客户。

该列将是客户 ID。

仅此而已。

因此，您可以看到，现在我们在这两个表之间有了连接或关系，我实际上也将添加 Orders 表。

我还创建了订单表，这是主表，现在我将为订单创建一些外键。

一切都搞定了。

如果您想在此时创建任何索引，您可以这样做。

所以我想我们结束了。

基本上，我们在逻辑设计中添加了四个表，这四个表，然后我们创建了列，并定义了它们的数据类型。

我们还为每个表创建了外键，当然还有主键和唯一键。

你可以看到你知道的外键关系清楚地显示在这里，你知道，这就是你创建数据模型要做的。

好了，现在实际上，让我们继续为这个数据模型创建一个 SQL 脚本。

所以你去数据库，然后做正向工程。

然后基本上，你提供你想要创建的数据库细节，这些表就是模式。

所以这是，这些是我的详细资料继续，到下一个，提供密码。

现在我们连接上了，我不得不试了两三次密码。

这基本上为我们创建了 SQL 脚本，以创建包含所有主键、唯一键和外键约束的模式和表。

我们能做的就是继续，然后数据库或模式创建完成，然后执行脚本。

关闭。

现在你可以看到马厩已经建成了。

所以你甚至可以进入你的 SQL 编辑器，然后你可以开始阅读你的，可以开始查询你的表。

给你。

所以你准备好回来了，当然，没有数据在里面。

现在您可以开始使用您的数据库了。

因此，我们实际上成功地创建了基本模式，或者说为这个电子商务网站设计了数据模型。

表创建或 CREATE TABLE 命令以 CREATE TABLE 关键字开始，后跟表名和括号。

所以在括号内，这对括号，是所有这些列名，后面是列数据类型，后面是约束。

如果希望列值递增，也可以使用这个 auto increment 关键字。

在将记录加载到此表时，以及在定义列之后，当您将值自动加载到时，您可以选择指定主键、唯一键、外键等键，也可以在创建表的过程中指定存储引擎类型。

这是一张非常简单的桌子。

您还可以拥有分区表或包含压缩表、加密表的分区表，所有这些都需要在您的表定义中使用特殊的关键字。

请检查我的续集文档。

如果你想知道更多关于语法的细节。

如前所述，我只使用了整数表字符数据类型，MySQL 文档显示了所有这些不同的数据类型，如数字、日期和时间数据类型、字符串数据类型(如我正在使用的类型)和 JSON 空间数据类型。

所以这些都可以在 MySQL 中找到供你使用。

所以让我们继续创建这个表。

在创建表之前，我想运行这个 drop 命令，以确保该表不存在。

我将创建该表，并查看该表是否已创建。

是的，已经成功地创建了表，我将从表名运行一个 select star，看看我是否也能从这个表成功地查询。

然后它回来了。

基本上，它不会返回任何表示表中没有数据的信息。

这就是使用 CREATE TABLE 语法创建表的方法。

最后，实际上有一个 default 关键字，它可以帮助您为某个或您的列指定默认值。

因此，如果您没有在 insert 语句中为 quantity 列指定值，或者当您通过过程加载数据时，它将自动采用默认值。

差不多就是这样。

我将在下一次 MySQL SQL 会话中与大家见面。

所以我在我创建的表上做了一个描述，它有产品 id、产品名称、产品类型、价格和数量。

您可以看到，产品 ID 也是一个自动递增的列，现在其中没有任何数据。典型的 insert 语句如下所示，让我们转到 insert into 关键字，表名是括号内的一组列，即您要填充的列，后跟 values 关键字。

后跟实际的列值。

如果你能意识到我实际上没有指定产品 ID 值，因为它是一个自动递增的列。

让我们继续执行这个 insert 语句。

让我也运行 select 语句。

如您所见，产品 ID 表已经取了值 1，这是自动发生的，ident 提供值 1，所以我将继续并提交更改。

然后让我们转到第二个变奏。

所以这一次，我将为产品 ID 指定一个值，其他没有什么不同。

所以我想告诉你这是可能的。

所以它通过然后提交。

然后让我们做一个选择，以确保值已被插入。

所以让我们来看看这个 insert 语句的第三个变体。

所以基本上是一样的，除了实际上，我会跳过一些值，然后插入值 10。

对于这个产品 ID 列，我将继续这样做。

它通过一个注释并再次选择，然后你可以看到这也是好的。

所以，是的，这很有效。

所以你可以跳过几个值。

让我们来看看下一个变化。

同样，我将向表中插入一条记录，没有专门指定产品 ID。

或者明确地说，这里缺少产品 ID 列，我将运行 insert 语句并提交。

然后我将运行 select 语句。

我只是想向大家展示，无论这个自动递增列的最新值在哪里，我上次都为产品 ID 插入了值 10，然后下一次插入时，自动递增开始，然后增加，将这个值从 10 增加到 11，从上次插入的值开始。

我将使用另一个 insert 语句，这一次，它实际上是插入到表名中。

我们实际上从不同的表中选择，而不是指定列名、值等的 values 关键字。

基本上，如果 products three 表与 products 的结构完全匹配，一个表，那么我们甚至可以做一个 select star from。如果列不完全匹配，就像在相似的产品中，一个表有不同的列集，而 product three 表有不同的列集，那么我们需要确保我们确实选择了列。

然后，例如，这个产品 ID 来自产品，三个映射到这个产品 ID 和产品一，产品名称来自产品，三个映射到产品一，在对不起，产品名称和产品一，等等。

让我们继续运行它，看看会发生什么。

然后那就通过了。

然后，如果我现在选择产品，在一个表中，您可以看到所有这些行都被正确插入。

基本上产品一个表被填充。

然后我们从产品三表中获得所有数据。

所以这次我想给你们看 insert 语句。

同样，这有点像将批量插入或多次插入合并到一个语句中，您可以看到 insert into 子句只指定了一次，但在该子句的值 spark 中，实际上，我们同时指定了两行。

所以我们甚至可以使用诸如语法和提交，然后选择所有好的。

这些是 insert 语句的几种变体。

我希望你明白这是怎么回事。

下一节课再见。

嘿，我的续集学习者。

所以在这节课中，实际上，我要讲的是 update 和 delete 语句。

所以像往常一样，我将使用我的 eecom 商店模式。

我将使用我的产品表来做这个演示。

很快，如果我们选择产品表，现在有两行。

所以第一次更新只是给大家展示一下 update 的语法。

因此，update 关键字后接表名，再接 set 关键字。

然后您可以拥有表中包含的任意多的列，但是在本例中，我只有一列，我可以运行这个更新。

让我们实际上再添加一个子句，即 where 子句，这是为了只更新您真正想要更新的行，因此我们将只更新产品 ID 等于 1 的行。

所以让我们开始吧。

然后我会进来从产品中进行选择，数量增加了 50，从 299 增加到 349。

现在还有一件事要意识到，实际上你可以，你知道，你可以指定文字值，当你更新的时候，你知道，这是经常发生的。

或者您也可以指定一个公式，或者您可以使用 SQL 函数，如 replace substring、length 等，您可以查看我的 SQL 文档，以了解此更新中有哪些可用的函数，例如，我只是想向您展示语法，基本上是为了让您知道，您可以有多个，您可以一次更新多行。

在这种情况下，我把像，值一，二，三，你知道，你不必一次做一行或任何事情。

所以当你使用 end 关键字时，你可以说产品 ID 或者其他什么，调用它们，然后用一堆值来选择你想要的行。

还有其他方法可以做到。

但关键是，您可以一次更新多个记录。

另一个有趣的用法是使用 case 语句，你知道，你可以假设你有一堆 update 语句，一个表示产品 ID 等于另一个表示产品 ID 等于 2，另一个表示其他产品 ID 值。

您可以使用 case when then 子句或关键字将所有这些合并到一个 UPDATE 语句中，基本上，在这种情况下，实际上，对于产品 ID 等于 1，我想将数量增加 50。

产品 ID 等于 2，我想将数量增加 100，以此类推。

然后我有了这个类似的 WHERE 子句，它类似于我之前给你们看的那个，我将运行它，你们可以看到列是递增的，我不会回去检查，我很确定它做了正确的事情。

所以下一个基本上是当你想从一个表中删除记录或清除数据时，你可以使用一个简单的 delete 语句。

如果你想删除一个特定的行，类似于更新，你可以使用一个 where 子句来缩小你想要删除的数据，这个特定的语句是从一个表名中删除，然后 where 列名等于或列值。

这里可以有多个过滤器。

这里我没有第三行，我想我已经把它删除了。

好的，让我们继续看产品三表，我只是想向你们展示它比我的另一个表包含了更多的数据。

您可以看到它包含大约 5849 行的数据，我还想向您展示这个特定的参数 MySQL 配置参数，基本上可以启用和禁用安全更新。

比方说，如果您的 delete 语句或 UPDATE 语句没有在 where 子句中使用主键列，那么基本上，如果您启用了这个特定的参数，比方说通过设置这个参数，然后如果您运行您的 delete 语句，您将会得到一个错误代码 1175，它表示您正在使用安全更新模式，等等。

它不会引导您运行这种添加删除语句，因为这可能是导致性能下降的一个好原因。

所以如果我禁用同样的东西，然后运行 Delete 语句，然后再次运行 select 语句，那么应该会成功，因为现在参数被禁用了。

还有两件事。

实际上，如果您有一个巨大的表，并且您想一次只删除几行，那么您可以使用 limit 关键字来限制语句删除的记录数，您知道，在这种情况下，因为我只想删除 10 行，所以让我们继续这样做。

它应该工作得很好。

然后，如果我进行选择，您会看到行数的差异。实际上，现在是 5839，在它被激发四个晚上之前。

这就是 LIMIT 子句如何帮助你的，在 limit floors 中，你也可以指定 ORDER BY 子句。

它基本上按这些列对数据进行排序，首先按数量，然后按产品 ID，然后它删除最上面的和或 100 或实际上你放在这里的任何值。

因此，让我们继续操作，然后再次选择。

是的，卡尼，七个 D 不见了。

所以前 10 排都没了。

是的，差不多就是这样。

实际上，这些都是 update 和 delete 语句的一些变体。

当然，我们可以进入很多话题，但我会把这个任务留给你。

我希望它是有用的。

如果你有任何问题，请在评论中告诉我。

下节课再见。

MySQL 学习者。

因此，在本节课中，我们将了解 SELECT 语句，不仅仅是语法，还包括一些实际上可以提高查询性能的方法，我将使用名为 income store 的模式来解释这个 SELECT 语句，其最简单的形式如下所示。

所以您有 Select 和 from 关键字，然后在 Select 之后，您指定选择列表，这是您想要选择的列。

如果您指定一个星号或 asterik，实际上是从该表中选择所有列，然后在 from 关键字之后，指定要从中选择数据的表名。

因此，如果我从产品下划线 3 中选择星号，它将返回产品下划线 3 表中的所有数据。

但是请记住，无论何时在 Select 之后或者在 Select 列表中使用星号，您基本上都是在查询表中的所有列，在大多数情况下，您不需要查询表中的所有列，所以您只需要指定需要查询的列。

因此，在下一个查询中，让我们一行一行地查看对该查询做了哪些更改以使其更好。

假设我只想选择这些列。

这就是为什么我在选择列表中只指定了这些列。

在 from 子句中，我指定了 products 下划线三个表。您经常会从多个表中进行选择，您需要连接这些表，然后从中检索有用的数据。

在 where 子句中，您可以指定所有的过滤器，或者筛选出数据所基于的条件。

所以我在这里，只包括数量少于 25 的数据。

这样，我就可以过滤掉这个表中的大部分数据，这对于减少从数据库中检索的数据量非常有用。

您的查询将会很快，因为 ordered by 基本上会根据我们在此指定的列对检索到的数据进行排序。

所以在这里，我就像按产品名称排序一样。

当然，当你排序数据的时候，特别是当你排序大量数据的时候，这个操作会很昂贵，除非你的源缓冲区大小，也就是槽所在的内存区域。

除非大小合适，否则操作可能会非常慢。

所以你也需要注意那个配置。

我还有另一个查询，它只是向你们展示，这是一个非常简单的 SELECT 语句。

同样，在这个 select 中，实际上，我只有 Select 关键字和一个函数，我使用的是 now 函数。

但是您可以在脚本中使用其他几个 SQL 函数，例如，我可以使用 database 函数返回我实际连接到的数据库。

如您所见，我实际上能够在同一个查询中调用多个函数。

差不多就是这样了。

下节课再见。

在本节课中，我将讲授 SQL joints，让我们直接进入演示，我将使用一个名为 eecom store 的模式。

我先创建一个表，名为 T one，有一列，列名是 C one，我把这两个值插入到这个表中。

第一个和第二个，我创建了另一个名为 T ^ 2 的表，它有一个名为 C ^ 1 的列，我再次将这两个值插入到表 D ^ 2，1 和 3 中。

这里是 1 和 2，这里是 1 和 3，我们将继续运行 commit，使我的更改永久生效。

我会创建这两个表，给你们看记录，D 1 有 1 和 2，D 2 是 1 和 3。

当然，连接是连接两个表的操作。

我们有所有这些不同类型的关节，我们将逐一了解它们是什么。

这是语法，所以选择你要选择的 a 列列表。

所以我们加入了 t1 和 T2。

然后，我们指定要进行的联接类型。

然后我们还有这个 on 关键字。

然后是连接表的条件。

所以我将继续运行这个查询，看看会发生什么。

如您所见，这个查询，这个内部连接已经返回值 1，所以这意味着实际上，它返回存在于两个匹配的表中的值。

这就是内连接的作用。

所以让我们把它改成一个左连接，然后运行它。

现在左连接将把你左边的所有值返回给表 t1。

所以 T 1 有值 1 和 2 是行 1 和行 2，然后 T 2，它将只返回匹配的值。

然后对于这个值，它只存在于表 T 1 中，它会返回，然后我会把它改成右连接，你可能已经猜到了，它会返回从表 T 到没有匹配值的地方，它会返回一个空值。

让我们看看这是否会发生。

这正是我们所期望的。

所以我们从 T ^ 2 得到所有的行，然后对于 T ^ 3，没有匹配的值，T ^ 1，你知道，那个位置没有值。

现在我们将快速跳转到一个联盟。

然后我们会回到完全联接，一个联合基本上会是这样的。

所以两个查询，然后在中间，我们有 union 关键字，让我们看看它返回什么，你可以看到它被写成一，二，三。

这实际上是两个表中的行，但这有点像是将数据组合在一起，然后将它们粉碎。

然后你有一个，两个，三个，然后让我们运行相同的查询，略有不同。

我们会把联盟放在首位，然后看看会发生什么。

已经写了一，二，一，三。

这就返回了两个表中的所有数据，但除了这次，我们有重复的值，Union 去掉了所有重复的值，这几乎就像一个集合，其中有一个唯一的数据集，union all 返回所有的值，包括重复的数据。

跳回到完全连接，我们没有一个完全连接关键字。

所以，在我的续集中，我们会以这种方式完全加入。

基本上，你有一个类似的查询，其中你连接 t1 和 T2，首先是一个左连接，有一列，然后你有另一个查询，再次连接 t1 和 T2，只有一列，但然后我们做这两个的联合，这将返回两个表的数据，我们有一个，两个，这两个匹配，然后对于两个，没有匹配值。

所以它返回，现在对于三个，在 t1 中没有匹配的值，它在这里返回一个空值。

这是一个完整的连接，基本上是所有的连接，你可以在 MySQL 中使用的所有不同类型的连接，我希望这个例子很清楚。

下次治疗时再见。

好了，我的 SQL 学习者们。

在本节中，我们将学习锁。

更具体地说，我想谈谈隔离级别部分。

所以第一件事就是看看我这里有什么，我有两个终端会话。

一件是黑色的。

另一个是浅栗色的。

因此，我将作为 root 用户登录数据库。

我会在这里做同样的事情。

给你。

我登录到我的 SQL 数据库。

这里我有一个小脚本来创建一个名为 T one 的虚拟表。

好的，让我给你看一下 SQL 脚本。

实际上，在这一点上，你可能不理解 SQL 语法等等。

但是让我解释一下。

简而言之，我要做的第一件事是将自动提交设置为零，或者说提交基本上是一个用来保存工作的命令。

基本上，您所做的数据更改会永久存储在数据库中。

当你发出一个 commit 命令时，在我的 sequel 中，你有一个名为 auto commit 的变量，它在默认情况下是打开的，这意味着你所有的命令都会被自动提交。

如果你不关掉它，我想对我在这里做的事情有更多的控制权。

基本上，我是在执行自动提交，先禁用，然后启动一个事务。

为了安全起见，如果我已经创建了这个表，我将删除它。

所以这张桌子不存在。

所以它说未知表。

接下来，我将在 eecom store schema 中创建一个名为 T one 的表。

然后列名是 C one。

数据类型是 int 和它的主键。

然后我实际上是在插入值，就在这个叫做 P1 的表中插入一行，对，就是我们刚刚创建的那个。

我发出一个 commit 命令，alter 或者 commit 的替代命令是 rollback 命令。

因此，这基本上是回退奖励您刚才在该会话中所做的更改。

如果我从稳定的恒星中选择一颗恒星，我会看到这个值，到目前为止还不错。

所以这很简单。

到目前为止，我们还没有谈到隔离级别。

因此，我所说的隔离级别是指，当多个会话试图修改或访问相同的数据数据时，您需要锁定机制来确保数据没有损坏，或者数据库的行为方式符合您的预期，以了解您实际上是如何设置隔离级别的。

这是命令。

这是我打开的另一个会话，展示了会话变量，比如隔离。

这表明事务隔离级别设置为已提交读取。

没错。

所以这是可能的选择之一。

这是提交读取，还有未提交读取，以及重复读取或可重复读取。

实际上，还有一个可序列化的值，让我们一个一个来。

在这个会话中，我已经启动了一个事务。

因此，我将尝试使用 update 命令来更新这个值。

所以基本上，我在更新同一个表，我在更新这个列，它的列值现在是 1。

因此，我将关闭自动提交。

所以这里还没有提交开始一个事务。

让我对同一个表进行查询，复制并粘贴表名，输入它，我们看到值 1，这是前一个值。

如果我在这里运行相同的查询，在这个会话中，我会看到值 2，因为这是我们修改数据的会话，对吗？因此，我可以在这里的同一个会话中提交之前看到更改。

实际上，由于该事务隔离的值或隔离级别被设置为 read committed，因此只能读取提交的数据。

换句话说，当多个会话访问相同的数据时，在这种情况下，该表中的这一列，除了实际修改数据的会话之外，其他会话只能看到提交的数据，即在执行 select 之前提交的任何数据。

我将在这里运行一次提交，然后回到这里运行一次选择。

现在您可以看到最新的数据，因为提交发生在我运行这个查询之前。

现在让我们谈谈未提交读隔离，设置实际上是重新登录，因为这些事情会变得棘手。

所以每次我想重建表格来消除混乱。

让我们再次登录，好的，在这里，我将执行之前向您展示的相同脚本。

所以只需禁用 auto 命令，启动一个事务，删除 stable 并重新创建它，插入这个值，然后运行命令。

现在，我们可以做的是，继续将这个值更新为 2。

但是记住，我还没有提交这个数据。

我们去参加这个会议吧。

在这里，继续将隔离设置更改为 read uncommitted，因为默认情况下，它总是设置为 read committed action。

没错。

所以你可以在这里看到。

这是一个会话级别的设置。

你也可以在全球范围内改变它。

但是对于本演示来说，我们只需要在会话级别对其进行更改。

所以会话级隔离最初读提交，然后我运行 set 会话事务，隔离级别，读未提交，然后再次检查值。

现在它变成了 read uncommitted，如果我从这个表中运行一个 select star，那么我得到的值是 2，如果你还记得，我只把值从 1 更新为 2。

你已经可以看到这个测试版了，尽管它没有在这里提交。

这就是 read uncommitted 的工作方式。

所以这里没有太多的锁定。

因为数据库现在允许会话进行脏读，因为一个会话能够读取，而其他会话甚至在提交实际发生之前就发生了更改。

所以这些都是肮脏的阅读。

是的，实际上。

所以让我们继续下一个。

到目前为止，我们已经看到了读取、提交和读取提交。

现在，让我们继续讨论可重复读取操作。

对吗？所以退出吧。

所以在这里我要提交。

我要重新运行我的初始脚本来清空表格。

所以删除 table，然后重新创建 insert，再次赋值 1，然后提交。

所以现在，桌子又回到了原来的样子。

所以在这里，让我再次登录。

这是可重复读取设置，对吗？所以请记住，这个隔离设置的默认值总是 read committed。

因此，如果我将其更改为可重复读取、写入，然后再次检查值，那么您可以看到这一点。

请记住，或 show variables 是检查当前值的命令。

然后 set 是正确设置配置的命令，所以我会将所有这些命令放在 git GitHub repo 文件中，然后您可以从那里获取命令，然后您可以自己尝试。

基本上，我要将设置从提交读取更改为可重复读取，所以我要在这里开始一个新的事务，我要将这个值更新为 2。

在这里，我将运行我们之前看到的选择查询，从该表中选择所有内容。

你会看到这个值现在是 1。

这很有道理。

让我继续运行 commit。

如果我运行同样的查询，我会看到值 1。

这与之前读取的值相同，即使数据被另一个会话更改。

然后在此事务中提交，我们看到的数据在其他方面是相同的，基本上，我们正在读取相同的数据，或者说读取正在重复。

没错。

这是第三个场景。

最后一个是最严格的锁定配置。

所以哪个叫做可序列化。

所以我要像往常一样，删除这个表，然后重新创建它们重新创建，再次插入值 1，它们可能会进来。

在这里，我们将再次登录。

和往常一样，默认设置是 read committed，对吗？让我们先检查一下，只是为了向您展示一下，然后我将把它更改为串行可序列化。

这意味着，基本上，我要开始一个交易。

因此，在第一个会话中，我将运行一个更新，基本上将值从 1 更改为 2。

在这里，我将启动一个事务，并在那个表上运行一个查询。

没错。

现在这个查询，即使它只是一个选择，选择只是一个读取，它没有更新，它没有删除或做任何事情，它只是一个读取，它在等待，因为更新基本上是更新这些数据。

然后，它不是数据库，MySQL 数据库，甚至不允许从其他会话读取或选择查询来查看数据。

所以这是最严格的设定动作。

因此，如果我在这里提交，那么在另一个会话中，您会看到 Gradius 返回，并看到最新的值。

所以如果我继续运行另一个 select，当然，它会返回同样的结果。

但是，如果我尝试将该值从 2 更新为 3，另一次更新基本上会等待 Select，基本上现在正在运行的事务是因为 Select 再次选择只是一次读取，它只是读取数据。

但它仍然锁定数据库中的那一行，不允许对该数据进行任何更新或修改。

然后，您可以看到更新甚至失败了，因为它等待了一段时间，然后超时值超过，所以我们不必进入这些细节。

但是我现在要试着更新一下。

还有这里。

我将退出此会话，这将释放所有锁。

这将有助于更新通过。

然后我也可以提交和退出，你们应该清楚了。

如果你有任何问题，请写在评论里，然后联系我，我知道你能想出来，因为你们是下一部分。

嘿，MySQL 的学习者们。

所以欢迎回到我的 MySQL 教程的这个新部分。

所以在这个视频中，或者在这个部分，我们将讨论锁。

这些锁是什么？对吗？所以让我们从逻辑上来看这个问题。

因此，如果你有一个数据库，如果你是这个数据库中唯一的工作人员，那么你基本上不需要担心任何事情，对不对？你知道你在做什么。

因此，您可以按照自己的方式插入、删除或更新数据。

没有其他人试图干涉或打断你的工作。

但遗憾的是，事实并非如此。

在当今世界。

如果你想到一个像亚马逊这样繁忙的电子商务数据库，那么这些网站上有很多正在进行的事情。

就像很多人在浏览一样，很多人在买东西。

有人在这些网站上卖东西，他们更新与他们的产品相关的数据。

这基本上就是并发，对吗？所以你有许多用户试图同时在这个网站上做一些事情，那么你如何管理这种并发性，这就是为什么我们需要锁。

因此，如果我让每个人同时处理相同的数据，那么将会有很多混乱。

我们可能会丢失一些数据。

让我给你们看一个简单的例子来说明这是如何发生的。

所以我有一个表，一个产品表。

因此，如果你一直在关注我的教程，那么到目前为止，我们已经讨论了这个叫做 products 的表。

所以我们存储所有产品信息的地方。

现在，这里有一些记录。

假设我们有一个卖家和一个买家，他们正在处理这些记录，特别是像这个特殊的记录，第一个，这是一本书，书，奖品，这个和数量，在我前面的章节中我们谈到它时没有数量。

但是我在这里增加了数量。

这是数量栏。

有一个卖家和一个买家对这个记录感兴趣，让我们看看这个，对，我们这里有一个时间顺序。

因此，这个特定产品的卖家正在试图做的是，他试图将这个产品的数量更新为 91，他将这个产品的数量增加 60，也就是 40 加 60，也就是 100。

这就是我们在这里看到的。

然后一个买家来了，他看了看数量。

然后他基本上想订购两本或这些书，那是 100 减 90 100 减 2，是 98，然后你在这里有数量 98。

所以这是按顺序发生的。

但是我们担心并发性，对吗？并发就像事情同时发生一样。

但是如果好的话，首先卖家来了，然后他读这个项目的数量。

最初是 40 件，然后买家来了，他也看到数量是 40 件。

对吗？并且在 901。

所以前两个操作在九点同时发生，或者一个卖家进来，他说我想更新，我想增加 60 本书的数量，意思是我还有 60 本这种书名的书，但是然后买家来了，他说好的，我想买两本书。

他之前看到的你是 40 岁。

所以 40 减 2 等于 38。

所以他更新了数量 38。

所以卖家在 200 更新。

但是，由于之前的查找，数量更新为 38。

因此整个事情，整个行动都失败了。

对于这个数量列，我们最终得到的是一种类似损坏的数据。

因此，这是一个简单的例子，说明如果管理不善，并发性可能会导致这样的数据问题。

MySQL 学习者。

所以在这个视频中，我们将从根本上了解表锁是如何工作的。

在电子商务数据库的上下文中，我们创建了一个简单的数据库或模式，称为列存储。

我们创建了一堆表或使用另一个虚拟表来解释我们的事务隔离级别。

所以如果你没看过我之前的材料，回去看看吧。

然后回到这里。

但是，是的，你有四个主桌。

我们感兴趣的主表是 products 表。

在 products 表中，我插入了几条记录。

这些是假记录。

所以我没有前端或应用程序在这里运行。

所以我们只是在看数据库，对吧。

所以在本教程中将要发生的是，所以我们，我们将基本上模拟一种情况，一个卖家试图更新他在这个网站上出售的书的数量，这实际上是第一本书，不平凡的成功的共同道路。

然后现在这个数量是可用的数量。

你知道，这本书是 40，对不对？所以他想更新这个数量 200。

还有，我们会有更多的用户或买家，基本上一个买家想买同一本书，我们会有另一个买家 Hill，他想买一本不同的书，就是这本书，微小的习惯，然后同一个买家也会尝试浏览网站，就像当然，就像，我们将不得不想象一点点，因为我没有一个前端向你展示一切。

让我们来看看这是怎么回事。

首先，你知道一些基本知识，实际上，让我们关闭自动提交。

事实上，我们对正在发生的事情有更多的控制。

让我在我开的三个会议中都这样做，第一个会议是卖方会议。

第二次会议是买方会议。

基本上，第三次会议是买方会议。

因此，我将关闭自动提交，这基本上是一种启用时自动提交的机制。

我不想那样。

所以我要关闭它。

接下来，我想向大家展示事务隔离级别。

我们在之前的会议中讨论过这个问题。

所以现在它是一个可重复的读数。

对所有人都一样。

因此，我们将把它更改为“已提交读”,因为“已提交读”隔离是 OLTP 数据库的正确隔离级别。

现在让我们从第一次销售会议开始。

所以三个疗程。

因此，第一个销售会话将更新他感兴趣的这本书的数量或他的销售行为。

但是我们将采用这种激进的方法来记录整个表。

没错。

假设应用程序以一种正确的方式返回，它记录整个产品。

然后在另一个会话中，比如说在第二个会话中，买家 1 来了，他想买两本书，我们实际上是通过运行更新来完成的。

因此，我们基本上是在更新产品表，我们将数量减去两个，这意味着我们实际上购买了两本书。

还有书里面是哪本书？产品 ID 等于 1 的记录在哪里，对吗？因此，如果您记得数据，产品 ID 是这本书，让我们继续在第二个会话中运行此更新。

很明显，它将等待，因为表本身已被卖方会话锁定，买方会话正在等待。

让我们去找买家，让他去澳大利亚，试着买一本不同的书，是哪本书，另一本，是一本产品 ID 等于 2 的小习惯书。

我们会做到的。

当然，即使那样也是挂着或者等着。

这实际上有点疯狂，不是吗？

所以只是卖家试图用一本书来更新这一记录的数量。

一切都糟透了。

买家也想买一本不同的书，但他放弃了。

所以他去了另一个地方。

而不是购买或试图购买一本书，他只是试图浏览网站，这是一个选择查询或阅读查询，阅读选择查询，这也是挂。

所以买家现在也很沮丧。

所以你可以看到这种序列是多么受限制。

因此，如果有人使用表日志，这将从根本上减少数据库中可能发生的操作的并发性。

这就是这个演示的要点。

嘿，我的续集学习者。

因此，在本节课中，我们将简要了解一下行级锁。

在我的续作中，我有三个会话，我已经连接到我的电子商务数据库，MySQL 数据库，这是数据现在的样子。

因此，我们有一个产品表，其中包含您知道的数据，现在只有两本书，只是我创建的虚拟数据。这是价格，数量列显示每本书的剩余数量。

所以第一次会议是卖方会议。

第二个环节是买家环节，我们可以称这个买家为一个环节。

第三阶段是买方对买方的阶段。

这是数据。

为了清楚起见，实际上，我想向您展示事务隔离设置，即读提交。

自动提交被关闭，基本上是禁用的。

因此，除非我显式提交，否则我的事务不会是永久的。

让我们从卖家开始。

他会在网站或门户网站上更新库存，比如说书籍、信息技术或产品，也就是这本书。

因此，他将单击一些按钮，这将转化为在此数据库中执行的更新语句，对吗？假设他想增加库存中的图书数量。

这意味着数量将增加 50。

这就是 UPDATE 语句。

他将运行更新。

我们可以在一个会话中查看买家，假设买家一试图购买同一本书。

然后，他会在网站上点击“立即购买”或其他，然后会在数据库中翻译成这条更新语句，选择数量等于数量减一。

所以数量减少一，意味着他买了一本书。

当然，还会有其他语句更新其他表。

但是为了简单起见，我只向您展示产品表更改部分。

如您所见，这需要等待，因为 seller 正在更新这个特定的 row 操作。

使用 acquittee 可以看到这一点。

因此，如果您在这种情况下，当然，您可以根据自己的需要修改这个查询。

但是，如果您查询这个，您会看到有许多会话，并且是锁定模式列。

然后是发生锁的数据库所在的表，这个表提供了很多细节。

所以如果你想了解这里发生了什么？

因此，我们有 products 表，然后我们有 ix 锁，这是表本身的专用锁，意味着一个事务将要获得一个专用锁。

这是在牌桌级别，但不要被它骗了。

还有另一行表示有记录级或行级锁。

那就是只记录等于 1 的数据。

因此，如果您还记得 UPDATE 语句，我们将使用产品 ID。

所以数据实际上是 1，所以产品 ID 等于 1。

这就是我们在这里看到的。

如果您看到这里，这个买家会话实际上已经超时，因此他将再次尝试购买。

这就是为什么，你可以在这个表中看到锁的细节。

让我们试试，比如说买家二在这个时候进来。

然后他试图浏览这个电子商务网站上的库存。

这意味着选择查询或读取查询。

他能够做出这种快乐的反应。

没错。

所以没有问题。

因此，在推出的同时，其他会话可以读取该表，他们甚至可以查看同一产品的数据。

但是他们不能买这本书，因为它被卖家屏蔽了。

所以又一次超时了。

因此，在这一点上，买家 2 想购买不同的书，你知道，我不能购买这本书，让我尝试购买不同的书，这将转换为，你知道，产品 ID ID 等于 2，这不是由卖方锁定。

然后更新通过。

此时，假设卖家已经完成了库存更新。

当然，如果你看看数据，现在，它会看起来不一样，因为这已经更新到 150。

当然，这并没有发生，因为购买者，购买者，仍然在购买这本书的过程中，因为提交还没有在应用程序中发生。

如果我们再看一下数据，数据还是下降了，或者数量下降了，那么通过 two，假设想买买家 1 想买的第一本书。

此时，该表中没有锁。

因为每个人都承诺了，比如说买家，他想买这本书，然后他完成了日期，然后承诺并查看数据。

然后数据实际上在变化。

这就是行级日志允许高并发性的基本方式。

因此，只有事务记录的行不能被其他会话修改。

没错，所以你的交易没有涉及到的其他记录可以更新、删除等。

当然，您可以添加新书，这意味着在该表中插入新记录。

所以我只想向您展示表级日志和行级锁之间的区别。

因此，本次会议和我之前的会议将有助于理解这种差异。

谢谢，下次治疗时再见。

在这节课中，我们将讨论死锁。

我只想告诉你死锁是如何发生的，它们确实发生在繁忙的电子商务或 b。

数据库，所以知道它们是什么是很好的。

因此，这将是一个非常短暂和甜蜜的会议。

这里，我们又有两个会话，因此连接一个连接到同一数据库的有两个会话，两个不同的会话。

假设我们正在处理产品表，对吧。

在我之前的治疗中，我们已经看到了马厩。

基本上，这个表格包含了在电子商务网站上销售的产品的信息。

我们这里有几条记录，你知道，我们要先假设，你知道，如果卖家来更新这个产品的数量，基本上，假设他想增加 25 的数量。

对于这第一本书，这是他的命令，你知道，这将被执行，你知道，无论他点击什么按钮，都将被翻译成这样的更新命令。

没错。

比方说，来自同一家公司的不同的人想要更新这本书的价格，而不是这本书的价格，假设我们有另一本书，我实际上只是使用产品 ID 来更新正确的产品。

因此，我们有一个销售会话，一个是更新此项目的数量，我们有另一个会话，我们正在更新此项目的价格。

然后，如果你看到价格增加了 2，比如说 2 美元。

这很好，对吗？所以现在我们有了行级锁。

这家伙在这一行持有一个行级锁。

这个家伙在这一行上持有一个行级锁。

所以这很好，对吗？所以我们对两个不同的记录进行操作，两个不同的锁是相互独立的。

一切都好。

现在我们假设同一个卖家，第二个更新价格的人，想要更新另一本书的价格，就像他实际上提高了价格一样。

同样，这本书的 2 美元，产品 ID 等于 1，哪本书，这本书，让我们继续尝试增加价格。

通过运行这个命令，你知道，他在等待锁 ECI 独占锁。

这是不可能的，因为这个卖家没有承诺实际上没有承诺。

让我们回到这里，这个卖家在同一时间更新这本书的价格或数量。

所以两个会话都在争夺几乎相同的资源，你知道，我们最终陷入了僵局。

所以我的续集是聪明的，聪明到足以杀死会话。

否则，我们将会有两次会议无休止地相互等待。

对吗？在这里，您可以看到抛出的错误代码，它表示在尝试获取锁并尝试重新启动该事务时发现死锁。

因此，让我们继续查询 products 表，看看它是什么样子。

您可以看到，整个事务被回滚了。

正确。

两个事务都被回滚。

甚至这个都被回滚了。

所以我认为 Locke 也被杀了。

这就是为什么这一个通过了。

如果你能看到价格增加了 2 美元。

因为最初是 1699 年和 2039 年，这里是 8099 年和 20 到 39 年。

好吧，这就是它的工作原理。

这是一个典型的死锁情况，我希望这个解释是清楚的。

下次治疗时再见。

好吧，我的续集学习者们。

所以在这节课中，我们将讨论聚集索引。

聚集索引并不是一种不同的索引类型，你可以自己直接创建聚集索引。

所以这是一种索引，MySQL 实际上是在幕后维护的。

因此，在表数据中，插入到表中或装载到表中的数据也在这些索引中维护。

我的意思是，假设这是一个 B 树索引，对，这是一个 B 树索引。

所以你有我的续集，创建这个 B 树索引，当你加载数据到这些表中。

然后，你知道，在叶节点中，你拥有的实际上是数据，你加载到这些表中的数据，对吗？在聚类中，排序是基于你定义的主键，或者，你知道，在这个表中，实际上，如果你没有定义主键，MySQL 会自动选择一个不可空的索引键，这意味着，让我们说，实际上，实际上，让我们直接进入我为你们准备的例子。

这是我的 MySQL 工作台。

你知道，我会给你看这个表的定义。

所以这叫做产品强调一。

它基本上是一个产品表，通常用于电子商务商店。

如果你一直在听我的课，这就是我一直在用的，我只是改变了表的名称，来演示这个概念，这个聚集，聚集索引的概念。

你有所有这些列，我定义一个主键。

好的，让我们开始，你知道，我将切换到一个名为 eecom 的数据库，存储我们名为 econ store 的模式，我将删除这些表，如果它们已经存在的话。

所以这个表是不存在的，这没关系，所以我要创建这个表，我刚刚讲过，叫做 products。

然后这个表有一个主键，主键是产品 ID。

所以产品 ID 有点像一个整数列。

这是一个自动增量，对吗？所以你甚至不需要为这个列提供值，实际上，当你加载数据时，你可以把所有的信息都放进去，然后我们就好了，MySQL 会自动增加这个列动作的值。

当然，就像我说的，有 isbm 专栏，在这里，有点像 iasb 的腿书。

如果你，你知道，如果你像这样记得你的学生时代，这是一个附在任何书上的数字，就像这样。

所以某种 ISDN 字母数字号码。

所以我称之为唯一键或唯一约束。

让我们继续创建稳定和约束。

这样就成功地创建了。

我将创建一个过程，我可以用它来填充 stable，所以不用担心这个过程的细节。

这是我写的用来填充这个表的东西。

然后成功创建，并将分隔符改回分号。

然后我要调用这个过程，它会抛出一些警告，这对我来说没问题。

只要数据被填充，我就没事。

所以它可能会生成一些，你知道，加载大约 6000 多行到这个表中。

所以我们会看到我们有多棒。

所以它实际上加载了大量数据。

似乎已经完成了。

让我们继续提交数据，现在实际上，我将选择该表中的数据，对吗？只要选择所有的数据，你就会看到默认的数据，或者数据实际上是根据主键排序的，主键就是产品 ID。

你可以看到，我们知道，我还没有指定任何顺序。

所以这是，你知道，这是数据的默认排序。

所以基本上，你的表数据是基于你的聚集索引排序的，聚集索引是主键，因为你在表部分有主键。

没错。

现在，下一件事实际上是，我将创建一个类似的表，你知道，所以我也将它称为产品。

但是在这种情况下，我基本上不会定义一个主键，我仍然会有一个唯一键，同样的事情，你知道，它是 isbm，它是一个唯一键。

让我们给它取一个不同的名字，就像，我们对不同的约束有不同的名字。

让我们实际上继续创建这个表。

创建了这个表后，我将从第一个表中复制数据，您知道，我在第一个表中加载了大量数据。

所以我要把那个表的数据复制到这个表，对。

所以很简单。

然后我要提交，对，所以这个表中插入了 6455 6455 行。

我将从这个表中选择所有的行。

您可以看到，现在数据不是按产品 Id 排序，而是按 iasb 排序。

它首先基于第一个字符排序，然后最初，第一个和第二个字符是相同的，然后 010 为真。

接着是 05，然后是 090，通用电气对冲的 BCD，然后是 0，你知道，看到 1，所以它基本上是基于 iasb 对数据进行排序。

为什么呢，因为没有主键，它会选择这个 iasb 和列，它会选择这个不可空的唯一索引键，它是基于 iasb 和列的。

所以它是基于这一点开始的，但这实际上是一个非常非常糟糕的想法。

因为如果你为 iasb 生成随机的字母数字字符串。

然后，你知道，你不会按照升序或者任何顺序来生成字符串。

所以在那种情况下，实际上，你知道，当你，当你把数据插入到表中时，B 树将会在幕后创建。

然后我的续集，就像任何在幕后创建或维护这个数据结构的程序一样，必须非常非常努力地管理这个 Bre B 树索引，实际上，对。

这就是为什么把你的 UID 或者某种字母数字串作为主键，或者在没有主键的情况下，这是一个可怕的想法。

我的续集将使用这个键进行聚类。

再说一次，这是非常糟糕的。

所以在实际创建表格时，请记住这一点。

没错。

最后，我要做的是创建另一个名为“产品三”的表。

在此之前，我将向您展示这个查询的输出，它基本上是空的，或者没有，没有，没有返回 road 行。

我所做的就是检查这个索引，名为 Jen flushed index 的索引，是否在这个数据库中。

然后我检查 InnoDB 表和我在 oDB 表和 odb 索引中加入的信息模式。

我在检查这个索引是否确实存在，对吗？假设它不存在，这就是这个，这个信用，不返回任何行，我将创建这个表，这次，我甚至不创建创建唯一键。

我要把所有这些列都设为可空列。

我只是想向大家展示一下，当你创建一个表，其中所有列都可以为空，没有主键索引，没有唯一的、不可为空的索引，然后你知道我要向这个表中插入数据时，会发生什么。

第六次，插入 400 多行，提交。

现在，我将从该产品的三个表格中进行选择。

当数据出现时，你可以看到仍有一些排序在发生。

而且，你知道，我们没有这些选项中的任何一个主键或不可空的唯一键，那么 MySQL 是如何对数据进行排序的呢？它使用的是什么，所以它实际上使用了一个隐藏的，隐藏的键，实际上，对，一个隐藏的主键。

因此，如果您再次运行相同的查询，准备好了，您可以看到这个索引已经在 products three 表上创建，它由我的 SQL 在内部维护，实际上只是为了聚集这个表。

好的，这是很多信息。

我希望你觉得这很有用。

我会在下一个视频中看到你们。

大家好，我的 SQL 学习者们。

所以在这节课中，我想教你在 MySQL 中使用 explain 或 explained plan 的基础知识。

好的，现在让我向大家展示一下我将要使用的表格，我将使用名为 products underscore one 的表格。

它在产品名称、产品类型和价格上有所体现。

如果产品是一本书，它会有一个 ISP 编号。

然后还有一个数量栏。

这些是你在电子商务网上商店会看到的一些基本栏目。

因此，让我们从查看该表的索引开始。

所以这基本上有两个指标。

一个是主键索引，在产品 ID 上。

另一个是 iasb 和专栏的索引。

实际上，这是一个独特的指数。

因此，让我们从选择一个简单的查询开始，我们将使用 explain 对其进行优化。

所以我要用的查询是这样的。

所以我会选择 iasb。

从这个产品下划线一个表，其中产品名称有猫。

所以产品名字叫猫。

好的，在我运行这个查询之前，我要看一下它的解释计划。

我会在末尾加一个斜杠 g。

所以我认为我们应该以一种可读的格式放进去。

首先，它给出了这个输出，对，还有选择器，只有一条直线，简单的选择。

这就是它所展示的。

但最重要的是，我们正在处理，这一行指的是这个表。

除此之外，实际上，你有所有这些列，然后它们现在都是空的，好像除此之外它们没有什么意义。

所以这是一个紧列，这意味着它正在进行全表扫描。

基本上，MySQL 正在进行全表扫描，它正在扫描整个表。

有多少行是这么多行。

我们在这里使用一个过滤器，它获取所有这些行，然后过滤输出。

基本上，你知道，大约有 600 行的产品名称等于 cat，对吧，所以被过滤的人的年龄基本上是 10%，然后还有一些额外的信息。

让我们继续在这个表上创建一个索引。

创建索引叫做，你知道，我们可以给一个任意的名字。

当然，我将创建一个附加产品，一个表和一列是产品名称。

这是我正在创建索引的列。

实际上，让我们继续再解释一遍。

这就是解释过的计划。

看起来就是这样。

因此，基本上，您可以再次看到，这是几乎相同类型的输出，但这一次，它还显示了所有这些列的一些数据。

首先，所有可能的键列显示了该查询可以使用的所有索引。

其中，像这样的是键或索引，你知道，它将会使用这个特定的执行，这是键的长度，以字节为单位，实际上写的是在这个键中被扫描的行数，是 589。

而且，你知道，因为这是基于索引的，我们并不真的过滤数据，相反，我们只是去索引和获取数据。

所以那边没有过滤。

让我们实际上创建另一个指数，它也包括 iasb。

看看会发生什么，实际上，我们要创建另一个索引，并给它一个不同的名字。

因此，让我们继续运行解释计划。

所以现在，同样，可能的键是这两个索引，但它仍然选择这个特定的索引，索引，键长度是相同的，然后增长，等等，等等。

所以没有过滤发生，对不对？因为我们在选择一个指数。

所以你可能会想，比如，你知道，为什么不用覆盖指数，对吧。

因此，这应该是覆盖索引，覆盖索引应该比普通的非聚集索引或二级索引更好。

所以你可以使用 JSON 格式来获取更多信息。

你可以通过指定 like format equals JSON，并使用。

这将给你 JSON 格式的输出。

你可以看到，它给了你更多的信息，比如查询成本，你知道，这是我的 sequel 执行这个查询的成本。

这是 MySQL 实际运行这个查询所要做的工作量的表示。

所以这个的成本是 7690，对吧。

又一次，它说这些是可能的密钥。

用过的密钥是用过的密钥部分是产品名称，这里没有给出。

然后是成本，这是成本去向的划分。

因此，您可以阅读我关于所有这些字段的 SQL 文档。

你可能想知道为什么没有使用覆盖指数。

我们实际上可以通过使用这个使用索引来强制使用那个索引。

语法或使用 index 关键字。

然后我会把我想要强制的索引名，也就是这个。

当我运行它时，它运行了这次解释的计划，它显示这个计划的成本将是 109.27，与之前的解释计划相比，成本仅为 76。

这就是为什么我的续集会采用这个特别的计划而不是这个人。

好吧，我希望这次谈话有用。