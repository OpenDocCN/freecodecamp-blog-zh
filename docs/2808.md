# 如何理解 JavaScript 中的递归

> 原文：<https://www.freecodecamp.org/news/understanding-recursion-in-javascript/>

> “要理解递归，必须先理解递归”——未知

如果你像我一样，那么当你第一次读到递归时，你可能不理解它。

对我来说，这是因为

1.  递归本身是一个很难理解的概念，而且
2.  我看的一些教程和文章不是超级清楚。

出于某种原因，大多数解释递归的文章都使用了阶乘数和斐波那契数列的例子。这意味着我必须理解斐波那契数列是如何工作的，然后把它和递归联系起来。

但是我们在这篇文章中采取了不同的路线。

## 什么是递归？

用最基本的术语来说，递归就是函数不断调用自己，直到它不再需要调用为止。

什么？是的，这个函数一直在调用它自己，但是每次输入都变小了。

把递归想象成一场电路竞赛。这就像一遍又一遍地跑同一条赛道，但圈数每次都变得越来越小。最终，你会跑完最后一圈，也就是最小的一圈，比赛就结束了。

递归也是如此:函数不断用较小的输入调用自己，最终停止。

但是，函数不会自己决定何时停止。我们告诉它什么时候停下来。我们给这个函数一个称为**基本情况**的条件。

基本情况是告诉函数何时停止调用自身的条件。它就像告诉函数比赛的最后一圈是什么，所以它在那一圈之后停止运行。

## 递归的例子

好了，这就是递归。让我们看一些例子来理解递归是如何工作的。

还记得你第一次学习循环吗？你可能做的第一个例子是一个倒计时程序。就这么办吧。

首先，让我们了解我们希望我们的程序做什么。从一个给定的数字开始往下数，一直到最小的数字，每次减 1。

给定数字 5，我们期望输出如下:

```
// 5
// 4
// 3
// 2
// 1 
```

好的，我们如何用递归来编写这个程序呢？

```
let countDown = number => {
    //base case
    if (number === 0) {
        return;
    }
    console.log(number);
    return countDown(number - 1);
};
console.log(countDown(5)) // 5, 4, 3, 2, 1 
```

这到底是怎么回事？

如果你注意到了，我们做的第一件事是定义基本情况。为什么？因为函数首先需要知道何时停止调用自己。

你永远不会在不知道比赛有多长的情况下参加比赛，是吗？

如果你不告诉函数什么时候停止，那么就会发生 stackoverflow。堆栈将被正在被调用的函数填满，但这些函数不会返回或者从堆栈中取出。

它的递归部分实际上发生在第 7 行。在这里，我们告诉函数不断返回自己，但每次减少一个输入。

实际上，这就是正在发生的事情:

```
// The current input is 5
// Is 5 equal to 0 ?
// No, Ok so lets log 5 to the console.
// Its calls Itself again with number - 1 OR 5 - 1;
// The current input is 4
// Is 4 equal to 0 ?
// No, Ok so lets log 4 to the console
// Repeats until input is 0 so then function stops calling itself. 
```

好吧，有道理。让我们试试另一个例子。

你知道我们如何通过使用余数(%)运算符来判断一个数是偶数吗？因此，如果任何数字% 2 == 0，那么这个数字是偶数，如果任何数字% 3 == 0，那么这个数字是奇数。

事实证明还有另一种方法。

如果我们不断地从一个数中减去 2，直到最小的数是 0 或 1，那么我们就能知道这个数是奇数还是偶数。

让我们用递归来试试。因此，给定数字 6，我们的程序应该返回**‘偶数’**，因为 6-2-2-2 = 0。给定 7，我们的程序应该返回**‘奇数’**，因为 7-2-2-2 = 1。

让我们看看它的代码。

```
let oddOrEven = (number) => {
    if (number === 0) {
        return 'Even';
    } else if (number === 1) {
        return 'Odd';
    } else {
        return oddOrEven(number - 2);
    }
};
console.log(oddOrEven(20)) // Even
console.log(oddOrEven(75)) // Odd
console.log(oddOrEven(98)) // Even
console.log(oddOrEven(113)) // Odd 
```

同样，第一步是告诉函数何时停止调用 self。然后我们告诉它当它调用自己时该做什么。

递归基本上是分而治之。我们不断分割问题，每次都把它变小。

## 递归与循环

说到速度，循环比递归函数要快得多。写循环也比写递归函数容易。就可读性而言，了解循环比递归函数更容易。

但是，递归函数非常优雅。

那么最好的选择是什么呢？效率还是速度？

这是《雄辩的 JavaScript》一书中的一段引文。

> 担心效率可能会分散注意力。这是另一个使程序设计变得复杂的因素，当你正在做一件已经很困难的事情时，额外的担心会使你陷入瘫痪。
> 因此，总是从写一些正确易懂的东西开始。
> 如果你担心它太慢——通常不是这样，因为
> 大多数代码执行得不够频繁，不会占用太多时间
> ——你可以事后测量，并在必要时改进它。

在这一点上，你可能想知道为什么你会选择写一个递归函数而不是一个循环。我是说循环要简单得多，对吧？

嗯，这是真的——但是有些问题用递归更容易解决。如果你想探索这样一个问题，那么可以考虑阅读《雄辩的 JavaScript》的第 3 章。

既然你发现了一种新的超能力，那就让它派上点用场吧。

使用递归进行下列练习。如果你觉得你可以承担更多，那么你可以解决著名的阶乘和斐波那契数列问题。

## 练习

如果你想进一步挑战自己，那么考虑解决这些递归问题。

1.  写一个程序，用递归来反转一个字符串。给定字符串“freeCodeCamp”，您的程序应该返回“pmaCedoCeerf”。
2.  写一个程序，返回一个字符在字符串中出现的次数。你的程序应该接收一个字符串和字符。然后它应该返回字符在字符串中出现的次数。给定字符串“JavaScript”和一个字符“a ”,你的程序应该返回 2。

    **提示**:试着弄清楚你希望函数什么时候停止调用自己，以及函数每次调用自己时如何返回一个缩小版的问题。

本文到此为止。希望对你进一步理解递归有所帮助。

*如果你喜欢这篇文章，你可以在[推特](https://twitter.com/joeepm)上联系我。*