# 休息是新的肥皂

> 原文：<https://www.freecodecamp.org/news/rest-is-the-new-soap-97ff6c09896d/>

由 Pascal Chambon 撰写，由 raphal gomès 审核

***更新*** *:本文主要讨论 RESTish 生态系统，它现在构成了 webservices 的主要部分。更多关于原始 REST 和 HATEOAS 的深入分析，请参见我的后续文章[。](https://medium.com/@pakaldebonchamp/follow-up-to-rest-is-the-new-soap-the-origins-of-rest-21c59d243438)*

### 介绍

几年前，我在一家大型电信公司开发了一个新的信息系统。我们不得不与越来越多的 web 服务进行通信，这些服务由旧系统或业务合作伙伴公开。

不用说，我们经历了相当多的肥皂地狱。深奥的[wsdl](https://en.wikipedia.org/wiki/Web_Services_Description_Language)，不兼容的库，奇怪的 bug……所以只要有可能，我们就提倡——并使用——简单的远程过程调用协议:XMLRPC 或 JSONRPC。

我们为这些协议开发的第一批服务器和客户端非常基础、有限、脆弱。但是渐渐地，我们改进了它们；通过几百行附加代码，我们实现了梦想:支持不同的方言(如 Apache 特有的 XMLRPC 扩展)，python 异常和分层错误代码之间的内置转换，功能性和技术性错误的单独处理，后者的自动重试，请求前/后的相关日志记录和统计，输入数据的彻底验证…

现在，我们只需要几行代码，就能够健壮地连接到任何这样的 API。

现在，我们能够通过一些装饰器和文档更新，将任何一组功能暴露给广泛的受众、服务器和 web 浏览器。

当涉及到我们不同应用程序之间的通信时(微服务风格)，这是我们系统管理员的工作；软件方面，它几乎是透明的。

![U8IwqOXGlnAp-z3A25ZgRz3Gm2PUjlduG1-c](img/5ec03038e87996ccbd58bdc688e5e235.png)

Developer resting after a tough 30mn spent integrating an RPC API.

接着是休息。
**具象状态转移。**

更新的浪潮动摇了军种间交流的基础。

RPC 已经死了，未来是 RESTful 的:每个资源都存在于自己的 URL 上，并且通过 HTTP 协议被专门操纵。

从那时起，我们不得不公开或消费的每一个 API 都成了新的挑战；更不用说是精神错乱的证明了。

### 休息有什么问题？

一个简短的例子抵得上长篇大论。这是一个小 API，为了可读性，去掉了数据类型。

```
createAccount(username, contact_email, password) -> account_id
addSubscription(account_id, subscription_type) -> subscription_id
sendActivationReminderEmail(account_id) -> null
cancelSubscription(subscription_id, reason, immediate=True) -> null
getAccountDetails(account_id) -> {full data tree}
```

只需添加一个正确记录的异常层次结构(InvalidParameterError、MissingParameterError、workflowererror……)，用子类来标识重要的情况(例如 AlreadyExistingUsernameError)，就可以了。

这个 API 易于理解，易于使用，并且健壮。它由精确的状态机支持，但有限的可用操作集使用户远离无意义的交互(如更改帐户的创建日期)。

将这个 API 作为一个简单的 RPC 服务公开的估计时间:几个小时。

好了，现在是时候去休息了。

不再有标准，不再有精确的规范。只是一种模糊的“宁静哲学”，容易引发无休止的形而上学辩论，以及许多丑陋的变通办法。

如何将上面的精确函数映射到少量的 CRUD 操作？发送激活提醒电子邮件是对“必须发送激活提醒电子邮件”属性的更新吗？还是创建“激活 _ 提醒 _ 电子邮件资源”？如果订阅在宽限期内保持活动状态，并且在此期间可能会复活，那么使用 DELETE for cancelSubscription()是否合理？如何在端点之间分割 getAccountDetails()的数据树，以尊重 REST 的数据模型？

你给你的每个“资源”分配了什么 URL 端点？是的，这很容易，但无论如何都要做。

如何使用非常有限的 HTTP 代码来表达错误条件的多样性？

对于输入和输出有效载荷，您使用什么序列化格式、哪些特定的方言？

如何在 HTTP 方法、URL、查询字符串、有效负载、头和状态代码之间分配这些简单的签名呢？

你离开了几个小时，重新发明轮子。甚至没有一个定制的智能车轮。一个破碎脆弱的车轮，需要理解大量的文档，甚至在不知道的情况下违反了规范。

![0bAxdhnQJw0WseQEmDT9Km9hn2Nj2VfsWJzb](img/6018ceccbd2238f80a24caf74eed16ae.png)

为什么休息意味着这么多的工作？
*这既是一个悖论，又是一个无耻的双关语。*

让我们进一步探究由这种设计哲学产生的人为问题。

当心:通过这篇文章，你会遇到许多半修辞性的技术问题。不要误解它们，它们并不意味着 RESTish 服务不能解决这些问题。它们只是意味着用户有额外的负担去做决定，去集成扩展，去应用定制的变通方法，这本身就是一个问题。

### 休息动词的快乐

Rest 不是垃圾，它的拥护者会确保你不会混淆这两者。然而几分钟后，他们会欣喜地发现 HTTP 方法有定义良好的语义来创建(POST)、检索(GET)、更新(PUT/PATCH)和删除(delete)资源。

他们会乐于宣称这几个“动词”足以表达任何操作。嗯，他们当然是；就像一些动词足以表达英语中的任何概念一样:“今天我用我的身体更新了我的 CarDriverSeat，并创建了一个引擎点火，但燃料箱删除了自己”；成为可能并不会减少尴尬。除非你是托基波纳语的崇拜者。

如果要点是极简主义，至少让它做对。您知道为什么 PUT、PATCH 和 DELETE 从未在 web 浏览器表单中实现吗？因为它们无用且有害。我们可以用 GET 来读，用 POST 来写。或者在不需要 HTTP 级别的缓存时专门发布。其他方法往好了说会妨碍你，往坏了说会毁了你的一天。

您想使用 PUT 来更新您的资源吗？好的，但是一些神圣的规范规定数据输入必须等同于通过 GET 接收的表示。那么如何处理 GET 返回的众多只读参数(创建时间、最后更新时间、服务器生成的令牌……)？你忽略了它们，违反了卖出原则？无论如何，您都要包含它们，如果它们与服务器端的值不匹配，您会遇到“HTTP 409 冲突”(迫使您发出 GET...)?你给它们随机的值并期望服务器忽略它们(无声错误的喜悦)？选择你的毒药，REST 显然不知道它是什么只读属性，而且这个问题不会很快得到解决。同时，GET 被危险地认为要返回在之前的 POST/PUT 中发送的密码(或信用卡号);也祝处理这种只写参数好运。

我是不是忘了提到 PUT 也会带来危险的竞争条件，几个客户端会覆盖彼此的更改，而他们只是想更新不同的字段？

您想使用修补程序来更新您的资源吗？不错，但是像 99%使用这个动词的人一样，您只需在请求有效负载中发送资源字段的子集，希望服务器正确理解预期的操作(及其所有可能的副作用)；许多资源参数是深度关联或互斥的(例如它是信用卡或 paypal 令牌，在用户的账单信息中)，但是 RESTful 设计也隐藏了这些重要信息。无论如何，你会再次违反规范:补丁不应该只是发送一堆字段被覆盖。相反，你应该提供一套应用于资源的“指令”。所以你又来了，拿着你的纸板和咖啡杯，你必须决定如何表达这些指示。通常有手工制作的规范，因为非发明地综合症在其他国家是一个事实上的标准。(编辑:REST 的拥护者在这个问题上打退堂鼓，推出了 [Json 合并补丁](https://tools.ietf.org/html/rfc7386)，这是对像 [Json 补丁](https://tools.ietf.org/html/rfc6902)这样的格式的替代)

您想删除资源吗？好的，但是我希望你不需要提供实质性的上下文数据；比如来自用户的终止请求的 PDF 扫描。DELETE 禁止拥有有效负载。这是 REST 架构师经常忽略的一个约束，因为大多数 web 服务器不会对收到的请求强制执行这个规则。附带 2 MBs base64 查询字符串的删除请求有多兼容？(编辑: [RFC 2616](https://tools.ietf.org/html/rfc2616#section-4.3) ，表示没有语义的有效载荷应该被忽略，现在已经过时)

![Kh0pTcWKoXqHlue3kdqTPNk9HhwjzDoe4kFQ](img/a0658d895db71d12a83091009684a271.png)

REST 爱好者很容易承认“人们做错了”，他们的 API“实际上并不 RESTful”。例如，许多开发人员使用 PUT 直接在其最终 URL(*/my resource base/my resource id*)上创建资源，而“好方法”(编辑:根据许多人的说法)是在父 URL ( */myresourcebase* )上发布，并让服务器用 HTTP“位置”头指示新资源的 URL(编辑:尽管这不是 HTTP 重定向)。好消息是:没关系。这些严格的原则就像大端对小端，它们占据了哲学家们几个小时的时间，但对现实生活中的问题几乎没有影响，例如“把事情做好”。

顺便说一下…手工制作网址总是很有趣。您知道在构建 REST urls 时有多少实现正确地编码了 urlencode()标识符吗？没有那么多。准备好迎接恶劣的破坏和 SSRF/CSRF 的袭击。

![3cj3Mv2d3PmHunKtUoRheSjqK4ALGsJXAEud](img/f308260875fd10fa849e02d19a03b609.png)

When you forget to urlencode usernames in 1 of your 30 handcrafted URLs.

### REST 错误处理的乐趣

大约每一个编码者都能够让一个“名义案例”工作。错误处理是这些特性之一，它将决定你的代码是健壮的软件，还是一大堆火柴棍。

HTTP 提供了现成的错误代码列表。太好了，让我们看看。

使用“HTTP 404 Not Found”来通知一个不存在的资源听起来很 RESTful，不是吗？太糟糕了:你的 nginx 错误配置了 1 个小时，所以你的 API 消费者只得到 404 个错误，并清除了数百个帐户，以为它们被删除了…

![E7ViySx5TgWjpOm4ajHxsAhkfRY58Sz1IQW5](img/9d0ed75577ac6fc049486f26e3ec3814.png)

Our customers, after we deleted their gigabytes of kitten images by error.

当用户没有第三方服务的访问凭证时，使用“HTTP 401 未授权”听起来可以接受，不是吗？然而，如果你的 Safari 浏览器中的 ajax 调用得到了这个错误代码，它*可能*用一个非常意外的密码提示吓到你的最终客户【几年前，YMMV 就是这样做的】。

HTTP 早在“RESTful webservices”之前就存在了，web 生态系统充满了对其错误代码含义的假设。用它们来运输应用程序错误就像用奶瓶处理有毒废物一样:不可避免地，总有一天，会有麻烦。

一些标准的 HTTP 错误代码是 Webdav 特有的，另一些是微软特有的，剩下的几个定义非常模糊，没有任何帮助。最后，像大多数 REST 用户一样，您可能会使用随机的 HTTP 代码，比如“HTTP 418 I'm a 茶壶”或未赋值的数字，来表达您的特定于应用程序的异常。或者您会无耻地返回所有功能错误的“HTTP 400 Bad Request ”,然后发明您自己的笨拙的错误格式，将布尔值、整数代码、slugs 和翻译的消息填充到任意的有效载荷中。否则你会完全放弃适当的错误处理；你只需用自然语言回复一条简单的信息，并希望打电话的人能够分析问题，并采取行动。祝你从一个自治程序中与这样的 API 交互好运。

### 休息的乐趣概念

REST 通过吹嘘任何头脑正常的服务架构师已经尊重的概念，或者吹嘘它甚至没有遵循的原则来成就自己的事业。以下是一些摘录，摘自排名靠前的网页。

REST 是一种客户端-服务器架构。客户端和服务器都有不同的关注点。这是软件世界中的独家新闻。

REST 在组件之间提供了统一的接口。嗯，就像任何其他协议一样，当它作为整个服务生态系统的*通用语*被强制执行时。

休息是一个分层的系统。单个组件无法看到与其交互的直接层之外的内容。这听起来像是任何设计良好、松散耦合的架构的自然结果；太神奇了。

Rest 很牛逼，因为它是无状态的。是的，webservice 背后可能有一个巨大的数据库，但是它不记得客户端的状态。或者，嗯，是的，实际上它记得它的认证会话，它的访问权限…但是它是无状态的，尽管如此。或者更准确地说，就像任何基于 HTTP 的协议一样无状态，就像前面提到的简单 RPC。

![kRhdDUN-QCazUckRJuN8D4cKsB7zNS0mcWbp](img/66233855ea2de30c9fe5f3c2343c2021.png)

使用 REST，您可以利用 HTTP 缓存的强大功能！这里是最后一个结论:GET 请求和它的缓存控制头确实对 web 缓存友好。也就是说，不是本地缓存(Memcached 等。)够 99%的 web 服务用吗？失控的贮藏是危险的野兽；有多少人希望以明文形式公开他们的 API，以便在资源被更新或删除很久之后，路上的清漆或代理可以继续提供过时的内容？如果曾经发生过配置错误，甚至可能“永远”交付它？默认情况下，系统必须是安全的。我完全承认，一些负载很重的系统希望从 HTTP 缓存中受益，但是为繁重的只读交互暴露几个 GET 端点比将所有操作切换到 REST 及其可疑的错误处理成本要低得多。

*多亏了这一切，REST 才有了高性能*！我们确定吗？任何 API 设计者都知道:在本地，我们想要细粒度的 API，能够做我们想做的任何事情；在远程，我们需要粗粒度的 API 来限制网络往返的影响。这又是一个 REST 惨败的领域。“资源”之间的数据分割，每个实例都在自己的端点上，自然会导致 N+1 查询问题。要获得用户的全部数据(账户、订阅、账单信息……)，必须发出尽可能多的 HTTP 请求；并且您不能将它们并行化，因为您事先不知道相关资源的唯一 id。这一点，再加上不能只获取部分资源对象，自然会产生令人讨厌的瓶颈(编辑:是的，您可以在您的设置中填充像复合/部分文档这样的扩展来帮助解决这个问题)..

REST 提供了更好的兼容性。怎么会这样？那么，为什么这么多 REST 服务在它们的基本 URL 中有“/v2/”或“/v3/”?使用高级语言，只要在添加/取消参数时遵循简单的规则，向后和向前兼容的 API 并不难实现。据我所知，休息不会给这个问题带来任何新的东西。

*休息简单，大家都懂 HTTP！*每个人都知道鹅卵石，但人们很乐意在建造房屋时使用更好的石块。就像 XML 是一种元语言一样，HTTP 是一种元协议。要有一个真正的应用协议(就像“方言”对于 XML 一样)，你需要指定很多东西；您将最终得到另一个 RPC 协议，就好像还不够一样。

REST 是如此简单，它可以从任何 shell 中查询，并带有 CURL！好的，其实每个基于 HTTP 的协议都可以用 CURL 查询。甚至肥皂。当然，发出 GET 特别简单，但是手工编写 json 或 xml POST 有效载荷会有好运；人们通常使用 fixture 文件，或者更方便的是，直接在他们喜欢的语言的命令行界面中实例化的成熟 API 客户端。

*“客户使用本服务不需要任何预先了解”*。这是我最喜欢的一句话。我已经发现它无数次了，以不同的形式，尤其是当流行词 [HATEOAS](https://fr.wikipedia.org/wiki/HATEOAS) 潜伏在周围的时候；有时后面会有一些小心的(但不充分的)“除了”短语。尽管如此，我不知道这些人生活在哪个幻想世界里，但在这个世界里，客户端程序不是一群蚂蚁；它不会随机浏览远程 API，然后根据模式识别或黑魔法来决定如何最好地处理它们。恰恰相反；客户端对它的含义有强烈的期望，用这个值把这个字段放在这个 URL 上，服务器最好尊重集成过程中达成一致的语义，否则一切都有可能失控。

![34MrY7lPN5IORJltxiixXPAQaJPXy6efQRNa](img/36a7220613246ca4b2d93df387c72a23.png)

When you ask how HATEOAS is supposed to work.

### 如何做到正确快速的休息？

忘掉“正确”的部分。休息就像一种宗教，没有一个凡人能理解它的天赋，也没有人能“做好它”。

所以真正的问题是:如果你被迫以一种有点 RESTful 的方式公开或消费 web 服务，如何快速完成这项工作，并尽快切换到更有建设性的任务？

***更新*** *:原来休息其实有很多“标准”和产业化的努力，虽然我个人从来没有遇到过(可能是因为用的人少？).更多信息在我的[后续文章](https://medium.com/@pakaldebonchamp/follow-up-to-rest-is-the-new-soap-the-origins-of-rest-21c59d243438)。*

#### 服务器端曝光如何产业化？

每个 web 框架都有自己定义 URL 端点的方式。因此，期待一些大的依赖项，或者一个好的手写样板层，将您现有的 API 作为一组 REST 端点插入到您最喜欢的服务器上。

像 Django-Rest-Framework 这样的库通过充当 SQL/noSQL 模式之上的以数据为中心的包装器，自动创建 REST APIs。如果你只是想做“HTTP 上的 CRUD ”,你可以接受。但是如果您想要公开带有工作流、约束、复杂数据影响等的常见“替我做”API，您将很难改变任何 REST 框架来满足您的需求。

准备好将每个端点的每个 HTTP 方法逐个连接到相应的方法调用；手动异常处理的公平份额，将传递异常转换成相应的错误代码和有效负载。

#### 客户端集成如何产业化？

根据经验，我的猜测是:你没有。

对于每个 API 集成，您将不得不浏览冗长的文档，并遵循 N 个可能的操作中的每一个必须如何执行的详细方法。

您必须手工制作 URL，编写序列化程序和反序列化程序，并学习如何解决 API 的模糊性。在驯服这头野兽之前，要做好反复试验的准备。

你知道网络服务提供商如何弥补这一点，并简化采用吗？

很简单，他们编写自己的官方客户端实现。

因为。每一个。少校。语言。还有。站台。

我最近处理了一个订阅管理系统。他们提供 PHP，Ruby，Python 等客户端。NET，iOS，Android，Java…加上一些外部对 Go 和 NodeJS 的贡献。

每个客户端都有自己的 Github 存储库。每一个都有自己的提交列表、bug 跟踪标签和 pull 请求。每个都有自己的用法示例。每个都有自己笨拙的架构，介于 ActiveRecord 和 RPC 代理之间。

这令人震惊。有多少时间花在开发这种奇怪的包装器上，而不是改进真正的、有价值的、有效率的 web 服务？

![6e6uGUi7IVtFgglB6VlN3m6Kq5ohKtztGVet](img/7b9da4a489f4438f1ab3767b1f2ac87f.png)

*Sisyphus developing* Yet Another Client for his API.

### **结论**

几十年来，几乎每种编程语言都有相同的工作流程:向可调用函数发送输入，并获得结果或错误作为输出。这很有效。很好。

休息，这已经变成了一个疯狂的工作映射苹果到橘子，并赞扬 HTTP 规范，以更好地违反他们分钟后。

在一个微服务越来越普遍的时代，如此简单的任务——通过网络连接图书馆——怎么会变得如此复杂和麻烦？

我不怀疑外面的一些聪明人会提供让 REST 大放异彩的案例；他们将展示他们自制的基于 REST 的协议，由于超链接，允许在任意对象树上发现和进行 CRUD 操作；他们会解释为什么 REST 设计如此出色，以至于我还没有阅读足够多的关于其概念的文章和论文。

我不在乎。树是通过它们自己的果实来识别的。用简单的 RPC，我花了几个小时编写代码并且非常健壮地工作，现在需要几个星期，并且不能停止发明失败或打破期望的新方法。发展已经被修补取代。

几乎透明的远程过程调用是 99%的人真正需要的，而现有的协议尽管不完美，却能很好地完成这项工作。这种对网络最小公分母 HTTP 的狂热，主要导致了时间和灰色物质的巨大浪费。

REST 承诺了简单，却带来了复杂。
**安息许诺了强健，交付了脆弱。
**休息许诺互通性，交付异质性。**
**休息是新肥皂。****

### 收场白

未来可能是光明的。仍然有大量优秀的协议可用，有二进制或文本格式，有或没有模式，有些利用了 HTTP2 的新功能……所以让我们继续吧，各位。我们不能永远停留在网络服务的石器时代。

许多人要求这些替代协议，这个主题应该有自己的故事，但是人们可以看看 XMLRPC 和 JSONRPC(简单但非常相关)，或者 JSONWSP(包括模式)，或者内部使用的特定于语言的层，如 Pyro 或 RMI，或者公共 API 的新成员，如 GraphQL 和 gRPC

![L5hrdnm4vPQK-RaCYSy4z49vFhqYeUdsZom3](img/cd356699e7ece4ed6672d93f424bbf6f.png)

“Always finish a rant on a positive note”, momma said.

2017 年 12 月 12 日编辑:

*   标准化章节标题
*   去掉一些错别字
*   在 POST 操作后纠正不正确的“HTTP 重定向”措辞
*   添加替代协议的建议

2017 年 12 月 28 日编辑:

*   修复“HTTP 方法”和“REST 动词”之间的混淆

2018 年 1 月 7 日编辑

*   修正不明确的措辞

2018 年 1 月 19 日编辑

*   修正“PUT vs GET”注释中的错误措辞
*   精确定义“真正的 API”(非 CRUD)
*   用看跌期权提及撤销风险
*   更新补丁段落，删除故障

2018 年 1 月 19 日编辑

*   修正“不在此发明”综合症的措辞

2018 年 2 月 2 日编辑

*   在“简介”和“如何工业化”章节中，添加关于原始休息的后续文章的链接

2019 年 4 月 14 日编辑

*   添加关于“半反问句”的说明，以及关于复合/部分文档等扩展的提示

2019 年 7 月 6 日编辑

*   修复错别字和法语链接

请在下面留下你的评论。以下是媒体对这篇文章的评论:[https://medium.com/p/97ff6c09896d/responses/show](https://medium.com/p/97ff6c09896d/responses/show)