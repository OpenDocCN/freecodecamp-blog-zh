# 异步 JavaScript——回调、承诺和异步/等待解释

> 原文：<https://www.freecodecamp.org/news/asynchronous-javascript-explained/>

如果你学习 JavaScript 已经有一段时间了，那么你可能听说过“异步”这个术语。

这是因为 JavaScript 是一种异步语言...但是这到底意味着什么呢？在这篇文章中，我希望向你展示这个概念并没有听起来那么难。

# 同步与异步

在我们开始真正的交易之前，让我们先看看这两个词——同步和异步。

默认情况下，JavaScript 是一种同步的单线程编程语言。这意味着指令只能一个接一个地运行，而不能并行运行。考虑下面的小代码片段:

```
let a = 1;
let b = 2;
let sum = a + b;
console.log(sum);
```

上面的代码非常简单——它将两个数字相加，然后将总和记录到浏览器控制台。解释器按照这个顺序一个接一个地执行这些指令，直到完成为止。

但是这种方法也有缺点。假设我们想从数据库中获取大量数据，然后在界面上显示出来。当解释器到达获取该数据的指令时，其余的代码被阻止执行，直到数据被获取并返回。

现在，您可能会说，要获取的数据并不太大，也不会花费太多时间。想象一下，您必须在多个不同的点获取数据。这种复合延迟听起来不像是用户想要遇到的事情。

幸运的是，同步 JavaScript 的问题通过引入异步 JavaScript 得到了解决。

把异步代码想象成可以现在开始，以后再完成执行的代码。当 JavaScript 异步运行时，指令不一定像我们之前看到的那样一个接一个地执行。

为了正确实现这种异步行为，开发人员多年来使用了一些不同的解决方案。每个解决方案都在前一个的基础上进行改进，这使得代码更加优化，在变得复杂的情况下更容易理解。

为了进一步理解 JavaScript 的异步本质，我们将讨论回调函数、承诺、异步和等待。

# JavaScript 中有哪些回调？

回调是在另一个函数内部传递的函数，然后在该函数中调用以执行任务。

迷惑？让我们通过实际执行来分解它。

```
console.log('fired first');
console.log('fired second');

setTimeout(()=>{
    console.log('fired third');
},2000);

console.log('fired last');
```

上面的代码片段是一个将东西记录到控制台的小程序。但是这里有新的东西。解释器将执行第一条指令，然后是第二条，但会跳过第三条，执行最后一条。

`setTimeout`是一个接受两个参数的 JavaScript 函数。第一个参数是另一个函数，第二个参数是该函数执行的时间，以毫秒为单位。现在你看到回调的定义开始起作用了。

在这种情况下，`setTimeout`内部的函数需要在两秒(2000 毫秒)后运行。想象一下，当其他指令继续执行时，它被带到浏览器的某个独立部分执行。两秒钟后，返回函数的结果。

这就是为什么如果我们在程序中运行上面的代码片段，我们会得到这样的结果:

```
fired first
fired second
fired last
fired third
```

您会看到在`setTimeout`中的函数返回结果之前，最后一条指令被记录。假设我们使用这种方法从数据库中获取数据。当用户等待数据库调用返回结果时，执行中的流程不会被中断。

这种方法非常有效，但只在一定程度上有效。有时，开发人员必须在他们的代码中对不同的源进行多次调用。为了进行这些调用，回调被嵌套，直到它们变得很难阅读或维护。这被称为**回调地狱**

为了解决这个问题，承诺被引入。

# JavaScript 中的承诺是什么？

我们总是听到人们做出承诺。你的那个答应给你免费寄钱的表弟，一个答应不经允许不再碰饼干罐的孩子...但是 JavaScript 中的承诺略有不同。

在我们的上下文中，承诺是需要一些时间去做的事情。一个承诺有两种可能的结果:

*   我们要么运行并解决承诺，或者
*   在这个过程中出现了一些错误，承诺被拒绝

出现了解决回调函数问题的承诺。一个承诺接受两个函数作为参数。也就是`resolve`和`reject`。请记住，解决是成功，拒绝是错误发生时。

让我们来看看工作中的承诺:

```
const getData = (dataEndpoint) => {
   return new Promise ((resolve, reject) => {
     //some request to the endpoint;

     if(request is successful){
       //do something;
       resolve();
     }
     else if(there is an error){
       reject();
     }

   });
};
```

上面的代码是一个承诺，包含在对某个端点的请求中。像我之前提到的，承诺包含`resolve`和`reject`。

例如，在调用端点之后，如果请求成功，我们将解析承诺，并继续对响应做我们想做的任何事情。但是如果有错误，这个承诺就会被拒绝。

承诺是解决回调地狱带来的问题的一个好方法，这种方法被称为**承诺链**。您可以使用此方法从多个端点顺序获取数据，但是代码更少，方法更简单。

但是有一个更好的方法！您可能熟悉下面的方法，因为这是 JavaScript 中处理数据和 API 调用的首选方式。

# JavaScript 中的 Async 和 Await 是什么？

问题是，像回调一样将承诺链接在一起会变得非常庞大和混乱。这就是 Async 和 Await 产生的原因。

要定义异步函数，请执行以下操作:

```
const asyncFunc = async() => {

}
```

注意，调用一个异步函数总是会返回一个承诺。看看这个:

```
const test = asyncFunc();
console.log(test);
```

在浏览器控制台中运行上面的代码，我们看到`asyncFunc`返回了一个承诺。

现在让我们真正分解一些代码。考虑下面的小片段:

```
const asyncFunc = async () => {
	const response = await fetch(resource);
   	const data = await response.json();
}
```

正如我上面提到的,`async`关键字是我们用来定义异步函数的。但是`await`怎么样？嗯，它阻止 JavaScript 将`fetch`赋给响应变量，直到承诺得到解决。一旦承诺被解析，fetch 方法的结果现在可以被赋给响应变量。

同样的事情发生在 3 号线上。`.json`方法返回一个承诺，我们仍然可以使用`await`来延迟赋值，直到承诺被解决。

# 阻止代码还是不阻止代码

当我说“停止”时，您一定认为实现 Async 和 Await 会以某种方式阻止代码执行。因为如果我们的请求时间太长怎么办，对吗？

事实是，它没有。异步函数中的代码正在阻塞，但这不会以任何方式影响程序的执行。我们代码的执行仍然是异步的。为了证明这一点，

```
const asyncFunc = async () => {
	const response = await fetch(resource);
   	const data = await response.json();
}

console.log(1);
cosole.log(2);

asyncFunc().then(data => console.log(data));

console.log(3);
console.log(4); 
```

在我们的浏览器控制台中，上面的输出看起来像这样:

```
1
2
3
4
data returned by asyncFunc
```

你可以看到，当我们调用`asyncFunc`时，我们的代码一直运行，直到函数返回结果。

# 结论

本文没有深入讨论这些概念，但是我希望它向您展示了异步 JavaScript 需要什么以及需要注意的一些事情。

它是 JavaScript 的一个非常重要的部分，本文只是触及了皮毛。尽管如此，我希望这篇文章有助于打破这些概念。