# 什么是扼杀者 Fig 模式，它如何帮助管理遗留代码

> 原文：<https://www.freecodecamp.org/news/what-is-the-strangler-pattern-in-software-development/>

任何足够旧的代码库最终都会包含遗留代码。架构、性能、注释等等在它们被写出来的那一刻就开始退化。

代码库的某些部分比其他部分持续的时间更长，但是不可避免地会出现新的编码标准来减少技术债务。然后，您必须在零停机的情况下重做一个大型应用程序，在不破坏您的发布或开发中的任何东西的情况下，创建一种“新的”工作方式。

扼杀者无花果图案是解决这个问题的有效方法之一。

## 什么是扼杀者无花果？

名字 **[扼杀者无花果图案](https://en.wikipedia.org/wiki/Strangler_fig)** 实际上来源于一组通过“扼死”寄主而生长的植物。

它们生长在对光竞争激烈的地区，并且它们已经进化到将它们的种子分散(通常通过鸟类)到宿主树的顶部，在那里它们可以容易地获得阳光。

它们的根沿着树向下生长，幼苗向上生长，尽可能地吸收阳光。这就“勒死”了树，无花果幼苗经常会杀死它们落在上面的寄主树。

这是一个扼杀者无花果的图片，我在维基百科上找到的。

![image-99](img/f43cfcc095a51087f88899a3072b311d.png)

An image of a strangler fig, where the roots grow down the tree trunk to the soil whilst the seedlings grow up above the trees canopy. [Source](https://upload.wikimedia.org/wikipedia/commons/4/46/Ficus_watkinsiana_on_Syzygium_hemilampra-Iluka.jpg).

那么这如何应用于软件呢？🤔

# 扼杀者无花果图案是什么？

要完全重写一个大型的、复杂的代码库，其中包含许多不同的交互，通常是与不同的团队一起进行的，这会导致一场规划噩梦。

在像这样的大型复杂项目中，去 T2 大爆炸一般会迫使你:

*   深入理解每一个交互，确保你在发布时不会破坏任何东西
*   重写代码时，在新旧代码库中完成所有新的 bug 修复
*   保持合并和最新
*   花数周时间测试
*   为新代码库的推出处理大量的标注和非工作时间支持

更糟糕的是，它通常以开发人员加班加点和大量 bug 的涌入而告终。

当我们使用**扼杀者图**时，我们试图消除的一个大困难是让使用你的软件的人知道你的新软件现在可以在哪里访问。

例如，当您重写后端时，如果您将所有内容都放在一个新的端点上，并友好地要求您的用户指向您的新端点。但是如果出了问题，你可能要让他们都指向原来的那个。

如果您遇到非常棘手的 bug，您可能会在这两个端点之间来回切换，这可能会让您的用户感到沮丧。

当我们使用**扼杀者无花果图案**时，我们可以避免以上所有情况。

## 为什么扼杀我们的代码

扼杀者无花果模式旨在逐步重写你的代码库的一小部分，直到几个月或几年后，你已经扼杀了你所有的旧代码库，它可以被完全删除。

大致流程是:向系统添加一个尚未使用的新部分，打开代码的新部分——通常带有一个特性标志，以便它与旧代码共存——最后删除旧代码。

### 扼杀者无花果模式的好处

除了帮助您避免我们已经讨论过的所有问题之外，它还:

*   当您需要更新时，降低您的风险
*   开始立即给你一些好处
*   允许你把你的改变分成小的模块，更容易发布
*   确保零停机时间
*   通常更加敏捷
*   使您的回滚更容易
*   如果您有多个优先级，允许您将您的开发扩展到更长的时间。

实现**扼杀者 Fig 模式**有多种方式，这取决于你要移除的系统，等等。因此，让我们具体来看一个例子。

## 门面支付提供商示例

举个例子，你有一个巨大的后端代码库来处理支付。它是巨大的。几百万行代码，有多个端点，出于多种原因，您希望将其重新编写成对您的公司来说新的东西。

现在的性能很差，架构太混乱，新的开发人员很难上手，而且有很多[死代码](https://www.freecodecamp.org/news/antipatterns-to-avoid-in-code/)你需要删除，但不想破坏任何东西。

破坏一个涉及客户支付的巨大代码库可能会导致最后一个推上来的不幸的开发人员丢掉工作！

好吧。你如何慢慢地挤出这个旧的代码库？更棘手的是，你不想只是在那里放一个新的端点，然后强迫每个人都移动。您有数百个客户在使用这个软件，如果您有错误需要回滚，他们不能在您的端点之间来回切换。

仅仅增加最后一个挑战，你也不希望改变你的接口到这些端点。作为参数传递或返回的所有内容都应该保持不变。

## 基于扼杀者 Fig 模式的解决方案

我们可以创建一个外观来拦截发往遗留端点的请求。

新的外观将移交给你写的新 API，或者移交给遗留 API，如果你还没有重写代码库的话。

这个外观本质上是一个[垫片](https://en.wikipedia.org/wiki/Shim_(computing))来捕捉网络请求并将它们传递到正确的位置。

然后，您可以一点一点地逐渐迁移到新的 API，您的用户将不会意识到对底层代码的任何更改，因为您已经正确地将其抽象掉了。

如果你这样做是正确的，你通常会:

*   只要一开始就有遗产的方式
*   制作新的 API
*   让它与遗留 API 共存，在遗留 API 中，您可以使用特性标志来打开和关闭它
*   越来越多地转向新的 API
*   完全迁移后删除旧方式

**扼杀**的部分正在一点一点地发生，你将越来越多的责任从遗留 API 转移到新 API 中。

## **结论**

我希望这已经解释了什么是**扼杀者无花果模式**以及它的一些好处。

我在真实的软件项目中见过这种模式，它非常有效。这无疑是我参与的最复杂的项目之一，而**扼杀者 Fig** 让它变得简单多了。

它让你几个月都不能写软件项目，然后祈祷它投入生产，同时希望你没有忘记任何事情。

当我写这篇文章时，有两个非常有用的无价资源:

*   *扼杀者图应用*由马丁·福勒[在此](https://martinfowler.com/bliki/StranglerFigApplication.html)，以及
*   避免从头重写一个遗留系统，通过扼杀它找到[这里](https://understandlegacycode.com/blog/avoid-rewriting-a-legacy-system-from-scratch-by-strangling-it/)。

如果你喜欢这篇文章并想看更多，我在 Twitter 上分享我的文章。