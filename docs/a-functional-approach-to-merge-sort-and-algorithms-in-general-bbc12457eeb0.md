# 合并排序算法的一种函数方法

> 原文：<https://www.freecodecamp.org/news/a-functional-approach-to-merge-sort-and-algorithms-in-general-bbc12457eeb0/>

由乔追逐一个

# 合并排序算法的一种函数方法

![yOEzzeaSsJspQoc6e7VvAqK3lxDt-gUfnbm2](img/4bf0ace6ece30123feee905cfaac38cb.png)

Photo by [Ricardo Gomez Angel](https://unsplash.com/photos/vvst7KmzKUc?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/search/photos/architecture-repetition?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

算法往往让人难以理解。我相信这是因为它们通常是用一种鼓励在非直觉的程序或指令中思考的语言来编程或解释的。

当用图形描述时，算法的核心(如何在没有计算机编码的情况下逻辑地解决一个特定的问题)通常看起来非常简单和容易理解。然而，令人惊讶的是，它通常不能很好地翻译成用 Python、Java 或 C++等语言编写的代码。因此它变得更加难以理解。

**换句话说，算法概念并不直接映射到代码应该如何编写和读取**。

### 为什么算法这么难编码？

嗯，我们可以将其归咎于早期机电计算机的内部工作方式。今天一些最常用的编程语言的早期发明者永远无法摆脱这些特性。或者也许他们会情不自禁地在他们的发明上留下指纹。一旦你很好地理解了计算机，那就无法挽回了。

更糟糕的是，在已经存在的微管理语言之上，必须有人发明一个 API 来实现更好的微管理。他们称之为面向对象编程(OOP ),并在编程中加入了类的概念——但我认为模块和函数可以很好地处理同样的事情，非常感谢。

C++并没有让 C 变得更好，但它确实通过启发更多 OOP 的后代铺平了道路。综上所述，所有这些事情使得抽象算法思考变得困难。

### 案例研究:合并排序

对于我们的讨论，我们将使用合并排序算法作为样本。看看下面的图表。如果你会数数，会拼拼图，那么你大概几分钟就能明白它是怎么工作的。

![ZcTwK7oDpCLBjTjYrP-3ZlnUCSWe7EkYj7Zb](img/7417e6ff21dbb9f05a651c477d2ba59d.png)

By Swfung8 — Own work, CC BY-SA 3.0, [https://commons.wikimedia.org/w/index.php?curid=14961648](https://commons.wikimedia.org/w/index.php?curid=14961648)

生成合并排序的关键步骤既少又简单。事实上，我可以用我女儿的数字积木来解释它(通过回到动画图进行参考，有助于理解这些积木):

*   首先，我们需要继续将一个数字列表(或者字母，或者任何类型的可排序值)一分为二，直到我们得到许多单元素列表。具有一个元素的列表在技术上是排序的。这被称为平凡排序。
*   然后，我们创建一个新的空列表，在这个列表中，我们可以开始重新排列元素，并根据一个比另一个小的顺序一个接一个地放置它们。
*   然后我们需要将每对列表“合并”在一起，有效地逆转细分步骤。但是这一次，在每一步中，我们都必须确保所讨论的元素对中较小的元素首先被放入空列表中。

为了便于讨论，我们将通过把每一个过程都变成一个子程序(正常情况下的函数)来描绘出上面的过程。这个算法最重要的部分是合并，所以让我们先从合并开始。

```
def merge(a, b):
    out = []

    while (len(a) > 0 and len(b) > 0): 
        if (a[0] <= b[0]):
            out.append(a[0])
            del a[0]
        else:
            out.append(b[0])
            del b[0]

    while (len(a) > 0):
        out.append(a[0])
        del a[0]
    while (len(b) > 0):
        out.append(b[0])
        del b[0]

    return out
```

去吧，花点时间看看。您可能会注意到，对于命令式 Python 代码，它是被设计成说出来然后被理解的。用英语很好理解，但逻辑不行。

#### 我们的第一次尝试

以下是一个尝试(您可能会在白板会议中使用):

为了合并列表`a`和`b`，为了清楚起见，我们必须首先创建一个名为`out`的空列表(因为在 Python 中，我们不能确定它最终是否真的会“出来”)。然后，只要这两个列表都不为空，我们将继续让这两个列表的头进行较量。小于或等于对手的获胜，首先进入`out`。失败者将不得不留在那里等待下一个参赛者。重赛继续进行，直到第一个`while`循环中断。

现在，在某一点上`a`或`b`将是空的，剩下另一个有一个或多个悬挂的元素。在另一个列表中没有任何参赛者的情况下，两个`while`循环确保快速跟踪那些可怜的元素进入`out`，因此两个列表都被耗尽。然后，当这一切完成后，我们返回`out`。

这是合并的测试用例:

```
assert(merge([1], [2]) == [1, 2])
assert(merge([2], [1]) == [1, 2])
assert(merge([4, 1], [3, 0, 2]) == [3, 0, 2, 4, 1])
```

我希望在这一点上，你能明白为什么我们会有最后一个案例的结果。如果不是，试着在白板或纸上画画，模拟解释。

#### 各个击破

现在我们将继续细分部分。这个过程也被称为分割，或者用更宏大的语言来说，[分而治之](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm)(顺便说一下，[在政治中的定义同样有趣](https://en.wikipedia.org/wiki/Divide_and_rule))。

![7r1BOCtjx7Z261gFldhvdk6sxqLYy0xGpe57](img/79d6d734f60a1aef1f1b257831de459b.png)

Gold Medallion of Philip II of Macedonia who is said to have coined the maxim *divide et impera (divide and conquer).* Bibliothèque nationale de France, Paris

基本上，如果任何事情很难征服或理解，你应该把它分解，直到它变得更小，更容易理解。这样做，直到部分是牢不可破的，并重复其余的过程。

```
def half(arr):
    mid = len(arr) / 2
    return arr[:mid], arr[mid:]
```

`half`例程所做的是找到中间索引，将输入列表分割成大致相等的子列表，并将两者作为一对返回。它只需要这样做一次，因为父函数最终会递归调用它。

既然我们已经有了这些部分，现在我们只需要把它们组合成一个连贯的方案。这是水变得浑浊的地方，因为涉及到递归。

在深入研究更多代码之前，让我解释一下为什么递归和命令式编程语言(如 Python)不能很好地结合在一起。我不会深入讨论优化的话题，因为这与今天的讨论无关，也不那么有趣。

这里一个明显的讽刺是，即使在像 Python 这样具有迭代循环的语言中，它仍然不能完全避免递归(它可能不需要递归，但我确信这将使它更加奇怪)。在递归领域，迭代结构(如 for 和 while 循环)变得完全无用。

此外，递归在 Python 中并不自然。它感觉不到自然和透明，而是感觉它的 lambda 是半生不熟的。用 Python 来表达递归的尝试就像是，“然后我们递归地做这件事，祈祷它能顺利完成并最终达到基本情况，这样它就不会陷入堆栈溢出的无限黑暗中。”哇，对吧？

这里是`mergesort`函数:

```
def mergesort(arr):

    if (len(arr) <= 1):
        return arr

    left, right = half(arr)
    L = mergesort(left)
    R = mergesort(right)

    return merge(L, R)
```

显然，这真的很干净，很容易阅读。但是不清楚调用`half`之后会发生什么，至少在语义上是这样。由于递归的“非天生”性，递归调用非常不透明，阻碍了教育工作。

可视化合并排序过程的唯一方法可能是跟踪每一步中子列表的变化:

```
input: [0, 3, 1, 3, 2, 6, 5]
A alias for mergesort / half
B alias for merge

## subdividing by half ...

                 A([0, 3, 1, 3, 2, 6, 5])
              A([0, 3, 1])    A([3, 2, 6, 5])
          A([0])  A([3, 1])  A([3, 2])   A([6, 5])
    A([]) A([0]) A([3])  A([1]) A([3]) A([2]) A([6]) A([5]) 

## base case reached, start merging ...

       B([], [0]) B([3], [1]) B([3], [2]) B([6], [5])
          B([0], [1, 3])         B([2, 3], [5, 6])
                B([0, 1, 3], [2, 3, 5, 6])
                 B([0, 1, 2, 3, 3, 5, 6])

output: [0, 1, 2, 3, 3, 5, 6]
```

从渐近的角度来看，分而治之几乎总是会导致对数运行时间。当您继续将一个集合划分为`N`个子集合时，无论它包含 10 个还是 100，000，000 个项目，在后一种情况下所采取的步骤数都会以对数基数`N`的速率增加。

例如，保持 10 除以 2 需要大约 3 个步骤，直到它尽可能地接近 1(或者在整数除法中正好 3 个步骤达到 1)。但是做同样的事情只需要 26 步，然后把 100，000，000 除以 2，直到 1。这一事实可以表述如下:

```
2^3.321928 = 10
2^6.643856 = 100

...

2^26.575425 = 100000000

or 

log base 2 of 100000000 = 26.575425
```

这里的要点是，为了理解算法的内部工作，我们必须可视化递归过程——即使它在动画图中看起来如此微不足道。

**为什么算法本身的概念过程和指示计算机计算这种过程的代码之间会有鸿沟？**

这是因为在某种程度上，通过使用命令式语言，我们实际上仍然在精神上被机器所奴役。

![NEuX4NWEDEEpa2TikKqjT2ABx5kj8tPZk8A5](img/1cc2fc4b606cfb325df6581016e006e3.png)

Not quite like this, but you get the point.

### 深入研究代码

> “知道道路和走在道路上是有区别的。”
> ― [莫斐斯，黑客帝国](https://www.goodreads.com/author/show/7392901.Morpheus_The_Matrix)

编程很难，我们都知道。真正深入地理解编程对你的灵魂(和你的职业)来说更难。但我想说，就像墨菲斯说的，有时候走在路上才是最重要的。能够清楚地看到是编程中最有价值的事情之一。

在函数式编程中，程序员(你)坐在前排，看着数据如何递归地变化。这意味着您有能力根据外观快照来决定某种形式的数据应该如何转换为另一种形式的数据。这与我们想象中的合并排序过程没有什么不同。让我给你一个预览。

假设您想用 Python 创建一个基本案例。在其中，当只有一个元素时，你想返回一个有问题的列表，当有两个元素时，你想返回一个空列表。所以你需要像这样写:

```
if (len(arr) == 1):
    return arr
elif (len(arr) == 2):
    return []
```

或者更糟但更有趣的是，您可以尝试通过索引 0 访问第一个元素，通过索引 1 访问第二个元素，并准备好处理`IndexError`异常。

在像 Erlang 这样的函数式语言中——我将在本文中使用它来描述像 Python 这样的动态类型系统——您或多或少会做这样的事情:

```
case Arr of
  [_] -> Arr;
  [_,_] -> []
end.
```

这使您对数据的状态有了更清晰的了解。一旦经过足够的训练，它阅读和理解代码所需要的认知能力比`len(arr)`要少得多。请记住:一个不会说英语的程序员可能会问，“len 是什么？”然后，你会被函数的字面意思而不是表达式的值分散注意力。

然而，这是有代价的:你不能享受循环结构。像 Erlang 这样的语言是递归原生的。几乎每个有意义的 Erlang 程序都会使用严格的递归函数调用。这就是为什么它与通常由递归组成的算法概念有更紧密的联系。

让我们试着回溯一下产生 mergesort 的步骤，但这次是在 Erlang 中，从`merge`函数开始。

```
merge([], [], Acc) -> Acc;
merge([], [H | T], Acc) -> [H | merge([], T, Acc)];
merge([H | T], [], Acc) -> [H | merge(T, [], Acc)];
merge([Ha | Ta], [Hb | Tb], Acc) ->
  case Ha =< Hb of
    true  -> [Ha | merge(Ta, [Hb | Tb], Acc)];
    false -> [Hb | merge([Ha | Ta], Tb, Acc)]
  end.
```

多么令人厌恶！你认为这绝对不是可读性的提高。是的，Erlang 不可否认不会赢得任何漂亮语言的奖项。事实上，对于未经训练的人来说，许多函数式语言看起来就像是胡言乱语。

但是让我们给它一个机会。我们会像以前一样经历每一步，也许最终我们中的一些人会看到光明。但是在我们继续之前，对于那些不熟悉 Erlang 的人来说，有几点值得注意:

*   `merge`的每个块都被认为是同一个函数的一个函数子句。他们被`;`隔开。当表达式以 Erlang 结尾时，它以句点(`.`)结尾。根据不同的情况，将一个函数分成几个子句是一种惯例。比如，`merge([], [], Acc) -> A`cc；子句将前两个参数为空列表的情况映射到最后一个参数的值。
*   Arity 在 Erlang 中起着重要的作用。具有相同名称和 arity 的两个函数被视为同一函数。否则，他们不是。例如，`merge/1`和`merge/3`(函数及其 arity 在 Erlang 中是如何处理的)是两个不同的函数。
*   Erlang 使用严格的[模式匹配](https://en.wikipedia.org/wiki/Pattern_matching)(这在许多其他函数式语言中使用，但尤其是在 Erlang 中)。由于纯函数式语言中的值是不可变的，所以将数据形状相似的变量绑定到现有的形状匹配的变量是安全的。这里有一个简单的例子:

```
{X, Y} = {0.5, 0.13}.
X.  %% 0.5
Y.  %% 0.13

[A, B, C | _] = [alice, jane, bob, kent, ollie].
[A, B, C].  %% [alice, jane, bob]
```

*   注意，当我们使用 Erlang 函数时，我们将很少讨论返回值，因为它们本身并不真正“返回”任何东西。它将输入值映射到新值。这不同于从函数中输出或返回它。函数应用本身**就是**这个值。例如，如果`Add(N1, N2) -> N1+` N2 `., Add(1,` 2)是 3。它没有办法返回除 3 以外的任何值，因此我们可以说它是 3。这就是为什么你很容易就能把`do add_one = add`①和 th`en add_one`②算成`3, add_one` (5)算成 6，以此类推。

有兴趣的可以看[参照透明](https://stackoverflow.com/questions/210835/what-is-referential-transparency)。为了使这一点更清楚，并冒着冗余的风险，这里有一些东西要考虑:

> 当`f(x)`为一个 arity 的函数，映射为 `f(x) ->`；x，那么就确凿 th`at f(1) -`&g`t; 1, f(2`)`-> 2, f(3.1416)` ->`3.1416, and f("fo`o”)->“foo”。
> 
> 这看起来似乎是显而易见的，但是在一个不纯的函数中没有这样的映射保证:
> 
> `a = 1`
> `def add_to_a(b):`
> `return b + a`
> 
> 现在`a`可能是在`add_to_a`被调用之前的任何东西。因此，在 Python 中，您可以将上面的代码编写为:
> 
> `def add(a, b):`
> `return a + b`
> 或`lambda a, b: a + b`。

现在是时候进入未知世界了。

![Vg7C4II-2IY3Jx58NEN-nzHtSmVS9FwmWk6L](img/b4e17c3490acaf751cf80e47f4520c24.png)

That’s what Frank O. Gehry said.

#### 与 Erlang 一起前进

```
merge([], [], Acc) -> Acc;
```

`merge/3`函数的第一个子句意味着当前两个参数为空列表时，将整个表达式映射到(或“返回”)第三个参数`Acc`。

有趣的是，在一个纯函数中，没有办法保持和改变自身之外的状态。我们只能处理作为函数输入的内容，对其进行转换，然后将新状态输入到另一个函数的参数中(通常这是对自身的另一个递归调用)。

这里，`Acc`代表累加器，你可以把它想象成一个状态容器。在`merge/3`的情况下，`Acc`是一个以空开始的列表。但是随着递归调用的进行，它使用我们编程的逻辑(我们将在下面讨论)从前两个列表中累积值。

这个耗尽一个价值以建立另一个价值的过程统称为缩减。因此，在这种情况下我们可以得出结论，既然前两个列表都已用尽(空)，`Acc`一定是捡的时机成熟了。

```
merge([], [H | T], Acc) -> [H | merge([], T, Acc)];
```

第二个子句匹配第一个列表已经为空的情况，但是第二个列表中至少还有一个元素。`[H | T]`表示一个列表有一个头元素`H`，这个头元素[叠加到另一个列表](https://en.wikipedia.org/wiki/Cons#Lists) `T`上。在 Erlang 中，一个列表是一个链表，头部有一个指向列表其余部分的指针。所以一列`[1, 2, 3, 4]`可以认为是:

```
%% match A, B, C, and D to 1, 2, 3, and 4, respectively

[A | [B | [C | [D | []]]]] = [1, 2, 3, 4].
```

在这种情况下，正如您在 conning 示例中看到的，`T`可以只是一个空的尾列表。所以在第二种情况下，我们将它映射到一个新列表的值，在这个新列表中，当`T`是第二个参数时，第二个列表的`H`元素被连接到调用`merge/3`的递归结果上。

```
merge([H | T], [], Acc) -> [H | merge(T, [], Acc)];
```

第三种情况只是第二种情况的反面。它匹配第一个列表不为空，但第二个为空的情况。这个子句以类似的模式映射到一个值，除了它用第一个列表的尾部作为第一个参数调用`merge/3`，并保持第二个列表为空。

```
merge([Ha | Ta], [Hb | Tb], Acc) ->
  case Ha =< Hb of
    true  -> [Ha | merge(Ta, [Hb | Tb], Acc)];
    false -> [Hb | merge([Ha | Ta], Tb, Acc)]
  end.
```

先从`merge/3`的肉开始吧。此子句匹配第一个和第二个参数是非空列表的情况。在这种情况下，我们输入一个`case … of`子句(相当于其他语言中的 switch case)来测试第一个列表的头元素(`Ha`)是否小于或等于第二个列表的头元素(`Hb`)。

如果这是真的，我们将`Ha`连接到下一个递归调用的结果列表上，与前面第一个列表的尾列表(`Ta`)合并，作为新的第一个参数。我们保持第二个和第三个论点不变。

这些条款构成一个单一的功能，`merge/3`。你可以想象它可能是一个单一的函数子句。我们可以使用复杂的 case … of 和/或 if 条件加上模式匹配来剔除每个案例，并将其映射到正确的结果。这将使它变得更加混乱，因为你可以很容易地在单独的行上看到函数匹配得非常好的每一种情况。

然而，对于细分操作，事情变得有点棘手，这需要两个函数:`half/1`和`half/3`。

```
half([]) -> {[], []};
half([X]) -> {[X], []};
half([X,Y]) -> {[X], [Y]};
half(L) ->
  Len = length(L),
  half(L, {0, Len}, {[], []}).

half([], _, {Acc1, Acc2}) ->
  {lists:reverse(Acc1), lists:reverse(Acc2)};
half([X], _, {Acc1, Acc2}) ->
  {lists:reverse(Acc1), lists:reverse([X | Acc2])};
half([H|T], {Cnt, Len}, {Acc1, Acc2}) ->
  case Cnt >= (Len div 2) of
      true -> half(T, {Cnt + 1, Len}, {Acc1, [H|Acc2]});
      false -> half(T, {Cnt + 1, Len}, {[H|Acc1], Acc2})
  end.
```

这就是你会想念 Python 及其破坏性的地方。在纯函数式语言中，列表是链表。当你和他们一起工作时，就没有回头路了。没有逻辑说“我想把一个列表分成两半，所以我要得到中间的索引，并把它分成两个部分:左边的*和右边的*和**

如果你决定使用链表，你会更倾向于“我只能在链表中前进，一次使用几个元素”。我需要创建两个空列表，并记录我从源列表中检索了多少项，并放入第一个列表中，这样我就知道什么时候该切换到另一个桶了。上述所有内容都需要在递归调用中作为参数传入。”咻！

换句话说，把一个单子切成两半就好比用一把刀子在奶酪中间切一块奶酪。另一方面，这样做的功能比较就像将咖啡平均倒入两个杯子中——您只需要知道什么时候停止倒入第一个杯子，然后转向第二个杯子。

`half/1`函数虽然不是真正必需的，但它是为了方便而存在的。

```
half([]) -> {[], []};
half([X]) -> {[X], []};
half([X,Y]) -> {[X], [Y]};
half(L) ->
  Len = length(L),
  half(L, {0, Len}, {[], []}).
```

到目前为止，您应该知道每个 Erlang function 子句在做什么。这里的新括号对表示 Erlang 中的元组。是的，我们正在返回一个左右值对，就像在 Python 版本中一样。`half/1`函数在这里处理简单、明确的基本情况，这些情况不值得传入其他参数。

但是，请注意最后一种情况，即参数的列表包含两个以上的元素。(注意:少于或等于两个元素的已经由前三个子句处理。)它简单地计算以下内容:

*   列表的长度`L`并以`L`作为第一个参数调用`half/3`
*   一对计数器变量和列表的长度，它们将用于表示从列表一到列表二的切换
*   当然，还有一对空列表来填充来自`L`的元素。

```
half([], _, {Acc1, Acc2}) ->
  {lists:reverse(Acc1), lists:reverse(Acc2)};
```

看起来很乱，但只有未经训练的人才看得见。当源列表耗尽时，第一个子句匹配一个模式。在这种情况下，第二对计数器和长度无关紧要，因为它已经是结束。我们只知道`Acc1`和`Acc2`是时候让步了。但是等等，这两者的颠倒是怎么回事？

向链表追加元素是一个非常慢的操作。对于每次追加，它都要运行 O(N)次，因为它需要创建一个新的列表，将现有的列表复制到列表上，并创建一个指向新元素的指针，然后将它赋给最后一个元素。就像重做整个列表一样。再加上递归，你注定会遭遇灾难。

向链表中添加内容的唯一好方法是把它放在前面。然后它需要做的就是为这个新值创建一个内存，并给它一个链表头的引用。一个简单的 O(1)运算。因此，即使我们可以像使用`[1, 2, 3] ++ [4]`一样使用`++`来连接列表，我们也很少希望这样做，尤其是递归。

这里的技术是首先反转源列表，然后像`[4 | [3, 2, 1]]`一样在上面添加一个元素，然后再次反转它们以获得正确的结果。这听起来可能很可怕，但是把一个列表倒过来再倒回去是一个 O(2N)的运算，也就是 O(N)。但是在这两者之间，将元素加入列表只需要 O(1)，所以基本上不需要额外的运行时间。

```
half([H|T], {Cnt, Len}, {Acc1, Acc2}) ->
  case Cnt >= (Len div 2) of
      true -> half(T, {Cnt + 1, Len}, {Acc1, [H|Acc2]});
      false -> half(T, {Cnt + 1, Len}, {[H|Acc1], Acc2})
  end.
```

回到`half/3`。第二个子句是函数的核心，它做的事情与我们前面提到的倒咖啡的比喻完全一样。由于源列表仍在“发射”数据，我们希望跟踪我们从它向第一个咖啡杯`Acc1`注入值的时间。

还记得在`half/1`的最后一个子句中，我们计算了原始列表的长度吗？这里是 Len 变量，它在所有调用中都保持不变。它在那里，这样我们可以比较`Cnt`计数器和它除以 2，看看我们是否已经到了源列表的中间，应该切换到填充`Acc2`。这就是`case … of`的用武之地。

现在，让我们将它们一起放在`mergesort/1`中。这应该和 Python 版本一样简单，并且很容易比较。

```
mergesort([A]) -> [A];
mergesort([A, B]) ->
  case A =< B of
      true -> [A,B];
      false -> [B,A]
  end;
mergesort(L) ->
  {Left, Right} = half(L),
  merge(mergesort(Left), mergesort(Right), []).
```

#### 就是这样！

在这一点上，要么你认为这是一种新颖而有用的思考问题的方式，要么你觉得这只是简单的混淆。但是我希望你能从这种编程方法中得到一些东西，帮助我们思考算法。

#### **更新**

函数`merge`的 Python 实现效率不高，因为在每个`while`循环中，列表中的第一个元素被删除了。虽然这在函数式语言(如 Erlang)中是一种常见的模式，但在 Python 中，在最后一个位置之外的任何位置移除或插入元素的代价都非常高，因为与 Erlang 中的链表不同，Python list 的行为就像一个数组，当移除或添加一个元素时，它必须重新定位所有其他元素，从而导致 O(n)运行时。

更好的方法是牺牲很少的空间来为每个列表定义一个计数器变量，该变量可以递增并用于访问源列表的当前元素，而根本不需要删除最顶层的元素。

```
def merge(a, b):
    out = []

    ai = 0
    bi = 0

    while (ai <= len(a) - 1 and bi <= len(b) - 1): 
        if (a[ai] <= b[bi]):
            out.append(a[ai])
            ai += 1
        else:
            out.append(b[bi])            
            bi += 1

    while (ai <= len(a) - 1):
        out.append(a[ai])
        ai += 1

    while (bi <= len(b) - 1):
        out.append(b[bi])
        bi += 1

    return out
```