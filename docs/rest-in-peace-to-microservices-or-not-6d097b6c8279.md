# 安息吧:真实例子中的微服务与整体服务

> 原文：<https://www.freecodecamp.org/news/rest-in-peace-to-microservices-or-not-6d097b6c8279/>

通过 RDX

# 安息吧:真实例子中的微服务与整体服务

![VdzzAyuUrLQghJ6uM63rf8ykFaz9ZycYd3S0](img/0611073460026a352be8c56806c946a6.png)

[Image credit](http://thepatternlibrary.com/)

我咨询过十几个微服务项目。有些很棒*(这是未来！)*还有一些同样令人沮丧的*(谁发明了这种垃圾？)*

重要的是执行，而不是方法。你可以成功，也可以失败。不要只是接受外面的爱/恨宣传。

以下是我的一些经历，展示了单片和微服务如何发挥作用。

### 为正确的工作选择正确的工具

我的团队开发了一个新闻阅读器应用程序。它必须抓取文章、提取内容、分类、提供 API、显示管理面板和管理用户。

*   [Scrapy](https://scrapy.org/) (当时的 python 2)在网页抓取方面是佼佼者。所以我们创建了一个抓取网址的微服务。(如果你感兴趣，这里有更多关于我与 Tor、Privoxy 和一个过程管理器的 [15MB Docker 图像。)](https://medium.com/@rdsubhas/docker-image-with-tor-privoxy-and-a-process-manager-under-15-mb-c9e344111b61#.pa0hop2iy)
*   [报纸](https://github.com/codelucas/newspaper) (python 3)是最好的开源文章提取库之一。所以我们创建了一个微服务，给定一个输入 URL，返回提取的内容。
*   R 有一些很好的分类库。一位精通 R 的同事使用 R 的 REST API 开发了一个文章分类服务。
*   ActiveAdmin 是最好最简单的管理面板界面之一。很长一段时间以来，我们一直将它用于管理屏幕，我们也在几天内将其连接到这里。
*   最后，对于 API 网关，我们使用 Node.js 和 [PassportJS](http://passportjs.org/) (用于多重认证)以及 ElasticSearch。

在这次大改写之前，我们的旧应用程序是一个 Rails 的庞然大物。它试图重新发明之前提到的一切。您可以想象代码、工作和时间对于质量、进度和产出的权衡。

糟糕的巨石柱试图改造世界。他们认为代码和设计模式是所有事情的解决方案。他们努力构建可重用的组件、库，同时也成为一个平台。但是他们通常不会在这些目标上取得成功。

**外卖#1:** 微服务是一种业务解决方案，而不仅仅是一种技术解决方案。它们让开发人员不必浪费时间重新发明已经解决的技术问题。

我不在乎你称它们为“服务”、“面向服务的架构”还是“微服务”。一旦我们忘记了那些流行词汇，“整体服务对微服务”可以归结为“1 服务对 N 服务”

对于我们的应用程序，“N 个服务”就是我们想要的堆栈。

### 怪物 CRUD 应用

一些企业项目可以简单地归类为怪物 CRUD(创建-读取-更新-删除)应用程序。它们是永无止境的表单、数据关系、转换和极其复杂的“业务逻辑”范围很大，但受众很小。

这里没有人关心用户体验的最佳实践，快速而丑陋的屏幕完成工作是很常见的。

我们有一个这样的企业转型项目。旧的 monolith 是基于数据库视图的集成。它设计得非常好，只需要几个人来维护，包括丑陋的用户界面。

新的后端服务大部分是用 Java 编写的，因此很难开发、集成、共享和维护兼容性。新的前端服务被带入了不断变化的单页面应用程序世界。

部署需要庞大的基础设施自动化设置。这是几年前的事了，那时开发者工具生态系统还没有成熟。当时，每一项合同变更都需要手工协调和更新。这与之前的场景相反——微服务的工作/产出/开销感觉比旧的整体服务大得多。

**外卖#2:** 小心。将微服务视为将代码层分割成一个个有序的盒子可能会导致“千刀万剐”

### 驯服一棵巨大的依赖树

我们还有另一个遗留企业应用程序转换，它做了很多事情，比如产品收集和并行聚合。这是一个复杂的，已经麻烦不断的庞然大物。

当我们在一个应用程序中处理大量正交的业务特性时，会产生一个巨大的编译时依赖树，包含大量的库和框架。因此，运行时足迹、生命周期和构建时间也很长。这导致了真正的问题:开发人员不能快速迭代，因此功能的上市时间受到影响。

编写一个简单特性的代码所需的时间:几天。

升级一个 library _juice)版本的时间:1 周。

升级一个框架(Spring)版本所花费的时间:永远。

琐碎的东西有机会撕开每一次估计。即使一个小重构也要花很长时间。事实证明，千刀万剐也有可能杀死巨石柱。

我们把这个项目分成几个功能界限。我们积极地确保不共享库，并避免依赖树瓶颈。

例如，我们使用现代客户端库通过 PubSub 为微服务发布消息。但是 monolith 庞大的依赖树不允许我们使用同一个库。所以我们使用了不同的基于 HTTP 的 PubSub 客户端。

微服务迁移者经常犯共享太多库的经典错误，从而重新创建相同的编译时依赖树(一个“分布式整体”)。

但是通过避免共享功能，我们可以使用不同的库来完成相同的任务，而不必升级世界。

其中一个服务需要大量的并发性(每个请求需要大约 1k 次查找)。它最初利用了 RxJava。但是它可以在 Golang 中用相同的 API 契约随时重写，没有人会关心依赖树。

**要点 3:** 有了微服务，你再也不会听到“大重写”或“遗留系统”这样的术语，因为没有大系统。

### 可扩展性神话

我的团队开发了一个代码评估应用程序。90%是 CRUD、用户界面和报告，10%是十几种语言的复杂代码评估。

在我们加入之前，它是一系列的微服务——每种语言一个，监听不同的消息队列。它有单独的前端即服务、管理面板即服务等等。他们最初的推理？可扩展性。

我们把整个东西都毁掉了，建造了一个更好的整体。它完全是作为一个 Rails 应用完成的——用户界面、管理、后端和候选界面。

代码评估部分作为后台作业(ActiveJob)运行。我们通过简单的、无状态的、一次性的 Docker 容器来解决这个问题。评估代码的核心契约从 REST/JSON 变成了 file/stdin/stdout。它的伸缩性比旧系统好得多，因为我们只需要增加后台工作人员来处理更多的代码评估。

从外部看起来像一个复杂的应用程序——支持 8 种主要编程语言和智能评估——在内部却极其简单。

**要点 4:** 你不需要微服务来运行一个服务或工作者的多个实例。好的 monoliths 也可以针对某些问题进行扩展。

创建可扩展的单片和不可扩展的微服务是完全可能的。这一切都归结于你如何很好地应用每个人的基本原则。

### 微服务作为产品

我参与过的最令人满意的微服务项目之一就是将微服务作为产品。我们的客户非常聪明，是技术功能型的人，他们显然在利用微服务作为商业工具。

他们将每个服务建模为一个产品，然后向不同的客户发布多个产品。他们以一种可以利用彼此的 API 的方式排列产品发布。反过来，他们创造了一个辉煌的生态系统。这使他们成为垂直市场的领导者。

如今，普通企业至少使用十几种软件产品和集成。普通云消费者使用多种云产品。我现在看到连非技术人员都在用微产品和微 app。例如，一个工具用于面试，一个用于假期跟踪，一个用于工资单等。人们正在采用更小、更专业的工具来正确完成工作。

**外卖#5** :我们正强劲而坚定地进入微产品、微应用和微服务时代。最好学会做好。

总是担心机器学习会抢走编程工作。如今，大多数编程工作都变成了 API。

### 分布式事务

反对使用微服务的一个最常见的理由是与分布式事务相关的风险。

您是否正在呼叫一个扣除款项的外部支付网关系统，但该系统可能会在您的回拨中失败？您是否有多种登录机制(如电子邮件或 OAuth)？您是否致电没有回滚选项的第三方 SaaS 产品？您是否在利用不考虑您的事务边界的云 API 和存储桶？您的工作流是否跨越同一服务的多个请求生命周期？

那么无论您喜欢与否，您已经以这样或那样的方式拥有了分布式事务。

认为一个系统和一个请求可以代表或控制业务问题的整个事务状态的想法是一种幻想。如果您可以在没有分布式锁和事务的情况下对外部集成建模，那么您也可以对内部集成建模。

**外卖#6** :分布式锁和交易也不能免费使用 Monoliths。

### 工具 vs 人

是的，更多的服务意味着更多的工具。这包括持续集成和持续部署(CI/CD)、基础设施自动化、开发人员工具、设计良好 API 的能力、合同共享、文档、客户端智能和库、流程、测试以及许多其他工具。

你必须至少有这么高才能乘坐微服务。

如果一个组织没有足够的工程健壮性和成熟度来毫不费力地运行一些服务(12 因素、CI、CD、集成、测试等)，转换到其中的许多服务将是一场灾难。

许多有着独一无二思维的人会提前做好大的设计。微服务最好是当它们**在你面前**的时候。只是[扔掉所有的样板](https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8)，以一种严肃的方式实现 API，而不是在高质量的单元/合同测试上投入时间。就像工具对人一样——微服务需要思维方式的改变，以及大量的**遗忘**。

好消息是，这些工具问题中的许多都有很好的工程解决方案。Docker、Kubernetes、REST、Swagger、Falcor、gRPC、CI/CD 管道工具、PaaS、Cloud 等等。围绕微服务的生态系统已经相当成熟，并且一直在改进。

坏消息是微服务不能像框架或工具一样学习。他们需要一种来自经验的整体方法。你需要优秀的人，他们不仅是蛮力型的优秀程序员，而且是在整个软件开发生命周期(从开发到测试再到部署)中具有坚实基础的全面发展的工程师。

有些大企业每一次整合都要花费数月时间。还有像谷歌、脸书和网飞这样的现代公司，它们以更高的质量和速度运行着数以千计的集成服务。区别不仅仅在于工具，还在于参与的人和他们的工程方法。

**要点 7** :微服务是多种工程实践的结晶。他们有一个陡峭的学习、遗忘和转化曲线。

#### 结论

微服务方法只是解决方案专家工具箱中的另一个工具。工具只是工具。它最终可能成为强大的业务资产，或者成为低效的开发瓶颈。我们是对是错都归结于我们如何使用这个工具。