# 编程中的垃圾收集指南

> 原文：<https://www.freecodecamp.org/news/a-guide-to-garbage-collection-in-programming/>

## 什么是垃圾收集？

通俗地说，垃圾收集(GC)就是收集或获取已经分配给对象但当前没有在程序中使用的内存。

让我们进入更多的细节。垃圾收集是程序试图释放对象不再使用的内存空间的过程。

每种语言的垃圾收集实现方式都不同。大多数高级编程语言都内置了某种垃圾收集。低级编程语言可能会通过库添加垃圾收集。

如上所述，每种编程语言都有自己执行 GC 的方式。在 C 编程中，开发人员需要使用 malloc()和 dealloc()函数来处理内存分配和释放。但是，在 C#的情况下，开发人员不需要关心 GC，也不建议这样做。

## 内存分配是如何发生的？

在 C#中，对象的内存分配发生在托管堆中，由 CLR(公共语言运行时)负责。堆的内存分配在操作系统中是通过 win32 dll 完成的，类似地在 c 语言中也是如此。

但是，在 C 中，对象被放在内存中任何有适合对象大小的空闲空间的地方。此外，内存映射基于链表概念工作。在 C#中，堆的内存分配以线性方式一个接一个地进行。

每当创建一个新的对象时，就在堆中分配内存，并将指针移动到下一个内存地址。C#中的内存分配比 C 快，这是因为在 C 中内存需要为对象进行搜索和分配。所以它会比 C#多花一点时间。

## C# GC 中的代

英寸 net 编程中，堆有三代，称为第 0 代、第 1 代和第 2 代。每当创建新对象时，第 0 代首先被填充。然后垃圾收集器在第 0 代填满时运行。新创建的对象放在第 0 代中。

在执行垃圾收集时，所有不需要的对象都被销毁，因此内存得到释放和压缩。一旦发生垃圾回收，垃圾回收负责指向被释放内存的指针。

第 1 代和第 2 代包含具有更长生存期的对象。在第 0 代有足够的内存分配之前，第 1 代和第 2 代上的 GC 不会发生。

您不应该以编程方式调用 GC。顺其自然就好。每当第 0 代填满时，GC 就会得到调用。

## GC 的利与弊

垃圾收集是一个为程序员节省时间的工具。例如，它取代了 c 语言中对 malloc()和 free()等函数的需求，它还有助于防止内存泄漏。

垃圾收集的缺点是对性能有负面影响。GC 必须定期运行程序，检查对象引用并清理内存。这会占用资源，并且经常需要程序暂停。

## 什么时候做

如果一个对象没有引用(不再可达)，那么它有资格进行垃圾收集。

例如，在下面的 Java 代码中，最初由“thing1”引用的 Thing 对象的唯一引用被重定向到堆中的另一个对象。这意味着它是不可访问的，它的内存将被垃圾收集器分配。

```
class Useless {
  public static void main (String[] args) {
  Thing thing1 = new Thing();
  Thing thing2 = new Thing();
  thing2 = thing1; // direct thing2's reference towards thing1
                   // no references access thing2
} }
```

垃圾收集的一个例子是 ARC，它是自动引用计数的缩写。例如，这在 Swift 中使用。ARC 归结为跟踪所有被创建对象的引用。如果引用数量下降到 0，对象将被标记为释放。

#### **更多信息:**

*   [https://docs . Microsoft . com/en-us/dot net/standard/garbage-Collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)-了解更多关于垃圾收集的信息