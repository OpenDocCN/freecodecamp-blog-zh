# 在 Swift 中查看映射、过滤和减少的幕后操作

> 原文：<https://www.freecodecamp.org/news/a-behind-the-scenes-look-at-map-filter-and-reduce-in-swift-1991f5c7bc80/>

一个函数接受一些输入，对它做一些事情，然后创建一个输出。函数有一个签名和一个主体。如果你给一个函数相同的输入，那么你总是得到相同的输出。简而言之就是 ***功能*** 的定义。

现在我们将通过更深入地了解函数来更多地讨论它们。我们将在 Swift 中探索高阶函数。将另一个函数作为输入或返回一个函数的函数称为 **高阶函数**。

在 Swift，我们每天都在玩**地图，过滤，还原**。当我们使用这些功能时，就像变魔术一样。此时，您可能不知道幕后发生了什么。通过函数式编程的思想和方法来映射、过滤和减少工作。尽管 Swift 不是一门纯粹的函数式语言，但它允许你做函数式的事情。

现在让我们一个接一个地看看在他们的背景下发生了什么。首先，我们将为一些特定的数据类型实现这些函数的基本版本，然后我们将尝试实现一个通用版本。

#### 地图功能

假设我们有一个整数数组，我们需要写一个函数，在给原始数组的每个元素添加一些 delta 值后，返回一个新的数组。我们可以使用一个简单的 for 循环轻松地编写一个函数，如下所示:

现在我们需要另一个函数，它通过将原始数组的每个元素加倍来返回一个新数组。为此，我们可以这样实现它:

如果我们看上面两个函数，可以发现它们基本上做的是同样的事情。只有 for 循环内部的功能不同。它们都将一个*整数*数组作为输入，通过使用 for 循环转换每个元素，并返回一个新数组。所以基本上主要的事情是把每个元素转化成新的东西。

由于 Swift 支持高阶函数，我们可以编写一个函数，该函数将接受一个整数数组，转换该函数作为输入，并通过将转换函数应用于原始数组的每个元素来返回一个新数组。

但是，上面仍然有一个问题:它只返回一个整数数组。例如，如果我们需要将输入的整数数组转换成字符串数组，那么我们就不能用这个函数来实现。为此，我们需要编写一个适用于任何类型的通用函数。

我们可以在数组扩展中实现一个通用函数，如下所示:

1.  在数组扩展中声明一个映射函数，它使用泛型类型 **T** 。
2.  该函数采用类型为**(元素)- > *的函数；*** T 为输入
3.  声明一个空的结果数组，该数组在函数中保存 **T** 类型的数据。
4.  实现一个迭代自身的 for 循环，并调用 transform 函数将元素转换为类型 **T**
5.  将转换后的值追加到结果数组中

这就是 Swift 中的 **map** 功能的工作方式。如果我们需要实现**地图功能*，*** ，那么我们会像上面这样实现它。所以基本上，它不会在数组中产生任何奇迹——我们可以很容易地自己定义函数。

#### 过滤功能

假设我们有一个整数数组，我们想只保留数组中的偶数。我们可以通过使用一个简单的 for 循环来实现这一点:

现在，假设我们有一个表示项目的类文件名的字符串数组，我们只想保留 ***。*迅捷**文件。这也可以通过如下所示的单个循环来完成:

如果我们仔细观察上面两个函数的实现，我们会发现它们基本上做的是同样的事情——只是两个数组的数据类型不同。我们可以通过实现一个通用的过滤函数来概括这一点，该函数将一个数组和一个函数作为输入，并根据 **includeElement** 函数的输出来决定是否将元素添加到结果数组中。

#### 减少功能

假设我们有一个整数数组，我们想实现两个函数，返回元素的和与积。我们可以通过使用一个简单的 for 循环来实现这一点:

现在，假设我们有一个字符串数组，而不是一个整数数组，我们想要连接数组中的所有元素:

这三个功能基本上做同样的事情。它们将一个数组作为输入，初始化一个结果变量，迭代数组，并更新结果变量。

从这里我们可以实现一个通用的函数，它应该适用于所有人。为此，我们需要结果变量的初始值以及在每次迭代中更新该变量的函数。

所以我们可以用下面的定义来实现通用函数:

上述实现对于任何类型为 **[Element】的输入数组都是通用的。它将计算一个类型为 **T** 的结果。为了工作，它需要一个类型为 **T** 的初始值来赋给一个结果变量。然后，它需要一个类型为 **(T，Element) - >** T 的函数，该函数将在每次迭代的 for 循环中使用，以更新结果变量。**

#### 感谢您的阅读！