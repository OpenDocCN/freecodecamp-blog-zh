# 创建一个 REST API。NET 5 和 C#

> 原文：<https://www.freecodecamp.org/news/create-a-rest-api-with-dot-net-5-and-c-sharp/>

。NET 是微软开发的一个流行的软件框架。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一门课程，将教你如何使用最新的技术从头开始创建一个端到端的 REST API。NET 5 创新和 Visual Studio 代码。本课程使用 C#编程语言。

胡里奥·卡萨尔开发了这个课程。他是微软的高级软件工程师，也是一名优秀的教师。

以下是本综合课程中涵盖的所有部分:

### 入门指南

*   介绍
*   创建项目
*   浏览生成的项目文件
*   信任自签名证书
*   探索默认的 Swagger UI 页面
*   配置 Visual Studio 代码设置

### 实体、存储库、控制器获取

*   介绍
*   添加实体
*   添加内存存储库
*   创建控制器
*   实现获取所有项目
*   实现获取单一项目
*   返回 404 未找到状态代码

### 依赖注入

*   介绍
*   什么是依赖注入？
*   提取存储库接口
*   将存储库注入控制器
*   将存储库注册为单例
*   添加数据传输对象 DTO
*   创建 AsDto 扩展方法

### 发布、上传、删除

*   介绍
*   实施岗位
*   通过数据注释添加验证
*   实施 PUT
*   实现删除

### 用 MongoDB 持久化实体

*   介绍
*   使用邮递员
*   创建 MongoDB 存储库
*   使用 MongoDB。驱动程序 NuGet 包
*   实现 MongoDB 创建
*   运行 MongoDB Docker 容器
*   配置 MongoDB 连接设置
*   注册 MongoClient singleton
*   测试 MongoDB 集成
*   在 VS 代码中探索创建的数据库
*   实现 MongoDB 获取、更新和删除

### 任务，异步和等待

*   介绍
*   使用异步后缀
*   使用存储库中的任务
*   使用异步和等待
*   返回已完成的任务
*   使用控制器中的任务
*   在 Postman 中测试异步方法

### 秘密和健康检查

*   介绍
*   在 MongoDB 中启用身份验证
*   使用。网络秘密管理器
*   在服务中使用 MongoDB 凭证
*   健康检查简介
*   添加运行状况检查的端点
*   添加 MongoDB 运行状况检查
*   添加就绪性和活性检查
*   自定义运行状况检查响应
*   探索其他运行状况检查 NuGet 包

### 码头工人

*   介绍
*   Docker 是什么？
*   正在删除 https 重定向
*   在 VS 代码中生成 docker 文件
*   建立码头工人形象
*   添加 Docker 网络
*   在码头网络中运行集装箱
*   在 Docker 中运行 REST API
*   将容器映像推送到 Docker Hub
*   探索 Docker Hub 中的图像
*   将图像拉回到本地盒

### 库伯内特斯

*   介绍
*   What is Kubernetes?
*   在 Docker Desktop 中启用 Kubernetes 集群
*   为 VS 代码安装 Kubernetes 扩展
*   声明 rest api kubernetes 部署
*   在 Kubernetes 创造一个秘密
*   声明健康探测器
*   声明 REST API Kubernetes 服务
*   在 Kubernetes 中创建 REST API 资源
*   宣布 MongoDB Kubernetes 州集合
*   声明 MongoDB Kubernetes 服务
*   在 Kubernetes 中创建 MongoDB 资源
*   测试托管在 Kubernetes 中的 REST API
*   探索 Kubernetes 的自我修复能力
*   缩放立方体 pods
*   通过 ILogger 添加日志
*   在 Kubernetes 中获得新的图像版本
*   跨 pod 的负载平衡请求

### 单元测试和 TDD

*   介绍
*   什么是单元测试？
*   什么是测试驱动开发？
*   重构文件和目录
*   创建 xUnit 测试项目
*   在 VS 代码中构建多个项目
*   为单元测试添加 NuGet 包
*   测试 GetItemAsync 不存在的项目
*   使用 AAA 模式
*   通过 Moq 清除依赖关系
*   在 VS 代码中运行测试
*   使用。NET 核心测试资源管理器扩展
*   测试 GetItemAsync 现有项目
*   使用 FluentAssertions
*   测试 GetItemsAsync
*   测试 CreateItemAsync
*   测试 UpdateItemAsync
*   测试 DeleteItemAsync
*   重构和捕捉回归
*   使用 TDD 来测试一个尚未创建的方法
*   通过修复失败的测试回到绿色
*   在 Postman 中测试新的控制器方法

观看以下课程或 freeCodeCamp.org YouTube 频道上的[(6 小时观看)。](https://youtu.be/ZXdFisA_hOY)

[https://www.youtube.com/embed/ZXdFisA_hOY?feature=oembed](https://www.youtube.com/embed/ZXdFisA_hOY?feature=oembed)

### 视频抄本

(自动翻译)

您将学习如何使用。NET 5 来创建一个 Rest API。这门课程的创建者是微软的一名高级软件工程师，他也是一名优秀的教师。

REST API 允许您的应用程序或系统向网络内外的多种类型的客户端公开其功能，包括互联网上的客户端。如果你想写一个程序从 Twitter，Yahoo，finance，甚至 NASA 收集数据，你就会用到这个。如果您正在考虑构建自己的 REST API，并且您正在考虑为其开发 dotnet 平台，请继续关注我，因为我将向您展示如何使用 dotnet 提供的最新创新来实现这一点。五，希望你喜欢。

在本教程的第一部分，您将学习整个教程中使用的场景，如何从头开始创建 dotnet five Web API 项目，如何使用 Visual Studio 代码来构建和调试项目，我们将学习如何绘制 dotnet 安装的开发证书。五个，这是 HTTPS 访问以及如何使用 swagger UI 与 API 交互所需要的。

按照教程，你需要一些东西，包括 dotnet，五个 SDK，Visual Studio 代码和对 C sharp C sharp 语言的一些基本理解。

现在让我们来讨论一下这个场景，我们将把它作为本教程的一个领域。让我们想象一下，我们有一个目录系统。我们有一大堆可用的物品。从这个意义上来说，我是一个视频游戏玩家，所以我喜欢把这些东西想象成我会在视频游戏中使用的东西。所以像药水，剑，盾牌之类的东西。没错。这是我们现有的系统，它有一个目录。当然，我们会有一些用户想要通过他们的浏览器来清除这个目录，对吗？他们有一个浏览器，他们想以某种方式管理这些目录项目。

他们想做的是，我们如何在目录中创建商品？我们如何检索该目录中当前可用的商品列表？亨卡。我们更新项目的属性。以及如何删除该目录中的商品。所以今天，我们确实有目录。但是我们没有办法将这个目录公开到互联网上，这样人们就可以通过浏览器来使用和管理它。这就是我们要为这个目录介绍 REST API 的地方。在本教程中，我们将看到如何使用 dotnet 从头构建这个 REST API。五个。

所以我们现在要做的是重新编码。我们要做的第一件事是开设一个全新的航站楼。在这个终端中，我们将切换到目录，在那里我们将创建我们的项目并创建一个项目，我们将使用. net CLR。

为此，我们要说的是，我们想要为 REST API 创建的新产品和产品类型将是 Web API。项目的名称是 catalog，按回车键。

这就创建了你的种族的所有文件，在 web API 模板上面对它。现在，我将打开生成的目录文件夹。

和 a 一样，当您像往常一样打开 a 时，当您在 Visual Studio 代码中打开一个 dotnet 项目时，它会提示您添加几个用于构建和调试项目的附加文件。所以我要说 Jess，那些文件在 Ws 代码下得到 d 级。在左侧，你可以看到所有生成的文件。让我们快速浏览一下这些文件

因为周围缺乏爱。所以我们要看的第一部分是 ACS proc 文件。这个文件被称为项目文件。这用来声明我们将如何构建这个项目。在这种情况下，我们说我们将使用 dotnet web SDK 来构建项目，其中包括一系列专门为 web 类项目设计的工具和任务。下一个有趣的事情将是目标框架，一个监视器或目标框架，在我们的例子中是 net five。目标框架定义了 API 或接口，或者什么样的 API 可以用于你的项目。在这种情况下，5 对我们来说非常好。下一件事是一堆牛轧糖包，我们现在不打算深入研究。但这些只是我们在这个项目上已经获得的依赖。关闭它，接下来我们将看看这个程序。看见

他的发音就是我们所说的申请的切入点。这将会做的就是和宿主赛跑或者站起来。我的意思是，这个过程将成为我们问题的主体。它还声明了一堆默认值。它还为我们的项目设置了我们称之为 startup 的启动类。所以让我们实际上去一个创业公司，看看那里发生了什么。

真的，主要的事情和启动是

我们有一个名为 configuration 的属性，它是作为启动构造函数的一部分接收的。这是您可以在任何时候使用的，您需要从多个来源读取一些配置信息，例如从环境变量或文件、不同种类的文件或一堆其他地方，您不想硬编码的配置是您的服务。下一个有趣的方法是配置服务。这是一个你可以

注册您将在应用程序中使用的所有服务。我们将在稍后的视频中讨论这个问题。最后一个有趣的部分是配置方法。

这是我们配置 a 的地方

ASP 上的请求管道。网。这只是定义了一些典型的中间件，它们是

将在、控制器或代码实际执行之前执行的附加组件。所以每一个都可以执行

当请求进入时，进入 ASP。NET 进程。从那里一直到你的代码执行。但我们不会在这个视频中探究这一部分。

还有一些其他的事情，所以我们有一个天气预报。这是为这个示例应用程序生成的模型，这里只有一些非常简单的属性。除了这个模型，还有一个控制器。现在 ASP 中的控制器。NET 差不多就是处理路由的类。

是的，基本上是您的服务公开的路线，对，但我们不会在此视频中使用这些路线。所以我们不要太深入。

其他一些文件被打乱了。json，这是你可以声明配置的地方，那将是你不希望在你的，你的程序，你的源代码中使用硬代码。因此，现在，它只是有一些登录配置和应用程序中允许的批发商。还有一个 appsettings JSON 的变种，开发起来很荒谬，Jason。所以开发，我的意思是，事实是，a 说开始开发 JSON 意味着我们正在开发环境中运行，

这些设置将优先于对面的是杰森。因此，您可以为您的每个环境(如生产、测试集成等所有这些环境)准备一堆 appsettings 文件。

我将谈到环境，这可能是一个很好的时机来看看文件时代与代码，这是一个任务和逻辑贾森做了很多，贾森只是一个文件，它用这些关键概念和代码片段来声明任务，你可以声明任务，任务可以是一堆东西。在我们的例子中，最有趣的是我们想要使用运行 dotnet build 命令。所以 dotnet build，将用于构建我们的代码。就启动 JSON 而言，这是一个文件，它控制着当我们确实喜欢 f5 时将启动或执行什么。或者当我们开始调试的时候，代码已经指向正确的 DLL 开始调试了。

最后，

我们也有启动设置。因此，Jason 真正感兴趣的是应用程序的 URL。在这里，我们为我们的应用程序定义 URL，URLs Imperial，在这种情况下，我们说我们将在 localhost 5004 中为我们的服务器提供服务，HTTPS 版本将在其中提供服务，默认版本将是 5001。我们还声明了实际的 a，一个 spinet 核心环境变量。我们把它设定为发展。因此

同样，在商业上也是如此。这不是真正的那个更难的那个会更难吃午餐，杰森。正如你在这里看到的。这是一个先例，如果它是重新编码。所以这很好。

我们现在要做的实际上是测试这个项目，以确保一切按预期运行。所以我要做的是切换到调试中心。

听我说得更详细一点。所以我要做的就是点击并开始工作。让我们看看会发生什么。

没错。所以会弹出一个浏览器。如果你在这里看到这些页面，a，这意味着很正常，这意味着我们没有脱离网络的自签名证书，它不被信任。对吗？因此，有一个非常简单的方法来规避决策，并适当地信任 dotnet 附带的调查。所以让我把这个关上，然后停下来。让我们切换回终端。实际上让我在这里开辟一个新的终端。是的，在那里。

因此，为了信任与 dotnet SDK 捆绑在一起的证书，您只需键入 dotnet，def cert，https

信任。

当你运行这个，你会得到这个弹出窗口，要求你确认你确实想要信任这个证书，我会说是。然后我们应该去做。所以我要再运行一次。

让我们看看我们得到了什么。

好吧，所以是的，所以我们还是什么都没得到。但是我们再也看不到任何信任问题了。现在，如果我们想在这里看到一些有意义的东西，虽然在这一点上对我们来说并不太重要，但你可以做的只是去 swagger。

然后你会得到这个漂亮的用户界面。这就是我们所说的 swagger，也是一个开放的 API 规范。这是一个现在和 dotnet，five 捆绑在一起的组件，所以你不需要做任何事情就可以使用它。如你所见，我们什么也没做。所以就在那里。在斜杠招摇的网址里。这样做的目的是让您可以轻松地描述 API 中可用的所有操作、所有动作和所有路线，并且让您也可以轻松地与它们进行交互。例如，如果我只是转到 get 路线，然后单击某个交易，单击执行，它将继续运行。我们可以看到这条路线的一些成果。

我在做这些项目时喜欢做的一件事是，每次运行项目时，不要打开浏览器。让我们实际上稍微改变一下 VS 代码的行为，让这个窗口保持打开。然后任何时候我们只要按 f5 或运行，它就不会打开更多的窗口。为此，我将在这里停下来。我们可以启动 JSON 并关闭它。

您唯一需要做的就是删除这里的服务器就绪操作部分。

差不多就是这样。如果我再跑一次，顺便说一下，你只要按 f5 就可以了，

我现在就做，五分钟。

如你所见，它开始运行，但我们没有，他没有再打开任何窗口，这很好。因为我们已经准备好调用浏览器了。

然后，就练习设置而言，我想做的最后一件事是简化我们如何分段构建项目以进行记录。因此，让我尽量减少，回到正题重新编码。停止这个，关闭那个我要做的是去数据 Jason。我要做的唯一一件事是将这一小部分添加到 build 任务下，这就是我们所说的组，它将进行构建，它说默认为 true。这使得我们可以更容易地构建一个项目。所以现在我可以去让我拯救这个被拯救的人。我可以去终端室建造任务并立即建造。没有它，我们只能弹出另一个菜单来进行构建。我现在也可以按 Ctrl+Shift+B，它会做同样的事情。所以，是的，这只是加快了我们的情况。

在 net five REST API 教程的第二部分中，我们介绍了 API 的基础，包括用于表示目录中的项目的核心实体、负责所有项目的存储库类、与存储相关的操作，以及处理发送给 REST API 的所有请求的控制器。

在这里，您将学习如何通过 C sharp 记录类型对实体建模。

如何实现内存仓库？

来源

以及如何实现带有 get route 的控制器来检索资源。

好了，现在我们对项目的初始设置感到满意了，是时候开始设置实体和存储库了，这些实体和存储库将用于存储和检索将在服务中使用的项目。所以我们要做的第一件事是，让我们关闭这些和终端。让我们去掉一些对我们的项目毫无意义的类。所以我就在这里删除天气预报吧。我会删除天气预报控制器。所以我们可以更干净地开始。

那么我们来介绍一下我们的实体，item 实体。为此，我们在这里添加一个名为

实体。因此，人们会说领域，因为很多人可能会看到模型，在我们的情况下，实体应该足够好。让我们在这里创建一个文件，姑且称之为

项目。这是肯定的。

让我们在这里遵循正确的名称空间。

所以下一页应该是目录，因为他戴着 ntds 文件夹，让我们说实体。

然后

这时你通常会做的是声明一个类，对，所以你会说公共类，让我们这么说。然而，由于一个点网，五和一个 C 升九，这里有一个新的选择，这就是我们所说的记录类型。所以记录类型几乎是一个很大的类别。但是他们对不可变数据有更好的支持，不可变数据模型，对吧，这意味着一旦你得到了这个对象的一个实例，就不可能真的修改它。这非常方便，尤其是对于通过电线接收的对象。所以所有这些都来自于，来自于网络，通常用一个来拿走它们，用它们做一些事情，但是你不想修改它们。没错。此外，记录类型有这样一个东西，在本教程的后面你会看到谁的表达式。然后还提供基于值进行比较的能力。他们称之为有效的平等，这意味着

当您比较某项的这两个实例时，在这种情况下，

只有当实例的所有属性都相同时，这些实例才是相等的，而不仅仅是对象本身的身份，这是类的情况。因此，记录类型非常方便，我认为对于我们将在这里使用的对象来说，这是一个很好的选择。因此

让我们换一节课来记录。现在，是时候介绍这个记录的属性了。所以让我们在这里添加几个属性。让我们来看看。所以让我们用一个好的来代表我们的身份。

让我导入该系统，您的系统名称空间在那里丢失了。在添加更多属性之前，让我在这里做一个小小的改动。所以不用 Get set，我们改用它。所以你为什么会看到它。这是 dotnet 中 in C sharp nine 的又一新增功能。五个，非常适合，

对于属性初始值设定项。我们只允许在初始化的时候设置一个值。这意味着，例如，在过去，你可以说你可以说，准备好。这意味着在你创建了对象之后，你可以一次修改一个 ID。所以这不是我们想要的，我们想要一个不变的属性。所以对于不可变的，我们将不得不设置

私处，对。所以这使得它不可改变。但是现在构造任何一组这样的对象都很有挑战性。现在我们必须引入一个构造函数。然后，我们的客户没有一个真正更好的方式来浏览我们的对象。因此，为了达到一个良好的中间状态，他们在这里引入了 init 访问器。所以这意味着

您可以使用创建者创建表达式来构造此项目对象，就像您将使用带有集合的一样。但是创建之后，你就不能再修改这些属性了。所以这是两个词之间很好的平衡。稍后我会看看事情会如何发展。现在，让我们定义一下我们的属性。让我们来看看。让我们加上当然，名字。

姓名。

研究名字真好

哦，

也在里面，我们补充一下，

让我们为我们的项目添加一个价格。

价格，也在其中。

最后，

让我们补充一下

时间偏移。这是

太好了。

这将是物品在系统中被评分的日期和时间。让我们也不要忘记改变这一点。

现在是时候介绍我们的存储库了，这个类将负责在系统中存储项目。现在为了简单起见，我们将只使用内存中的存储库。在本教程的几集之后，我们将引入一个合适的数据库。

因此，让我们在这里创建一个新文件夹，名为“存储库”。

在这里，我们将添加一个新文件。让我们称之为

隐藏的人物品类型是 30。

这里的写作空间不要忘记，它将是人们看到 30 年代的目录。

没错。

现在，让我们创建一个类。因此

神圣的类，我只是从主文件中抓取名称。

对吗？

我们要在这里做，就像我说的，这是在内存中。所以我们将定义一个非常简单的项目列表

将会是我们将要用到的初始化器。所以我们在这里声明一个租约。因此，让我们看看写入速率，并使其只读，因为它不应该改变。我的意思是，在我们构建这个存储库之后，租约的实例不应该改变。

对象。

作为一个项目列表是很好的

我们曾经和他战斗过。

我认为，

是的，这些是物品。

是的，我们需要导入

两个名称空间，它们的集合是最不通用的。以及该项目的其他实体。

我们想说这是新的。

我们想宣布名单。现在这些是 C 调九度的另一个加法。

正如你在过去看到的，你可能需要说好的，所以这是新的项目列表，对吗？但这有点多余。因为我们已经清楚地知道这是一个项目清单。那么为什么，为什么这么多的仪式，所以让我们只是消除这一点。这就是你现在需要做的。很好的加法，升 C 九。

所以我们在这里补充几项。所以让我们说新的项目。

让我们，让我们做

这里的初始化。所以我们就随机选择吧。

你去找身份证。再一次，让我们把博物馆变成一个空间。所以对于这个名字。因此

就像我在介绍中提到的，我喜欢在视频游戏项目方面玩这些想法。所以我要选择的第一个项目是堕胎。这些电子游戏中的超级经典。假设这个的价格是 9 美元。和创建日期。好吧，我就说

他们抵消了

信息技术等。现在。这意味着现在是 UTC 时间，不是当地时间，只是 UTC 时间。

评估我们需要这些，让我们添加一个

再来几个。

所以同样好。我是说，给每一个都换一个新的图形用户界面。但是让我们称这个为。这将是一个闲置的词，度假村。假设它会更贵。20 分钟吧。最后一个，假设我们要做

玫瑰拍摄。

比方说，要便宜一点。

好吧。哦，我们已经准备好了最初的项目清单。

现在在这个仓库里，我们要处理一堆东西，对吧。那么我们如何得到一个项目呢？我们如何获得项目集合？我们如何创建一个项目更新，删除所有这些东西。为了简单起见，让我们从 get 开始。所以我们要在这里得到金属。

第一个是 get items，如果我们要做的话，我们将返回 item 的 ienumerable。

项目。对吗？因此，一个名义是非常基本的项目，它是一个基本的接口

您可以用它来返回一组项。

然后，是啊，这总是很简单，就像说，嗯，你的回报，无论我们现在有什么项目，它是

那种获取物品的方法。下一个也会是类似的。但是这个家伙只返回一个项目，它的名字是 get item。

但是这需要知道要返回的商品的 ID。对吗？

开始吧。然后。为了检索正确的项目，我们要做的是你说好的，让我们从项目集合返回。

我要说的是，这需要另一个重要的命名空间，它位于现在导入的链接中。

所以我们会说，好的，从这个列表中，

物品在哪里

身份证明

等于我们在参数中得到的 ID。

这将返回一个集合。但是我们不想要集合，这是一个，一个他应该找到所有文件所在的文件夹的项目？不。所以如果它找到了，它会返回它。如果没有找到，它将返回 null。

好了，这就是我们的知识库。接下来要介绍的是控制器。就像我说的，控制器将会是一个接收客户端发送的请求并正确处理它的类。那么让我们添加控制器类。所以新文件在控制器、文件夹和

场景，我们在这里处理的原因是一个项目。所以惯例就是给它命名。物品管理员。

这是肯定的。没错。同样，在这种情况下，安全权限命名空间目录将是控制器。好吧。

所以这个控制器将会是

所有类项目控制器。关于控制器类有趣的事情是，你总是想从控制器基类继承

这给了你一个重要的命名空间。

这将有效地把它变成一个控制器类，对吗？所以让我们总是从控制器基础继承。

这是第一件事。下一件事是将这个类标记为 API 控制器。就在那里。是啊，API 控制器。所以这为你的控制器类带来了一些额外的默认行为，这让我们的生活变得更容易。所以是的，不要忘记添加 API 控制器层。是的，顺便说一下，有大量关于这些属性的文档，或者

下一件事是宣布路线。因此，路由定义了一个，这个控制器将对这个 HTTP 路由做出响应。而且，

默认情况下，您在这里输入的只是控制器的名称。所以如果你这样做，这将意味着无论控制器的名字是什么，这将是路线。对吗？所以在这种情况下，比如说，

它会得到斜线物品，对吗？这将是我们将要使用的 URL 的一部分。

所以是的，我的意思是，你可以这样做。或者你可以明确地声明一个你想要使用的路径，比如，我可以说，两个条目，这是完全有效的。事实上，让我们坚持下去。

让我们继续前进。

当然，在这个控制器里，

对于我们要做的任何动作或任何操作，我们都需要我们刚才工作过的那个存储库。所以让我们举一个例子。我们将声明私有只读。

还是那句话，因为它不会在构造后被修改。

我想是 3030 号座位。没错。和

是的，任何我们准备好的地方。在继续之前。让我告诉你，随着我们的前进，我们会做出一些不太理想的选择。只是为了解释一下

一堆概念，对吧？所以事实上，我把显式依赖引入到我的记忆中。

这，这并不理想，但我只是想让事情变得简单，然后随着我们的前进而改进。对吗？所以这些人并不认为这是你应该如何做的最终决定。现在，我们将在这个控制器的构造函数中构造这些。所以让我们添加一个

高清控制器作为构造器。

好吧，那我们假设是，双层的

等于新名称。是的，没错。所以，嘣，我们有一个栓剂，随时可以使用？因此，让我们定义路由状态来查找路由。让我们来看看。我们如何找到取回所有物品的路线？在这个仓库里？让我们声明一个名为

Hi 可枚举。

物品？抱歉，物品，拿物品。

好的，这些方法将返回一个 ienumerable 项，就像存储库一样。让我们导入正确的名称空间。我们漏了吗？

好吧。

但是为了让这个方法成为一个路由，并对一些 HTTP 动词做出反应，你必须声明它是正确的，正确的属性，在这个例子中，HTTP GET 是我们想要声明的。所以这样做，意味着当有人对斜杠项执行 get 时，这是一个对此做出反应的方法，对吗？我明白了

在一些情况下，我们几乎有相同的路径，但是是动词决定了调用哪个方法。那我们在这个 HTTP GET 里面做什么呢？很简单，我们会说，好的，我们的物品将会是一个存放处。

还记得吗，我们创建了这些 get items 方法。所以我们只需调用它，我们有项目，然后我们返回项目。

仅此而已。

好的，有了这个，我们应该可以测试一下，看看效果如何。所以我要在这里按 f5。

好吧，我要回斯瓦格了。我将使用刷新我们从上一个视频中打开的页面。如你所见，一切都更新了。现在不再有天气控制器了。现在我们有了一个项目的控制器。这是我们的第一条路径，我们使用 get 来获取项目。

我们不仅如此，我们还有一个描述一个项目的模式，它将如何布局。如果我们点击物品。让我们看看，试试看。让我们看看我们得到了什么。

就在这里，如您所见，swagger 将显示执行的路由器引导，如我们所说，这是一个 get on 斜杠项。这是这里，这是我们的主机和端口。所以针对 localhost 5001 项。和

这是结果。所以我们有三个声明为静态的项。嗯，我们的项目集合的初始值，对吗？或者是药剂，剑和盾，对吗？

这太棒了。

停下来，添加我们的第二条路线，这是返回一个特定项目的路线。所以这将是公开的

项目，得到项目，然后我们收到货物，对不对？

然后我们是不是漏了什么空间？再一次，让我们看看。是的，聚焦在一个空间。就在那里。然后就像之前一样，我们只是说，好吧，var item 等于 repository

dot 获取项目。好的，这是我们添加到存储库中的另一个方法，我们只传递 ID，然后返回那个项目。

现在，再一次，我们需要在这里标记一个像右边熊一样的顶部。所以这将是一个 HTTP GET。但在这种情况下，有一点额外的细节，这就是模板。所以我们必须提供一个模板

我们将如何对待这条路线的另一部分。像在这种情况下，路线不会只是得到斜线项目。这将是很好的斜线项目。这个项目的想法，对，就是大盘子的那一块，我就这样放。所以你会要求项目是斜线具体项目的 ID，然后这个

这件作品将会被执行。对吗？

所以是的，让我们看看会怎样。我再做 f5。

好吧，这是回到斯瓦格。只需刷新页面。如你所见，现在我们有了第二条路线。就像我说的，这是斜线项目斜线 id。所以，为了实现这一点，让我们，

让我们实际执行第一个项目，以获得所有

我们知道的物品。

让我们抓住第一个。

如此昂贵，我们应该能通过另一条路线得到那个项目。那么网关广告，让我们在这里尝试一下我们的基本项目，所以这些如何在开放 API swagger 中，您可以引入值，对吗？现在执行它，看看会发生什么。这是执行的路线。所以你可以看到斜杠项和斜杠的实际 ID。然后

有趣的是，我们得到了 204。对吗？所以这意味着有些事情并不像怀疑的那样。

我要做的是回到 Visual Studio 代码，在这里放一个断点，看看我们得到了什么。所以回到 swagger、UI 和 execute。

这里，我们有一个断点。是的，我们得到了不，这就是正在发生的事情。所以物品还没找到。为什么会这样呢？让我想想。这是我们的物品。这是我们的目标。我做的。

所以，是的，所以真的，这里发生的事情是，每当我们向我们的控制器、我们的服务发出请求时，我们实际上是在创建，正如你所看到的，在这里，主要项目的新实例是积极的。对吗？这意味着他创建了一个全新的列表，它是用一组随机的新代码创建的。当然，当我们试图用我们以前用过的好东西时，它不会发现它，因为现在我们有了一个全新的列表。

所以我要做一个五，昨天去

这实际上是一件好事，因为你必须意识到我们需要在控制器中正确处理这种情况。所以在这个 get item 方法中，我们不应该只是返回一个好的，那么我们如何处理呢？所以让我们停止吧。

所以我认为，我们可能想要做的是，在我们可以找到 ID 的情况下，返回正确的状态代码 HTTP 状态代码。因此

姑且这么说吧，如果项

不，好吧，让我们用不同的东西返回它。所以让我们回来吧

不远。这就是让一个点网为 not found 创建正确的状态码的方法，这样我们就不用去计算了，所以我设置了一个状态码。

是的，如果找到了，他们会直接把东西退回去。现在我们确实有一个问题。因为现在在一个分支中，我们试图返回这个类型，或者没有发现结果，在这些其他的毕业生权利返回只是一个项目。那么这是怎么回事呢？我是说，不像在里面，对吧？我们期望总是返回一个项目。我们如何通过使用动作结果类型来处理这个问题。所以如果我们做动作结果，

这实际上允许我们从这个方法中返回多个类型。如你所见，没有错误了，因为现在这是在说，如果你想返回 not found 返回 not found，或者如果你想返回直接关联的类型，你也可以这么做，对吗？或者我们也会说，好吧，如果你想，那很好。但是现在这种情况下，两种情况都可以处理。所以让我们再运行一次，看看我们用什么来为这些动作获取正确的状态代码，以使其完全 restful。所以让我们刷新一下。让我们再来一遍，让我们弄一个这些物品来试一试。

执行。

太好了。是的，你能不能拿一个我们知道找到它没什么好处。但是要得到那种好处。然后打开这里，尝试一下

用 ad 和 execute。这一次，我们确实得到了 404，这是“未找到”的正确状态代码字，正如您在这里看到的，

在 dotnet five REST API 教程的第三部分中

我们将学习依赖注入技术，以及如何利用它将存储库实例正确地注入到项目控制器中。我们还介绍了数据传输对象的概念，以及如何使用它们与我们的 API 消费者建立明确的契约。

今天你将学习什么是依赖注入，如何在 dotnet 中注册和注入依赖。五，

如何实现数据传输对象，也称为 dto，

以及如何将实体映射到细节。

在之前的视频中，我们能够实际创建我们的实体、存储库，甚至我们的控制器，以便能够获得项目和我们的特定项目。然而，我们发现一个问题，当我们试图检索一个项目时，我们可以检索它，因为当我们找到并返回代码时，

每当我们在项目控制器中收到请求时，我们都会创建一个新的存储实例。这就带来了一堆我们永远也找不到的新东西，对吧。那么我们该如何解决这个问题呢？我是说，我们怎样才能真正用正确的方式解决这个问题？

因此，对于这些，有一个非常重要的概念，我们需要在这里学习，这就是所谓的依赖注入。让我们来谈谈这个。

那么什么是依赖注入呢？让我们想想我们的类，对吧，我们有一个类，它想利用其他的类，在我们有这种关系的地方，我们说其他的类是我们类的依赖。更具体地说，在我们的例子中，我们有 itis 控制器，它的构造器在 meme items repository 中创建一个新的存储库实例。现在，就依赖注入而言，我们真正想做的是稍微翻转一下。不用测试控制器来构造实例，我只需在这里打开我荧光笔，

我们将在构造函数中接收存储库，然后将那个引用放入类中。因此，在这一点上，我们将存储库依赖注入到 IDS 控制器类中。

这也带来了一些非常重要的东西，这就是依赖倒置原则，在这个原则中，我们有一个类，我们有一些依赖，我们称之为依赖 a。这个类依赖于依赖 a，但是我们想做的只是不要依赖那种依赖，相反，让我们的类依赖于一个抽象，在这个例子中，在 C 语言中，它是一个接口，对吗？所以类不再依赖依赖，它只是依赖依赖 a 将要实现的某个接口。对吗？因此，我们通过让一个类只依赖于一个接口，而依赖项 a 实现该接口，从而颠倒了依赖关系。

同样，我的意思是，当我们这样做时，我们可以引入一个依赖项或任何其他也实现接口的依赖项。但在这种情况下，你可以想象，现在我刚刚控制的存储库 receive 只是一个接口。因此，在这种情况下，类不知道它正在处理哪个显式依赖，可能是 B 或任何其他依赖，只要它们实现了契约，在这种情况下，契约就是接口。而且这个指导班很乐意与之合作。好的，这就是，这就是依赖性反转原理。和

嗯，问题是，好吧，那我们为什么要这么做？很常见的原因。是的，就像我说的，就像他说的，对，所以通过让我们的相互依赖依赖于抽象，我们将实现彼此解耦。所以它给了我们更多的自由来处理这些依赖关系，而不需要接触我们的类。这使得煤更干净，更容易净化，也更容易再利用。但我很谨慎，这样更容易测试。

但是接下来，如果我们要这么做，我们要怎么构造这些依赖，对吧，因为现在我们只是在构造函数中接收它们。如果我们有所有这些依赖，依赖 ABC，我们怎么去构造构造函数。因为我们班要接收他们，对吗？他们打算在那里注射。因此，这个叫做服务容器的东西开始发挥作用，从网络的角度来看，它是一个人工智能服务提供商。

因此，在应用程序启动期间，我们将进行注册，每个依赖项都将注册到服务容器中。

最后，当类被实例化时，服务，一个服务提供者单独的容器将负责解决该类所需的任何依赖关系，就像它有一个我们每个类所需的所有依赖关系的映射。因此，如果需要的话，解决依赖性，构造它们。当然，只是第一次，这实际上取决于应用程序的生命周期，这个生命周期是为类的依赖项设置的。所以如果需要构造函数，否则，它会重用它。然后它拒绝依赖关系。

事实上，这将有助于我们解决我们现在在内部项目中遇到的小问题，我们希望构建和构建我的意思是，我们不希望对监管机构有分裂的依赖，或者我们不希望构建，明确构建警告，因为每次我们创建控制器时，我们只是希望收到一个 East，就好像它是可用的一样，许多构建都是第一次构建，并通过服务容器进行排序。

现在让我们看看如何利用依赖注入。所以我要做的是回到代码上。所以让我们停止调试关闭终端。因此，让我们来解决我们明显依赖电子邮件 it 存储库的情况。首先，我们需要一些接口，这样控制器就不会对具体的存储实例进行操作。让我们来看一个主要观点，我们要做的就是右击这个类

实际上在灯泡里，让我们提取接口。这将为我们创建一个接口，并使实现该接口成为可能。现在，我们可能想把接口放到它自己的文件中。让我们开始吧。

一个新文件，

让我们实际上称它为一个 I 项目仓库，应该是一个更好的名字。

好吧。

因此

谢谢，太空目录，偶极故事。这里是我们要引入界面的地方，我将使用 cut

粘贴到这里。这是一个有几个不错的空间的报告，让我们看看，是给实体的。

为 CS 做好事。集合泛型，应该可以了。好了，我们有了接口。这是储存库。

存储库实现接口。现在我们有了接口，让我们回到控制器。和

让我们把它转换成，我的意思是，这种类型转换成存储库中的一个项目

政策的

项目。

为座位艳俗。

确保这是关闭的。是的，我们必须为此做正确的命名

游戏。现在我们已经收到了。所以我演示存托。这是一个老板的故事。

为了不混淆，我们这么说吧，储存库等于保管库。

好了，现在我们有了潘西注射法。这个类也不再知道哪个库将在幕后使用。现在，我们唯一要做的就是

这是怎么回事，实际上，我刚刚在我们的实验室里修好了它。另一件事是我们必须登记，对吧。因此，要实现我们存储库的过度膨胀，或者我们将要做的是启动和配置服务。因此，这是您注册所有将在您的服务中使用它的服务的地方。我们现在需要的服务是我们的历史。所以让我们做一些服务

添加 Singleton。现在有很多方法可以添加 URI。为了在这里注册你的服务，我将使用一个 singleton，所以 singleton 什么也不是，什么也不是，只是在我们服务的整个生命周期中有一个类型实例的副本。所以只会创建一个。无论何时何地，只要需要，它都会被重用。这将有助于我们解决目前的问题。因此，为了添加单个票价，我们指定了接口。

因此

我添加了存储库，我们可能需要添加它。是的，我们命名空间。这就是界面。然后具体的例子是

在主项目存储库中，对吗？

就是这样。这就是你注册依赖关系的方式。因此

此时，我们应该做好准备，蓄势待发。所以我要做一个五。

现在我要换成 swagger 了。

所以我们有和以前一样的 API，无论如何我都要刷新。现在我们来做一个练习。让我看看，我将试用我们的项目，端点。所以我去拿一件我们的东西。

我现在应该能找到了。所以，看，物品，我要试一试。我把它放在这里和那里，让我们试着找到它。

这里有一个断点。让我们看看。是的，这一次，我们不能再解决了，不，去掉那个断点，跑回 swagger。这就是我们的响应代码 200，是对该项目的请求，这是所有重要的主体。

因此

正如预期的那样，现在我们只有一个存储库副本，它被注入到控制器中，这允许我们实际上找到我们正在寻找的数据。

现在，还有一件事需要注意，我们应该马上解决。事实是这些

我们现在启用的这些路由正在启用或者正在将我们的项目实体直接暴露给外部。我们必须明白，当我们构建 REST API 时，我们也在与我们将要使用的任何客户端建立一个契约，这是一个我们不应该轻易打破的契约。我们现在的问题是，因为我们公开了 item，这是我们用来处理持久性的项目，我们有多功能性。

任何时候我们想要添加感觉，我的意思是，任何时候我们想要修改或删除我们在内部存储中使用的任何字段，现在，在多功能性方面，我们可能会破坏我们的客户端，对，破坏那个合同，这真的不是我们构建这些 REST 服务的目标。

那么我们如何避免在那里暴露这些项目契约呢？所以让我们，让我们看一看，让我们回到这个项目。让我们找到那个实体。所以我们这里有项目。正如我们所说的，我们在获取项目和获取项目中返回它。所以我们现在要做的是引入我们所谓的 DTO 或数据传输对象。因此，数据传输对象就是客户端和我们的服务之间将要启用的实际契约。为此，我们将在这里引入一个新文件夹。我们称之为视频吧。

让我们为我们的项目 dt 添加一个新文件。好吧。这笔交易没问题。同样，命名空间目录在这种情况下将是视频。

身份将会非常相似

实际上，是我们的项目。

所以让我们只是复制

物品。

因此

将添加缺失的空格。

到处都是。没错。是的，我的意思是，在这种情况下，我们想在我们的方法中返回的项目恰好与我们将存储在存储库中或检索存储库的项目几乎相同。所以我们用，好吧，现在看起来有点多余。但是，当您开始修改数据库时，好处会变得明显。你不必碰这份合同，或者你可以非常小心地对待这份合同，或者随时打断我们的客户。因此，这为您发展数据存储提供了很大的灵活性。

现在我们有了，让我们把它重命名为 DTO。很抱歉。好吧，我觉得这个交易。现在我们有了它，是时候开始正确使用它了，所以让我们回到 iTunes controller。

所以在这个时候，我们需要做的是转换 iTunes，或者我们开始有好的想法，对，我们必须将这些从项目转换成身份。一种方法是用 link 做一个简单的投影。所以我们会做一个选择

然后可能遗漏了链接，这里有一个空格来添加它。我会说好吧，所以我倾向于

投影到一个新项目 DTO

我可能需要在这里添加一些空格。就在那里。

这里我们要引入属性，对吧，我要说好的，所以 Id 等于 item.id。

名称等于项目名称，同样的事情。价格。

好了，现在我们有一个我们的项目集合是一个项目集合，我们有

我想我们这里少了括号。

我们回来了

那些物品，不再是物品，必须有物品 B 才能

建立合同。好的，所以，是的，所以应该这样做，我们必须通知项目，这样做，这样做。正如你可能猜到的，我们必须在这里做几乎相同的事情，对吗？

这一点，会有点多余吧？那么，为什么要用完全相同的属性进行两次转换呢？因此，我们可以克服这个问题的一个方法是添加一个扩展方法。让我给你展示一下我的意思。所以我要在这里添加一个新文件，我们称之为扩展名。

游戏。祝你好运。然后加法金属做的扩展是，它只是通过增加一个求和方法来扩展一个类型的定义，这个方法可以在那个类型上执行。所以在这种情况下，我们将只添加一个类静态类或者对于扩展方法，你必须使用一个静态类，还有一段路要走，

扩展。

然后我们要在这里声明一个方法。公共静态将返回项目 DTO。

我们称它为 DTO。它将对当前项目进行操作

这个方法就是这个意思。所以，让我们在这里添加一些名称空间。

所以这个方法接收一个项权限，通过在这里使用它，意味着当前项可以有一个名为 DTO 的方法，返回它的标识或版本。

因此，在这一点上，我们可能可以利用我们在这里所做的。让我们看看，这就是我们用来创造活动的东西。因此，我们可以说，我们返回新的身份或从我们收到的项目。

女士们，我们有一个有效的方法可以使用。所以现在我们将去调整控制器，我们所能做的是代替这一切，我们可以说这样的项目被投射到它里面，并且那作为交易。

仅此而已。让我们稍微折叠一下。

这样，我们也可以在这里使用同样的方法。因此，当我们得到项目，我们会说，因为你这样做，当然，我们需要改变这到我们的 do 合同。

然后剩下的。事实上，我会这样做。所以让我们先拿到东西。检查一下是不是，如果不是，那我们做 CTO。

好了，现在我们已经完成了，让我们看看接下来会发生什么。所以我再做一次 5。

好吧，回到大摇大摆。

我要刷新这个。让我们看看这是否仍然有效。所以物品，我要去试用一下。执行。是的，就在我们拿到物品清单之前。但是这一次，如果你向下滚动，你会看到免责声明。我们向消费者公开的合同不再是一个项目，而是与这里发布的属性相关的项目。

在 dotnet five REST API 教程的这四个部分中，我们介绍了用于创建、更新和删除项目的附加控制器动作。我们还将学习如何验证传入的 dto，以防止无效数据进入服务。

今天，你将学习如何创建资源，如何验证 DTO 房地产的价值，

如何用 good 更新资源

以及如何删除我们删除的资源。

现在是时候介绍我们的其余部分了，我们的 routes，对，所以 route 用于创建项目，route 用于更新、删除，或者更新项目，route 用于删除，以便能够删除日期。

那么就从 post 开始吧。没错。在做任何其他事情之前，我们要做的是更新我们的存储库，以便能够创建正确的项目创建路径

让我们开始吧。我将重新开始，通过界面，这是要做的第一件事。所以让我们宣布

作废，创建项目，

项目项目。好的，这个新方法不返回任何东西。它只接收需要创建到存储库中的项目。现在让我们回到主要的混凝土，it 仓库。我要说，实现接口。这就带来了一种新的方法。和数控车削记忆库，这是一样简单，只是说项目增加

项目。

仅此而已。

现在，我们希望将这些暴露到控制器中，对，我们开始向控制器添加路由。但在此之前，我们必须意识到，客户将发送这些项目。我们将不得不建立另一个契约来接收那个，那个物品，它不能是身份，或者因为我们不需要像身份那样多的属性，或者创建一个物品。让我们看看我的意思是什么。因此，我将转到我们的详细信息文件夹，我将创建一个新文件，姑且称之为

创造身份哦，

并添加空间

给视频分类。然后。

好的，和以前一样，我们将使用 record 来实现这一点，这对于各层来说非常方便。现在我回头看了一下，让我们看看，当我们创建一个项目时，客户端发送什么有意义。所以通常，ID 是在服务器端自动生成的，对吗？所以我们不需要传入那个 ID，我们需要一个名字和价格。并且很可能创建日期也将在该服务上生成。所以我们只包括这两个

列表。所以我们有名字和价格。这将是我们创造项目 DTO。

现在让我们看看如何在控制器中使用它。所以回到控制器。

让我们看看如何将这些声明为 post 路由。所以这将会是

公共行动结果。因为在这个方法中，我们可以返回不止一个东西，事情可能会发生。和

他们称之为 post 或 create 方法的约定是创建项目并返回创建的项目。所以如果我们要这么做，我们要我们应该可以返回身份。既然这里的惯例会有所不同。所以有些人会在这里创建他们自己的响应对象，这并不一定要涉及到我，在这种情况下，它对我们来说很好。所以没关系。所以它将被直接调用

八年级 MBT 哦，那将是我们的投入合同。项目 BPO。

好，然后让我们用正确的动词来修饰它们。所以每个 HTTP 帖子，然后只是为了交流，就会这样说。当然，当有人用正确的正文发布到商品路径时，就会调用这个函数。

那么我们如何创建一个项目呢？很简单，我们会说，好吧，第一项，

项目等于新的，我们将不得不找到类型。所以感谢夏普九。

然后，我们假设 ID 等于，这是我们实际上

生成项目的 ID。所以会很好，那种新的好。

所以名字和那个名字一样，价格也一样。

价格，然后是创建日期，如您所料

现在 UTC 时间偏移，

就是这个项目。现在我们必须构建我们将利用我们刚刚创建的存储库方法。

创建项目，然后它去那里。

一旦项目被创建，这里的约定是，我的意思是返回被创建的项目，并且返回一个标题，它指定了你可以在哪里继续，并获得关于那个评分项目的信息。所以要做到这一点，我们可以做的是使用

创建添加动作，你也可以使用创建路线，这是另一种方法。渐变动作对我们来说很好。因为我们在这里可以说，好的，那么我们想要什么样的行动？这反映了什么

获取项目信息的途径。这将是我们在这里的获取项目操作。

我们在这里可以做的是，这里有 get 项的名字。

然后当您指定 ID 时，它将传递给订单路径。因此，让我们在这里创建一个简单的匿名类型。

ID 等于 ID 和 ID。这是一个生成的 ID。最后，要返回的实际对象，是一个东西。同样，让我们利用我们的扩展方法作为 DTO。所以我们把相同的创建，然后我们昨天刚刚转换成。

是的，就是这样。我们来做 f5。看看这个有没有用。

所以回到大摇大摆。让我们刷新一下。所以，现在我们有我们的邮政路线在这里，正如你所看到的，我们的等级身份也显示为一个新的合同，我们正在暴露扭矩灯。所以我们去贴吧。试试看。如你所见，现在我们只需要提供一个名字和一个价格。

让我们看看名字。但是让我们看看，让我们引入另一种类型的支持，我想，因为让我们看看

德纽姆斯有点贵，比如说 35 英镑。

是的，让我们开始执行吧，

看看我们得到了什么。如您所见，这里的请求 URL 与 get 相同。但在这种情况下，它是一个职位，我们有守卫 201，意味着一个创造的艺术路线。所以他创造了一种新的物种。正如您在这里看到的，我们在这里有一个位置，它指定了我们可以在哪里找到该项目。

如果我们真的把这些代码放在这里，我们就可以找到折叠，找到 get 路径。去试试吧。我们将把它粘贴到这里。执行。如您所见，这是在此位置为 post 提供的路线。它实际上能够为开发者找到我们刚刚创造的新资源。事实上，在他的用例中，获取所有项目的完整列表。尝试它，执行它。所以现在我们没有你的三个我们有四个项目，包括致命性。

但是让我们再尝试一件事。如果我试图创建一个没有名字的东西会发生什么？这有意义吗？好吧，让我们试一试。

这是被接受的 V。现在我们有一个没有价值的项目，这是完全不可接受的。事实上，我们使用代码来获取路径，我们说，执行，我们可以看到

我们有一个项目没有，这是非常糟糕的。我们如何保护自己免受这种情况的影响。因此，有一种称为数据注释的东西，在这种情况下，我们可以将它添加到 d to 中，以防止出现这种情况。那么回到创建身份，哦，我们能做的只是请求这个字段是必需的。

我将在那里添加数据注释命名空间。因此，必须提供它的名称和价格。对于价格，不要只做加法，我们再做一件事，比如说

价格会有一个可能值的范围，因为我们可能不接受负值，甚至是零。假设我们只设置从 1 到 1000 的值，这对我们来说应该是一个有效的范围。这样做，我们就保护了将要进入控制器的值。所以我要再做一次 5。

让我们看看结果如何。所以回到斯瓦格，

我要毁掉这条路线。所以回到帖子里，我会试着再做一次同样的事情。试着执行这个。而这次。

现在我们有了 400。如此糟糕的请求错误。很明显，这里写着姓名字段是必填的。因此，现在数据验证正在进行。所以我们必须提供一个名字。让我们实际上在这里玩价格。假设我尝试一个负数。好吧，看看会发生什么。

如果你有价格必须在 1 和 1000 之间。没错。因此，估值的数据符号对于关联点 r 或 D 非常有用

现在是时候实施我们的更新路线了。所以让我们回到源代码，关闭终端。

就像之前一样，让我们回到我们的 a 库，我识别接口并添加相关的方法。假设这是一个空。再次更新项目。这将接收要更新的项目。

非常类似于创建项目。现在，回到具体的实现。

我要再说一遍，实现接口

这带来了方法数据项。那么我们如何更新这个项目。因为它是一个内存列表，

实际上，我们唯一要做的事情就是使用查找相关的条目，并用传入的条目更新它。为此，我们要做的是找到相关条目的索引。所以我要说物品，找索引。这是现有的项目。

因此，您将找到与现有项目 ID 匹配的现有项目

项目标识。

好，这就是找到我们要找的 ID 的索引。我们找到了，我们可以做项目，索引等于项目。

仅此而已。因此，我们将在正确的位置更新项目。所以是时候回到控制器了，我们差不多要回到控制器了，因为，正如你可能意识到的，在这一点上，我们确实需要一些视频来接收更新路由的输入。即使这样做了，你还是会和拥有伟大身份的人一样，哦，这是一个很好的实践，因为你现在不知道这是一回事。但最终，更新可能意味着不准确的东西。所以让我们用更新身份哦，

这是一个伟大的身份副本，哦，几乎相同的属性是你唯一可以验证的名称和价格。和范围，对吧。现在让我们回到控制器，就这个控制器，

让我们在干旱中创造。

所以这又是一次，

公共行动结果。

在这种情况下，输出的惯例是实际上不返回任何内容。所以用我们所谓的无内容。所以除了行动结果，这里没有其他类型，它将被称为更新项目，我们收到两件东西，第一件是项目想法的好处。然后他们是新更新的项目 DTO。

让我们称之为 DTO 项目。

然后，我们不要忘记添加正确的动词，这里是一个 HTTP put。

就像我们之前做的一样，这个路径只是为了文档，当你把项目放入斜杠，然后斜杠是我们这里实际上缺少的部分，我们还需要在这里指定模板

在这种情况下就是 ID。这意味着当我们发布广告时，我们必须以这种方式来证明广告

就像这些，对，所以 put items 斜杠 ID，它们会在这里调用这个方法。让我们来看看。首先，我们将如何进行更新，首先要做的是找到项目。因此，现有的项目，它将使用一个存储库，我们已经有了一个方法，这就是获取项目

传递 ID。然后验证这些物品是否真的存在将会很棒。因此，如果一个现有的项目是没有，那么好吧，我们找不到它。所以我们只会返回没有发现的地方。

在故事的结尾，那根树枝。

如果我们找到了，如果我们找到了，我们要做的就是继续做

我们将创建一个新项目，这是我们系统中的更新项目。因此，在这种情况下，我们要说的是项目更新项目等于它本质上我们现有的项目。

但是随着

一些不同之处。好像我们需要用一个名字

所提供身份的。哦，这个价格也提供了身份。哦

所以，现在在这里，我只使用我在谈论记录类型时提到的 190 个记录类型中的一个，这是这里的宽度表达式。这里发生的事情是，我们说，好的，我们把这个现有的项目放在这里，我们用下面两个修改了的新值属性来创建它的副本。所以这是一个很好的补充

记录，并允许我使用真正的不可变类型。但是，我仍然可以在初始化时修改一些属性。因此，如果项目只是记录类型中具有一系列属性(如 nice addition)的现有项目的副本，其中我们有这个更新的项目，我们可以继续说，好的，那么更新了我们刚刚创建的方法的存储库，并发送 bladed 项目。就像我说的，

惯例是不返回任何内容，所以不返回任何要报告的内容。

让我们试试这个。f5。

并返回到 swogger 刷新。

这就是我们的看跌期权

我们的港口路线。在做端口之前，我们先来看一个 a 项。

所以试一试，执行。假设我们要修改我们的药剂。

好了，药剂，我要把它们折叠起来放入，所以对于放入，我们必须在这里提供一个 ID 和更新的值。这是一种药剂，让我们把它改名为，比如说超级药剂。

让我们把价格提高到我不知道，比如说

1.  所以执行吧。

然后正如所料，我们得到 204，这是没有内容。你可以看到这里执行的路线。如果成功了，我们应该能得到一个

那里有更新版本。所以我得到了我们所有物品的完整清单。现在让我们看看会发生什么。并且不再有价格更新的魔药超级魔药。

此外，请注意，我们现在有了一个更新身份，即新合同。

因此，我们将更新真的，最后要添加的是我们的删除路线。让我们回到控制器。所以回到这个项目。就在之前，回到存储库接口。让我们做虚空。标题，

我们已经知道我们需要的阅读材料只是知道它的想法。所以回到仓库。

让我们实现接口

用于删除项目。

实际上，该项目将与更新项目非常相似，我们要做的第一件事是找到该项目，我的意思是该项目的索引。现在我们可以只说我们移动的项目。

看

那个索引。

仅此而已。不好意思，只能说到这里了。

我们已经有相反的情况了。现在我们可以期待控制器了。

在这种情况下，我们不需要另一个 DPO。因为这里唯一需要的是使用一个简单的 ID。所以让我们使用实现控制器动作。

所以公众行动的结果。

删除项目，就像更新一样，我们将不返回任何内容。所以行动结果删除项目，好的 ID。

让我们加上动词。所以这将是一个 HTTP 删除。同样，文档。所以这些都是要缠着或者删斜线的物品。

然后 slash，别忘了我们的模板，

也就是 ID 斜杠项 ID。

而要执行删除，类似的，肯定跟更新类似。所以我们先试着找到物品。我们只是复制这个基础

那里。如果我们找不到，那就没找到。然后我们转到存储库，删除项目和它

就像我们以前做的一样，返回，没有内容

仅此而已，所以 f5

并且由

swogger 再次刷新。现在，您可以看到我们有了可用的删除操作。因此，让我们来看看我们的一个项目的名称，看看我们是否可以删除它来执行这个。所以让我们试着删除那个药剂，

复制，

折叠、展开、试用，

投放广告并执行。路线是这样的。我们得到了 204 的预期，没有内容。所以如果我再次尝试得到这些物品，让我们看看会发生什么。

你所需要的，所以这里不再有魔药了。

是的，那将是我们路线的终点。

在 dotnet five REST API 教程的这一集中，我们将看到如何在持久性存储中启动我们的实体。具体来说，在 MongoDB 数据库中，我们将实现一个简单的 MongoDB 存储库，它可以通过对我们的服务进行最小的更改来替换我们现有的解放库。

今天，您将学习如何实现一个简单的 MongoDB 存储库，如何将 MongoDB 作为 Docker 容器运行，

以及如何使用 postman 与 REST API 进行交互。

从这一集开始，你需要一些其他的东西来一步一步地跟随视频

Docker，我们将使用它来运行一个本地 MongoDB 实例。

和 postman，我们将使用它们与来自伊朗的其他 API 进行交互。

现在让我们想象一下现在的场景。我们的用户试图通过浏览器管理他的项目。他会通过联系我们的 REST API 来做到这一点。更具体地说，通过联系国税局的控制员，这是我们所有路线的终点。现在，我只是控制者将与囚犯物品仓库互动

来管理这些项目。并且项目实际上作为简单的项目收集权利存储在主存储处内。

现在，如果 REST API 因为任何原因停止，不管是 eat 停止还是重启，都会发生什么，这可能是显式的，也可能是无意的。但是一个服务需要重新启动是一个非常常见的场景。

如果发生这种情况，当然，我们的项目集合将会消失，因为它只是内存中的一个集合，对吗？这都是我们所期望的，我们需要找到一种方法来保持这些项目在 REST API 的生命周期之外仍然存在。

这些是什么，我们有几个选择。我能想到的第一个非常基本的选择是使用文件。所以你可以想，好吧，我将为存储库中的每一个项目创建一个文件。

但实际上，目前最常见的选择是使用数据库。在数据库方面，我们有 1000 多种选择。但是您可以将它们分为关系数据库和非 SQL 数据库。

在本教程中，我们将使用无 SQL 数据库。这样做的原因是，因为它提供的好处，除了没有 SQL 数据库是目前最流行的选择之一这一事实之外，还有一个事实是，您不需要模式或 SQL 来与数据库进行交互。我的意思是，你不必在这里学习 SQL 或者其他语言，你可以坚持你的面向对象编程。在我们的例子中，今天，她是 C 调的。

您还拥有低延迟、高性能，这是因为

不需要像在关系数据库中那样有很强的一致性。此外，这些都是高度可扩展的。

在我们的例子中，我们将特别选择 MongoDB，

这是一个非 SQL 数据库，特别是一个文档存储类型的数据库。所以它将实体作为文档存储，特别是作为数据库中的 JSON 文档。这是我们在本教程中要用到的。

所以你可以认为现在我们将把这个数据库放在我们的 race API 之外。

现在，当一个控制器收到一个请求时，它实际上会把它交给一个叫做 MongoDB 的新存储库。我刚刚参观了它，这就是我们要在这里创造的。

即使我们的服务停止并重新启动，数据库也不会重新启动，我们的数据将保存在那里。这样，我们可以在 REST API 的生命周期之外保存我们的项目。

在我们开始实现我们的 MongoDB 库之前，我想向您展示另一个工具，当您与 API 交互时，您可能会发现它很有用，postman 也是如此，您可以在 postman 下载页面中获得它。如果你没有

已经完成了？

你为什么要用邮递员？如果你还记得的话，到目前为止，我们一直使用这个页面，swagger UI 与我们所有的 API 进行交互。

然而，这里的问题是，最终你可能不想打开，你知道，网页确实与你的每个 API 交互。这些 API 甚至可能不在你的主机中，它们可能在某个地方。所以你还能做什么？可能没有一个大摇大摆的用户界面。所以你确实需要一种方法

与他们互动。

此外，您可能需要一些额外的功能，这些功能在本页面中并不提供。这就是邮递员能帮助你的地方。所以在这种情况下，让我在这里打开一个邮递员。

因此，我们如何在 postman 中与您的 API 进行交互。所以就像点击这里的加号一样简单。你要做的第一件事是选择一个你要用的动词。在我们的例子中，让我们试着，我知道你要读取请求 URL，所有这些 URL 都以你的主机开始。在我们的例子中，让我们看看您的主机是什么，让我们在 VS 代码中使用 f5。您可能还记得，我们的主机 Ace 也是 HTTPS 端点的最后一行将是 localhost 5001。我要复制这个

回到邮递员，粘贴它。如果你还记得，我们的路线，回到 VS 代码，现在，我们的路线是 a

从路线开始，从右边的项目开始，就在这里。这就是我们在《邮差》中想要使用的路线。所以在这里输入物品。这应该足够我表演了。所以我将只看到“点击发送”。

然后，如果您在这里遇到这个问题，这个问题说 SSL 错误，无法验证第一个证书，这是因为邮递员正在执行 SSL 验证。但是这种验证并不适用于 dotnet five 自带的自签名证书。所以在这种情况下，

您想要做的只是禁用 SSL 验证，这应该没问题。所以你可以点击这里。

这将运行请求。同样，如您所见，它运行了请求。我们这里有资源。与我们之前在 swagger UI 中得到的结果相同。但是现在，我们正在更直接地与那个 API 交互，同样的方式，我们需要让你可以在这里做 post put 和一堆其他动词。我们将在这一集的教程中继续这样做。

所以现在让我们回到 VS 代码。

我将在这里停止主机并关闭终端。我要用控制器关闭它。

所以我们首先要做的是

实现新的存储库

能够与 MongoDB 数据库进行交互。

为此，我将创建一个新文件。

我们将把它命名为 Mongo DB。项目存储库。

没错。

感谢空间。

看到了。存储处

游戏。所以它将被称为联盟

MongoDB 类。保管处。正如我们的电子邮件栓剂一样，我们将实现项目存储库。

我们可能需要在这里导入一个名称空间，我将实现接口。

通过这样做，我们的 VS 代码已经搭建了所有需要实现的方法，以符合这些接口。现在，为了与 MongoDB 交互，我们需要一个所谓的 MongoDB。客户。所以客户是

是由 MongoDB 所有者的创建者提供的一个组件，您可以使用它来与 MongoDB 进行交互。

因此，我们需要像对待其他事物一样注入这种依赖，我们需要将这种依赖注入到我们的存储库中，以便我们可以与之交互。所以我首先要介绍的是我们的构造函数。让我们来看看。叶酸 MongoDB 是电容。

这里是我们需要接收 MongoDB 客户端实例的地方。

我们从哪里得到这个 MongoDB 客户端？因此，要做到这一点，我们必须添加一个牛轧糖包。我要做的是打开一个新的终端

我就要死在这里了

dotnet 将驱动程序 MongoDB 打包，输入，

去 noget 拿 MongoDB 牛轧糖包。如果您转到目录 CS Pro，您会看到现在我们有了依赖关系。

哦，回到仓库，我们可以开始注射了。

让我们看看，我们将在构造函数中收到我们称之为眼睛的东西，

Mongo 客户端，

为了监听端口，在这里导入正确的名称空间 MongoDB 驱动程序，我们将它称为 Mongo client。

现在我们要存储什么呢？

我们要去的是，我们想在这里存储的不是真正的客户，而是我们所说的集合。所以集合是 MongoDB 将所有这些实体关联在一起的方式。所以我要在这里声明一个变量。

我只写了

因为我们在构造函数中唯一修改的是只读变量，I Mongo 集合。你必须指定项目的类型，实体或文档的类型，实际上在这个集合中，我们的类型就是我们的项目实体。

和他的同事，物品收藏。

然而，在我们得到一个集合之前，我们需要一些其他的细节，即数据库名和集合名。所以通常，像你所有的文档一样，是的，你所有的文档都将被分组到集合中。并且您可以在一个数据库中拥有一个或多个集合。所以我们首先要添加的是数据库的名称。所以我们在这里加一个常数

就叫它数据库名。

这里一个好的数据库名称可能是使用 catalog。

现在让我们添加一个集合名称。所以私弦，

集合名称。

集合将被称为项目。

现在我们有了这些，这又回到了构造函数，

实际上我们现在关闭了航站楼。

而我们能做的就是下面这些。首先，让我们获取一个实例，创建一个对数据库的引用。所以我要说，我 Mongo 数据库数据库等于 Mongo 客户端获得数据库。所以数据库名。这将为我们提供对数据库的引用。现在我们需要一个集合的引用。所以物品收集，

就是我们之前声明的变量，等于得到集合的数据库，然后是项的类型

然后是集合的名称。

这样做的好处是，数据库和集合都将在第一次需要时创建。所以我们用哪个 API 与数据库和集合 MongoDB 交互并不重要。或者我猜驱动程序会检测到我们没有它们，它们会自动为我们创建，我们不必担心。

所以我们有一些方法要实现。因此，首先，我们将使用创建项目方法。在本视频中，我们将开始一个接一个地实施和练习每一个。要实现 create item，您需要做就是利用 items 集合。所以你可以说，items 集合插入一个，然后你只需传递对该项的引用。所以在这种情况下，它只是一个项目。

因此，在这一点上，你可能想知道，这个数据库在哪里是我们要与之交互的 MongoDB 数据库？

因为是的，我的意思是，我们有代码准备创建一个项目，但我们没有一个数据库。因此，有几种方法可以将 MongoDB 数据库装入您的机器。因此，您可以通过 MongoDB 安装程序安装数据库，也可以将数据库作为 Docker 容器的一部分运行。

实际上我们会选择第二个。这方面要理解的第一个概念是 Docker 图像。和

我的意思是，我们不会在这里深入讨论 Docker 概念，我们将在未来的视频中讨论它。但是现在，你可以把我们的 Docker 镜像看作一个独立的软件包。这实际上包括了运行应用程序所需的一切。在我们的例子中，这个应用程序是 MongoDB。所以一切都包装在这个 Docker 形象里。然后，当我们运行或执行这个 Docker 映像时，它就变成了我们所说的 Docker 容器。Docker 映像的运行实例也是如此。

Docker 容器将在 Docker 引擎中运行。

那么，如何将这个 Docker 引擎放入您的盒子中呢？您只需转到 Docker 下载页面，我现在就可以向您展示，您是否转到了该页面，选择您的平台，然后就可以下载并在您的机器中安装 Docker。然后你有一个 Docker 引擎。

您可以运行任何公开可用的 Docker 映像，比如 MongoDB，或者一些私有的 Docker 映像，这些映像可能存储在您自己的容器注册表中。在这种情况下，我们将选择一个 MongoDB，一个公共 Docker 映像，让我们看看如何获得它，我们可以运行它。所以我们要做的第一件事是去终端，比如说新终端，

我们将键入以下内容

码头运行，

然后我们将使用破折号 d 破折号 RM 修饰符，这样我们就不必附加到进程上。所以我们就随它去了。RM 是这样的，如果图像真的很抱歉，容器会在我们关闭进程后被销毁。那么，我们要给它一个名字，Mongo，这样我们就可以很容易地识别出这是哪张图片。然后，我们将打开一个端口，该端口将是 27，零 1727，零 17。这里的语法意味着我们想要打开，比方说，我们要打开 Docker 容器中的一个窗口或视图。MongoDB 通常监听端口 27，零 17。

因此，我们必须打开一些本地端口，因为在本地机器中，我们必须打开一些可以映射到 Docker 容器中的 MongoDB 端口的端口。这是您的操作方式，您可以在左侧外部分配任何其他端口。但是在右边，您必须将它指向 MongoDB 端口。最后，我们将指定一个卷。这样做的目的是为了不丢失存储在 MongoDB 中的数据。当您停止 Docker 容器时，好吧，如果您不这样做，那么当您开始获取内容时，您将丢失所有数据。因此，我们将这个卷命名为 MongoDB data

这将被映射到数据数据库。这里，斜杠数据斜杠 dp 是 MongoDB

会将数据存储在容器中。我们只是说，我们将把这个名为 MongoDB data 的位置从本地机器映射到 Docker 容器中的 slash data slash dv 目录。最后，我们必须指定图像的名称，在这里是 Mongo，

然后我会按回车键，

也许我可以扩展一下这个终端。因此，第一次运行 Docker 映像时，会将其从 Docker Hub 下载到机器中。因此，这可能需要一段时间，取决于您的互联网连接。但是你可以看到，这里有多条线。它们中的每一个都代表了我们所说的层。所以他们每个人都有这个 Docker 映像的一部分，包括所有的依赖项。所以就像我说的，这只是第一次，只要你已经把那些人的生活放在你的盒子里，下一次就会飞快地进行。所以现在我们有了 Docker 镜像，甚至 Docker 容器也可以运行了。如果我真的做 docker ps，我可以看到我有 docker 映像启动并运行，并在这个端口 27，零 70 监听。

我要关闭终端。因此

我们现在需要做的是能够指向那个 Docker 图像。为此，我们需要写一点配置。所以我要打开设置 Jason。

因此，为了与数据库对话，我们需要两个基本信息:主机和端口。为此，

我想在这里介绍一些新的设置。我们称这些为 MongoDB 设置。

就像我说的，我们需要一个主持人

我们需要一个港口。

因此，对于在您的机器上运行的 MongoDB 实例，您可以引用主机，您可以称它为 localhost。

正如我们所说，我们在 Docker 容器中打开的端口是 27，070。

这些是我们需要和他们讨论的细节。现在，为了将这些设置读入我们的服务，我的意思是

有很多方法可以做到。但我认为最好的方法是声明一个表示设置的类，这样我们就可以轻松地与 C sharp 代码中的多个设置进行交互。为此，我们将在这里引入一个文件夹，姑且称之为 settings。

ukoliko，称之为配置选项。有很多方法，我去设置。所以我们在这里添加一个文件，我们称它为

抱歉，

Mongo DB 设置。

再次，命名空间，看起来设置在这种情况下，这声明了一个类。

姑且称之为 MongoDB 吧。设置。在这里，我们将声明我们在应用程序设置中看到的那些设置，Jason this，这将它们声明为属性。所以我们的第一个财产将是

道具串成本。

下一个呢

public int port，所以这是一个整数。

然后，让我们利用这个类来计算与 MongoDB 对话所需的连接字符串。

所以我们在这里能做的实际上是一个只读属性。

让我们来看看。

让我们开始吧

字符串，姑且称之为连接字符串。

好的，我们要移走布景，我们不需要任何水手在里面，这个门，我们要打开。

所以这里变成了只读属性，我们可以返回计算出来的连接字符串。所以我们需要在这里做一点字符串插值。所以我能说的是，它们正常连接，MongoDB 连接字符串如下所示。因此

MongoDB，

鞭笞鞭笞，然后来了一个主机，然后来堕胎。

这些将从属性 host 和 port 中获取，这些属性是我们在那里声明的。

因此，有了这些，我们就有了一个获取连接字符串的简单方法，只要我们已经填充了主机和端口。现在我们有了这个，是时候注册一个 MongoDB，一个客户端，一个 Mongo 客户端，我们注入到 MongoDB 中，它是 30。所以这位客户

必须在某个地方注册，对吗？就目前而言，我们知道的是，我们在创业时就做这些事情。所以只要打开启动。

在这里，我们来配置服务。这就是你注册你所有的服务，我们将在 Singleton 上做这些服务，因为我们只需要 Mongo 的一个副本，整个服务的 IMO 客户端。

我是蒙哥的客户。我们把它作为重要的命名空间。没错。

然后在这里，不是像我们在这里做的那样，仅仅声明依赖项的显式类型，在另一件事情中，你不需要，我们要做的是显式地构造那个类型。

因此它被注入了我们本周所做的额外配置，因为我们必须指定一个客户端将需要的连接字符串。为此，我们要说，好的，我们要说服务

服务提供商，

我们将接受那个服务提供商。然后我们打开大括号，在那里添加列。然后在这里，我们可以这样做，首先，让我们实际上抓住 A，设置。我们已经在应用程序设置中填充了这些设置的一个实例。Jason，让我们通过 MongoDB 设置类来获取它们。我们如何做到这一点？回到启动阶段，它有两个小节设置。

你可以使用你的配置属性，我们这里的那个，已经被运行时填充了，你可以用那个来表示 get 部分。

然后

所以现在你需要得到一个相反的部分，我们把它命名为 MongoDB settings，和我们的 MongoDB settings，settings 类同名。因此，我们可以说

说出你的名字

MongoDB 设置

抱歉，

让我正确地输入 DB 设置。然后我们需要导入这个名称空间。

好的，这样我们就有了一部分。然后让我们把它变成一个对象，作为 I 配置部分返回，让我们

把它变成一个适当的 MongoDB 设置

像这样。

所以现在我们有了一个设定主题。现在我们实际上可以用

返回新的 Mongo 客户端。然后我们将设置连接字符串，我们在该类中计算的属性。

所以我们应该准备好注册并将客户端注入到存储库中。

既然我们做到了这一点，是时候实际翻转我们的服务，开始使用我们新的 MongoDB 存储库了。因此，我们可以在这方面做，你记得，我们以前注册的电子邮件，它已经是它了。所以转到另一个储藏库就像你在这里说的一样简单。

Mongo 数据库项目库。

仅此而已。

为了让我们的生活更轻松，我们还要做一件事，告诉 MongoDB，一个客户端，一个驱动程序，如何序列化一些类型，在这种情况下是代码和日期时间偏移。如果你记得我们的实体项目，它都同意日期时间偏移。我认为我们的 MongoDB 是，如果你不告诉它，我们到底要如何反映这一点，数据库中的这些类型，他们可能会结束

一个不太友好的表示，至少对我们的学习目的来说不是。所以我要做的是说，让我们说这些，所以我要做

这些在串行器上。

看看能不能找到正确的名称空间，

寄存器串行器。今天，我们要说新 COVID

序列化程序。

这将会是

成为某种类型。

让我们折叠这个坐标空间，这个字符串告诉 delsey，任何时候它在我们的任何实体中看到一个商品，它应该实际上将它们序列化为数据库中的一个字符串，

我们将对日期、时间、日期时间偏移做一些非常类似的事情。所以复制那句台词。我要说，日期时间偏移到你的激光

基于类型字符串。

一会儿我们会看到这些属性以及数据在数据库中的实际样子。但是现在，我们应该准备好开始测试了。所以我要在这里按 f5。

我又要转行做邮递员了。

在这里，我们将再次开始登录。因为我们还没有实现我们可以从一个帖子开始。

因此，要发布一篇文章，我只需打开一个新标签页，然后将动词切换到 post。我们需要请求 URL。所以我们可以从之前的正确用法中得到答案。

应该是同一个 URL localhost 5001 项。但我们要做的是，在这种情况下，我们需要一个主体，对吧，所以主体就是我们要发送的有效载荷

我们的 API。所以我们在这里换成划船。然后我们将这里切换到 Jason。

让我稍微简化一下。

这里，我们只是一个类型，JSON 代表我们想要创建的实体，JSON 由一个名字组成，如果你记得，它只是一个名字

和

一个价格。

所以试着选择一个名字和价格。所以对于他们数据库中的第一个项目。假设我们去

很好，价格大概是 22 美元。

这就是我们发布帖子所需要的全部内容。然后我们要点击发送。

如您所见，该项目已创建 201。

我们可以看到来自 API 的响应。我们得到了一个 ID，如何在 MongoDB 中生成它，以及通过我们的控制器创建的创建日期。

我们也可以看看我们在这里收到的加热器。当我们返回一个创建的动作时。您可以看到位置加热器是如何被填充为

使用正确的 URL 来检索该项目的详细信息，如果你想知道的话，还可以知道该项在数据库中的实际情况。所以我们怎么知道。所以让我们回到 VS 代码。让我们停止并关闭终端，我们可以做的是为 Visual Studio 代码安装一个 MongoDB 扩展。所以我要打开扩展跳转到这里。

我要输入 MongoDB，

在这种情况下，是那边的第一个入口。所以只要点击安装。

这样，我们就有了与 MongoDB 实例对话的方法，我将关闭这个实例。如果你看到，当你点击它的时候，在 MongoDB 的左边有一个新的项目，

然后有一个已经为本地主机建立或定义的连接。27，零 17。

第一次尝试连接时，这可能会失败。所以如果失败了，你能做的就是不去做，我要移除这个连接，或者我要重新添加它。添加连接，本地主机 27，零 17 是默认值，并且

关闭 STS 和那个，然后我们不，我们不使用身份验证在这一点上。所以还是说不吧。

然后点击连接。在左侧，您将看到一个到 MongoDB 本地实例的连接

将要折叠这些和这些。

如你所见，这里有几个数据库。其中一些是 MongoDB 的默认数据库。我们关心的最接近的是什么，现在我们关心的是我将要打开的目录数据库。如您所见，我们已经有了目录数据库和商品集合。

我们解散这些。您可以看到，我们有一个文档，打开它，这里的商品应该与创建的商品相匹配。让我们看看 FCO 27，打开邮递员就在这里。

不好意思，回复的正文，FC 27。这就是回到 VS 代码的内容。如果您单击那里，您可以看到存储在那里的实际数据。如您所见，这是我们的文档数据库中的可疑数据，它以 Jason 的身份将数据直接存储到数据库中，我们有 ID、名称、价格和降级日期。如果我们没有在这里做这两行，这些 reducers 认识到它行在这里，你将会看到的 ID 和创建日期的数据将会是非常不同的格式，这将不是非常友好的。但是你可能想根据你的需求来做一些决定。

我要关了它。

我认为是时候实施一条赢得锦标赛的自动路线了。仓库中的其他方法在哪里，让我们实际上走获取项目的路线。首先，

如何实现 get 项，

你唯一要做的就是这个。但是让我们把范围返回到我们的集合，我只是集合，我们要说查找。

在这里，因为我们需要集合中的所有元素，所以我们将只说 new visa document。

哎呀，会有一些文档，我要导入名称空间。

然后它会找到所有的文件。然后你会说要列表。

这将为我们提供集合中所有项目的列表。所以我们找到了一种受尊重的方式来要求所有的项目。但这只是其中一种方式。还有其他一些方法。但是，是的，这将得到所有的项目在那里。有了这些，我们就可以试着得到物品。所以我要再做一次 5。

回到邮递员。

碰巧的是，我们这里的门已经开了。所以应该和再运行这些一样简单。所以我要点击发送。

这就是了。我们正在收集我们的物品。和

看看你现在是否只有一个，为什么不创建几个其他的，就像我们以前做的那样，在这里有一个小列表。因此，我返回到文章页面，文章选项卡，我将添加几个其他项目。所以让我们说解药怎么样

既然这样，那就 15 分钟吧。所以他发了三封，如果他创作的话，然后再加一封。

称之为有效

因为金剑会更贵，比如说 40 英镑。

它发送了

如果我们回去把它寄出去。现在我们有了这三个项目。正如你看到的那样

好吧，如果我们只需要一件东西。

所以这就是我们，

为此，我们需要实现我们的 get item，或者这里的 get item 方法。

但是在我们实现它之前，我们需要一个 MongoDB 称为过滤器定义构建器的东西。这是一种方法，当你在集合中找到想要返回的项目时，你可以过滤它们。因为这是一个很常见的对象，我们将在这里的多个方法中使用，我将在这里把它声明为自己的局部变量。

抱歉，类变量。所以我要说，私有只读过滤器 defini shim builder，那么我们必须指定类型，在这种情况下将是 item。我们称之为过滤器构建器。

然后我们将使用 builders 对象 MongoDB。item 类型的过滤器，这样我们就有了对这个过滤器对象的引用，您将看到我们现在是如何使用它的。你做梦去吧。

所以除了得到物品，

我们要这么做。首先，要建立一个过滤器。所以我们要说，条形滤波器

等于等于 So 的过滤器构建器，其中项目

ID 为的项目。

因此，项目的 ID 必须与我们作为参数接收的 ID 相匹配。那是过滤器。然后我们只需要做类似于之前的项目收集，查找，我们通过了一个过滤器。

然后，我们不需要所有的项目，我们只需要他们应该找到的一个项目。所以我们要说，单或默认。

仅此而已。说完，我要再说一遍五。

回到邮递员身边。

所以这一次，我将打开另一个选项卡，我将粘贴“忘记路线”。但现在我必须指定其中一项。根据我们之前的练习，假设我们想要查看上一次插入的信息。所以我要复制这个

广告。我将把它粘贴到路由项目斜杠项目 ID 中，然后单击“send”。

这里我们可以查询一个特定的项目，而不是所有的项目

回到 VS 代码是时候实现我们的更新方法 update item 了。因此，类似地，为了适应门票项目，我们需要引入一个过滤器，以便我们可以告诉哪个项目更新。

给你。现在，我们必须找到这些变量，因为我们不希望有这么多名为 item 的变量。为了避免混淆。因此，现有项目将被命名为现有项目。

该 ID 的现有项目应该与我们获得该 Id 的项目相匹配，也就是要更新的项目。

当我们找到它时，我们要做是收集物品，

更换一个

过滤项目。这样我们就可以将该项替换到 MongoDB 数据库中。

让我们看看五个并尝试一下。

五、背邮递员。

然后我们要复制大门路线，并在这里打开另一个标签

使用我们的 put。

如此简单。

然后我们必须切换，切换到车身排。我会再回来的，杰森。然后我们把这个拿下来。我们必须把尸体放在这里。因此，如果我们使用 if，我们将更新我们的金剑。对吗？所以我要拿到我们运动员的尸体。是的，我的意思是这个 put 请求的格式，我要从 post 中获取它。

让我们看看我们能对这个词说些什么？实际上我们称之为。

但是在插入时。

假设价格实际上要贵得多。假设是 35。所以这应该会变成白金。所以有了这个变化。让我们看看我们要去的输出，点击发送。

我们得到一个工具，没有预期的内容，然后项目应该已经被修改。所以如果你现在去，回到

或者获取该项目的路径，我将运行它。然后你可以看到，他已经明显改变了新闻价值艺术价格 75，我们得到所有的项目，点击发送，我们看到我们有准备剑作为最后一个项目

很棒。

最后，是时候实现我们的 delete 方法来返回 VS 代码了。

让我们看看删除。

和

是的，过滤器将再次，非常类似于我们的获取项目过滤器。所以把它抄在这里。

在这种情况下，就像说 items 集合那样简单

删除一个，这是过滤器。

这就够了。

所以我会按 f5。再一次，

回到邮递员。

然后，我将复制路由器并使用 input 打开一个新选项卡，从 gate 切换到 delete。

基本路线，我们不需要正文，因为这是删除。我会点击发送。

我们得到了我们的工具，没有预期的内容。如果你再次进入获取路径并点击发送。

现在我们没有那种血腥。你看只有两个项目。另一个不见了。如果你想删除另一个，让我们说伟大的 x 调用删除

1.  在那里，它没有发回任何内容来获取所有的项目，也没有大 x。

所以是的，看起来成功了。然后我会回到 VS 代码学习，结束我想让你们意识到的是，我们根本不需要接触我们的项目控制器。除了添加一些配置和

你知道，注册 MongoDB 客户端，我们所做的唯一一件事就是创建这个插入到服务中的新身份存储库。并且能够自己完成与 MongoDB 交互的所有逻辑，服务的其余部分没有任何变化。这是我们从依赖注入中得到的巨大好处，在这种情况下，是仓库模式。

在这一集的 dotnet five REST API 教程中，我们将讨论 dotnet 中的同步编程模型。第五，为什么你应该关心它，以及如何通过使用任务 async 和 await 在你的 REST API 中实现它。

今天，您将学习什么是同步抓取模型，以及如何使用 tasks async 和 await 将同步编程添加到 REST API 中。

为了理解同步编程的概念，你可以考虑一个常见的场景，比如准备一份早餐。

所以当你准备早餐时，你要做一堆任务。例如，你要准备你的锅

你要加热它，以便之后，你将继续和冷冻最大值。接下来可能会是

烤面包。在那之后，当面包被烘烤时，你可能想要添加一些花生酱或使用你喜欢的黄油或果冻。最后，也许你还想准备一杯果汁。在这种情况下，你已经连续执行了一堆任务。

如果以这种方式完成，大概需要 30 分钟。但这是你通常的做法吗？

像这样的情况呢，你继续按下按钮。但是不要等着锅被加热，直接开始搅拌面包。没错，你不必等到复试结束。不仅如此，在把面包烤好之后，你还可以开始准备你的使用类。那完全是你在那个时候可以做的事情。

然后，是的，最终，英镑会被加热，你可以继续煎鸡蛋。同时，如果面包已经烤好了，你可以把花生酱果冻放在面包里。所以事情正在发生，一堆事情正在平行发生。

与顺序相反。有了这样的一系列事件，你可以大大减少准备早餐的时间，比如说一直减少到 15 分钟。这两个模型就是我们所说的第一个，也就是我们所说的同步编程模型。我的意思是将我们的编程模型类比为同步的，然后另一个世界将是异步的。所以以同步的方式

模型，你不必等到每一个任务完成后再开始另一个任务。所以，当你可以的时候，你就开始，到时候你会回到之前的任务。然后回想一下我们当前的场景，我们确实有一个数据库，一个 MongoDB 数据库。然后我们有一个与数据库交互的存储库类。现在，与数据库交互是一项昂贵的操作，因为您必须执行输入输出，对，您必须通过网络与该数据库对话，该数据库可能需要一段时间才能向您返回结果，这取决于它的位置，取决于它在该时间点的负载量。这可能需要时间，所以你不希望等待数据库完成工作，你要做的不是对数据库进行同步调用，而是对数据库进行同步调用。

所以你开始工作。然后你让它完成工作，工作。结束的时候，如果你必须做别的事情，你就继续做别的事情。同样，我们将让我们的控制器与存储库进行对话。但是现在我们要把它变成一个异步调用。因此，控制器将与相反的控制器对话，它不会等待它完成与数据库相关的任何工作，它会继续做您可以做的任何其他事情。然后最终它会回到那个任务来完成工作。同样，无论谁调用，我们的控制器也应该能够以异步方式调用它，这样他们就不必为了继续做其他工作而等待我们的控制器完成正在执行的任何工作。这就是我们所说的基本上异步的方式。所以链 a 的所有调用都是以异步方式进行的。这为代码的执行提供了很高的性能和效率。

为了在 REST API 中重用异步编程模型，我们需要对仓库和控制器进行一些修改。让我们首先对我们的项目存储界面进行必要的修改。因此，让我们打开存储库项目容量。

在这里，我们需要做两件事。第一个会是

确保这些项都返回黄昏，而不是 item 或 ienumerable 或 void。

另一种方法是重命名这些方法，使其具有 async 后缀。因为在这种情况下，当你创建 API 或接口时，这是一个约定，如果你有一个更好的同步，你应该用异步来修复它，告诉消费者这个方法是 Nic Nic 方法。实际上我们将从这样做开始，因为我们将利用 VS 代码的重构能力。因此，这是一种全面的重命名习惯，而不是必须转到每个文件并进行更改。所以让我告诉你我的意思。所以我只需右键单击获取项目。我会重新命名符号。然后我们在这里输入新的名字。太神奇了。我来敲回车。

如您所见，不仅仅是名称，在界面中更改它。如果你也看到了，我刚才的控制器已经被修改了。和

如果我们看到这里，我们调用存储库的地方，get itis async 是一个已经使用的新名称。没有我们做任何其他事情，他可能有栓剂，现在它已被重命名为方法，以获得项目异步。MongoDB 也是如此。存管处，

异步获取项目。所以保理业务实际上一直在进行。所以我们要对所有的方法做同样的事情。然后为了让事情变得更快，而不是右击，我们要做的是使用热键 f2，我们用了一个快捷方式。所以你按 f2 键，然后输入 pacing。我要把这个后缀复制到这里，输入 F 来表示 a seeing，输入 F 来表示 Singh，输入 F 来表示 async。

因此，我们所有的 a 或四种方法都没有改变。

现在，就像我说的，我们唯一要做的就是确保这些方法都返回任务。这是因为这是一种方式，表明这不再是一个同步方法，而是一个异步方法。所以你要做的就是

这种情况下项目的任务。让我导入命名空间系统的三个任务。

就像我说的，这是说当你从这个方法得到一个项目，你不会马上得到这个项目，它不再是一个同步的方法，你会得到一个代表异步操作的任务，这个任务最终会返回一个项目，无论何时我们完成了从数据库中检索这个项目。这使得金属互联网同步化，我们要对这里的其他方法做同样的事情。所以 item 的 ienumerable 任务，然后对于空的情况，我们就变成了 desk

这就是该接口，该接口已准备好作为同步接口运行。接下来，我们将进入我们的列表，稍微打开一下

MongoDB 物品有听觉。

好吧，

让我们来看看。我们一个一个来。

所以这个列表中的第一个是伟大的异步项目。所以我又要把博伊德变成任务了。

然后我要导入一个导入命名空间的方法，右命名空间。和

此时，我们要做的是开始调用方法的同步版本，在本例中，MongoDB 是项目集合提供的。这是一种常见的 a 模式，就像在这种情况下，我实际上要在这里打开智能感知，您会看到对于 insert one，有一个替代的 insert one 异步方法。在这种情况下，对于 insert，有许多 AZ met，这将是许多这些库的常见情况，它们必须寻求一些外部服务。因为这些操作可能很昂贵。并且它们表示输入输出操作，您希望提供以异步方式执行操作的能力，而不是异步方式。

当你做 C 同步操作时，就像我们之前做的那样，插入一个，你实际上是在做一个阻塞调用，你只是让这个方法在那里停下来，直到调用返回到方法中，没错，在这个例子中是从数据库中。而这恰恰是你不想做的。所以就变成用异步方法了。你不需要等待，我的意思是，代码不需要等待调用结束。这将使你的整个应用程序更加高效。这是我们要做的一件事，让它成为同步调用。然而，我们仍然有一个小问题。事实是我们遗漏了一件事，那就是 async await 关键字。因此，通过在 task 旁边执行 async，然后在这里等待，当我们进行调用时，我们在整个方法周围添加了一点语法糖，告诉编译器 dotnet five，这将是一个异步调用。请帮助我们，不必写更多的代码来告诉它，我们将如何绕过这个异步调用。所以一个接收器和一个权重，它确实在定义方法将变成异步方面帮助了我们很多。这样我们就不必编写更多的代码来处理任务以及如何中断它。这将是它的等级项目异步。所以现在让我们继续用其他方法。或者我们删除图像化。同样，我们将执行异步任务。

在这种情况下，我们要做一个我们称之为数据库的行。在这种情况下，lid one 会做一个 weight is 集合，删除一个 async。

是的，这就是删除。下一个，异步获取项目。在这种情况下，我们将对 item 执行异步任务，因为我们必须返回该 item，但它是任务的一部分。然后我们要做 return await，我只是集合 find foot by filter single 或者 default async。

下一个 get 是 async 将执行 item 的 ienumerable 的异步任务

然后等待返回。

然后在这里列出异步。

我认为这是最后一次异步更新。再一次

异步任务。

然后我们就在这里等着，

我们说我们基于一个异步。

这就是你要做的。正如我所说的，通过这样做，您可以确保每次与数据库对话时，您不再进行阻塞调用，您实际上是让框架，我是说，归还资源，我是说，在我们等待数据库操作完成时，归还框架继续工作的机会。就像我说的，这给欧洲带来了更多的效率和性能。现在我们做到了，正如你所看到的，我们仍然有一个问题，迷因是一种可能性，也就是说，这是我们在第一个视频中使用的原始知识库。因此，我们可以选择在此时删除这个存储库，因为我们将不再使用它。但是作为一个学习练习，我们实际上可以把这个家伙也变成一个异步 a

类，我想，即使我们不打算调用任何外部的东西，对吧，所以在这种情况下，我们只是在处理一个有电子邮件列表的项目。因此，这里并不真正需要异步的东西，但是我们需要

我们需要处理已经实现的接口。让我给你展示一下我们是如何做到的。

让我们从一个恶作剧开始。和我们之前做的一样，这必须是 ienumerable 项的异步任务。然后我们有了重要的空间。

我们在这里做的，我们说返回等待。但是在这种情况下，因为我们没有任何东西可以叫噪音，我们只能说，嘿，我只是想做一些基于结果的任务。

我们会传递一些项目。这意味着我们想要创建一个已经完成的任务。我们希望将这些项目集合的价值引入到这项任务中。这就相当于说，嘿，继续执行这个，执行这是另一个方法，等待它完成，然后返回结果。但是既然我们没有什么可以调用的，你说，嘿，只要返回一个完整的任务，里面有项目就行了。那是，那总是，所以这就是你如何处理这种情况，你没有别的东西可以调用。让我们看看如何异步获取项目。所以我们会做

一个场景异步，任务 vitam。

在这种情况下，我们将使用 capture，在动态的情况下，我们将捕获 ID 等于 items，在这里，我们捕获找到的项，我们做一些类似的事情，像以前一样，等待结果。

项目。

是的，同样的事情，我们返回结果，用我们找到的项目完成任务。

用于异步创建项目。同样，我们将执行异步任务。

在这种情况下，我们真的没有任何东西可以返回。所以我们唯一要返回的东西是某种任务，对吗？所以我们说这是一个重量任务，在这种情况下，我们可以完成一个任务。这意味着只创建一些已经完成的任务，然后返回它，而不返回里面的任何东西，因为没有东西可以返回。现在让我们来异步更新一个项目。所以异步任务。

然后再次复制这个等待任务，即已完成的任务。最后，我们将执行删除操作。所以异步任务

并等待已完成任务。没错。所以就这么简单。现在，让你知道，

没有必要在每种情况下都使用 async 和 await，你可以避免这种组合。然而，在某些情况下，我会认为这是一个有点高深的概念，我现在不想深入探讨，因为它有一些你必须知道的陷阱。并且事先知道它们不是微不足道的。所以现在，我建议您在必须运行异步 INVOKANA 同步操作并将自己的方法定义为异步操作时坚持使用 async await。现在，让我们转到我们的 itis 控制器，进行我们需要在这里介绍的最后一组修改。

那么让我们从一个获得物品开始。对，所以是一样的。

让我们把这个家伙，我的意思是，这是一个水槽所有的权利，所以我们必须把一切异步现在异步任务 ienumerable 身份所有这些忘记的项目。同样，重要的是空间。

我们不要忘记，这个方法现在应该加上 async 后缀，因为它是一个异步方法。现在我们要做的是再次行动并等待

并等待 get a get is 异步调用。但是这里有点问题，因为

权重和实际方法是分开的，我们试图马上链接一个选择，这是行不通的，我们必须把它放在括号里，告诉它先这样做。完成后，继续选择正确的选项，这样就符合编译器对我们的语法要求了。实际上，我会把它放在第二行，以便更好地观察。就在我们继续获取之前，我们对它进行异步等待，当这一步完成时，我们选择我们得到的项目。我们把它们转换成 sto，然后把它们返回给调用者。

当我们学会得到物品时，我们现在要做的是

的同步任务实际上是将它出售给和

应该是异步获取项目。

这里，当我们调用异步获取项目时，我们通常等待

那就行了。

当我们不做下一个帖子时，我们会做

异步任务。

评分项目进度。

这是我们创建项目的地方。所以我们将做一个权重，创建动画。然后记住，现在这个方法实际上被命名为 get item async，所以我们必须进行适当的重命名。

下一个更新项目。

所以让我们说异步任务。

动作结果更新项，一个接收器。

让我们看看，这就是我们所说的。所以我们会说等待异步获取项目。在这里，我们还必须等待更新异步项的调用。最后，让我们来看看 delete item 方法。会再次发生的

异步。任务，操作结果列表项异步。

然后等待

然后在这里，

等待栓剂，异步删除项目。所以现在我们的控制器是全异步的，并且调用全异步的方法。而储户也在调用方法，总是在。所以我们基本上一直在做异步。所以让我们看看这是怎么回事。所以我现在只做 f5。

而且我要开邮差了。

让我们看看，让我们开始尝试 API 的。第一个，我们看到的第一个是物品。所以让我们试着得到完整的项目列表。所以我会点击发送。

正如你所看到的，我们确实有之前视频中的解药还在，工作得很好。现在让我们试着创建一个全新的项目，对吧，我们该怎么称呼它，假设这是

高药剂。这种药剂可以增强玩家的力量。所以价格会是，比方说 30 美元。

我要点击发送。让我们看看这是否可行。

因此，我们确实有一个问题，我们得到一个 500 内部服务器错误，没有路由匹配提供的值。所以这实际上是意料之外的情况。这是因为 ASP。网核三。让我告诉你为什么会这样。让我回到项目控制器，我将使用一个 stop this，close that。如果你还记得，我们刚刚在 grid item 异步方法中做的是，我们在这里更新或创建了一个 action 调用，使用 get items 的名称 get async，而不是 get item，因为我们只是在这里将其重命名为，get item async。这是以前得到的。现在，对 ASP 感兴趣的突破性变化。NET Core 是在运行时，框架实际上要从中删除 async 后缀，这实际上看起来就像 get it，而不是 get Iam async。

假设当我们在这里尝试执行最大的添加操作调用时，它无法找到该操作所代表的路线。这就打破了一些东西。所以有几种方法可以解决这个问题。我要做的是告诉一个点网，我不想要那种行为，我只想继续使用异步后缀。为此，我们可以做的就是启动

启动时，你要做的是找到你对我们的控制器的调用。在这里，你只需要指定一个选项，那就是选项。让我们看看选项，打开花括号，然后你想做的选项，抑制了实际名称中的主题后缀

等于 false，这将不会在运行时从任何方法中删除 async 后缀。让我们看看会怎样。

像五个，

回到邮递员。

现在你要记住的一件事是，创造确实成功了。只是碰巧我们不能调用创建我们的动作，对吧。所以只是为了确认一下，如果你回到这里，你会看到我们确实创造了高药剂。原来如此。但是我们不会我们无法完成创造。我的意思是，我们能够成功地调用创建操作。

因此，让我们实际上在这里创建一些其他东西，不要将它们与高份额混淆。所以我们称之为超级药剂，否则超级药剂会更贵。比如说 45 岁

所以现在我要做发送。

这一次，他们成功地创造了它。

没有问题。

现在让我们使用这个项目来实际尝试 get 路径。为了得到该项目的 a，让我们看看这是否可行。

那工作得很好。现在，让我们来试试这个项目的 put put 路径。让我们看看，我们将使用相同的名称，也许制作一种药剂。但是我们再来说一个价格。让我们看看我们有什么价格。这里我们有 45，让我们说它是更昂贵的 50 为超级药剂。

所以我会点击发送。

那应该更新了超级药剂。所以让我们回到大门，确保价格的变化。所以再次点击发送。如您所见，价格现在是 50 英镑。

和

让我们看看，让我们实际上不要删除我们将尝试删除路线中的构成。不过还是删点别的吧。假设我们要删除这个高的部分。实际上，他是我们最喜欢的实验品。所以我会复制那个身份证。所以我会试着删除它。

Anil 他已经向目标路线发送了两到四个新内容。让我们看看我们得到了什么。如你所见，希帕提娅走了。所以我们只有解药和超大份。

你想要配置的东西实际上正在被读入数据库。这就像回到 VS 代码一样简单，并且关闭。我将再次打开我们的 MongoDB 扩展，目录条目。我们确实让我刷新一下。我们有两份文件，一份是解药。

当他们推动时，是的，现在你完全同步了

REST API，它将给你带来出色的性能和效率。从现在开始。

在这一集的 dotnet five REST API 教程中，我们将讨论秘密管理和健康检查。我们将看到如何在开发过程中安全地存储秘密，您的 REST API 可以像使用任何其他配置一样方便地使用这些秘密。我们还将了解运行状况检查，以及它们如何成为报告 API 运行状况的好方法。

今天，您将学习如何通过 dotnet secrets manager 存储和使用机密，以及如何使用健康检查来报告 race API 及其依赖项的健康状况。

那么我们来谈谈秘密管理。如您所知，在这一点上，我们确实有一个 REST API 能够与数据库或 MongoDB 数据库对话。

为了能够与它对话，我们定义了一个配置服务，其中我们指定了主机和端口等详细信息。为了能够连接到 MongoDB 数据库。到目前为止，我们一直使用的配置源是我们的应用程序设置，即 JSON 文件

在那里，我们有主机本地主机和端口 27，零 17。

但是现在我们将启用对 MongoDB 数据库的身份验证。所以你需要一个用户名和密码来连接它。我们必须告诉我们的 REST API 如何使用这些信息。因此，对于用户，我们将添加我们的用户，另一个用户正在 JSON 的顶级设置中设置，我们将把它称为用户名的 MongoDB admin。然后我们还必须指定一个密码。那么我们是不是应该直接在 app 设置 JSON 文件里指定密码就好了？嗯，答案是否定的。你不希望在应用设置 JSON 或你的服务中的任何文件中添加任何秘密。没错。这是安全方面的一个基本的良好做法，永远不要在其中引入秘密。

如果我们做不到这一点，那么我们如何将这些信息传递给服务。所以它倾向于

app service JSON 只是可以提供给 REST API 的一组可能的配置服务之一。还有其他选项，比如您可以使用命令行参数，您可以使用环境变量，或者您甚至可以使用一系列其他云搜索，来自云的搜索可以为您的 REST API 提供配置信息。

在我们的例子中，我们将使用一个叫做秘密管理器的工具。这只是 dotnet 内置的又一个配置源。这已经为你预先配置好了，因为任何全新的 web API 都在那个秘密屏障中。我们可以安全地存储我们的密码，比如说 pass。而不必将密码放入 REST API 中。所以它不会出现在任何组成 REST API 的文件中。它会被安全地存储在我们机器的某个地方，但是 REST API 在读取时不会有任何问题。那个密码是因为就像其他任何东西一样，它只是作为一个新的信息来的。

主要来自我们的配置服务。其余的 REST API 可以轻松使用。

我们现在将启用对我们的 Mongo 数据库的认证访问。有几种方法可以做到这一点。但是为了保持简单和安全，这只是一个用于学习目的的开发数据库，我们将删除 Mongo container 当前存储所有数据的卷。这允许我们使用一个全新的 Docker 卷启动一个新容器，并启用身份验证。

因此，您可能想要做的第一件事是验证您是否已经在运行容器。所以我们要做的是打开一个新的终端。

我将执行 docker ps，它会告诉您容器是否已经运行。你确实是，在这种情况下，我是。如果我要做的第一件事是停止这个容器。所以我要做 Docker stop Mongo

这就停止了集装箱。现在我想知道的是，这里有多少卷。因此，Docker 卷 LS 将为我们提供一个我们现在关心的卷 MongoDB 数据。现在我要做的就是删除它。所以 Docker 卷，RM MongoDB 数据。

因此，现在卷消失了，我们可以用一个全新的卷重新启动容器。所以我现在要做的只是抓取 a 的初始设置，运行容器的初始命令，就像我们之前做的一样。如您所见，相同的卷在这里，将会有一个新卷，因为我们已经删除了它。我想做的只是添加几个环境变量，它们代表将在数据库中的使用的用户名和密码。所以如果我用破折号 E，这是文件，变量的名字，在这里是 Mongo。

dB。

Root 用户名。

我们在这里为用户指定名称，您可以在这里使用任何名称，我将使用 Mongo admin。

这是用户名，现在是密码

对于密码，您必须使用 Mongo ini dB，

root，密码，

等于，然后你要选择一个密码。所以我在这里选点东西，不是超级强，但还是

类似这些的东西。

最后，在这种情况下，我们想要使用的 Docker 图像的名称是 Mongo。因此，这是一个点击进入。现在我们有了 docker ps，我们有了一个数据库，该数据库使用 Mongo admin 用户和 pass bout 密码启用了身份验证，我们就是其中之一。

所以在这一点上，我们的数据库请求认证，但是我们的服务还不知道它。因此，如果我们在这一点上尝试查询日期，会发生什么，我要做的只是点击 f5，服务。

好的，然后去当邮递员。我将尝试查询几个项目，看看会发生什么。这些是它发送查询项目。

是的，命令 find failed 命令 phi 需要认证，对吗？所以很好。身份验证正在进行。只是我们的服务不知道与数据库对话的正确凭证。那么我们如何才能让这个服务知道需要使用的用户和密码呢？所以让我们回到 VS 代码。让我们停下来，结束这一切。我要做的是，首先我要为用户声明一个配置设置。所以我要开放杰森系列。在我们有 MongoDB 设置的这一部分，我将在这里再添加一个部分。

对于 for user，姑且称之为 user 吧。

我们知道我们为数据库指定的用户是 Mongo。

现在，我们还需要一个密码。当然，我可以在这里指定一个密码。但这不是个好主意。你不应该在你的应用设置 JSON 文件中指定秘密或机密信息，那是一个安全漏洞。所以你不应该这样做。相反，我们将利用 dotnet secret manager 来存储密码安全性，因为我们仍然能够毫无困难地将密码拉入 REST API 的服务中。为此，我将再次打开一个终端。

这就是我要做的。首先，让我们为我们的项目初始化秘密存储器。我们可以通过网络用户秘密做到这一点

有一点儿

如果你快速浏览一下 catalog CEUs 博客，你会发现那里有一个新的实体。用户机密 ID。所以这代表了这个项目的秘密配置的标识符。

从这里开始，我们可以开始为这个项目添加秘密，并做一个你能做什么 is.net 用户秘密的秘密

设置。并且在这里你已经指定了秘密的名称。现在，对于名称，我们要做的是遵循设置的惯例，

我们已经定义了 settings 属性，而您的属性是以 net 接受的格式在中添加的。因此，在我们的例子中，这意味着指定 MongoDB 设置，然后我们使用冒号，然后我们指定代表密码的实际属性，这种情况下将使用密码。

在那之后，我们指定了实际值，在这个例子中是密码，我们知道密码是密码一，或者一。

好吧。就像我在这里做的一样，我要说的是，这个秘密的名字将以 MongoDB 设置开头，它与这里的 MongoDB 系列相匹配。password 是 MongoDB settings 类中其他属性之后的属性之一，传递的是实际值

出单词一，回车。秘密已经被加上了。我们现在需要的是将用户名、用户和密码读入我们的服务的方法。为此，我们将进入我们的设置，设置类 MongoDB 设置。

当然，我们结束吧。

让我们在这里添加几个新的属性。所以让我们补充一下

字符串，用户。

和字符串

密码。这是两个在运行时由 dotnet 填充的属性。到我们的应用程序中。

现在，

另一个我们想要定义的是一个修改的连接字符串，因为现在它不足以给我们提供完整的支持。我们已经指定了用户和密码。对于 MongoDB 连接字符串，您可以这样做

用户冒号

密码。然后我们说在主机列端口。所以这是 MongoDB 希望从我们这里得到的相同文本。这样做之后，让我们再做一次等式运算，看看会发生什么。所以我要做一个五。

我现在就去找邮递员。所以让我们看看是否可以查询发送的信息。

是的，我们什么也没得到，因为记住，这些是全新的数据库，因为我们修改了卷，但我们得到的是 200。好吧，哦，事情似乎运行得很好。为了确保万无一失，我们要做的是发布一篇文章。我们将切换到 post 选项卡，看看我们是否真的可以用价格 45 重新创建这一大部分。不仅如此，让我在这里放一个断点。看看这些值在运行时是什么样子。辛西娅·辛格尔顿，我不得不停止并重启我们的服务。所以我们再按一次 f5。

所以第一次需要连接时，我们应该点击这个断点。所以去找邮递员。我会在这里发送。

我怀疑我们在这里有一个断点。如你所见，用户已经从我们的应用程序设置 JSON 文件中读取，密码已经从秘密管理器中读取。所以密码根本不读取，更新 JSON 只是来自秘密管理器。和

实际上，当我们创建默认构建器时，在这里运行的魔法是由程序 CS 驱动的，当多一个配置服务于我们的服务时，该部分负责注入秘密屏障。所以你不需要做什么特别的事情来让它发生。所以如果事情发生了，我们就让它继续下去。

回到邮递员身边。事实上，是的，大部分已经被创造出来了。如果我们为他们创造。我们会看到它就在那里。

所以继续下一个话题。现在让我们开始讨论健康检查以及如何启用它们。但是首先，让我们了解一下健康检查。

正如我们所知，此时我们确实有一个 REST API 与 MongoDB 数据库进行对话。

然而，随着时间的推移，面对问题并不罕见，对不对？所以 REST API 可能会因为各种原因而关闭。也可能是好意，对吧？我们可能会将这些 REST API 重新部署到我们的服务器、我们的云服务或我们的服务器上。因此，即使是暂时的，REST API 也可能会关闭。

在与我们的数据库对话的另一方面也会有问题，对吗？因此，出于任何原因，数据库，我们可能会失去与数据库的连接，无论是暂时的还是长时间的。

或者可能发生了什么，我们真的在和那个数据库对话，对吗？所以沟通问题可能会发生。有了这个，我们可能会开始得到一些等式，比如，我们的 REST API 还活着吗？那么它是活的吗？Ganga，我们实际上是在和这个 REST API 对话。没错。所以你可能开始想知道这个，或者你可能开始想知道，我们能找到一个数据库吗？它在那里吗？连接状态是否良好？

但实际上，你在这里问的是一个更广泛的问题，它健康吗？那么我们的种族 API 健康吗？它准备好接受测验了吗？它准备好以正确的方式完成工作了吗？

要回答这个问题，正确的方法是启用我们所说的健康检查端点。所以所以你不用猜。所以我们会有，你会有一个自然的端点，你可以称之为我们通用 API 的一部分。您可以调用它，它应该能够告诉您服务是否正常。没错。当然，会有人对这些信息感兴趣。因此，增加服务用户，如开发人员、工程师，可能希望查询帮助端点作为健康的服务。但真正最重要的情况，最有用和最原始的场景是当您有一个 orchestrator 系统时，它将负责知道您的服务何时准备好接收请求。所以我们会在以后的几集里多讲讲这个。但是

拥有一个健康检查端点是任何 REST API 的关键部分，你必须马上考虑。

现在我们已经了解了健康检查，让我们看看如何为我们的 REST API 启用它们。所以我们要做的第一件事是增加健康检查服务，这是我们可以在创业公司中做的。是的。在此之前，让我们停止调试，关闭终端，打开启动 CS。我将讨论配置服务方法。

在这个方法中，我们要一直往下走。

我们将在这里添加一行。服务 dot 添加健康检查

现在，这就是服务，现在我们需要为它添加中间件。这是我们必须在 Configure 中的 US endpoints 方法内完成的。这里，我们要说的是，映射健康检查的端点。然后在这里，您可以选择要用于健康端点的路由。所以对我来说，我会选择健康。但是你可以自由选择其他的东西，比如你可以做一些类似 hc 的东西，或者你可以做 health 看，这真的取决于你，你想用什么，我就用那些。

现在我要做一个五。让我们试一试。因此，这将为我们提供一个非常基本的服务运行状况检查端点。所以回到邮递员。您查询这一健康检查的方式与我们查询 iTunes 途径的方式非常相似。因此，我们只需在 postman 中打开一个新标签，就可以得到 burb。我将选择本地主机冒号 5001。然后你只需添加 URL 来路由我们的案件。我会点击发送。

这是你得到的结果，他说健康。

因此，你有一种方法，几乎像是在为你服务，看看它是否处于健康状态。因此，这意味着服务已经启动并运行，一切都应该正常。

然而，这实际上不是非常有用，因为即使服务启动并运行，如果数据库关闭，如果服务关闭，或者如果我们无法访问它，这也没有任何意义。

我们的服务实际上并没有那么健康。

那么，我们如何判断我们是否有任何依赖服务，比如处于非健康状态的数据库？我们如何利用健康检查来解决这个问题？让我给你展示一下我们能做什么。

回到这里，停止关闭这些将要做的是添加一个牛轧糖包。

那叫 ASP。NET 核心健康检查 MongoDB。这将允许我们添加专门用于验证 MongoDB 是否正常运行的健康检查。所以我要在这里开一个新的终端。而我要说的是 dotnet，add package，ASP。NET 核心健康检查。

所以这是一个开源项目，它不是 ASP 的一部分。NET Core 或 dotnet。五个，但这是一个非常方便的项目。有了这个包，让我向你展示我们能做什么。

再次关闭终端。然后。

在这里，我们要做的是向这个调用添加一些选项，以添加一个运行状况检查。但是在我们这样做之前，我们需要取出我们的 MongoDB 设置，以便我们可以在以后减少它们。为此，我要抓住这条线，

从外向内，比如说这里，

我们称这些为 MongoDB 设置。

所以现在这些 MongoDB 设置可以在这里用于我们的 MongoDB 客户机 Singleton。但也是为了我们现在的目的，在说了一个健康检查之后，我们要说

在 MongoDB。这里我们将使用 MongoDB 设置，

那个连接字符串

为了指定需要用来连接到 MongoDB 数据库的连接字符串，right 或 health check 将基于我们能否到达该数据库。我们还将在这里添加一些东西，比如用于定义这个特定健康检查的名称。我们就说 MongoDB。还有一点就是暂停。

这是因为我们不想让这种运行状况检查花很长时间来告诉我们数据库是否刚刚关闭。没错。在这种情况下，我们从秒开始计算 timespan，假设是三秒。如果三秒钟后，我们无法连接到数据库。但是我们会认为支票失败了。既然我们已经做到了，那就让我们试一试吧。所以我做 f5。

让我去掉这个断点。

又变回邮递员。所以在这里，是的，我要说你好再次发送。而且是健康的。我怀疑是因为我们的数据库正在运行。但是如果我回到 VS 代码，进入我们的终端，我使用一个 stop 我们的

MongoDB 容器。让我们看看 Docker stop Mongo，也就是 Docker container，这相当于完全停止我们的数据库，整个数据库服务都停止了。所以让我们看看当我回到邮递员身边时会发生什么。我试着检查她的健康状况

大概需要两秒钟。是的，就在这里。所以现在健康检查报告为不健康。这很好，因为现在任何时候数据库停机，我们都可以很容易地知道，这是我们在这里使用的运行状况检查的一部分。

现在还有一件事我们可以用来改进这个场景。事实上，我们可能希望有多个端点来验证服务是否启动，以及它是否准备好接收请求。这里的典型模式是指定一个就绪端点和一个活动端点。因此，我们的就绪端点将告诉我们是否准备好，服务是否准备好接收每个传入的请求，对吗，在我们的情况下，这实际上意味着数据库启动并运行就绪了吗？我们能用它吗？而实时端点将告诉我们我们的服务是否正常运行？是活的还是没活的。

所以这样做是这两个端点，让我们实际上回到 VS 代码。我会再次阻止这一切。

然后回到启动。

我们必须做的第一件事是返回到我们的运行状况检查配置，我们必须为我们的运行状况检查分配一个攻击，让我向您展示我的意思。所以实际上把这些东西放下一点，这样我们可以做得更容易。所以我要打开一个

这里还有一行。我会说是税。

所以我会在这里创建一个小数组。

在这里，我说准备好了。所以我在这里附加了一个标记，我称之为 ready。这将有助于我的团队，我要申请的每一项健康检查都是 ready endpoint。所以指定我是否准备好开始接收请求的端点，

我们如何使用这个。现在让我们回到我们的地图健康检查部分。

我在这里加一行。

所以现在我们知道我们需要在我们的两个端点中指定，一个用于就绪，一个用于生命。所以我们先去找乌鸦。因此，我将不再停留在这里，而是说，好了，准备好了，这将是我们准备好的终点。现在已经指定了健康检查。

健康检查选项，请参见那里的博物馆空间。

好吧，打开这个。因此，在这一点上，我们必须指定我们称之为谓词的内容，因为谓词是您可以筛选出要在此端点中包含哪些健康检查的方式。所以请记住，现在，我们只有一个真正的，我们的那一个已被标记为就绪。这是 MongoDB 的一种形式。因此，在镭点的情况下，我们希望包括 MongoDB 端点。所以要做到这一点，你要做的是，你说检查。

然后我们会说检查标签包含。

然后标签名准备好了

您已经将端点，将只包括那些已标记为就绪的运行状况检查。

然后我们必须定义另一个端点。所以我要复制，复制这些，

这一次将会是现场直播。

真的，对于现场案例，我们不用做太多，我们其实不想，我们不想包括任何健康检查，我们只想说一种对粉饭的回应。在这种情况下，我们说只是假的。通过这样做，我们排除了每一个健康检查，包括 Bongo DB one，因此只要 REST API 存在，服务就存在，健康检查就会返回给我们。这就是你生活的方式。准备好了，我们将确保数据库准备好为请求服务，life 将确保我们的网站和服务正常运行。所以有了这个，我们再跑一次。所以我做 f5。

我又变回邮递员了。这一次，让我们来看看。所以我会查询，让我想想，健康，生命。

看看我们得到了什么。

所以他说健康是可以预期的，因为这项服务已经开始运行了。

现在我准备好了。

看看我们得到了什么。

所以大约三秒钟后，我们就会变得不健康。这是因为我们的数据库 Docker 容器仍然处于关闭状态，对吗？就像我们以前做的一样。如果我回到这里，

我回到我的终端，比如说这个，实际上重启了 Docker 容器。

为了码头工人，罗恩，是的，当然，做吧。那就再启动一个集装箱，回到邮递员身边。他会发送邮件，但我被耽搁了，因为数据库服务器和数据库已经启动并正在运行。

通常这就足够了。这就是你想要做的，让你的健康检查。但是如果你碰巧想知道更多关于

您已经配置的运行状况检查，您实际上可以自定义您在这里得到的消息。这给了我们最基本的健康，但你可以得到更多，如果你想回答，让我告诉你怎么做。

回到 VS 代码中，打开关闭，

我们将寻找我们的 map 健康检查功能。红色的那个特别有趣。我们可以做的是利用所谓的响应编写器。

这是一个 post writer，您可以使用它来指定如何呈现您在收集运行状况检查结果时收到的消息。所以我要说

异步上下文。

很抱歉

背景报告。

让我们这样做，然后打开花括号，然后在这里，我要收集的结果，签出。

因此，我将说 sold equals，我将使用 JSON 序列化程序。

dotnet 自带的那个，

我要连载了。

现在我们要在这里创建一个匿名类型。所以我只说新的。然后我们要给它一个形状。所以这就是我们要返回到 postman，到项圈的形状。因此，我想展示的第一件事是一个状态开始，我们可以从报告中获得

点状态，只是为了串。

然后我们想得到支票的数组，

其中应该包括我们的 MongoDB 检查。在这种情况下，我要说的是报告条目，选择。

我会说，我把每一个条目都投射到一个新的匿名类型中。

在这种类型中，我想先展示它的名字，

然后我会得到这个非常具体的支票的状态，

它将从输入值状态转换为字符串。

然后可能会有来自数据库的异常。让我们实际上也抓住这一点。

哎呀，对不起。

异常，将会是空的值，但是我们可能有也可能没有异常，这取决于检查的状态。所以我们要说的是，如果异常不是 No，我们会得到一个入口值，异常消息。但是如果我们没有任何例外，如果没有，我们就说没有。

最后，最后一个有趣的细节是持续时间，它将告诉我们进行这个健康检查需要多长时间。

和三个值，持续时间到字符串。

野味，所以要品尝。

现在我们可以做的另一件事是格式化输出。所以我要说，上下文，内容类型的反应等于

媒体类型名称。

用一些东西

杰森的那个应用程序，

这将让我们在 postman 中呈现一个漂亮的 JSON 字符串。最后，我会把这些信息写出来。所以等待上下文响应。对吗？

右侧异步

结果

使用一个新垫片。

这应该可以了。现在，我们已经定制了该消息的呈现方式。所以我要再做一次 5。

又变回邮递员。现在，让我们看看当我尝试我的无线电端点时会发生什么，就像点击发送一样。

现在正如你所看到的，结果变得更好了。所以我们的状态是 Lt，然后我们可以看到对象的数组。在这种情况下，我们有 MongoDB，有一个健康的伤害感受和持续时间。如果我们想得到一个有实际例外的例子，你可以再次停止你的本地 Docker 容器。

跟踪狂停止蒙戈

集装箱已停止。我会在邮递员送来的时候再试一次。

三秒钟后，我们应该得到是的。所以现在，如你所见，在这里，整个健康检查是不健康的。MongoDB 是不健康的。是的，手术取消了。这就是我们从 dry dock 到 MongoDB 所得到的。

现在，我想给你们看的最后一件事是，实际上已经有很多健康检查可供你们使用。就像我们做了一个 MongoDB 一样，让我停下来关闭它。如果你记得的话，我们做到了

这里，我们做了 MongoDB。第一，就像这样，根据你使用的服务，已经有一堆其他的软件可供你试用。让我把你带到这一页，这是我提到的开源项目的一页，有这些健康检查。在这个 GitHub 项目中，你会看到它，它会告诉你如何使用这些健康检查的一切。但我想向你们展示的是，已经为许多提供商内置了健康检查，对吧，所以 SQL Server、MySQL、许多东西 Cosmos TV、sendgrid、一些 Azure 服务、Amazon 服务、Google stuff，这是我们使用的 MongoDB。和

所以是的，所以有

已经有很多供应商了。甚至还有一个你可以用的牛轧糖包。甚至还有对 UI 的支持。我一般不用这个。但是，如果您想要显示一个非常好的 UI，其中包含所有运行状况检查，以及每项检查的明细，您实际上可以启用这些运行状况检查 UI。抱歉。是的，这将在您的服务中建立另一个端点，您可以访问该端点，并呈现所有这些漂亮的用户界面。所以你可能想尝试一下。我通常发现有一些旧的方法来量化我的服务的帮助，正如我们在这些视频中看到的那样。但这是你可以尝试的另一种选择。

在 dotnet five REST API 教程的这一集中，我们将开始将 API 部署到我们的生产环境中。我们将了解在我们的开发者盒子之外部署 API beats 所涉及的关系挑战，Docker 如何帮助我们解决这些挑战，以及如何将我们现有的 API 转变为 Docker 容器。

今天，您将了解部署的挑战、Docker 的工作方式以及为什么应该使用它，

如何把 REST API 变成 Docker 镜像，如何把你的 REST API 作为 Docker 容器运行。

现在的情况是，我们已经有了一个 REST API，并且正在本地机器上运行。旁边还有一个 MongoDB 数据库作为 Docker 容器运行。

但是现在我们需要弄清楚我们将如何与世界共享这个 REST API，对吧，或者如何与我们本地内部网的人共享 REST API，或者如何与世界共享 REST API，也许是在公共互联网上。我们将要共享东西的地方就是我们所说的生产环境。生产环境可以是在您的建筑或家中运行的任何服务器。或者也可能是在互联网上运行软件的服务器。但在所有情况下，这是生产环境，在这里人们将能够访问 a REST API，而不必访问您的本地机器，您的开发者机器。当我们选择这个产品时，首先要考虑的一件事是，生产服务器是操作系统。所以我们需要弄清楚什么时候去找

安装了我们的 REST API 能够支持的正确操作系统版本的正确服务器。所以对于 for REST API 来说，这并没有什么大不了的，因为这五个是跨平台的。因此，到目前为止，我们所做的就是能够在一系列操作系统中运行。但是，我们仍然需要销售安装操作系统。因此，如果我们说我们将在 Linux 上运行它，那么我们将需要继续下去，并确保我们有 Linux 可用在该生产环境中的正确的 Linux 发行版和版本。

然后，我们还知道，我们确实需要 dotnet five 运行时来运行 REST API，REST API 是基于 dotnet five 构建的，因此，我们确实需要 dot net five 运行时及其所有相应的文件，它们需要放在生产环境中的正确位置。最重要的是，我们的应用程序可能有一堆依赖项，比如我们一直用来与 MongoDB 对话的 MongoDB 驱动程序。就像这样，它可能有一堆依赖项，它们也需要放入生产环境中。所以最终，

我们的 REST API 可以与所有其他组件放在一起，它可以愉快地运行。因此，在这一点上，我们可以，我们可以继续，我们有所有的文件，对不起，其余的 API 运行在生产中。

但是，我们还必须考虑到我们也有数据库需求，对吧。因此，我们有一个数据库，我们需要在这个生产环境中的某个地方播放。它在操作系统方面有自己的要求，并且依赖于 MongoDB 可能拥有的 MongoDB 和 Gene，所有这些都是我们在生产中运行数据库所需要的。因此它本身提出了另一组要求。因此，当我们思考所有这些问题时，我们需要做的事情就是让我们的生产正常运行。所以我们需要考虑一些挑战。所以第一件事就是准备一个盒子。所以，你真正想要的是确保我们用于生产的任何盒子都有我们迄今为止在我们的开发者盒子中拥有的一切，对吧。然后，您还必须考虑，我们是要选择物理机，还是要选择虚拟机，或者虚拟机实际上只是运行在其他物理机上的最新版本的操作系统。所以不管是否任职

同样的物理机虚拟机，我们需要想好，我们要从哪里得到这个机器？我们将在哪里举办它？谁将负责这台机器？一堆关于这台机器的问题。但也有办法弄清楚，好吧，那么它会是 Linux 吗？还是 windows？谁会把正确版本的“永远”放在那里？谁来确保他有正确的补丁集？谁来维护这些呢？真的，总得有人来处理这些事情吧？但是，我们如何将文件带到生产机器上，对吗？我们把这些文件都放在他们的盒子里了？不知何故，他们需要在生产中着陆？我们要怎么做？如果我们要使用某种 FTP 协议，能够与一台生产速度极快的机器对话？我们要把文件放在 USB 或硬盘里吗？然后用它复制到生产机器上？我们是否要将文件发送给运营部的某个人，B，也许是一些电子邮件，然后此人会将文件放在那里？你如何做到这一点？到达那里的第一件事？所以不管怎样？

会发生什么？我的意思是，在这种情况下，我们正在考虑将数据库服务器放在 REST API 旁边，如果我们要这样做，我们如何确保数据库的所有依赖关系和 REST API 的依赖关系

拥有正确的版本，即使我们只是把所有东西都放在同一台机器上。没错。所以在 MongoDB 数据库中需要的东西之间可能存在版本不匹配？REST API 中需要的细节是什么？对，从以前的系统开始？我们如何确保所有的依赖项都是它们的正确版本呢？如果他们是，如果他们不能，我们必须找出好的，所以也许我们需要把他的 REST API 分到一台机器上，把数据库服务器分到另一台机器上，这并不罕见。但是我们必须考虑所有这些事情。此外，如果我们最终决定迁移到新版本的 dotnet，该怎么办？好吧，我们假设六号网已经出局了。我们必须我们想进入下一个六人组。那是什么意思？我们是否必须引入一套全新的服务器，即已经支持 dotnet 的物理屋顶瓦？六个？我们是否希望只更新现有服务器中的 dotnet 版本，然后以某种方式确保应用程序不会因为进行这种更改而中断？我们如何实现这一目标？

此外，我们如何开始接收机器，因为它不只是复制文件在那里，对不对？所以不管怎样，我们需要在服务器上启动 dotnet 应用程序，必须有人来做。因此，我们必须引入某种自动化，某种脚本，在该机器中需要发生一些事情，以便能够使用 API 启动，而且不只是启动，而是快速启动。我们希望确保一旦我们将 beats 放入其中，应用程序就会快速启动，以便它可以开始为我们的用户服务。

最后，如果应用程序的一个实例是不够的呢？那么，如果我们开始拥有如此多的用户，而我们拥有一个用于 REST API 的 web 服务器是不够的，该怎么办呢？现在我们需要再引进一个？比方说 VM 虚拟机的一个配方，然后另一个，然后另一个？那么，谁来负责调配所有这些虚拟机呢？为了我们？数据库呢？如果我们交替使用数据库服务器的多个副本来处理负载，会怎么样？那么这一切将如何发生呢？那么我们需要考虑所有这些挑战吗？我们需要处理所有这些吗？还是有更好的办法？幸运的是，Docker 可以帮助我们。

现在，让我们回到我们的本地盒子。是的，我们的本地机器目前有 REST API 和数据库，我们需要投入生产。但是现在，不要开始担心如何将所有的东西复制到生产中，或者如何确保生产已经有了正确的东西，

我们可以开始使用这个叫做 Docker 文件的东西。所以本地文件是一种模板

您的 a 需要的所有东西，在本例中，是一个 REST API，用于将它部署到生产中。因此，在 Docker 文件中，您将声明我们需要的操作系统之类的东西。所以你会说，我在这个特定版本的 Linux 上运行，比如说，他的 Windows 版本是什么。所以他已经在那个文件里被声明了。所以你是说，只要那个版本在生产机器上可用，我就会运行得很好。不仅如此，你还可以说，嗯，我实际上需要网络的五零版本，或者 ASP。NET 核心运行时。和

通过这样做，只要我拥有了 dotnet 核心运行时的所有依赖项，我就能够运行我的 my REST API，对吧，这样你就可以声明将要运行的运行时。

您也可以声明或准备应用程序所需的所有依赖项。

好的，让 ongole 成为驱动程序和任何其他 DLL 或任何其他需要存在于其中的依赖项，您可以指定如何在生产环境中放置您想要放置的文件，您可以指定我们应该如何放置它们。您还可以准确地告诉它如何开始或如何启动 REST API。因此，scraping 需要说明如何启动它，它也可以在 Docker 文件中说明。因此，仅仅通过使用 Docker 文件，您就可以应对我们之前讨论过的许多挑战，因为这个 Docker 文件清楚地说明了需要如何构建环境才能让 REST API 正常运行。但是，使用这个 Docker 文件是不够的。现在你有了 Docker 文件，你要做的是使用这个叫做 Docker 引擎的东西来准备我们所说的 Docker 映像。这里发生的是 Docker 引擎，它只是一个在您的机器中运行的进程，Docker 引擎将获取该 Docker 文件，它将对其进行标记，并构建我们所说的 Docker 映像。

标记实际上是为你的图像创建一个版本的同义词。因此，您将在该映像上设置一个版本，然后构建它。因此构建 Docker 映像意味着逐行读取 Docker 文件，

或者执行所有这些指令来准备运行 REST API 的环境。这可以追溯到确保所有确切的依赖关系都在适当的位置，将文件放在正确的位置并启动应用程序。没错。所有这些都封装在 Docker 映像中。但是，一旦有了 Docker 映像，仅仅让它在您的机器上运行是不够的，对吗？你真正想要的是让它在生产中可用。那么你如何把它从你的盒子里带进生产呢？因此，进入容器注册中心，容器注册中心是一个可以在任何地方的地方，从你的互联网中的某个服务器到云中的某个地方，它是你可以放置你的 Docker 映像的地方，你可以推送你的 Docker 映像

以便它最终可用于您的生产环境。所以这个容器注册中心，我的意思是，你不一定要把 Docker 图片放进去。注册表中可能已经有一些其他的图像。例如，在 MongoDB 的例子中，我们一直在使用

一个实例，MongoDB 的 Docker 映像。因为前几集，我们实际上并没有创造出达蒙已经在那里的形象。该映像实际上可以在一个名为 Docker Hub 的特定容器注册表中获得。因此，Docker Hub 是一个公共注册中心，许多供应商将他们的 Docker 图像放在这里供公众使用。但是就像有一个 Docker Hub 一样，也有其他的容器，私有的注册库，比如 Azure 容器注册库，或者 Google 注册库。亚马逊 ECR，我想是这个名字。也有这些天，GitHub 有一个注册表。所以有很多版本可以使用。但是它们都能够以同样的方式操作你的 Docker 图像。因此，如果您将 Porsche Docker 映像放入容器注册表中，那么您就可以将您的生产机器放入物理机器、虚拟机中，无论是什么机器，它都可以将您的 Docker 映像放入其中。通过拉它并执行那个图像，它变成了我们所说的 Docker 容器。因此，Docker 容器变成了一种活版本，我们的 Docker 映像的可执行或运行版本，但是一个 Docker 容器。因此

Docker 容器正好有它

拥有 Docker 文件中声明的所有文件和所有依赖项，并按照您在 Docker 文件中声明的方式执行 REST API，就像我们如何为 REST API 建立 Docker 容器一样，我们可以为 MongoDB 建立 Docker 容器

Docker 图像。然后，当然，这些容器可以就所有这些神奇的东西相互交谈，我的意思是，它之所以能够工作，只是因为您的机器中也有相同的 Docker 引擎，您将在生产环境中使用它。因此

在这里，只要您在任何一台机器上都有 Docker 引擎，您就可以继续运行您的 Docker 映像，然后您的 Docker 映像就可以作为 Docker 容器在该环境中运行，您不需要 Docker 引擎。这带来了很多好处。另一件事是，您不仅可以运行 Docker 容器的一个实例，实际上还可以运行本地容器的多个实例。因此，当您需要越来越多的扩展时，可能是因为您有太多的用户，那么您可以使用开始将越来越多的 Docker 映像拷贝旋转到生产中的 Docker 容器中，而不必为能够调配越来越多的环境而遇到许多麻烦。所以，有很多好处

Docker 真正在这里，是从高效利用资源的用法开始的。因此，与必须建立新虚拟机或新物理服务器的情况相反，您不必真的投入大量新资源。创建一个新的 Docker 映像并不占用大量的 RAM，也不占用太多的空间，因为 Docker 中的 layers 会进行大量的缓存。因此，大量的缓存、内存只会随着您的具体需求而增加，

为了你，为了你的形象，为了你的服务，免费的 REST API。所以你真的可以安装更多的 REST API 实例，在这种情况下，你也可以在同一个产品中安装更多的数据库实例。

像以前一样，只需提供 REST API 的一个实例，或者 MongoDB 容器，

或者一个 MongoDB 数据库，在同一个生产箱中，你可以装更多。

通过使用容器，也有更快的开始，因为

因为 Docker，Docker 引擎能够缓存所有这些，这些层只是第一次需要下拉 Docker 映像，它将对除了自己的层之外的所有层执行此操作，它将能够只拉已更改的层。这使得它可以非常快地启动。所以你不需要，也不需要启动整个操作系统，只需要安装你的应用程序。所以操作系统已经准备好了，你只需要启动你的 app。Docker 可以非常非常快地做到这一点。

如果这些容器中的每一个都以完全隔离的方式运行，那么也存在隔离。因此，在实际的生产主机中发生了什么，或者在机器中运行的任何其他容器中发生了什么，都无关紧要。每个容器都是独立运行的。所以从他们的角度来看，他们是在那个时间点在那个环境中唯一发生的事情。所以这从另一方面给了你很多好处。

你也可以想象这些容器可以在任何地方运行。因为就像我说的，只要你的生产机器上有一个 Docker 引擎在运行，你就能保证在那里运行你的 Docker 容器。因此非常便于携带。最后，可伸缩性，就像我提到的，在相同的空间中，以前，您将能够只运行 REST API 的一个实例，就像虚拟机的情况一样。现在，您实际上可以运行本地容器的多个实例，而使用的资源要少得多。因此，您可以通过使用 Docker 容器来显著扩展。

现在让我们看看我们需要做些什么来容器化或 Docker eyes 我们的 REST API。

要为 REST API 创建 Docker 映像，我们需要做的第一件事是创建相应的 Docker 文件。然而，在此之前，为了简单起见，我们将更新我们的 REST API，使其不再执行 HTTPS 重定向，只允许使用 HTTP 地址。从现在开始，HTTPS 的使用已经超出了本教程的范围。

那么这意味着什么呢？如果您还记得，我们为 REST API 配置了两个 URL。这些都是在我们的午餐设置文件中配置的。你说丽莎，杰森，应用程序的网址，我们有 HTTPS 本地主机 5001 和 HTTP 本地主机 5000。

按照现在的配置方式，如果有人试图访问 HTTP localhost 5000，他们将被重定向到 HTTPS localhost 5001。

你想测试这个，你能做的只是启动应用程序。所以我在这里做 f5。

我会打开邮差。通常我们会去 HTTPS 本地主机 5001。但是我会把这个改成 HTTP localhost 5000。

在这种情况下，我将在下面打开邮递员控制台

去看看幕后发生了什么。我会派人去查询物品。查询成功。但是如果你看到这里有两个调用，第一个是 HTTP localhost 5000 斜杠项。它返回 307 代码，这意味着重定向。然后是对 HTTPS 本地主机 5001 斜杠项的调用。因此，这是一个已经配置好的重定向，至少是我们希望为 Docker 案例所做的更改。

那么我们该如何改变这种情况呢？回到 VS 代码，我将暂时停止应用程序并关闭它。

这是在 startup.cs 中配置的。

在“配置”方法下，我们这里有这样一行，它使用 HTTPS 重定向

所以他转向我，当你在 Docker 文件中运行时，嗯，对不起，在 Docker 容器中，ASP net 环境从开发切换到生产。这就是我们可以用来在这一行放置条件的东西。所以我们可以说，如果，那就是发展，

那么我们将允许 HTTPS 重定向，否则，我们将不允许。

这是我们在这里要做的唯一改变。我们将看到这是如何工作的。实际上，当我们准备好码头集装箱的时候。

这一点，我就把这个关了。现在，我们实际上想要生成或创建这个 Docker 文件。因此，有两种方法来创建 Docker 文件，要么您可以手动创建，要么您可以生成它。对于本教程，我们将不得不加快速度，我们将生成。所以你需要一个 Docker 文件。嗯，如果你是一个重编码的企业，我建议你使用 Docker 扩展来编写 Visual Studio 代码。如果你去扩展中心，

你可以在这里输入 Docker。

然后，您将继续安装扩展。

现在关上这个。现在你可以做的只是说，查看命令调色板，然后你可以键入 Docker Docker 文件到 workspace 是第一个选项。

现在，您可以选择 Docker 映像的平台，我们将在本例中创建 dotnet。ASP。网芯，

然后你必须选择容器的操作系统，在我们的例子中是 Linux，因为它是大多数时候最流行的选择。

然后你可以选择你要在那个容器中释放的端口。在我们的例子中，它将是端口 80。

最后，如果你想生成一个 Docker 合成文件，我们不会在本教程中使用它来点击 No。

现在，如果您转到我们的浏览器，您会看到有几个新文件，我们有 Docker 文件和 Docker ignore 文件。所以让我们从查看 Docker 文件开始。

在 Docker 文件中，您在这里看到的每一行都代表一组指令，这些指令将在构建 Docker 映像时应用。

这些线中的每一条也会产生我们称之为的层，它代表了从一条线到下一条线所发生的变化。这在我们对这个 Docker 映像进行后续构建时，在步骤缓存方面很有帮助。所以我们第一次建造它，需要时间。这是一段美好的时光。所以硅时代将会更快。现在让我们一行一行地来了解这是怎么回事。

首先，我们要说的是，我们将在. net ASP . net 映像的基础上构建我们的映像，特别是第五版，零，对吧。所以这是，这是你开始的方式，你想从哪里开始，通过指定点网。asp。net，你一定会建立一个基于

工作的 ASP net 环境，在这种情况下，是一个五零环境，它具有运行 ASP。NET app。不仅仅是 ASP net 映像有一个，同时也是建立在正确的总是基于等待的基础上的，在我们的例子中，您在哪里运行您的映像，因为我们将在 Linux 机器上运行它。这将包括运行 ASP NET 核心应用程序或 Linux 中的 net five 应用程序的所有依赖项。

现在，我们也说这是五零为基础。这意味着这将是我们建造容器的第一阶段。这是

这是对多阶段构建概念的一个很好的继承，这也是这里所允许的。这意味着构建过程将有多个阶段。在每个阶段，您可以指定一组不同的指令，这些指令可能与在其他阶段执行的指令无关。举个例子，我们在这里说，这是第一阶段，我们称之为基础。在这个阶段，我们将从一个网络。asp。net，这是 ASP 的运行时映像。NET five work 将会有斜杠 app 意味着在这之后发生的一切都将发生在 app 目录中。然后，我们公开了端口 80，这一行实际上并不意味着什么，只是一种文档字段。公开端口的方式实际上有点不同。但是有一个约定来指定他们监管的港口。现在暂时完成了第一阶段和接下来的九个阶段

在第五行中，我们将进入下一个阶段，我们称之为构建。有趣的是

这个阶段的一部分是它来自另一个基础映像，如果你注意到它来自 dotnet，SDK

到 dotnet。SDK 五系应该是 dotnet。asp。网。因此，SDK 是拥有所有构建工具、所有库以及构建所需的一切的映像

还有 dotnet 五个 app，这并不是说你只需要运行五个 AP 之外的，对吧。所以这张 ACP 图像中的任何东西都可能更大。那里有更多的文件、编译器和构建容器所需要的东西，但不仅仅是运行所需要的。这意味着，实际上从基础图像中得到的最终图像可能会比我们用来构建容器的图像小得多。

因此，我们从这个阶段开始，在这种情况下，它会有一个 slash src。从现在开始，我们将把所有文件放在这里。这正是我们正在做的。然后在下一行，我们说，好的，让我们复制目录，那个 CS 配置文件，那个定义我们的项目到当前位置的根目录。

他们将在休息时运行点网络恢复。这样就带来了所有需要的牛轧糖包，然后我们说，好了，我们已经恢复了所有的包，现在每隔一个文件夹复制一个需要的文件。这包括了你在左边看到的所有文件，除了几个部分，但是大部分文件都在这里。我们一会儿会谈到这一点。

还有这条线，实际上并不需要那么多。因为如你所见，它与 as 线六几乎相同。所以我们马上会删除它。然后，我们进入实际的构建流程，我们说，嘿，继续执行基于目录构建的点网，上面写着布拉格，我们正在修改韩国配置以不再出现错误，我们希望发布该应用的版本以针对生产环境进行优化。并且那个构建的结果应该进入 slash app slash 构建目录。

目前，我们的构建阶段到此结束。所以是这一部分。然后我们将切换到另一个阶段，我们称之为发布。在牛市阶段，

我们要说的是，实际上，我们将从构建阶段。请注意，现在我们将从刚刚创建的构建阶段开始。我们将从这里开始，将其命名为牛市，然后只需执行. net 发布命令。与前一组参数相似，只是改变了输出目录。因此，波兰，它做的是

它创建了一个新文件夹，在这种情况下称为 Polish，所有文件都需要正确的形状，以执行应用程序。现在，在这一点上，我想指出的是，我发现其中的几行有点多余。所以我们可以把事情简化一点。所以我不认为我们需要把构建和废除阶段分开。所以我要在这里做一些改变。所以我要删除这一行，因为我们在第六行已经有了。所以我要把它去掉。我还将删除 dotnet build，因为 dotnet Polish 也为我们执行 dotnet build。所以不需要两条线。

实际上，我将完全删除波兰阶段，因为他们的构建阶段对于我们在这里所做的应该足够好了。

所以现在我们只有一个阶段叫做建造。第二阶段称为建造，将通过运行管道和抛光结束。我们需要的所有文件都应该是波兰文的。

现在，在 912 中，我们回到最初的基础阶段，构建阶段，我们将称之为最终阶段。没错。所以现在我们差不多完成了这里发生的事情。因此，我们再次切换到应用程序目录。然后我们说，我们说的是，好的，现在让我们从愚蠢的构建阶段复制，我们 net，在我们的情况下，它不再存在，我们实际上选择了构建。因此，我将实际复制它并将其更改为 build。因此，从构建阶段开始，继续复制 app slash Polish 目录中的任何内容，该目录将替换所有文件，将所有内容复制到录制目录中，该目录将是 slash app。

最后，我们将定义应用程序的入口点。这就是我们如何定义如何启动我们的 REST API。在我们的例子中，只需点击，我们正在用 dll 文件的目录执行 dotnet 命令。这就是启动我们的 REST API 所需的全部内容。

有了这个 Docker 文件，我们就差不多可以建立我们的形象了。但在此之前，我想做的只是向您展示点 Docker 忽略文件。

所以这个 Docker 忽略文件，它定义了一系列你想从 Docker 镜像中排除的文件和目录。所以可能有一个或多个你不想包含在 Docker 镜像中的文件，因为关闭它毫无意义。例如，我们在那里的 VS 代码实际上只对开发有用。但这意味着他有，这是没有意义的纳入码头形象。举个例子，这一行指定了，嘿，使用，继续，排除斜线下的所有 VS 代码。对于许多其他文件和目录也是如此。所以一个好的文件不要忘记记住，否则，你的形象最终会比它更大。

至此，我们应该可以开始构建阵列映像了。所以我要做的就是打开一个新的终端。

为了建立这个形象，你要做的就是使用一个 Docker is Eli。

所以我们要说的是 Docker build，

然后你，你必须指定攻击，我的意思是图像的名称和攻击。所以你是破折号 D，限定词。然后我们给它一个名字，名字是 catalog，然后你给它一个标签，在我们的例子中，假设它是 v one。最后，指定将要执行命令的目录。在我们的例子中，这将是

当前目录，由. so 指定。我将按 Enter 键。

这将继续建立图像。因此，我们需要做的第一件事是继续下去，下载任何一个基本映像。在我们的例子中，这将是. net ASP . net 映像，运行时映像将继续这样做。然后，对于第二个构建阶段的第二层，需要引入点网络 SDK、五零 SDK、五零映像，

这可能需要多一点时间，因为它是扬声器，然后它继续在图像中执行实际的构建过程。

所以 dockersrestore，

他们要发布，然后所有其他的步骤都以创建图像结束。至此，我们已经有了一幅图像。就像我说的，每一行都返回到一个本地文件，这里的每一行都代表一个层，映射到你在这里看到的每个步骤。所以他说一步，

这里有一堆台阶。

所以 13 步中的第一步，

到 13 岁，13 岁的三个。其中的每一个都将对应于您在 Docker 文件中看到的每一行。这些是从现在开始将被缓存的层，

这样你就不用再做了。所以在我们的例子中，如果我们没有它，如果你不做任何改变，如果你试图做 Docker 构建破折号 D，同样的命令，再次，我按下回车键，真的基本上什么都不会发生，因为一切都被缓存。因此，只有当你做了一些改变，然后这些层中的一些可能需要再次执行。

现在，需要记住的一点是，这不是我们的 REST API 需要的唯一容器。我们还有 MongoDB 容器，它为我们处理对数据库服务器的访问，对，它拥有我们的数据库。因此，我们需要确保 REST API 的新容器能够与 MongoDB 容器对话。做到这一点的方法，至少在本地机器中，是通过建立我们称之为 Docker 的网络。并且使两个集装箱都加入码头网络。所以我们如何处理这个网络来创建一个网络，你唯一要做的就是说，

Docker，网络，创建，添加使用，给它一个名字。所以我们会说五个教程

还有那个疯狂的网络

如果你想看到现有的网络，你可以做 Docker 网络 LS。

您将看到我们已经创建了我们的网络 530。

所以现在当我们运行我们的容器时，我们应该利用这个网络。所以我要做的是首先确保我还没有运行 MongoDB 容器。所以我会做 docker ps，MongoDB 容器现在正在运行。所以我要阻止它

码头工人停止蒙戈

到此为止，我将再次运行我们到目前为止用来运行容器的相同命令。

让我把它贴在这里。同样的命令。

但我将在这里添加一个修饰符，表示网络等于，您使用的网络名称在本例中定义为 net five

教程。

这使得一个磁盘容器成为一个有效的关节。所以我会说 Mongo，

Docker 图像的名称，所以按 enter 键。

然后 MongoDB 容器在那个网络中运行。这样做之后，我们就可以开始运行我们的目录容器了，顺便说一下，如果用于 Docker 图像，您应该能够看到我们创建的图像。如你所见，我们有一个目录，

准备执行，以及 dotnet 的 Docker 图像。SDK、dotnet、ASP net、运行时和樱井真子。

因此，为了运行我们的 Docker 映像，我们将做一些与我们对 MongoDB 所做的非常相似的事情。所以我们从 Docker run 开始。

对于 dash，我们不使用 dash D，而是使用 dash ID 进行交互，这样我们就可以将终端连接到 Docker 运行进程，只需查看从该容器中输出的日志。然后我们将执行 RM，这样每当我们停止容器时，它实际上会被删除，这样我们就不会一直徘徊。现在我们指定端口，类似于我们对 MongoDB 所做的。现在我们必须指定哪个端口将从我们的本地机器映射到容器中。在我们的例子中，让我们选择多动症，它不一定是它，你可以使用任何其他的身体端口。并且映射到 Docker 映像中的内部端口。现在，对于 ASP net，这五个图片。基本映像本身是一个运行时映像，它定义或覆盖应用程序执行的端口，至少对于 HTTP 是这样。所以端口是 80。因此，尽管我们一直使用端口 5000，但对于本地开发，当我们将 Docker 映像基于 ASP NET 核心运行时映像时，端口被高估为 80。因此您必须指定 80。如果你不想使用 80，有办法在 Docker 文件中指定你的学位要使用的端口。但是在我们的情况下，端口 80 就可以了。

现在我们要记住，为了让我们的应用程序连接到 MongoDB，我们必须指定一系列设置，对吧。如果您还记得 Jason 在应用程序设置中提到的，我们有一个 MongoDB 设置部分，在这里我们指定主机、端口和用户。不仅如此，它还会记得返回到设置 MongoDB 设置，我们指定主机端口用户以及来自 secret manager 的密码。

因此，在这种情况下，由于我们试图与 Mongo to MongoDB 对话。

从容器内部，我们不能再仅仅使用 localhost 来接触它。

他们记得这些中的每一个，

在容器内部运行的每个应用程序，无论是 arrest API 还是 MongoDB，都是以一种隔离的方式运行的。他们不再能够通过本地主机解决问题。因此，为了让我们的 REST API 与 MongoDB 容器对话，它必须通过 MongoDB 容器的名称来完成。在我们的例子中，请记住，我们给它命名为 Mongo。

所以我们必须覆盖主机名。为了和 Mongo 对话，我们不需要修改 JSON 文件，我们能做的就是利用 35 的配置系统来覆盖设置。所以这个将要被设置的部分可以被环境变量完全覆盖。这就是我们现在要做的。因此，只要我们遵守公约，我们应该能够做到这一点。所以我要说破折号 E，这是你在 Docker 中定义环境变量的方式，

我要说，我要用 MongoDB 设置。所以复制一下。然后我们会说结肠主机。这个主机将会是 Mongo，Mongo 容器的名字。这就是您如何覆盖此处指定的本地主机。现在，与我们之前做的一样，我们需要指定一个密码，因为我们目前使用的密码存储在 secret manager 中。secret manager 仅用于开发，开发目的仅在开发环境中可用，在生产环境中不可用，而 Docker 映像、Docker 容器将真正在生产环境中运行。那么我们如何输入密码，和我们刚才做的一样，我们会说 MongoDB 设置。别忘了在 MongoDB 中添加破折号、设置、密码，然后我们指定密码

作为约束词一。

仅此而已。然后，我们不要忘记，我们还需要将这个容器加入到与前一个容器相同的网络中。他们不会去内部，所以这将是网络

医学五教程，确保这是完全相同的网络，你用之前。最后是容器的名称

图像和卡片组的名称。所以那将被编入目录。成为一个

我想我可能有几个错误。

给你。第一件事可能是，让我想想，应该是破折号，而不是破折号。

下一个应该是。所以这一列应该等于假设列。然后我会按回车键。

这就启动了我们的 Docker 容器。如你所见，我们的托管环境已经从开发转向生产。因此，当您运行 Docker 映像时，生产环境将会反映出来，而不再是开发环境。现在让我们看看事情是否正常，我们应该能够在端口 8080 访问我们的 REST API。所以让我们打开邮差。

现在让我们从端口 5000 切换到端口 8080。

让我们看看会发生什么。

据说，API 一直在工作。但是现在正如你所见，我们到达了 8080 端口。所以事情发生在 Docker 容器中。

此外，请注意我们如何不再得到重定向。所以我们没有像以前那样得到 307，而是马上得到了 200。因此，这里不再发生重定向，我们只是在 HTTP 端点。现在为了让事情更有趣，让我们通过这里的张贴标签再张贴一个项目。我也会做同样的事情。我从 HTTPS 换成 http。然后我会做端口 8080。

八十年代。假设我们给你带回了解药。所以在过去的某个时候，我会做价格 15。

一小时热度送来。

如您所见，我将关闭控制台。现在，

音频已创建。

现在，真的，关于 Docker 和 Docker 图像有趣的部分，不仅仅是能够创建它们，对吧，而且能够共享它们，以便它们可以被其他人或其他系统使用。那么，我们如何与其他人分享我们盒子中的 Docker 图像呢？为了本教程，我们将做一些非常简单的事情来看看这是如何发生的，我们将利用一个名为 Docker Hub 的服务，让我在这里打开浏览器。

你可以在 hub 找到 docker.com。所以这是 Docker 的创作者提供的地方，让人们可以公开分享他们的 Docker 图像。所以在这里创建一个账户是完全免费的。所以请随意尝试。所以你必须想出一些码头 ID，我的意思是，某种用户名和密码。然后你就可以在 Docker Hub 拥有自己的账户了。

因此，我如何才能让我的形象波兰到 Docker 枢纽。所以让我们回到 Visual Studio 代码。我现在要通过 Ctrl 来停止 Docker 容器。我要做的第一件事就是登录 Docker Hub。因此，一旦你有一个帐户，你应该能够做一个简单的 Docker 登录，以便能够开始推送图像，有一种方法就是说，Docker 登录。

这将要求我输入用户名，我的情况是，它会要求我输入密码。

现在我登录了。

因此，现在为了让我们现有的图像进入 Docker Hub，我们只需要做一点点的重新标记，告诉它我们想把这个图像放在哪里。所以让我们再一次留下我们的图像，本地图像。这是任务目录 b1。所以我们想做的就是用这种方式重新标记这些。

所以让我们做 Docker 标签，目录是一个

那是韩国的，绿色标签，目录，大的。然后，我们的目标标记将以我们的用户名开始，在这种情况下，我的用户名，如您所见，然后在 Docker Hub 中划掉图像的名称，当您到达 Docker Hub 时，它将被称为存储库。所以那是在八月份，将会被编入目录。

不一定是你可以选择的。但是我想给它和以前一样的东西。所以你可以看到一个斜线目录，按下回车键。就像我说的，这只是一个标签。如果我再做一次 Docker images，我们会发现现在你有目录 B，你看到的是目录 B。但是，如果您注意到图像 ID 并仔细观察，您会发现这两个图像的 ID 几乎相同

所以你真的可以把栈想象成指向一个图像的指针。但是有了这个重新标记，我们现在能够真正地将图像推送到 Docker Hub。所以我现在要做的就是说，Docker push

我们新写的图像，目录 b1，点击回车。

这启动了上传过程，不仅仅是我们的 REST API dogri mesh，所有组成这些 REST API 的层都需要进入 Docker Hub。所以请记住，我们的 Docker 映像 Docker 基础是 ASP NET 核心运行时映像。在这种情况下，这个又在 Linux 的一些发行版中被审查。因此，所有这些东西都需要进入 Docker Hub，以便其他人在未来获得，只需提取该图像并开始使用。因为这是上传，所以可能需要一段时间，

上传任务。

好了，图像上传完毕。现在，如果我返回 Docker Hub，我将使用我的帐户登录。

正如你所看到的，我有我的图片，几秒钟前刚刚上传，你看到斜线目录。

和

这是我们现在掌握的一个事实。所以这是其中之一。

让我们来看一下，让我们扮演这样一个角色，现在他们的系统中没有这个映像，但他们想使用它。在这种情况下，他们可以做的是

Docker 拉，或者只是运行图像。所以让我告诉你我的意思。所以现在可以在 Docker Hub 上看到这个图片。所以我回到 VS 代码。我要做的就是完全删除我们系统中现有的图像。让我们再次处理 Docker 图像，我们要做的就是删除这两个图像，这样它就完全从系统中消失了。为了做到这一点，我会做 Docker Rmi，你会看到斜线目录 v 1，

和码头工人 Rmi，

一号目录。所以现在应该不再有目录图像了。

在我的系统中，只有 z，我现在只有这三张图片。现在，我唯一要做的事情就是使用 Docker 注销

来模拟实际上无法访问我的 Docker 注册表的人。但既然图像是公开的，他们应该能拉出来。因此，为了提取映像，您可以执行本地 Docker 池操作，或者立即运行它。所以我们可以像以前一样运行它。让我向大家展示一下几乎相同的命令行，我将在这里实际复制粘贴。

但是现在你不是说目录 b1，我们可以说 polisi，slash，catalog，b1。所以请记住，在这一点上，我是一个从来没有，

从未接触过目录，

REST API 服务，我无法访问 Docker 文件或任何关于如何构建这个映像的内容，我只想第一次运行它。所以我做了这个命令行并按下回车键。

它说是的，我在本地找不到这个图像。因此，我们将继续从 Docker Hub 中提取它，然后运行它。如你所见，它已经在运行了。如果我回到邮递员身边，

我再次尝试查询商品。

我从这个 Docker 图像中获取我的项目。这就是你如何发布或推送你的 Docker 镜像到我们称之为容器注册中心的地方，在这里是 Docker Hub，然后它被拉回来，可能在其他机器上。这样才可以分享。所以我们可能会在未来的视频中使用其他形式的 Docker 注册表。但是现在，我只想向您展示如何跨系统共享 Docker 图像。

在 dotnet five REST API 教程的这一集中，我们将继续使用 Kubernetes 将 REST API 部署到生产环境中。我们将讨论在不停机的情况下运行容器的含义，以及 Kubernetes 如何完美地适应这些挑战以及弹性运行分布式系统的许多其他挑战。

今天，您将了解为什么需要容器编排器。什么是 Kubernetes，哪些是它的基本组成部分。手榴弹如何使弹性分布式系统，如何站在一个基本单位靠近你的盒子，如何部署你的 REST API 和一个

来协调这一点，以及如何扩展 Kubernetes 部署。

如果你还记得上一个视频，我们谈到了这些橙色盒子，到目前为止，我们一直在谈论它是生产环境，对不对？在这种情况下，我们姑且称之为“老印第安人”,这是物理机或虚拟机，我们将在这里运行 Docker 引擎，对吗？这个 Docker 引擎的这些东西，能够在这个 dog 中运行一堆容器，这可能是我们的 API 容器，也可能是我们的 MongoDB 容器或许多其他容器，对，我们希望在这个节点中运行。

然而，随着我们采用这种方法，一些有趣的问题开始出现，对吗？例如，谁负责拉动和运行集装箱。所以我的意思是，可以想象如果没有任何更强的自动化，有人将不得不来到这个盒子，并实际上开始为我们想要在这个盒子中运行的每个容器进行 Docker 运行？对吗？这是一个有趣的问题。所以要么有人看到一些信息，要么有人必须处理这个，如何运行集装箱，对吗？所以谁知道呢？或者你在哪里看到的读数？所有这些不同的环境、变量、秘密和不同的公共参数，我们必须适应 Docker 运行，以便能够针对每种情况以完全正确的方式运行容器？

如果我们没有足够的容器实例呢？对吗？那么，如果我们需要更多，那么某物或某人必须开始旋转越来越多的实例，根据需要，既可以是配方容器，也可以是我们想要的任何其他容器，我们可能在这个盒子里。

对吗？然后还有，

我们可能会赢，也可能装不下，只是我是说，一个箱子只能装这么多容器，对吧？所以在某些时候，我们可能需要引入更多的节点，对吗？然后，必须有人决定是否要创建容器，在这种情况下，容器将进入节点 2，节点 3 和节点 2，节点 n，对吗？那么谁来决定这个距离呢？那么，我们是否有一个人正在查看每个节点的不同统计数据，并决定在每个索引机器上运行 Docker？这是怎么回事？

还有，集装箱卫生吗？那么，如果其中一个容器崩溃了，会发生什么呢？我们该怎么办？谁负责确保我们带回这个失败的容器，以便我们继续拥有我们想要的那么多？首先？

此外，我们在哪里存储所有的秘密？为 MongoDB 恢复数据库文件？数据库？你把这些都放在哪里？我们如何使容器能够相互交流？对吗？因为我们知道我们的 REST API 容器需要与我们的 MongoDB 容器对话。但到目前为止，我们一直在使用这些 Docker 网络进行通信。但是随着我们有更多的盒子，更多的容器，如何确保它们能互相交流。

还有一件事，我们如何从外部读取这个容器，对吗？因为所有这些容器都在盒子里运行。但是它们都是在本地打开了某个端口 a 的情况下运行的。但是如果有人从外面进来呢？外部人员用来与这些容器对话的公共 IP 是什么？如果他们和他们说话呢？

所有实例中的哪一个可以满足请求？因为我们有如此多的实例，谁来决定哪个是正确的实例，对于进来的请求呢？所有这些问题？我们如何解决所有这些挑战？嗯，这正是我们想要推出像 Kubernetes 这样的 orchestrator 工具的原因。所以进入 Kubernetes

因此

当我们描述打手能做什么时，让他们再想想这个

这些点，对吗？假设我们有这三个节点。我们需要开始在里面放置容器。我们必须做很多事情来让这些容器以正确的方式运行。因此，我们不再需要一个人或某种需要运行的脚本来进行分配，并确保所有事情都在这些节点上正常进行，而是要引入一个组件，我有一系列组件，我们在 Kubernetes 中称之为控制平面。因此，控制平面有几个组件，负责所有的它有点像冠状动脉的大脑。所以他决定如何安排容器进入不同的节点，他决定如果其中一个，其中一个容器被破坏了该怎么办，如何恢复一个，另一个如何让它们相互通信，以及一系列的决定。例如，当我们想要将一个新容器部署到其中一个节点时，或者我们可以通过控制平面来做，我们可以创建一个部署，这个部署将要做什么部署，顺便说一下，是手榴弹内的一个资源。因此，flaming 可以做的是，在容器注册表中找到我们需要的映像，然后为此分配我们称之为端口的东西，因为容器将会拉入，端口实际上是您可以在 Kubernetes 中创建和管理的最小可部署计算单元。没错。如果你认为这是一罐财富，我想这是码头工人的象征。但它是一组共享存储和网络资源的一个或多个容器。报告还声明了如何运行容器。所以你总是会更多地使用容器，你可以直接使用容器来阅读，你只会使用机器人。例如，在这一部分中，我们将有一个容器，这是一个非常常见的情况，每个 pod 都有一个容器。但是你不一定要有一个，你可以开始支持你的部署对象，你可以开始支持多个容器，比如说这是目录竞争 API。但是在第一个注意事项中，我们不一定要有这个目录 API。因此，我们可以为其他服务提供其他端口，在这种情况下，端口中有两个容器，而不是一个。不仅如此，我们还将有一个用于 Mongo 容器的 Mongo 端口，我们也需要引入该端口，该端口也可以访问这些数据库数据库需要获得对一些存储的授权访问，以便能够存储数据库文件。但问题是，这个目录帖子不一定要使用节点一，对吗？所以当我们用完空间时，我们可能想利用其他节点，比如这里的第二个。同样，控制平面将负责决定将这些端口放在我们这里的整个节点集的什么位置。在这种情况下，我们看到了三个，但您可以认为这可以是几十个节点的完整形式，然后控制平面将决定哪个节点最适合需要分配的端口。对，如果莱蒙宣称它需要三个端口。所以这可能是投票分布的一种方式吗？如果部署说没有，我需要四个花盆，我们可能要部署另一个花盆到节点 3，因为公证人在这一点上使用免费的，对不对？其他一些豆荚也是如此。他可能想被分配到别的地方。节点一没有空间了。所以我们不要把它放在树上。我想想，只是因为没有一棵树有这么多的可用内存，对吧？另一件事是什么三，让我们说三想谈我们所有的目录板，我们想谈数据库，对不对？那么他们是怎么做到的呢？所以有一个叫做坐标服务的对象。该服务允许我们访问其他可用的组件。那么集群中还有什么呢？在这种情况下，我说，我想通过 Mongo 服务访问 Mongo 服务，我实际上能够访问数据库。类似地，如果我们有一个外部客户端想要与我们的目录(一个 REST API)进行对话，我该如何找到它呢？因此，我们再次建立了一个目录服务，在我们的例子中，它现在可以接收本地主机，但最终它可能是一个公共 IP。然后这个客户端就可以访问这个服务，并使用这个服务。它可以到达不止一个，而是后面所有的豆荚

在表面后面，对，所以这是一种路由到那些机器人的方法。所有这些都是我们所说的，所有这些组件都是我们所说的七宝奇谋集群，对吗？所有这些组件的套装。现在，我在这里展示的只是所有可能资源的冰山一角。以及在坐标范围内可以使用的一系列配置和功能。真的，冠状动脉可以做很多事情，但在这里，我们将只探索其中的一些，以了解它是如何工作的。因此，就使用 Kubernetes 的好处而言，最重要的一点是能够将期望状态转变为活动状态。就像我说的，我们创建一个部署对象，我们说，嘿，我想要目录服务的三个副本。所以这是固态。因此，Kubernetes 通过控制平面，我们必须弄清楚如何使这四个目录容器实例在我们可用的一系列节点中的某个位置可用。如果你有三个节点，在这两个节点中寻找空间，如果你只有一个节点，那么想出如何在这一个节点中分配空间，或者我们可以有数百个节点，对吧。所以决定留在 Draco 州是 Kubernetes 的一个关键特征。然后，如我所说，选择运行机器人的节点。因此，控制机架了解已安装功能的统计信息。因此，根据 CPU 的数量，或者每个节点中可用的 RAM 的数量，它能够在正确的位置分配端口。它也允许自愈。因此，如果他检测到其中一个端口，比如说端口 3，因为任何原因最容易被破坏，它应该能够自动恢复另一部分。假设整个音符的一个音符是向下的，对吗？如果发生这种情况，控制平面将知道它能够我的意思是，它缺少一个节点，对不起，一个端口，然后它需要将该船分配到其他地方，在这种情况下是节点 1 或节点 3。这就是 Kubernetes 的自我修复能力。那真是太方便了。它还能够存储配置机密。因此，他有一个地方来存储您需要的所有服务配置，还可以安全地存储敏感信息和机密等，这样它们就不会被泄露。如我所说，他提供服务发现和负载平衡。因此，当客户端调用目录服务并与之对话时，它能够被定向到其中一个节点的右侧，并遵循某种算法在它们之间实现负载平衡。它还确保没有停机时间。因为无论何时，假设我们要跨所有这些点部署新版本的目录、Docker 映像，它不仅会立即销毁所有机架，并恢复一堆带有新映像的机架，实际上，当它开始销毁旧端口时，会慢慢推出新版本的映像作为新端口。因此，只有当它配置了新的端口实例时，新的端口实例才可用，他才会开始清除旧的端口实例。这样，我的意思是，它可以确保客户不会停机。他还可以自动缩放。因此，它可以配置为:嘿，如果我们的所有节点都使用了如此多的 CPU，只需以任意顺序增加更多可用节点即可满足需求。因此，在本教程中，我们将手动进行缩放练习，但角膜也可以配置为自动缩放。它还禁用了按需自动存储，因此您可以轻松地声明您想要为您的港口和粮仓提供这么多存储，我的意思是，您不必知道存储的确切位置。你必须说嘿，坐标，我需要存储和手榴弹将负责找出在哪里找到存储，并使其可用于港口。最后，它提供了一种我们称之为逐步部署和回滚的用途，正如我所说，它将根据需要逐步引入新的端口。此外，如果某些端口出现问题，它能够将它们回滚到正常版本。现在我们知道了 Kubernetes 是什么，让我们看看如何将 catalog REST API 和 MongoDB 数据库部署到本地 Kubernetes 集群中。

要开始使用 Kubernetes，我们首先需要一个 Kubernetes 集群。本地的。如果您已经在自己的机器上使用 Docker，那么您已经有了一种简单的方法来发送一个简单的本地 velocity 以用于开发目的。让我告诉你怎么做。如果你去你的 Windows 任务栏，你应该能找到这个 Docker 图标。你可以右击这个我可以选择设置。这将打开你盒子里的 Docker 设置，最大化它。在这里，您要找的是左侧的问答部分，然后在这里启用协调员，我只需单击它，然后单击应用，重新启动，然后单击安装。如果这是您第一次启用 coronaries，这将需要一段时间，因为这将设置一个只有一个节点的本地集群。但它仍然是一个本地集群，Docker 需要为 Kubernetes 的所有组件下载一堆 Docker 映像，放到您的机器上。所以这可能需要一段时间。在我的例子中，我已经下载了所有这些图片，所以速度有点快。我们要找的是这条完整的消息，说手榴弹正在运行，它应该说正在运行，它应该是绿色的，然后你就知道你可以走了。所以我现在就关闭这个窗口。随着 Kubernetes 集群的启动和运行，我想做的第一件事就是确保我连接到正确的 Kubernetes 集群。我们可以通过 cube control 命令行工具做到这一点，它是与 Kubernetes 交互的命令行工具。这些工具应该已经随 Docker 安装一起安装了。所以你应该能马上开始使用它。我会开辟一个全新的终端。我要做的就是输入多维数据集控件配置。当前上下文，按回车键。那就是把 Docker 桌面还给我。事实上，Docker desktop 是 Docker 安装的群集的名称，一旦我们启用了 Kubernetes 群集，我们就可以继续使用它了。现在是时候开始创建或声明我们希望如何将组件部署到 Kubernetes 中了。对于我们的 REST API 和数据库，这样做我们将需要编写一些莫亚文件。为了简单起见。我想做的是利用粮仓 VS 代码扩展。为此，我将首先关闭这个终端。我会去扩展中心。我将搜索格林纳达，这应该是第一次热，我只是说安装应该需要几秒钟。现在准备好了。所以我要关闭这个。我现在要做的是返回到我们的文件浏览器，我将创建一个文件夹，开始存储我们将资源部署到 Kubernetes 所需的所有文件。所以这将是我们的 Kubernetes 文件夹，它可以是任何你喜欢的名字。然后，我们将在此处创建的第一个目录将被命名为“作业目录”。我之所以这样命名，是因为这将声明我们将 catalog REST API 部署到 Kubernetes 所需的所有资源。也是为了让事情变得简单。为了加快这个过程，我将利用我们已经安装的 goodness 扩展来生成一点代码。我只需说部署，就会弹出一点智能感知，如您所见，然后我们只需点击它。这将为我们的部署资源提供一个基本的框架。现在，插件资源就是您用来声明容器的期望状态，或者特别是您想要部署到 Kubernetes 中的端口。在本例中是 REST API。那么让我们来理解这个文件意味着什么。所以如果你看到第一行声明了我们所说的 API 版本，这是所有 coronis 资源都会有的。这允许您指定想要在 Kubernetes 中利用的 API 表面。因此，根据您在这里选择的版本，您可以访问您正在配置的资源的或多或少的特性，在本例中，是一个部署资源。第二行声明我们所知道的种类，是支付对象。然后我们去元数据名称。元数据名称定义了这些部署的名称。所以在我们的例子中，我们将使用命名它

目录。然后我们进入规格部分。嫌疑人部分的第一部分就是我们所说的选择器。选择器是我们用来指定此部署如何选择它要管理的端口的。在这种情况下，它会说，我要管理所有具有以下标签的花盆。而在这种情况下，我们只有一个标签，它叫做 app。然后是一个值，我们在这里指定的值是好的。因此，所有具有值为 catalog 的应用程序标签名称的端口都将由该部署管理。然后我们继续进入模板部分。因此，我们将在这里声明所有这些容器，它们将包含在部署中。这里首先要声明的是机器人的标签。在这种情况下，我们将把这个机器人命名为 catalog，它将成为标签。这就是我们在这种情况下可以识别与目录相关的所有机器人的方法，这个机器人必须与我们刚才键入的标签完全匹配，以便部署可以实际管理这些机器人。然后我们将转到最有趣的部分，这是模板上的一个规范。我们首先要找到的是容器。所以在这里，我们声明将要包含在这个部署中的容器列表。对于第一个容器，我们要做的第一件事就是给它命名。同样，为了简单起见，我们将它命名为目录。然后我们必须声明，这是我们将要部署的映像。在我们的例子中，我们将只使用我们在之前部署到 Docker Hub 的视频中创建的图像。然后对我来说，是蓝色海洋目录，b1。因此，我们说，我们将下拉到 Kubernetes，这个名为“你看到的人目录”的图像是我们在那里说的一个图像，但你可以在这里指定任何你想要的图像。接下来，我们进入参考资料部分。因此，您可以在这里声明内存和 CPU 方面的具体资源，在本例中，为了运行 REST API，Kubernetes 节点需要哪些资源。在这种情况下，我只是说，嗯，我将需要 128 兆字节，顺便说一下，虽然可能是正确的，但大约相当于 1024 千兆字节。这就是它的全部价值，你可以根据自己的需要改变它。另一方面，我们有 CPU，我们说我们想要使用 5 亿个 CPU。这是一个有趣的符号。它真正的意思是，这类似于说，我会在这里键入 0.5 个 CPU，所以大约是一半 CPU，只是为了更好地理解它。所以 500。所以基本上，我们说我们可以用一半的 CPU 来支持 REST API，这对我们来说已经足够了。接下来，让我向下滚动一点。我们有港口。这里是单词 declare，这是我们的容器所公开的端口。为了访问 REST API，我们可以与通信。在我们的示例中，我们将像在上一个视频中一样，映射到入端口 80。因为我们说它们是基础 ASP NET 核心镜像覆盖了我们的端口，并通过使用端口 80。因此，我们将使用相同的端口，即 80。所以这是容器内部的一个端口，我们可以在这里访问 REST API。我们在这个部署中需要的下一件事是一些环境变量。因为如果您还记得，当我们运行我们的容器时，我们必须指定主机以便它能够与我们的 MongoDB 容器对话，还必须指定连接到该数据库的用户的密码。那么在这种情况下，我们如何指定环境变量呢，这相当简单。我们可以使用 M 部分，因此您只需键入 M，然后您必须为每个环境变量声明关键的应用程序名称值对。首先我们要声明的是

主机的那个。如果你还记得，在应用程序设置 JSON 中，我现在将快速打开它，我们有这个设置层次结构，我们有 MongoDB 设置。我们所说的是我们有主机或用户和密码。所以我会回去给贾马尔编目。我们必须遵循同样的等级制度。所以我来做 Mongo DB 设置。在这个 java 文件中，分隔 add 的方法是使用双下划线。记住，当我们将变量传递到容器中时，我们使用冒号，在这个 java 文件中，我们将使用双下划线。这就是你如何处理这些不同的设置。然后我们给它一个值。冠状动脉中主机的值将是 MongoDB。服务。稍后我们将看到如何定义这个 MongoDB 服务。但是现在，是的，这就是我们如何处理 MongoDB 容器的方法，我们将在后面声明它。接下来，我们需要一个环境变量作为密码。但是在我们声明它之前，我们实际上必须创建这个密码，添加成分。幸运的是，科尼有这个内置的秘密支持。像这样敏感的信息。为此，我们要做的就是打开我的终端。我将在这里使用一个快捷键 Ctrl J，打开我们上次使用的终端，向下滚动一点。然后，我们将在此处键入多维数据集控件，这是一个能够创建秘密的选项。那就是立方体 CTL。创造秘密。然后我会输入 generic。通用电路是我们在这种情况下可以使用的电路类型，但这里也可以使用一些其他选项，这对我们来说很好。我们将它命名为，目录秘密。我将使用 spooler，因为你实际上可以在其中一个秘密中放入多个秘密。但我们只会用一个。为了在命令行中直接输入，你要做的是从字面上说。然后，您必须指定秘密的名称和值。所以名字将会是 MongoDB。密码。这个值将会和我们之前做的一样，是一个坏的有界单词。然后我会按回车键。这就创造了秘密。既然我们已经创建了这个秘密，我们就可以开始声明它，并将其输入到一个环境变量中。为此，我们将做一些类似的事情。所以我们说名字。同样，我们将遵循层次结构，所以 MongoDB 设置，在这种情况下，双下划线将是密码。然后在这种情况下，我们不想使用值，我们想从秘密中读取它。从秘密中读出它，我们能说的是价值。我们会说密钥引用。所以我们引用了一个名为的秘密，它将成为目录秘密，这是我们给这个秘密取的名字。目录机密中的实际密钥将是 Mongo DB。密码。这就是你如何在 Kubernetes 环境变量的声明中解决一个秘密的方法。看起来不错。我会再次关闭这个终端，在这里有更多的空间。接下来我们要说明的是我们的健康探测器。因此，健康探测器是一种机制，使冠状动脉能够通过使用我们已经定义的健康检查来持续监控我们种族 API 的健康。如果您还记得，在几集之前，我们在 REST API 中声明了一些健康检查。所以现在我们可以，我们可以用它们来让我们知道我们的容器是否完好无损。他记得我们有活跃度和准备度调查。所以这两个我们都要用到。所以从活跃度探针开始，并在可以使用他的活跃度探针的地方声明它。还有一种探测器，也有几种探测器，我这里要用的是 HTTP HTTP GET 类型的探测器，它只是用 GET 动词调用一些 HTTP 路径到 API 中。

所以它需要使用的路径是，如果你还记得的话，应该是实时的。它需要使用端口 80。就是这样，这将是最大的探索。我将复制这个来定义我们的就绪探测。就绪探测将非常相似，但它以红色结束。如果你还记得的话，我们将使用活跃度探测来判断我们的接收者是否启动并运行，就绪探测来判断 REST API 的任何依赖项是否正确响应就绪，基本上，REST API 已经准备好为请求提供服务。因此，我们已经正确地声明了 REST API 的部署。但这还不够。因此，这将继续下去，并创建机器人拉这拉容器，环境变量等等。但是仍然没有办法让任何人从外面进入这个容器。为了实现这一点，我们需要引入另一个叫做服务的组件。因此，我们可以在另一个 java 文件中创建该服务，也可以在这里使用安全性，这就是我要做的。在 Java 文件中分隔这两种不同资源的方法是使用三个破折号。然后您就可以开始声明您的资源了。所以我会做一些智能感知。再次在这里，所以我只需输入服务。这就引出了查询服务 IntelliSense。在这里，所以我要点击它。这将为我们提供一些可以利用的片段。因此，服务是一种资源类型，您可以使用它来处理 Kubernetes 内部或外部的资源，这是我们此时需要的，我们需要提供的服务，我们还需要给它一个名称，就像我们对部署所做的那样。所以我们将它命名为目录服务。这里没有列出，但对我们来说很重要的一点是类型，有几种类型的服务。但是在我们的例子中，我们想要使用一个名为负载均衡器的 tight。负载均衡器允许查询请求自然 IP，或者一个自然的或不自然的，我猜，不是一个 IP，在这种情况下，因为它是本地主机。但是它要求有一种方法，让两个人可以打开一扇通向外面的窗户，这样人们就可以从外面接触到我们的 REST API。所以我们会看到，当我们运行这个时，这个名称是如何解析的，但是你知道，各种责任。否则，我们无法从外部访问服务。对于选择器，我们必须指定端口。我们之前声明的端口标签，如果您还记得这些端口，在这里，我们声明了模板，我们说过将由部署管理的所有端口的标签都是通用的。因此，我们必须使用相同的标签，即我们声明服务或颜色选择器所用的标签，我们会说，好吧，我们要这个服务将能够针对任何具有值目录的应用程序标签的端口。这就是你如何把服务和机器人联系起来。然后，您还必须指定，好的，哪个将是端口，从外部，人们可以从外部访问我们的 API，并且必须映射到容器中的端口。因此，在这种情况下，该端口将是我们将使用您的 ad，因为它是 HTTP 的默认端口。因此，这将允许我们的客户甚至没有这个 Wi Fi 端口，它将能够直接调用 API。因此它们将进入端口 80。目标端口必须是我们为容器指定的端口，记住，在这里，导入，我们声明容器端口 80。因此，容器端口 80 是我们想在这里使用的目标池。所以它实际上是映射 80，到 80。但不一定要这样，我们可以，我们可以说，假设 8080 映射到 80，这完全没问题，就像我们对容器做的那样。但是更常见的是使用端口 80。所以现在我们应该准备好开始部署这些，部署这些机构的资源，包括部署和服务。那么如何在 Kubernetes 中部署它呢？因此，我们必须回到我们的立方体控制工具能够做到这一点。所以我会再次打开我的终端，Ctrl J，我会切换到我的发布目录。应用此部署的命令称为 this this java file is

立方体控件，应用破折号 F，然后文件名，按回车键。您应该会收到几条消息，说明部署已经创建，服务也已经创建。现在，您希望看到一个部署或应该创建的部署的状态。您可以说“cube control，get deployments ”,这将为您提供所有已创建部署的列表。这种情况下，我们有一个名为“Gatling deployment”的部署，目前它说其中一个机器人没有准备就绪。所以这意味着它还没有真正准备好。所以，让我们更深入一点，了解实际创建的机器人的详细信息。所以我们可以说，cube CTL 被收购了。正如您所看到的，我们在此处声明的所有都包含一个单元，其名称以“启用部署”开头。然后它有了一个名字，我们称之为副本集，我们还没有，我们不会在这个视频中讨论。最后，一些识别实际的 pod。事实上，港口还没有准备好。也就是说，有 0 个端口可供使用，外部可以直接到达。但他还是说跑步。这意味着真正的意思是，我们的活性探测器，你记得，我们有一个活性探测器正在报告健康状态，但我们的就绪板没有报告健康状态。为了更好地了解这里发生的事情，我将进一步展开。让我们从目录板上找些日志。要查看多维数据集控制日志。然后机器人的名字按下回车键。然后我们在这里看到了一些有趣的东西。让我们向上滚动一点。是的。在这里，如您所见，我们的 MongoDB 就绪性检查失败，健康 dubray him 的状态被取消。正如您所料，这是意料之中的事，因为我们还没有真正部署任何数据库。但这很棒。这证实了我们的就绪性运行状况检查，这两项检查实际上都在正常工作。我们只需要确保我们解决了数据库的这个问题，我们提出了这个问题。然后我们应该能够启动并运行 REST API。让我们关闭终端。让我们实际声明我们需要为数据库声明的内容。所以我要回去迁移这个目录。我会说新文件。这个文件将被命名为 Mongo DB。因为我们在这里要声明的一切都只是为了部署 MongoDB 数据库。现在，我们将为 MongoDB 创建的资源类型实际上被称为有状态集。看看我们是否有办法为有状态集合生成框架。然而，我们将为此使用部署模板。因此，让我们使用来部署选择 Windows 部署。然后我要做的就是从部署切换到有状态设置。假设 Phil 说他与部署有相似之处。但它实际上是针对有状态应用程序的。因此，有状态集提供了关于 pots 的排序和唯一性的保证。因此，当您看到由有状态集合创建的 pot 时，它们不会有随机的名称，它们可能会有一些非常具体的顺序名称。例如，在这个例子中，它可能被称为 MongoDB，一个 MongoDB，两个 MongoDB，三个。更重要的是，如果这些端口中有一个死亡，比如说 MongoDB，就会有一个死亡。当它回来时，他将再次以 MongoDB one 的身份回来。这对于 MongoDB 来说非常重要。因为我们将为它附加一个永久卷，其中包含数据库数据文件。我们希望确保这些文件不会丢失，因为在出于任何原因需要提供端口的情况下，端口会被重建，对吗？所以我们想把它留在身边。因此，像 MongoDB 这样的持久性服务应该使用有状态的资源集。因此，就像我们在部署中所做的一样，这里要做的第一件事就是给有状态集分配一个名称。在这种情况下，我们将其命名为 MongoDB 稳定集。这里没有生成的一个重要的东西是我们称之为服务名的东西。

服务名用于为有状态集和将由它管理的机器人提供某种身份，这实际上并不是部署所需要的。但是对于有状态集合。这是必须的。我们在这里给它起的名字是 MongoDB。服务。我们看到服务是如何在 MongoDB 服务中消亡的，然后又是如何在目录中消亡的。就像我们在部署中所做的一样，我们需要定义状态将使用哪些标签来选择将要管理的端口。因此，在这种情况下，让我们说，我们的机器人将有 Mongo 数据库后，其应用程序标签中的 Mongo DB 值。我们将这样做，然后我们必须确保在标签应用程序中的 pod 模板中，我们必须使用相同的值。所以我们所有的部分都将有一个值为 MongoDB 的 app 标签。然后，有状态集被配置为管理应用程序标签中具有 MongoDB 值的所有 pod。现在我们继续深入到规范中的容器部分。然后我们给出容器的名字，再听一遍这个名字，MongoDB。对于图像，我们将使用到目前为止一直使用的相同图像，只是 Mongo，Mongo 的最新版本，然后我们继续进入参考资料部分。我们将保留这些资源，它们应该会很好地为我们服务。但是由您来决定修改您希望 MongoDB 服务器和 MongoDB 数据库使用多少内存和 CPU。继续，我们必须声明 MongoDB 容器监听的端口。现在我们知道这个端口是 27，017。没错。这就是我们必须使用的端口，连接到容器内的 MongoDB 服务。再一次，就像我们在 gadelha 莫亚做的那样，我们必须定义几个环境变量，以便能够与那口井对话，从而能够启动我们的 MongoDB 容器。这些是为 MongoDB 配置的用户的用户名和密码。所以让我们声明和抱歉，让我们看清楚和 M 部分。在这里，我们开始声明。所以这个环境变量的名字在里面是 Mongo，db。root 用户名。我们要赋予它的值就是我们正在使用的值。到目前为止，更多的去管理。对于密码，我们将使用与 gatok 相同的秘密。所以我在这里切换到目录。我会把我们的密码部分复制到 MongoDB 中。基地在这里，修一个大田。然后，正如你看到的，我们从相同的位置读取，但环境变量的名称只是有一点点不同，它将是 Mongo，db。root，password，对，所以那是一个，那是 MongoDB 容器期望的用户名和密码环境变量。在 MongoDB 容器的情况下，我们需要定义的下一件事是我们所说的持久卷。所以我们也需要声明一些存储方式，请求协调员提供一些存储空间来存放我们数据库的数据文件。否则，我的意思是，是的，一个数据库将存在于 MongoDB 容器中。但是，当集装箱和港口，集装箱的集装箱被杀死的任何原因，数据就会消失，对不对？所以我们不希望这种情况发生。为此，我们创建了一个我们称之为永久卷的卷，最大永久卷，我们将使用我们称之为卷声明模板的卷。让我们开始吧。他们确保我选对了地方。我应该在这里。我们来看看批量索赔模板。气球声明模板实际上是一种声明或向 Kubernetes 请求一些空间的方式，一些节点中的存储空间，pod 将在那里执行，对，所以我需要一些空间。我们必须声明一些关于我们要回收的空间的细节。首先，我们要设置一些元数据。我们只需要这里的名字。所以我们要给这卷书起什么名字，那就是数据。

然后，我们必须指定我们要请求的卷的规格。这属于规格部分。在这里，我们必须指定一个访问模式访问模式。因此，访问模式声明，这个持久卷将以哪种方式安装到注释中，实际上，它应该进入前面的一行，这样做。对于我们的情况，读写模式，一次，一次应该足够了，实际上这里的这个，意味着将要创建的将要装载的卷将以读写方式装载，对于单个笔记，这意味着一次只有一个笔记可以读写这些卷。如果你想的话。如果您希望有多个节点能够写入该卷，您必须使用不同类型的访问模式。最后，我们必须定义这里需要的资源。因此，在这种情况下，我们将声明资源，然后请求。最后是存储。这里是我们声明该卷需要多大空间的地方。对于我们的情况，让我们选择一个，我认为这个术语将是千兆字节，类似于 1gb，这将与存储一样多，我们将回收这个卷，比如说。这样，我们就回收了笔记中的空间，对吗？对于 MongoDB 的这个表单。然而，我们仍然需要告诉我们的容器这样一个空间的存在。我们必须将主机中的空间映射到容器中的空间。为此，我们将声明一个卷装载，气球装载需要在容器规范中声明。所以我在这里输入气球支架。在这里，我们将为它指定一个名称。这个名称必须与我们在气球声明模板中指定的名称完全匹配。所以我们说这将是数据。因此，数据是我们应该在这里使用的名称。mount pad 是传统上 MongoDB 在容器内部存储数据文件的地方。因此，该空间将是斜杠数据斜杠 dB。这实际上意味着，当 MongoDB MongoDB 容器将数据库的数据文件写入其 data DB 目录时，这些文件将最终进入阿德持久卷，该卷已在网站上声明，因此数据将从容器外部读入，并进入主机中某个位置的持久存储。这样，如果容器关闭，端口由于任何原因关闭，数据不会丢失，并且它们会在端口恢复时以有状态集中相同的身份恢复。我们需要做的下一件事，就像我们对目录莫亚做的那样，是声明一个服务，编写一个允许我们寻址或访问 MongoDB 服务的服务。所以我只需要，然后我会键入 service for cleaning service，就像我们之前做的那样生成。就像以前一样，我们必须为服务指定一些名称，让我们称之为 MongoDB。服务。这里还缺少一个重要的部分，那就是所谓的集群 IP。所以集群 IP 就是你用来为你的服务指定 IP 地址的。因此，默认情况下，任何服务都将获得本地 IP，可用于与群集中的其他服务进行对话。但是在我们的例子中，我们想要创建一个我们称之为无头服务的东西。所以我们不想给服务分配 IP。因为

在有状态的集合中，我们希望对每个 pot 的每个节点进行单独寻址。因此，在这种情况下，我们将说没有，所以我们不希望在这种情况下的 IP。所以它把它变成了一个无头服务。现在，对于选择器，我们必须再次指定如何将该服务映射到 MongoDB 的现有端口。好的，为此，我们必须返回，再次进入底板，底板元数据标签应用程序，我们正在寻找的标签是 AP，值是 MongoDB。所以我们回去，把它复制到这个 lector MongoDB。因此，每当有请求进入该服务时，它都会找到抱歉的节点，即在应用程序标签中标记有 MongoDB a 值的端口。然后这就是，这就是如何找到他们。最后，我们需要指定端口。就像我们对容器所做的一样，我们将对 27017 做一个简单的映射。因此，任何进入 27，017 的请求都应该被重定向到容器侦听的端口。正如您在这里看到的，该端口也是 27017。我把它抄过来。现在我们已经完成了，应该可以开始使用这个 MongoDB 容器了。我将再次打开我的终端，Ctrl J 打开终端。我将向下滚动一点。然后我要切换到 Kubernetes 目录。在这里，我将只做立方体控制，应用破折号 F，然后我们的演示文件 MongoDB 演示，我将点击输入。所以有状态集和这个服务都已经被分级了。在这一点上，让我们看看，有状态集合看起来如何，让我们做立方体控制。获取数据集。他们会给我们一个已创建的有状态集 MongoDB 有状态集，它看起来已经准备好了，很健康，状态良好，可以使用了。现在我们已经完成了，让我们看一下我们现在拥有的所有端口。所以再一次，立方体控制变得很热。如您所见，现在我们有了目录板，它实际上已经准备好了。所以它不再报告 01 是报告一个中的一个。这是因为 ad，因为 ready 准备就绪探测器试图进入我们的 MongoDB 数据库，现在它能够实际做到这一点。这是因为我们现在已经有了 MongoDB 服务。如果你记得，当我们在目录，Jamel，我们宣布 MongoDB 设置马将是 MongoDB 服务，它还不可用。但是既然我们已经声明并部署了它，我们就有了我可以使用的 MongoDB 服务。这样，我们的运行状况检查就可以通过，这样我们就可以成功地连接到数据库。我只是喜欢我们有板，我们也有端口，MongoDB stateful，设置为零。如您所见，它不是一个随机的 ID，在部署的情况下，它更像是这些有状态集合的一个非常具体的编号和有序索引。没错。所以如果它死了，它需要带着同样的数字回来。现在让我们看看我们的 REST API 是否工作正常。现在它在协调器中运行。所以让我们打开邮差。上次我们对 REST API 进行 get 时，是通过端口 8080 进行的。因为这是我们在运行时公开的端口，所以它是 Docker 的一部分。但是现在我们切换到了 80 端口。我们可以像这样查询 API，也可以删除 ad，因为它是默认的 HTTP 端口。因此，这对于针对 API 进行 get 应该足够了。让我们看看我们得到了什么。果然，我们没有得到任何结果。因为请记住，这是一个全新的数据库，现在托管在 Kubernetes 内部。所以这实际上没有任何数据。但是我们可以继续在那里创造一些东西。所以我要转到这里。我还将把它们更改为 HTTP localhost 项。然后对于身体，让我们快速地想出一些东西。假设我们要再次创造一种药剂，价格 12。然后点击发送。果然，药剂已经制造出来了，我们可以制造一种了就差一件事了，比如说一种解药。

有了价格，比如说 17，点击发送，并已分级返回到获取它发送。我们现在得到我们的两个项目。所以 REST API 工作正常。但现在一切都在手榴弹范围内运行。所以我们讨论了手榴弹的自愈能力。因此，无论机器人发生了什么，它都应该能够始终保持这种理想状态。让我们来看看这到底是怎么回事。所以我现在又回到了 VS 代码。我要做的就是在这里多留一点空间，以便更好地形象化事物。所以我要把左边一直移到左边。然后，我将启动另一个具有拆分终端负载的终端。所以现在我们可以有两个并排的终端。我会像这样移动一些东西，也许就在那里。我要做的是在左侧，我将观察具有立方体控制的机器人，获取 pod，破折号 w。这样我就可以看到当前现有机器人发生的任何变化。在右边，我将模拟杀死其中一个机器人。所以让我们假设，我的意思是，让我们想象板有一些错误，并导致机器人崩溃。好吧，接下来会发生什么。所以我们来做立方体控制，删板。因此，让我们试试我们的目录板或仅目录板。我会继续删除它。我按下 Enter 键，看看左边，马上。一旦它开始终止那个端口，它立即开始旋转一个全新的容器。这就是协调者的能力，总是能发现期望状态和实际状态之间的差异。一旦你检测到这种情况，它需要做任何需要做的事情来恢复事情的一致性。在这种情况下，Newport 已启动并运行，然后我只需执行 Ctrl C，我将再次获得没有 W 的 pod，现在您可以看到这一点。我们又有了两个机器人。但是现在我们有了一个不同身份的目录，对吗？你可以看到这不是以前的身份。这是因为部署类型的部署，伟大的机器人是短暂的，本质上是短暂的，对吗？所以他们只是无国籍。现在，这不一样了。至于我们的有状态集合，正如我们所说的，我们的有状态集合应该在一个 pod 的生命周期中持续存在，对吗？因此，如果我们只有这些 MongoDB 状态，在这里设置为零，如果我们删除右会发生什么？不仅如此，这个 MongoDB bot 保存的数据会发生什么，因为我们已经有数据在那里了。那么，当端口恢复时，数据是否仍在那里，我们来试一下。所以我要为机器人再洗一次。我将复制我们有状态集合的名称。所以我要做 cube CTL，cube control，delete bot，我要做 MongoDB stateful。设置，让我们看看会发生什么。在左边，这个分离舱确实被终止了。但是现在，格林纳达发现它需要把它带回来。它需要用 MongoDB safe 为零时的相同身份恢复它，因为这是一个有状态的集合。我们不想丢失这项运动掌握的数据。事实上，如果我只是控制 CD，伙计们，我会得到吊舱，我们有两个吊舱。现在我们应该能够验证数据没有丢失。所以应该还在。因此，如果我返回到 postman，并查询数据，我们可以再次看到数据仍然存在。所以它没有去任何地方。这意味着我们的持久卷确实被创建了，数据被存储在容器之外的主机中。这是由我们的状态集实现的。所以我现在回到 VS 代码。我们还谈到了这种手榴弹的能力，可以轻松地爬上港口和里面的集装箱，而不需要非常非常强大，对吧。因此，如果我们在我们的网络需要的地方，我们的网站有更多的请求，我们不只是有一个目录端口，但我们需要有三个，嗯，我们会怎么做？Kubernetes 如何帮助我们做到这一点。让我们再一次监视左侧发生的情况，获取豆荚。接下来，我将要求 Kubernetes 针对发现部署扩展部署，您可以做的是

多维数据集控制、扩展、部署，然后是目录部署。然后你要说我们现在有多少。现在我们想要三个。所以按下回车键。我注意到在左侧，立即开始提供一堆新的机器人来执行这个新的决定状态，对，这发生得非常快，对。因此，如果我只按 Ctrl+C，现在在左侧，并获得机器人，你可以再次看到，我们已经有三个机器人，而我们只有一个在几秒钟前。所以在这里你可以看到，像 Docker 容器和 Kubernetes 组合的力量，对吧，我们如何引入更多的 REST API 容器实例。在这种情况下，运行一行代码并没有太多麻烦，我们现在有三个容器副本在运行。现在，拥有 pots 的这些数据副本的全部意义在于，我们可以在它们之间实现良好的负载平衡。因此，当请求到来时，它应该在这些机器人中的一个或另一个中着陆。我们如何证实这一点？不幸的是，我们现在没有好的方法来做到这一点。但我认为我们可以很容易地在机器人中引入一点日志，这样我们就可以很容易地判断哪个机器人发出了请求。为此，我首先要做的就是暂时关闭终端。然后，我将转到我们的浏览器，或者转到我们的项目控制器。在这里，我将添加一点日志记录。要添加日志记录，我们可以做的是引入标准的日志记录程序接口。所以我将只为项目控制器做一个记录器。让我们称它为记录器。所以 logger 是一个标准对象，在 dot net 5 中可用，在任何 dot net 5 应用程序中都是如此。所以你在这里能做的，只是依赖注入，就像你在 dotnet five 的服务中所做的一样。我将在这里介绍 logger 实例。现在我们有了这些，我们能做的就是选择一个 API 并做一些日志记录。所以我选择最简单的一个，那就是我们的 Get diverse API。所以在这种情况下，我就在这里打开，一行。我将记录一条小消息，说明我们找到了多少项。为此，我要做的只是记录点日志信息。然后我们在这里做一点字符串插值。我要放在这里的第一年是当前时间。我将通过 date time 类来完成此操作，我将选择 UTC 时间作为字符串，然后我们将显示以小时、分钟和秒的格式调整时间。好的，在这里输入格式。然后我只做角落，只说取回。计数项目的项目。好吧，我们来验证一下东西是在不同的地方着陆的。所以我会保存这些。然后他们就不会改变了。我们现在要做的是创建我们 Docker 形象的新版本。所以我现在要打开我们的终端。我将删除其中一个，这样我们就只有一个了。在这里，我将重复上一个视频中的内容。所以我将运行我们的 Docker build 命令。我会把它发布到 Docker Hub 上。所以我会继续使用和以前一样的格式，首先使用用户名，然后是图像的名称。然后我要在这里弹出的一个东西是甲板，因为这是图像的一个新版本。因此，我们应该删除它，比如说两个，这是必要的，以便 coronaries 可以在以后告诉它这是一个新的图像，或者它需要从 Docker Hub 中删除它，否则，他将无法这样做，然后我会说点 O，按 Enter 键。我将会忽略这里的一个参数，即标记的破折号 D，您再次输入，这将构建映像，它将重用一些缓存层，然后它将只是所需的一部分。好了，图像建立起来了。现在，我将登录 Docker Hub Docker 登录。

现在我应该可以把图像推得更短了。所以我会做 Docker 推送，你看一下目录，B 进入。此外，Docker Hub 中已经存在一些层。因此，只有缺少的层，这是我在这里对一行的小更改，是包含在此图像中的层，也是需要推送到 Docker Hub 中的层。好了，有了 Docker Hub 中的图像，我们应该可以告诉 Kubernetes 我们想开始使用它。因此，我将返回到 Jamel 目录，我会说，嘿，cornice，我不想继续使用演示版，我想使用第二版。省省吧。然后回到终端，我会切换到我们的坐标文件夹。在这里，我将再次应用这个文件。所以立方体控制，应用破折号 F，然后我们将做资本伽玛。好的，那么生活就是如果我们控制立方体，得到豆荚，观察，看看发生了什么。如你所见，旧的集装箱涂料机器人正在被摧毁。新的机器人被立即安装起来，代表新的形象，我们需要使用的新的误解。所以这需要几秒钟。所以我现在要用 Ctrl+C。我会看到豆荚的实际状况。让我们看看我们得到了什么。因此，我们有了三个新的目录 REST API 副本，即 pod 的副本。因此，现在我们应该能够判断我们是否在它们之间进行了负载平衡。为了做到这一点，我们要再次做的是，我只是在这里腾出一些空间。我将扩展这个终端甚至更多。我现在将终端分成三部分。这样我们可以添加三个花盆的三角锁。首先是这里，现在回到上一个目录。因为他们可以控制得到罐子，所以我们得到所有罐子的名字，然后我会一个一个地做。我将为这一个做立方体控制日志，然后我将做破折号 f，以便我们可以告诉日志，然后我将在这里做同样的事情，这是我们的第二部分，让我们看看将是这一个，破折号 f。然后第三个是这些家伙在这里为我们的第三个终端控制日志，破折号 f。我要回到 postman，也许我们可以把这个放在另一个上面，看看发生了什么。没错。是的，还有一件事，实际上我们需要改变的是邮递员是我们的加热器。所以让我暂时最大化这个。因为 postman 的默认行为是，它将发送一个值为 pickle keepalive 的连接加热器。这实际上是在 postman 和我们的机器人之间建立一个持久的 TCP 连接。这实际上会阻止我们的小练习允许不同的后续连接进入不同的机器人。出于测试目的，为了了解工作原理，我将禁用这里的加热器，看看它们是如何工作的。是的，就这样，用这种方法最小化这些。让我们发送一个请求，看看它到达哪里。你看，它落在左边的第一部分，在 704 52 的两个项目之间。我们再发一次。现在我们进入第二部分，让我们发送游戏循环。再次，在第二部分，然后在这一点上有点随机。我是说，应该使用的算法是循环法。但事实上，东西可以落在任何锅里。这是重点。这就是 Kubernetes 中的负载平衡，相当简单，不需要你做太多的工作。如果您扩展到 1000 个机器人，那么所有的机器人都会适当地服务于您的请求。在 dotnet five REST API 教程的这一集中，我们讨论了单元测试、测试驱动开发，以及如何实现它们来提高 REST API 的质量。

今天，你将学习什么是单元测试，为什么它如此重要。什么是测试驱动开发，也称为 DDD，为什么您可能希望在您的项目中考虑它，如何通过 x 单元测试框架重新测试 REST API 控制器，如何通过模拟框架模拟依赖关系，如何通过 fluent 断言库编写更好的断言，以及如何在实践中实施 TDD。那么什么是单元测试呢？这是一个我非常热衷的话题。为了理解这一点，让我简单地打个比方。想象一下，你是负责首次测试 SpaceX 火箭的团队成员，工程师们使用了几十个，也许几百个不同的部件和系统，有些甚至不是 SpaceX 生产的。组装这辆超赞的车。每个人都把他们的顶级游戏建立一个火箭。现在我们想看看一切是否如预期的那样工作。发布日到了。然后，是的，这并不像预期的那样，你不能只是组装一堆零件，然后在火箭第一次发射时一起测试。幸运的是，这不是他们通常在发射前测试火箭的方式。不要对火箭太专业，因为我肯定不是这方面的专家。我只是想在这里展示一个火箭部件的简图，这是我从 NASA 网站上得到的。所有不同的部件和系统，像有效载荷系统，或者氧化剂，也是整个飞行器的独立单元，在火箭能够从它上面发射之前，它们都需要正常工作。工程师们不只是建造这个单元，然后把它们送到组装团队，把它们放在火箭上，在所有东西都组装好之后，弄清楚所有的部件是否工作。火箭的每一个部分在被送到最后组装成火箭之前，都要被单独测试，可能要测试好几次。这给每个部件背后的团队以确定性，只要按照规范使用，该单元将按预期工作。组装整个产品的团队也是如此。他们知道，他们可以按照规范连接所有部件，火箭应该会说谎。这对每个人来说都节省了时间和金钱。不太可能拯救一些生命。因此，就软件工程而言，我们可以将测试定义为一种在没有外部依赖的情况下孤立地测试每一段代码的方法。现在回到我们的目录，REST API。即使在这一点上有一个更简单的屏幕，我们也有一些组件可以相互交流，比如 itis 控制器，或者我没有听觉类，Mongo 客户端实例。最后是 MongoDB 数据库。这些组件中的每一个都是由一堆方法组成的，这些方法代表了我们可以从中获得的行为。例如，年龄控制器有像获取项目，等级项目，更新项目，删除项目的功能，我们肯定会在未来继续增加更多。这些是不同的粒度单元，必须单独正确工作，以确保整个服务提供预期的功能。因此，对他们中的每一个人来说，真的要写一系列的单元测试，真正的锻炼每一个方面和每一个角落或者每一个方法，在尝试来自 postman 或者任何其他客户的整个服务之前，给我们足够的信心在他们的质量方法上。除此之外，单元测试还有一大堆你绝对不想错过的好处。通过单元测试，您可以快速验证您的代码，而不必担心依赖性。例如，您可以确保您的类可以从数据库中检索项目，而根本不必站起来或与数据库服务器对话。这种测试可以在几毫秒内给出结果，而不是几秒或几分钟，您可以进行更改，而不用担心引入回归。在你有了单元测试之后。您可以根据需要尽可能多地重构代码，而不用担心破坏服务。因为你知道单元测试将为你提供安全网单元，这将在更容易和更便宜地修复它们的地方捕捉盒子。也就是在部署到生产环境之前，将您的代码合并到代码库中。修复已经对生产中的客户产生影响的东西可能会有巨大的成本，包括人力时间，当然还有使用它或服务的任何人的金钱损失。和单元测试。如果做得不好，这可能是 REST API 的最佳补充，因为每个用例最终都会变成单元测试。那些测试不会说谎。它们必须代表系统的工作方式。现在我们知道了什么是单元测试，让我们也来谈谈测试驱动开发或 TDD。那么什么是 TDD 呢？简单地说，TDD 是一种软件开发方法，在这种方法中，在编写足够的产品代码以通过失败的测试之前，先编写一个测试。

这转化为一个由三个阶段组成的循环，红色阶段是你写一个代表你的软件需求的测试。这个测试失败是因为您还没有实现任何产品代码。事实上，测试甚至没有编译。一个绿色阶段，在这个阶段，您只需编写足够的产品代码来通过测试。除了通过测试所需要的，你不需要实现任何东西。在这一点上，不优雅的或唯一的代码是允许的。最后，如果需要，在继续运行测试的同时重构刚刚编写的代码，以确保它们保持绿色。正是在这一点上，您最终会为了可读性和可维护性而对其进行代码优化。对于任何新的功能，您都要重复这个循环。这是 DDD 的一个基本循环。你为什么想要拥抱 DDD？嗯，接受这种实践有很多好处。但是有三个方面或者像大多数我们做的那样，你开始关注需求，而不是实现。这给了你很大的自由去尝试正确地处理需求，因为你不会被已经实现的代码所约束。当您实现代码时，首先，您结束了编写测试，这些测试只验证您有时间或耐心的已实现的代码，因为您已经在这些代码上投入了大量的时间和精力。您可以增加它的覆盖率，因为根据定义，除了通过测试所需的代码之外，您不需要编写更多的产品代码。再一次，当你不按照 DDD 的方式做事时，你可能会以多个角落案例结束，你可能会觉得你可能会忘记或者可能没有时间来正确地测试，从而减少测试覆盖率。最后，从一开始就实施干净的设计。当您编写一个测试时，您将自然地开始以一种导致通过测试的方式来设计产品代码。测试中出现了类和方法，您自然会避免将代码写入 Cobbold 进行测试的陷阱。目前，在 dotnet 生态系统中有三种主要的单元测试框架，以及 unit、Ms test 和 x unit。它们都实现了相同的目的，即允许您以自动化的方式编写和运行单元测试。但是，对于任何新的项目，我强烈建议你选择 x 单位。这个框架来自流行的终端单元框架的原始作者之一。但是它真正的目的是更紧密地符合 dotnet 平台，并帮助编写更清晰的测试。它也比 ms test 更直观，后者在测试类中需要更多的属性。其中一些不容易正确使用，尤其是对于新接触该平台的开发人员。现在让我们看看如何在实践中实现单元测试和 TDD。是时候为我们的单元测试添加一个新的测试项目了。但是在我们这样做之前，我认为我们应该稍微重组一下，给我们的 REST API 一个更具体的目录，它将与我们即将到来的测试项目并排存在。我将从左侧的资源管理器视图开始，在这里寻找一个空的部分。右键单击，我会说“新建文件夹”,新文件夹将对该 API 进行编目。现在，让我们将大多数目录和文件移到那里，除了 VS 代码是目录、API 和 OBJ。因此，让我们将所有其他内容都放入目录 API move 中。现在已经有了目录 REST API 的所有文件。现在，让我们关闭它。然后让我们删除这个目录，我们不需要这个 bin 目录或者这个 OBJ 目录，那些都没了。现在，为了匹配文件夹名，让我们将项目名重命名为 catalog 那个 API。然后，我们将不得不在一堆文件中进行一堆重命名，只是为了匹配这个新项目，正确的文件名。所以我就把这个名字复制到这里，关闭这个，然后我就去搜索替换。我们将替换目录。那是我们闯入 API CS 闯入的目录。所以让我们替换所有的，他们会用 DLL 做同样的事情。所以要看看这个 DLL，siapa DLL，它将被重命名为候选 API，这个 DLL 将替换所有这些文件。现在让我们看看名称空间。所以今天，我们有了这个名称空间目录。这应该变成 API 的基本目录。然后，对于使用该名称空间的每个 everywhere 类，让我们确保它们使用新的名称空间。因此，使用 catalog 应该转变为使用 catalog API 来进行替换。现在让我们看看我们的

到 VS 代码。这是一个 JSON 文件，其中我们有这些工作区文件夹斜杠目录 API 来改变这一点，用斜杠库替换这些，API 斜杠如何使用这个文件占位符，所有条目。都搞定了。现在让我们去吃午饭，Jason 和做一个非常相似的替换，所以 workplace 文件夹到 catalog API，或者三个文件夹斜杠 catalog API，替换所有这些文件。我认为这是我们必须做的。所以我只关闭这两个。然后我会做一个 Ctrl，Shift B，以确保一切都在正确地建设。是的，看起来是这样，或者合上这个，你会看到牛轧糖包装恢复了，但一切看起来都很好，

或者关闭终端。

现在，在我们修改的内容中，它们将会崩溃，这是 Docker 文件。因此，Docker 文件现在指向一个目录 API，该 API 表示 broke。所以我只是，我只是想确保这仍然是正确的建设。所以我现在要重建我们的码头工人形象。所以打开我的终端。让我们打开一个全新的部分终端。考虑到这个新的目录结构，我必须进入目录 API。在这里，我可以再次运行 Docker 构建命令。所以只是为了 Docker build，破折号 d，然后会有，你会看到斜线目录，B 三。所以 B ^ 3，因为我们正在创建这个 Docker 图像的新版本，上次是 B ^ 2，按 enter。好了，新图像已经创建好了，我来做 Docker 图像。就在那里，图像被创造出来了。所以一切看起来都很好。所以这很好。我将关闭终端并关闭这个文件。所以现在我们可以实际创建我们的展示了。所以我会暂时收藏它。因此，我们想打造一款新的展示品，供您在同一级别使用。实际上，回到 terminal，我们将向上转一个目录。要创建这个项目，您的操作与创建 web API 的操作非常相似。所以你选择只使用一个. net 类。就像我之前说的，他们更喜欢这个项目的框架是 x unit。所以我会选 x 单位。现在我们来给这个项目命名。单元测试按 Enter 键的目录。我们的单元显示很棒，因为这里有一个项目文件和一个初始类，display 类。有吗？现在一件有趣的事情是，我们需要建立一个而不是一个，而是两个项目，对吗？因此，每当我们想要确保一切都真正正常时，然而，我们的物理环境还没有为此进行配置。所以你看 JSON 碱中毒的话，配置的只是目录 API CS Pro。那么，我们怎样才能让它在我们构建的时候构建两个项目。所以有一个简便的方法，我会告诉你。我要做的是在这里的根目录下创建一个新文件，只需添加一个路由，它将被命名为，我们会称它为你的，我们会感到自豪。好的，然后我会折叠一会儿。这个文件将允许我们一次性构建所有的项目。你好你好。所以我们声明如下。所以你会做 Raju SDK。这里我们将使用构建路径遍历 SDK。要做到这一点，你只需在这里输入，微软点建立遍历。这就是文件操作。因为他会把一包牛轧糖放进你的机器里。我上次找到的最后一个版本是 303。所以我会这么做。好的，让我们继续，关闭这个。在这个部分中，您必须定义一个项目组。所以我可以分组，关闭那个组。在这里，你必须引用所有你想编译的项目文件。为此，你要输入引用，包括等号，然后我们就这样，这个表达式。所以所有的东西，所有的星号，所有以 Brock 结尾的文件，都将被这个文件编译。好了，这个文件准备好了，让我们回到资源管理器。让我们开始 Jason 的任务吧。让我们要求 it 部门不再只是构建目录 API CS，而是要构建

建造那个街区。好吧。做完这些，我要做 Ctrl+Shift+v。

没错。现在它靠近东方。让我们关闭它。你可以看到那艘船。让我先做一会儿。目录 API DLL 和 Catherine 等，它们将由这一个注释构建。所以请注意，您根本不需要 Visual Studio 解决方案来解决这些问题。这是我喜欢的构建方式，就像解决方案中的所有产品一样。所以构建布拉格使用包括所有的中断文件，这将做到这一点。好，现在合上这两个。然后我们的测试在这里中断，我们当然需要引用我们的 API，因为我们将测试 API 控制器。因此，让我们确保我们有参考。因此，再次打开终端，我将切换到我的 PowerShell 终端。然后让我们看看，我将进入 API 服务目录进行单元测试目录。然后我再做 dotnet，加参考。然后我们将对该 API 进行分类。目录 API。是的，兄弟。没错。这样就增加了引用，我们看单元测试，关闭它们，它会在这里有引用。好了，现在 break the test 可能不能使用任何文件，或者引用他们的 API 项目中的任何文件，然后我们在这个测试项目中需要几个额外的牛轧糖包。让我们再打开这些。这是第一次，我们需要 nougat 包作为扩展插件抽象。让我们开始吧。dotnet 增加了记录抽象的 Bakhash 微软扩展。这是因为我们将使用或尝试测试我们的控制器类，如果你快速查看，控制器类确实在这里的构造函数中接收了一个记录器。所以我们需要使用这些日志类。为此，我们需要它来获得我们刚刚添加的包。另一个包是名为马赫的网络包。这个小框架可以帮助你模拟你的类，你在控制器中使用的类。这样你就可以在控制器中只测试你所关心的部分，但是你不必担心如何创建或者如何依赖或者如何工作。我们一会儿会讨论这些细节。但是，是的，那是我们现在需要的两个牛轧糖包。所以我会再次关闭终端。然后让我们开始关注我们的桌面类，这个案例，你需要这个。让我们将这个类重命名为一个更合适的名称。所以把它们重命名为项目，控制器测试，对，所以我们在这里遵循的惯例是，如果控制器被命名为它的控制器，这是一个类名，我们将使用这个类名，这个类的后缀是控制器测试。这是我们这里的一个。这就是我们要用的，在这里的课上，叫做第三个测试。我将折叠此导航窗格，现在我将执行 Ctrl、Shift V 操作，确保所有内容都正确构建。然后，如果你碰巧在这里得到这些红色的曲线，我们不应该在那里。但是如果发生这种情况，让我关闭这些，你可以做的是使用 Ctrl+Shift+P，只做锐暗，只做锐，或者你可以在那里键入，我们从锐开始，这样就可以了。现在请注意这个事实属性，它被添加到我们的音频中，在这里叙述了这一方法。所以 fact 是一个属性，你必须用它来声明这个类中的一个方法实际上是这个方法。所以这是测试运行者认识到它必须执行这些测试的唯一方法。所以不要忘记在你的每一个测试方法中加入事实。还有其他方法来申报或装饰你的金属评估。但是对于本教程，我们将坚持事实。现在让我们开始编写我们的第一个单元测试。但在此之前，让我们再看看，其他物品控制器类。让我们看看应该对什么进行单元测试。我们将为我们所有的方法编写单元测试。但是让我们从最基本的开始，因为有几个简单的好例子，我们可以通过这些方法。

事实上，正如您所记得的，在收到广告后，我们将重新启动，并尝试在存储库中找到该项目。如果我们能，如果我们不能找到它，如果它是没有，我们将返回没有找到。否则，我们将继续将项目转换为详细信息。因此，让我们为编写几个单元测试来验证这个方法。回到我们的测试类，我想鼓励你的一件事是，为单元测试使用一个好的命名约定。这非常重要，因为它有助于确定他们应该做什么，真正要验证什么，而不必深入单元测试的所有细节。我喜欢的一个很好的命名惯例如下。你想在这里用三个部分，那将是工作单元。测试状态和预期行为。没错。所以首先让你开始工作。你在测试什么？这个单元测试将要测试的函数是什么？这是单元工作，然后状态测试。那么在什么条件下呢？你在测试这些测试方法，对吗？最后，是预期的行为。当我们执行完这些测试的动作部分后，我们对这个单元有什么期望。现在把它转化成我们的引导式异步方法，让我把名字复制到这里。工作单元实际上就是这个方法的名字。So 门项目异步。我要测试的第一种情况是，当我们找不到物品时会发生什么。所以物品，物品是满的，就在这一部分。在这种情况下，我会说有一个现有的项目，所以这个项目不存在，预期的行为是什么，然后它返回未找到。好的，这应该是一个很好的名字来证明这是一个测试。现在，在阅读测试中，也有一些其他的好习惯，鼓励我们用这种方式来写测试。这里有三个部分。第一个叫做范围。第二个叫做机智。最后一个名为 cert。这些也被称为 AAA。安排，行动，断言。这个想法是，你将首先有一个数组部分，在那里你将做好一切准备来执行测试。所以就在确保考试之前，所以这包括任何种类的标记。你需要了解的水平和投入。然后我们转到 x 部分，在那里我们实际执行测试，我们执行我们在这里测试的一个动作。最后，在 assert 部分，我们验证任何需要验证的关于单元操作执行的内容。好的，那么这如何转化为单元测试呢？所以我们想测试一下控制器。为此，我们当然必须创建一个项目控制器的实例。但是，请记住，这里我们需要两个参数。所以我们需要一个积极的态度，我们需要一杯啤酒。现在，这里要记住的一件事是，为了测试这个单元，这个 get imazing 方法，我们并不真正关心知识库的内部，例如，accusatory 的行为，所以我们不关心发生了什么。通常，当您调用 get it basic 时，如您所知，我们将继续与数据库对话，检索项目和所有这些内容。但是我们不想测试我们不想测试的存储库，我们只想测试获取明细方法，这是我们想要测试的一个单元。因此，您必须确保找到一种方法，从这些测试中排除那些依赖关系和依赖关系的行为，并且只关注测试这里正确的内容。所以要做到这一点，当然，我们不能用一个真实的爱达荷州的故事或一个真实的伐木工。这就是我们要介绍的，我们称之为止损。所以我停下来的是一个假的实例，或者说是这些类的这些项目的假版本，只是为了测试的目的。让我给你展示一下那是什么样子。在这种情况下，我会说我们需要一个存放处。所以让我们我会说存管处，

停止等于新模拟。然后 mark 是一个来自我们刚才安装的 mock 库的 con，使用 mock。所以这是一个库，允许我们模仿任何模仿或者停止我们类的任何不同的依赖。因此，在本地，我们的控制器，正如我们在前面的视频中看到的那样，我们以这样一种方式来制作它，我们可以在那里进行依赖注入。因此，控制器真的不知道哪种存储库将进入这里，或者哪种记录器将进入这里，您只需查看，它只是查看接口，如您所见。所以这给了我们在单元测试中伪造这两种依赖的灵活性。我会说好的，这将是一个新的物品库模拟。好吧，让我想想，如果我要开会的话。请注意，我将此命名为停止，而不是模仿。这是我喜欢做的一个微小的区别，因为当你停止时，你不会在这个对象本身上验证任何东西。当您进行模拟时，您将在 assert 部分，继续实际验证模拟准确性测试中发生的事情。所以这是一个微小的区别，但是在这里做正确的命名是有好处的，这样你就能理解你所使用的变量的目的。好的，现在我们的期望是，当我们调用这个对控制器的调用时，当我们回到我们的方法，当我们调用 get imazing 方法时，我们的想法是它将返回一个 no，所以当返回 No 时，我们应该返回控制器应该返回 not found。所以我们需要设置，不是吗？那么我们如何在 mock 中设置这个方法，使它返回 No，回到这里，你能做的是这个库，停止设置。然后你会说，让我们说回购，回购那个门项目异步。然后是参数。现在，在这一点上，我们要传入的东西是什么并不重要。这是不相关的，因为我们想做的是揭示返回值的变化。正因为如此，你能做的就是说它是一个由 Mark 提供的函数，也就是任何 COVID，这意味着无论哪个值进来，都没关系。所以马克会负责提供一些价值。然后它会返回一个值，不，这就是我们想要的。这是预期的行为。然后，但为了不让营销人员感到困惑，我们必须将这一点融入商品实体中。让我在这里添加罗伯特命名空间。好的，这是为艺术家们设置的场景。所以我们再说一遍，我们说无论何时控制器调用 get good at basic 和任何代码，这是 mark 将要提供的，你必须返回一个空值。这就是我们在这个用例中所需要的。类似地，我们会对记录器做一些事情，所以我们说记录器停止等于新标记。我会说，嗨，伐木工，或者物品。我只是控制。好吧，让我们看看我们是不是又漏掉了什么。没错。看到爸爸还在建筑空间里。好了，现在我们有两站可以去了。现在我们需要创建实际的控制器。所以现在我们可以说，控制器等于新项目控制器。然后我们经过了这个码头。所以如果我假设 Ori，stuff，我们实际上需要得到这些对象的对象属性，因为那是真正的对象，它将传递一个模拟对象，然后 logger 停止那个对象。这就涵盖了 act 阶段的单元测试的安排阶段。这是我们执行动作的地方。这通常只是一行，在这里你执行你将要测试的东西。所以我只能说，卖出，等于等待。是的，现在我使用了 Wait，让我记住我们必须为这些单元测试使用正确的返回类型，因为我们将调用一个异步函数。如今，它实际上应该切换到异步模式。任务。所以现在我们可以做一个重量控制器，这个好主意可以同步。然后，就像我说的，不管我们在这里提供什么好处。所以你会说，酷，太好了。

这就是行动。最后，我们继续做断言。所以我们下一单元，你有一堆可用的断言方法。所以我们就用断言吧。然后我们想要验证的是，我们得到的确实没有找到，他们没有找到，有一个类没有找到。所以我们能说的是断言没有找到类型。结果。然后让我们看看我们是否遗漏了什么。是的，加上那个。然后我们在这里传递结果。所以结果对象，结果变量代表我们收到的实际结果。结果中的 result 属性表示我们得到的结果的实际类型，在我们的例子中，它应该是 not found 结果。现在我们已经知道了，我们可以继续实际执行测试。所以有很多方法来进行这个测试。在 VS 代码中。我经常使用的方法之一是使用 kotlin 的 via via。如你所见，这里有一组注释，是科特林用来编码科特林的。你必须点击运行测试。这应该继续进行测试。让我们看看运行测试会发生什么。如你所见，这已经过去了，我们已经过去了，这很好。现在，有另一种方法可以直接使用. net 来运行测试。CLI。如果你去终端，我会切换到这里，确保你在目录单元测试目录中。在这里，你能做的就是做网络测试。是的，所以这将继续进行，并运行不只是一个测试，而是所有的测试，你有这样困难，更方便，当你有你有这个测试项目越来越多的测试。如你所见，它通过了零个失败，一个通过。现在，随着测试数量的增加，您可能希望有一种更好的方法来可视化您的测试套件的整体状态，即哪些词失败了，哪些情况通过了，等等。所以要做到这一点，实际上有一个很好的 Visual Studio 代码扩展，你可以安装它来提供论文。所以让我们去我们的扩展中心。让我们扩展一下。让我们看看 dotnet core，这是第一个浏览器，我先把它折叠一下，June Han 的 cortex explorer 是目前为止我发现的最适合这类测试的浏览器。所以继续安装吧。对于这个扩展，你需要做的是告诉它在哪里可以找到测试项目。如果我们到 Explorer 一会儿，你会记得我们有艺术家在这个类别测试文件夹，收集单元测试 OCS 过程，所以我们需要提供这个扩展的位置。为此，你可以点击这里的齿轮图标。只需点击扩展设置。如果您在这里看到的这些设置没有出现，您可以尝试关闭代码或关闭当前文件夹并重新打开它。然后这些事情应该出现，它可能会发生非常非常第一次，但之后，它应该只是罚款。然后你要做的就是一直走到显示 Internet Explorer 显示错误的地方。这些窗口指定了这个项目的路径。另外，您是否希望不要进入“用户”部分，而是进入“工作区”部分。通过这样做，您将要在此处键入的内容将与您的项目放在一起，而不是放在您的用户配置文件中的某个位置。这很好，这样你就可以把所有的东西都放在一起。所以在这里，我们要指定的只是一个简单的表达式。让我输入这是一个 glob 模式，我们要说的是在我们的目录中搜索所有的地方，在所有的目录中，然后寻找测试。做完这些，我们就可以结束了。如果我们去这三个点，现在有一个测试部分。如你所见，我们的一个测试已经出现在那里了。要运行它，您可以单击此处的显示图标，也可以单击顶部的播放图标，它将继续运行所有可用的测试。

绿色的那一面。你可以看到绿色条也在测试的顶部。如果有任何错误，您将在我们测试失败的位置看到一些红色的曲线。是的，所以我们在这个视频中使用这个扩展来查看我们添加和执行测试时的状态。好了，现在我们已经准备好了，并且我们已经有了一个检查现有条目的测试，让我们为现有条目添加另一个测试。那么当物品实际存在时会发生什么？所以让我暂时把它折叠起来。所以我会隐藏侧边栏。让我们在这里添加第二个测试。也许我会复制这个测试的标题。所以我会把它抄过来。这是一个新的方法。这个将被称为异步获取项目。等等，现有项目。退货。意料之中。好的，现在，就像以前一样，我们做 AAA。安排，行动。现在断言，对于这些测试，我们很可能还需要一个，我们的容量和我们的伐木船停靠站。与其复制，不如复制这里的实例化，为什么不声明一个类级别，几个类级别的字段。这样我们就可以在这次测试和未来的测试中重复使用它们。所以让我来做吧。所以我去这里。因此，我将通过诱饵声明 read only to marked off items repository，然后我将在这里复制这个库，尽管我可以这样做。然后是私有的，只有记录器或项目控制器的标记。然后我们就可以用伐木工的东西来解决这个问题。这样，我们就可以开始我们的初始测试用例，为了简单起见，不必在这里声明它，因为我们在这里停止，或者他们在这里停止。好的，回到新的测试用例，对于这个测试用例，我们实际上需要一个可以在桌子上使用的项目。因为让我们快速回到控制器，I 这个控制器 IDs。如果记得，异步获取项目。在我们想要命中的情况下，也就是返回 DTO 的那个，我们需要有一个项目，我们需要有存储库，得到返回的项目。然后我们需要把它转换成。为此，我们必须在测试中预先设置该项，以便在这里使用它。所以我要回去测试了。我认为，我们应该有某种助手函数，不仅在这种情况下可以使用，而且可以代替用户测试，非常快速地创建一些随机项目。所以我将继续创建一个私有函数来私有标识返回一个项目。让我们称之为创建一个项目，这将说，只是返回新的，让我们指定新项目的所有属性。所以它将是 Id，这使得你进去很好，因为我们真的不关心它使用什么 ID，同样我们真的不关心这些随机项目使用什么名称，应该与任何名称一起工作。那么新的顾 ID，把它们串起来，对于我们要做的价格大概只是生成一些随机数，这样我们就不会把它们固定成任何具体的价格。所以不管怎样，我要做的是创建一个随机的 a 变量，把它放在最上面。所以我要声明一个私有只读。随机，让我们把它命名为你的，它将是新的。因此，这将与我们在几个地方。所以现在我们可以回到这里。我们可以说接下来运行。然后我想我们说过价格应该在 1 到 1000 之间。所以我们假设最大值为 1000。应该够了。稀有将会是说 UTC 的时候。好吧，

现在我们有了这个方便的方法，让我们回到我们的测试案例，这里。就整理而言，我们要做的是首先准备好我们要存放或要归还的物品。因此，我们要说的酒吧规格，这个项目是创建随机项目，然后我们必须做的存储库设置。这和我们之前的测试有点类似。所以我要复制这一行，这是之前测试的第一行。所以当我们调用异步获取项时，现在要做的是返回该项。所以返回 async。预期项目。好的，然后我们继续做和前一天差不多的事情。抄下来，这几行。所以我们声明了一个带有两个停靠点的控制器，然后我们通过调用 get item async 得到一个结果，与任何 GUI 无关。然后是时候断言我们得到了什么。那么我们想在这里断言什么呢，所以可能想首先确保我们得到了活动或者其他结果，比如未找到或者错误的请求之类的。所以我会做一个搜索，也就是类型标识。让我们在博物馆里增加一个空间。然后我们看结果点值，因为它是值属性，在这种情况下实际上应该有交易。好吧。当我们断言 well 时，我们还可以做的是，我们应该做的是验证返回的所有属性都与期望项匹配。因此，让我们首先拿出 DTO。所以我们可以在这里做一些选角。我们对那个价值的认同是作为行动结果出售的。好的，我们可以做一个服务等于期望的项目。就像这样，我们将需要检查每一个单独的产权，所以 x 与 ID 现在预期的项目。该名称应该等于该名称的。我们会继续开发其他资产。但是在这一点上，想象你不只有几个属性，而是有几十个属性，就像对象可以变得复杂一样。所以今天继续寻找，寻找，寻找会变得很麻烦。事实上，断言太多东西并不是一个好习惯。在这种情况下，你应该试着断言或更接近，在每个测试中只做一件事，这是最好的实践。所以要做到这一点，我们可以做的是不做所有这些，我们可以切换到一个非常方便的断言库，称为流畅断言。达文将允许我们以更直接的方式来做这件事。所以让我们把终端也带进来。Ctrl J 和 l 转到 PowerShell 和 hoovering，我们这样做是为了确保您在单元测试目录的目录中，并且您可以执行 dotnet add package。流畅的断言。好了，就这样，我要关闭终端。所以现在我们可以做一些稍微不同的事情。让我展示给你看。我们能做的是，现在我们可以说我们卖了那个值，然后应该卖，如果你的断言命名空间等同于期望的项目，这很重要。好的，然后我会把这个拿掉。这需要做的是，它应该比较生成的 d to 的属性值。我们在这里创建的预期项目的属性，对吗？因此，通过这种非常方便的方法，我们不必逐个属性地进行比较，它会直接为我们比较整个事物。但是，这里唯一的问题是，看到怀疑它实际上是一个记录类型。正如您所记得的，该项目已经是记录类型的记录类型。好的，对象的 equals 方法，这会使这个方法表现不好，对吧，因为他认为你必须直接比较 DTO 和实体，而不是比较属性，这才是我们关心的。因此，为了解决这个问题，我们将在这里指定一个附加选项。

这将是选项，选项通过项目类的项目成员进行比较。如果我们没有说，嘿，不要直接比较 DTR 和物品，只关注它们各自的属性。只要属性的名称相同，就比较这些属性的值。这样的话，你就可以继续下去，告诉我们这些对象是相同的。没错。因此，让我们继续运行这个测试用例，看看我们得到了什么。因此，我们将单击“运行测试”。没错。这个案子已经过去了。就像我们这样做，只是为了保持一致，让我们也修改之前的测试，也使用流畅的断言。在这种情况下，结果应该是过期的。未找到结果。它取代了上一行。好了，我们来验证一下所有这些案例是否都通过了，我将在 Data Explorer 中运行这些案例。是的，一切看起来都很好。很好。现在让我们进入下一个单元测试。让我们简单地回到控制器。让我们看看还有什么。也许在控制器中，我们现在要测试的是我们的第一个金属，它返回存储库中 REST API 可用的所有项目。所以请记住，这些项目将继续进行，检索所有项目，将它们转移到 DTO。然后他回来了，这就是他所做的一切。因此，我们想要验证的是，对于我们为栓剂设置的任何项目，我们必须设置存储库，它们必须作为详细信息返回，并且它们应该与通过存储库获得的 id 完全匹配。因此，让我们继续为此编写一个单元测试。所以回到测试班。再次，我要复制加热器的这些这种情况。我将向下滚动到这里，复制它。好的，现在，让我们做正确的命名。因此，这些将被命名为 get I get items，a think，这些将只是与 exceed 现有的项目。他会说，退货或者物品。同样，让我们把我们的安排，行动和断言部分。在这种情况下，我们需要的当然是从存储库中获取一系列项目。所以我们首先要做的是声明这样一组项，我们将创建一个简单的数组。所以我要做的是，我说 bar 期望项等于 new，这将是一个数组。我们将在这里使用几次我们的创建随机物品方法，可能会少引入三个物品。是的，这样就可以了。非常简便的方法。现在，我们可以继续设置存储库来返回这些项目。因此，我将进行存储库停止，设置他们购买枪支的回购在哪里获取它，并说调用获取一个 gig Titan 16，这应该会返回预期的项目。然后我们必须构建控制器。我会像之前的例子一样，把这一行复制到这里。然后我们会继续做。所以 bar，act 两个 items，等于一个 weight，controller，get items 异步。谢谢，那应该能找回物品。现在我们要做比较。所以再一次，我们可以使用流畅的断言这种非常方便的方法来做一个等价的比较。所以我们可以说，项目应该等同于预期项目。我们又要做选择了。因为我们喜欢，再一次，我们处理记录类型。否则事情就不会成功，对吧。然后是按成员进行比较的选项，好的，我们继续进行这个测试。让我们看看我们得到了什么。

是啊，这次路过。太好了，关上吧。好了，让我们回到 ISIS 控制器，是时候测试我们伟大的项目异步方法了。这就是在存储库中创建项目的那个。所以在这种情况下，我们必须提供伟大的身份作为输入。然后我们可以验证，我们应该返回，我们应该收到一个添加了分级项目的返回。那是，那是这些金属应该做的。事实上，返回的项目应该包括 ID，因为它没有在那里提供，创建并这样做返回的项目将有一个 ID，他也将有一个分级日期。所以让我们写出一个可以验证所有这些东西的测试。所以回到物品，控制测试，他们可能会把桌子上的加热器拿走，也许我把整个东西都拿走了。复制这个，然后去掉空格，去掉这个，我去掉了实心的。好了，现在这个方法将被调用，从方法名开始，也就是异步创建项目。然后这将是在这种情况下，当前状态，让我们把它命名为项目创建，因为我们将提供应该创建的想法。而这篇论文是它还创造了一个标题。对吗？在这种情况下，安排的部分包括准备准确的身份。所以在这种情况下，就像我们到目前为止所做的那样，尝试使用一个创建的随机物品将会很棘手。所以在这种情况下我们会很明确。所以我们会说我倾向于创造等于新创造的物品 d to。这里我们将详细提供查询的元素。所以我们确实提供了一个名字，它将会是一个很酷的类核字符串，我们将会提供一个价格，它也将会是随机的，再次是 1000，我认为那将会是。让我快速创建一个包含 12 个数据的新表，以确保我已经包含了我们需要的属性。所以他知道名字和价格。是的，回到这里。在这种情况下，我实际上不需要在存储库中设置任何东西。因为没意思。我的意思是，对于这个测试用例来说，如果有一个真正简单的行为来创建项目，那么当存储库被调用时会发生什么并不重要。所以，如果你回头看看我只是控制者，这里真正要发生的是，耶和华神需要打电话问候，我是惊人的。我会继续评分。但是我会鼓励你们对将要在这里测试的东西要小心一点。因为你也可以决定不，我要确保他们创造的惊人的金属被称为储存库。没错。所以所以是的，我的意思是，它应该被创造出来。但是这有点过于深入测试用例的细节了。所以你将会使你的测试用例，在这个方法改变的情况下，很容易需要改变。因此，理想情况下，您希望以这样一种方式对待您的每个测试用例，即它们只为方法提供一些输入。最终他们会验证这个方法的输出，但是他们不会尝试去做一些内部将要发生的事情。所以在这种情况下，我们根本不需要携带所有的金属。事实上，我们不会设置它，我们将继续并回到这个案例，我们将继续并使用调用，调用操作。所以我们会说，var 迎接项。对不起，这将是酒吧的结果等于重量，控制器点，创建项目访问。我们提供要创建的项目。然后我们可以继续做断言。我们在这里要做的第一件事就是试着找回那个身份。所以我要做的是，我要做的是，我们做的项目是结果，结果是创造了一个行动结果。好的，这就是我们将要收到的结果类型，这是一个创建的操作结果。从那一个，我们想得到值。在这个例子中，这个值会把它变成一个有点复杂的项目。现在我们可以做同样的等价性的事情，我们一直在做。所以我倾向于创造

应该等同于 created by，好的，然后我们提供选项。就像我们说的，会有成员比较的选项。在这种情况下，我们将在这里使用的数据实际上是我可以成交。

好的，这是我们从前台收到的物品的类型

债权人的。好吧。但是另外，我们还想做一件事，因为 a，这两个 DTS 没有相同的成员，如果你还记得，如果我们去 F 12，去 identity，哦，这个有四个属性，你可以看到。但是如果我们进入大同一性，或者这个只有两个属性。这意味着，如果你试图比较这样的东西，会失败，因为你会说，嘿，你写的东西比另一个有更多的属性。所以这，这说不通。所以在这些情况下，你能做的就是，只看这两个对象之间共有的属性。在这种情况下，这将简化事情。所以我们只能这样了。然后本着流畅断言的精神，我们可以使用点号排除缺失的成员。对于那个断言来说应该是这样的。好的，我们正在比较这两个对象是等价的，但是我们不会注意任何其他对象中缺少的成员。但是，我们可能希望实际检查这些额外的成员。所以对那些将要成为的人会说得更清楚一点。所以贷方项目，ID 不能为空。因为是方法，所以它应该为踏板车骑手生成一个 ID，并且还创建一个创建日期的项。

应该

我们不知道具体是什么，哪一天我们会进入那里。但是我们知道应该是，应该是接近现在的时间吧？因为执行这个测试只需要几毫秒。所以我们现在说日期时间偏移 UTC。然后，为了安全起见，我们会给它一个精确的范围，因为我们不知道今天基本上花了多少时间，尽管它应该是超级快的。但是我们要给它 1000 毫秒，作为项目创建时间和我们在这里检查的数据之间的时间差。好的，这次测试应该是这样的。让我们继续从测试中运行它。看看我们得到了什么。测试通过。看起来不错。好了，我们要看的下一个测试，我们要看的一个较少的例子是更新，更新项异步的情况。记住这个方法，它得到要更新的项，它将从数据库中得到它。如果它没有找到，它会说没有找到。否则，它将创建该项目的副本，成为具有更新属性的更新项。然后它将继续更新数据库中的项目，最后不返回任何内容。好了，为了不在这里花太多时间，我们在这里只讨论一种情况，也就是物品实际存在的情况。但是你可以想象如何测试未找到的情况，这要简单一点。但话又说回来，不要陷入验证项目实际上是发送到一个存放处的日期逐项方法的陷阱。我们想要我们将在这里提供这两个参数的输入。我们希望输出没有添加任何内容，这是我们在这里需要验证的所有内容。没别的，我们不需要担心方法的实现。所以让我们回到我刚得到一个测试。我们再来一次，我会在这里复制一份上次的测试。因此，这将是更新，我认为我们采取现有的项目返回没有内容，好吧。然后，我们将满足这些谁需要一个控制器将需要，我们将删除这个物种在最后。因此，对于范围基地，正如你从这个控制器记得，我们将需要一个当好 imec，尤塞恩博尔特，你需要返回它的权利，以便我们可以前进到这种情况。因此，我认为我们已经在其他地方讨论过这种情况。所以，让我回到前面一点。这里的这个，我们将从异步获取项中获取这些。这种情况下，让我抓住这里。所以，这将允许我们有一个项目，由存款人完成返回。所以我们将这些命名为，物品 ID，那是存在于那里的 ID。现在我们需要声明我们要提供给方法的实际项目。所以他们更新了它。所以我们先把商品 ID 作为一个变量。所以物品 ID 是系统 ID。所以我们要抓住那里。然后我倾向于更新

这是一个新的更新 ID，所以我们将提供一个名称命名方案，如果你把它命名为 string，会很酷。或许

我们下载线。对于价格，我们可以选择现有商品的价格，然后由某人将其增加一倍，比如说增加三倍。好的，这就是这篇文章的更新内容。所以我们几乎改变了名字，因为我们变得非常不寻常，我们通过增加三个来改变价格。然后我们创建控制器。我开始做动作。所以我们说结果等于等待更新异步的控制器。然后这里是我们提供商品 ID 的地方。然后我们提供要更新的项目。最后是断言，断言会很简单，因为就像我说的，我们只想验证我们没有得到内容。因此结果的类型应该是。没有内容结果。仅此而已。因此，我们再次从存储库中设置项目的返回，我们准备九个过时的，我们修改属性，我们调用一点异步。最后，如果一切顺利，我们应该会得到满意的结果。所以让我们继续进行这个测试。最好的情况是，我认为我们在这一点上只缺少了一个方法。我们去国税局。这是删除 I 基本，对吗？它必须非常简单。为了验证和更新非常相似，我们得到一个 ID，它将不得不寻找项目。同样，我们不会检查所有的案例，对于这个案例，只是一个项目存在的案例。所以我们要让它返回这个项目。然后它应该不返回任何内容。同样，我们不关心存储库或这里的任何内部发生了什么，我们只关心它应该返回内容的事实。所以回到我只是崇拜测试。我要再一次复制你最近的案例。

这将被命名为删除，它可能与现有项目同步，不返回任何内容。是的，这是一个合适的名字。对于这种情况，该设置会工作得很好。但是那样的话我们就不用准备任何更新的物品了。用这些设置创建控制器。然后，我们将与数据库同步，这将只是现有的 ID 和该 ID，然后断言与之前完全相同。应该有敲击结果类型。仅此而已。所以我现在继续运行这个测试。

是的，它正在过去。事实上，如果我们转到测试浏览器，现在，让我们转到这里的测试部分。让我们运行这个。如你所见，我们已经通过了一整套测试。好吧，这很好，我们有一堆测试用例，涵盖了很多，我们的控制器里什么都没有。这给了我们很大的信心，让我们可以在 REST API 中做任何未来的改变。所以我现在想做的是，我想在所有方面做一些改变。但是我没有，我没有办法确保它不会损坏任何东西。但现在我们知道了。所以我要在这里做两个关键的改变。其中之一是，我将把我们的实体切换为不再是记录类型。所以记住，如果你去实体项目，他就在这里。所以他是记录类型的事实实际上使事情有点不灵活，我的意思是文本。因此，我们不能在控制器的 update a 操作中使用 update existing items，我们必须创建这个并不真正需要的副本。所以这些实体应该是可积极塑造的。所以我们真的不需要这些东西。所以我们会把这个切换成普通类。我们还将在这里添加一个描述属性，这样我们就可以为项目提供一些描述。所以让我们做这两个改变。让我们看看我们的测试用例是否能帮助我们防止破坏任何东西。所以就像我说的，这个项目会从记录变成类。然后我们不会在这里使用它。但是我们会把它切换到刚刚设置。所以在这一切中。而现在这是一个正常的标准类。但是，就像我说的，我们将添加一个描述，对实体的描述。做完这些后。实际上，我喜欢做的另一件事是简化我们使用视频的方式。记住，我们有三个视频的三个文件。但事实证明，有一种更好的方式来声明视频，如记录类型，这实际上提供了我们今天正在做的更多好处。所以我要做的就是把这些文件都处理掉。让我删除 CTOs 文件夹。或许可以稍微折叠一下，我要做的是在 catalog API 的根目录下创建一个新文件。我们来命名吧。CS 的视频。让我们引入一些命名空间，右命名空间，它将对 KPI 细节进行编目，我们将以更好的方式在这里声明所有的细节。让我隐藏侧边栏。因此，第一个视频将是商品详情。我们会问你把它记录到什么地方，然后我们会声明这些属性，就像我们在为这个属性创建一个构造函数一样。这是你可以做的事情，我们会说好的 ID。然后让我们看看我们是否遗漏了这个系统。他们会将新的描述命名为 property price，并记录创建日期。好的，这就是你要做的，用另一种语法来声明一个记录类型。如你所见，要简单得多。现在，让我们宣布下一个将是唯一记录，创建项目 DTO。然后它将没有 ID，只有名称和新的描述，属性。然后是价格。让我们不要忘记，我们已经在这里设置了一些属性，以确保我们得到有效的输入。所以在命名的情况下，我们希望它是必需的。它的空间令人惊叹，就价格而言，我们想要的是 25 英镑的范围。范围是从 1 到 1000，我们不需要描述，也不需要在价格中添加必要的属性，因为价格实际上是有效的。所以永远不会是不，无论如何你都会有人在那里。我们将验证范围是否正确。最后，让我们添加我们遗漏的最后一个细节。我只是复制了那个。这将被详细更新。没错。所以这就是我们所需要的。现在，我们在一个文件中声明了我们在 REST API 中使用的所有细节，而不是三个文件。我们看看还有什么需要修改的。既然我们做了这些更改，让我们看看扩展。让我们看看这是怎么回事。

是的，所以我会藏起来。所以现在我们改变了将我们的细节声明为记录类型的方式，它们变成了不可变的。我们不能再经历这种初始化了。我们必须通过构造函数创建 DTO。这是从现在开始创建它们的实例的唯一方法。而且建成后，没人能改变 DTO 的属性。所以我们会说新的身份哦，然后我们会提供它的 ID。本我和痛苦。对吗？还有那个剧本。我认为价格是创造日期的东西，对吗？总是这样，是的，我们在这里有液体，但是可能太多了，读不出来。所以我们就这样算了。好吧，让我们看看还有什么需要解决的。如果我们回去，那么控制器里有什么东西在活动？让我们看看它是什么。没错。更新图像有问题吗？没错。所以我们不能再使用这种语法了。因为该项目不再是记录类型。现在是标准班。事实上，这很好。这正是我们想要解决的问题。因为没有必要创建这个更新的项目，我们可以只修改现有的项目。所以我们会说，现存物品的那个名称等于物品 D 的那个名称，现存物品的那个价格等于同一性或那个价格。没错。所以我们不需要这些额外的人。我们就让它这样吧。然后为了更新，我们将使用调用现有的 IRA。好吧，所以，是的，这里没有更多的休息。让我们看看还有什么。因此，由于 API，单元测试中的一切看起来都很好。让我们看看是怎么回事。好吧，我们把边栏藏起来。让我们看看。没错。所以很大的恒等式哦，必须加权来定义构造函数里面的属性。所以我们必须提供这些名称。他们可能会为描述做同样的事情。对于价格，可能是随机数，所以我会删除它。然后我会这样做。这是更容易看到的。那里。好吧。所以让我们看看还有什么需要解决的。以防更新身份。哦。让我抄下这一行。所以我们必须提供，然后我们提供一个描述。然后我们提供价格，这将是现有的项目价格加三。好了，把这个拿开。没错。就这样，我想我们没有更多的休息时间了。我真的能看见。所以让我们继续吧。现在让我们运行我们的测试，看看我们得到了什么。所以继续做测试吧。没错。有趣的是，我们确实有失败的地方。让我们看看是怎么回事。太棒了。可能是同步失败了。如你所见，我们在这里得到 x，表示有问题。我们在这里得到曲线，表示那里有东西。如果我们看到那里的消息，你可以看到它说期望的成员描述是 no，但是在那里找到了一些值。没错。然后，会发生什么呢？让我们回到控制器上。所以我来做 f 12，从控制器。让我们来看看 Create 方法。在这里。让我们隐藏这个隐藏边栏。是的，这里发生的是，如果你能发现，我们没有描述的百分比值。让我来关闭这个。所以回到测试上来。没错。因此，当我们声明要创建的项目时，我们添加了一个描述。但是当我们创建降级的项目时，它没有任何描述的价值。这是因为我们没有在任何地方指定。所以这是我们必须解决的问题。这是一件好事，使用这些应该等同于，因为当你添加更多的属性时，你不必记得在测试用例中做适当的检查。否则，任何时候你在这里添加一个新的属性，你都必须回到那里的测试和其他属性，以确保你不会忘记这个用例实际上覆盖了你，确保你不会忘记在你实现 Edit 方法的地方添加那些属性。对于这种情况，

我会对这个描述进行描述等于认同。现在，让我们回到我们的测试列表，让我们再次运行它们。现在都是绿色的。你还可以做的一个小改进是，改变我们在几个测试用例中进行比较的方式。所以我们回到两个列表测试用例，删除，我们创建了一个回顾项。如果你看到我们是怎么做的，B，A，k 等同于这里，这些选项，我们需要这样做，因为 A 类中的 A 项，我们之前可以记录，所以这就产生了问题。既然它不是记录类型，我们可以坚持正常的行为。所以现在我们可以去掉这个，用这种方法做等价的事情。无畏的特工会知道该怎么做。因为这只是一个标准，加上同样的方法，我们可以到下一个例子，改变这个想法。这就足够了。这仅仅是因为，就像我说的，因为我们在这里比较的是，其他类不是记录记录类型，你仍然必须用另一种方式。所以让我们确保测试用例仍然通过。所以我会继续做所有的测试。一切仍然是绿色的。好吧，这很有效。现在我想我想把齿轮切换到测试驱动的开发 TDD。所以我们谈到了 TDD，它有一些非常好的好处，因为它允许你开始真正的需求测试，然后在以后继续实现。让我们来看看，它们是如何工作的。在实践中，我们要做的是，如果我们回到项目控制器，我会再次隐藏这些，让我们回到我们的第一个方法，让项目异步。如你所见，这是返回所有项目的方法。但是对 REST API 的一个新要求是，我们应该能够通过名称返回项目。所以如果有人在这样一个方法中指定了一个名字，这个方法应该只能返回名字中包含指定参数的项，对吧。所以如果，如果你的物品中有一个单词药水，像药水，药水，药水，所有这些所有这些东西，都会返回名称中包含药水的所有物品，而不是在右边，所以这是一种过滤东西的方法。但是让我们看看如何使用 DDD 来实现这样一个方法。所以我会回到刚才的控制测试。所以我们抓住这个，抓住这个方法，得到它，挑它做水槽。然后我就把它复制到下面，因为有类似的方法。但是在这种情况下，我们对它进行了重命名，以获得匹配项的 sink、returns，

返回

匹配项目。好的，在这种情况下，我们将继续，我们将不再使用随机项目，因为我实际上想为我们的项目指定一个名称。事实上，在这个测试案例中，这是我们唯一关心的事情。我们在这里想要什么？所以我想做的是重新排列一下，这样我们就不用这些了，我们把它们命名为，所有的项目都等于新的。然后我会把这些移到下一行，下一行会有点冗长。也许像这样。然后，在每一行中，我们将创建新项目，新项目，而不是这些，所以我们会说新项目。他会提供一个名字。所以让我们用一些我们可以用来做这些测试的东西。就像我说的，我们去拿魔药。药剂盒。所以我们会有一种药剂。然后再加两个。第二个将被命名为让我们给它起一个完全不同的名字，比如如何做。然后最后一个会是 highbush。在这种情况下，我们有两个项目有相同的术语部分，另一个没有。然后我们在这里声明一个变量，我们要说出它的名字，名字匹配等于现在注意，我们已经实现了这个新方法，但是这个方法根本不存在，他还没有被实现。这是 DDD 的正确做法。所以我们将从一个实际上会失败的测试用例开始，因为我们没有方法，然后我们将在以后继续实现。好了，现在我们是存放收件箱，异步获取项目，我们将返回我们在这里准备的所有项目。

记住，这是对相反的调用，而不是对控制器 get 的调用是异步的。然后我们继续，准备我们的控制器，然后一个恒定的时间，使调用的行为。

在这里，我们要更明确一点。第一个它现在将在左边的栏中，因为我们想要向 to C sharp 和 VS 代码发出信号，我们将从这个新方法或要创建的方法中接收到什么。所以在这种情况下，我们会收到一个 ienumerable。DTO 物品。这些是可以找到的物品吗？我们错过了什么吗？是啊，系统集合类属是惊人的。然后这些将通过调用重量控制器来实现，异步获取项目。但不是签名，我们需要一个新的签名，我们实际上可以异步管道它们。我们需要一个新的签名，我们可以接收匹配的名称。因此，我们将在这里传递名称以进行匹配。好吧。是的，所以是的，那一定很棒。然后，正如我们所断言的，我们必须验证的是，我们只得到他们名字的物品，在这种情况下，将名字与批次药剂相匹配。因此，为了验证这一点，我们会说电话项目应该只包含。然后我们可以说 item，其中 item 的名称应该等于 item，它将是 items soup，抱歉，这是所有的 item，sub 点名称，因为这是第一个，让我们向上滚动一点。所以我们得到了 0，我们得到了 1 和 2。所以应该是那个。或者，然后复制这个应该是，我认为名字应该等于那个名字的一个简化的套装。好的，这是一种方法，你可以使用流畅的断言，来验证集合中的条目是否匹配某些条件。所以不管我们得到什么，我们得到四个项目，a，项目应该匹配 phusion 或 hipolito。既然这样，好吧。如果我们继续构建这个，我会做 Ctrl Shift v，当然它会失败。因为我们没有这样的金属门是一件有争议的事情。这就是 DDD 的红脸。现在，要开始进入绿色阶段，我们需要向前推进并实现实现这是为了做到这一点，或者我们可以做的只是单击此处，我将做一个 Ctrl 点。a 给出了他的选项，或者我们可以使用一个生成方法，我只是用控制器来隔离异步。所以我会这么做。如果我做 f 12。这里，方法现在存在。我会把这个移到，我们已经有另一个重载的旁边。好的，然后我们可以继续尝试实现这些。但是正如你注意到的，这些方法是完全一样的。但是其中一个接收参数，另一个不接收。所以我认为最好把所有东西都放在这一个方法中，而不是尝试实现第二个方法。所以我要把这个参数从这里拿出来，放到那里。好的，我们并不期望总是收到这个名字，这取决于打电话的人想要什么。所以让我们使这些 a 可以接收 no，所以允许接收。好的，就这样，让我们继续，再一次运行这个案例 a，让我们看看我们得到了什么。我的意思是，在这一点上，你应该很好地构建，这个验证应该构建，是的，它确实构建了。现在让我们进行测试。我们怀疑它正在失败。它之所以失败，是因为它携带的物品比预期的多。在这个结果中找到了项，只是得到所有的项并不是只得到这里指定的项。所以让我们看看如何解决这个问题。所以让我们努力变得绿色。所以我们要做的是非常简单的事情，在检索完两个项目的列表后，我们要应用一些过滤，如果我们必须应用一个过滤器的话。所以如果 string .为空或空白。名称，要匹配的名称。这是唯一的列表，让我们将它们重命名为 name，而不是 need to match。这应该够了。如果名称是更多的空白如果它不被称为空白，那么我们将应用一个过滤器对我们已经收到的文件列表。所以物品将会是物品

身高在鸭名中，含玉米含 me。只是为了确保我们不会，我们不担心这里的套管。让我们做字符串比较。现在，在我们的情况下，我们认为这无关紧要。如果你在寻找大写 P 或小写 P 的魔药，应该没关系。我们不在乎这个。因此，只要提供了名称，就可以使用它来对项目进行过滤，这样我们就可以得到一个经过过滤的项目列表。这应该足够满足条件了。让我们回到测试上来。让我们运行它。而这一次是过去了。所以我们同意，现在通过运行整个测试套件，这实际上证实了这一点。确保我们没有打破任何东西。是的，如你所见，现在一切都是绿色的。所以一切看起来都很棒。这就是如何使用 DDD 的方法。在这一点上，我们真的不需要做更多的重构。但是如果你需要的话，你可以继续做更多的重构。但是我们已经经历了红色阶段，绿色阶段。现在重构不是不处理这种情况。我们现在可以做的是验证这一新功能在现实生活中是否确实有效。因此，我们将启动我们的主机，我们将看到如何使用这些来自邮递员。好的，我会继续按 f5 键。然后去邮递员这里。让我们来看看。首先，我们将看看我们的数据库中目前有什么。所以我这里有 URL 来获取数据库中的所有项目。所以我会点击发送。现在，我们有了药剂和解毒剂。我们已经准备好验证东西没有坏，因为我们已经在这两个方法中修改过了，它现在可以接收一个参数，但是它看起来工作得很好。因此，为了正确验证新功能是否正常工作，我将通过 post 操作在这里添加另一个项目。所以我只需复制 URL，然后加上，我会将它切换到 post，支付 URL，并在原始的正文中。我来演杰森。然后我会在这里复制其他东西的主体，复制这个，注意前面的项目没有描述，这样就可以了。新项目将会有一个，让我们确保我们能有一个。所以我们开始吧。那个。为了简单起见，我就给这家伙起名叫魔药。这将会储存少量的 HP。价格大概是 7 美元。让我们暂停一下。好吧，有没有。如果我们返回到“get a operation I hit”集合，在这里我们可以看到我们现在创建了三个项目，在这里我们可以看到筛选是否有效。所以现在我可以说名字等于，我们在找魔药吗？所以部分，所以他们应该只给我百万请愿和堕胎。因此，我将在这里点击发送。事实上，我们只得到这两个项目。注意，我在这里用了一个更小的 P，而不是之前的大写 P，这并不重要，他仍然能够找到这些项目。所以一切都在按预期进行。所以，是的，这就是你如何使用 DD 来驱动你的流程向 REST API 添加新功能。所以一如既往，我希望这是有用的。如果你想更深入地了解我在这一系列教程中所讲的内容，请查看我正在观看的视频描述中的完整在线课程的链接，我们下次再见。