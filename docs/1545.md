# 面向专业人士的 Git 免费版本控制课程

> 原文：<https://www.freecodecamp.org/news/git-for-professionals/>

几乎每个软件开发者都使用 git。许多人一整天都在使用它。虽然您可能已经知道了 git 的基本知识，但是如果您学习一些高级的 git 概念，您的生产率将会提高。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个 git 课程，它将帮助你把你的 git 技能提升到一个新的水平。

Tobias Günther 创立了这门课程。他有多年使用 git 的经验，甚至是 Tower 的联合创始人，Tower 是一家为 git 创建 GUI 客户端的公司。

在本课程中，您将学习与以下主题相关的一些高级 git 技术:

*   完美的承诺
*   分支策略
*   拉取请求
*   合并冲突
*   合并与重设基础

观看 freeCodeCamp.org YouTube 频道的全部课程(1 小时观看)。

[https://www.youtube.com/embed/Uszj_k0DGsg?feature=oembed](https://www.youtube.com/embed/Uszj_k0DGsg?feature=oembed)

## 副本

(自动生成)

这是 Tobias Günther 教授的中级 Git 课程。

他将帮助您超越 Git 基础并改进您的 Git 工作流程。

大家好，自由代码营的朋友们，我叫托拜厄斯。

今天我将提高你们的 Git 知识。

有很多关于 Git 版本控制的初学者教程。

但是我将帮助您理解 git 中许多事物背后的概念，如何设计完美的提交，如何选择分支策略，或者合并冲突是如何真正工作的。

所以我的目标是让你在使用 git 时更加自信，并让你更接近成为一名高级 Git 用户。

在我们开始向自由代码营团队大声疾呼之前，非常感谢你们参与这项教人们如何编码的任务。

谢谢你让我贡献一点点。

简单介绍一下我自己的背景，我是 tower 团队的一员，tower 是一个 git 桌面 GUI。

对于 Mac 和 Windows，我们已经存在了 10 多年，帮助了超过 100，000 名开发人员和设计人员更轻松地使用 git，提高了 git 的工作效率，减少了错误。

在今天的课程中，您不需要安装 tower，您可以在命令行中进行操作，没问题。

好吧，我们开始吧。

因此，让我们谈一谈如何创建完美的提交。

所以第一部分是添加合适的改动，对。

第二部分是编写一个好的提交消息。

让我们从向提交添加更改开始。

因此，我们的目标是创建一个有意义的提交，一个只包含单个主题的更改的提交。

与简单的方法相反，有时我们只是将所有当前的本地更改塞进下一次提交。

所以这是我们不应该做的坏事。

但是有选择性地仔细决定下一次提交应该做什么是非常重要的。

这是更好的提交方式，因为它分离了不同的主题。

另一方面，提交越大。

提交的主题越多，将来你的同事和你自己就越难理解。

因此，Git 临时区域的概念在这种情况下非常有用，它允许您选择特定的文件，甚至是这些文件的一部分，以便下次提交。

这就是暂存区可以为您做的事情，您可以选择单个文件进行提交，甚至可以选择部分文件进行提交，而将其他文件留待将来提交。

所以我们来看一个实际的例子。

在过去的几个小时，甚至几天里，我们已经做了很多改变，比如说 git status。

但是，让我们说，不是所有这些都是关于同一个主题。

因此，让我们坚持版本控制黄金法则，只在一次提交中组合来自相同主题的更改。

你可能已经知道，要包含一个特定的文件，我们可以简单地输入，git add 和文件名。

所以让我们在这里添加 CSS 文件。

瞧，让我们仔细看看另一个文件索引 HTML，看看它目前包含什么变化。

所以我们可以使用 git diff。

我们可以看到目前有两部分或两大块的变化。

假设第一个属于下一个提交主题，但不属于第二个。

让我们将第一部分添加到暂存区，我们可以这样做。

让我在这里退出输出。

我们可以用 git add git add dash p 标志来实现。

p 将我们带到补丁级别，我们希望在补丁级别上决定包括什么和不包括什么。

我们想用索引 HTML 来做到这一点。

所以现在 Git 和我们一起一步一步地完成每一个变化。

它问了我们一个简单的问题。

我们到底要不要将这一大块添加到暂存区？不要担心在那种情况下你能给出的所有其他可能的答案。

我不认识他们。

我想为了我们晚上睡觉。

简单的“为什么”代表“是”，或者“n”代表“否”就足够了。

所以假设这一个实际上是我们想要提交的主题。

假设是的，我们想把它包括进去。

对于第二个问题，这不是同一个话题。

因此，让我们暂时把它放在临时区域之外。

因此，如果我们现在再看一下 git 状态，我们可以看到部分 index HTML 将包含在下一次提交的提交更改中，而其他部分将留待将来提交。

还是那句话，所以 index HTML 列了两次，牛逼。

以一种非常精细的方式制作这样的提交，将帮助您创建一个非常有价值的提交历史，一个易于阅读和理解的历史。

如果你想保持领先，这是至关重要的。

现在让我们谈谈创建完美提交的第二部分。

这提供了很好的承诺信息。

我们将从主题行开始。

所以当然，不同团队的惯例是不同的。

但一般来说，建议是写得非常简洁，如果可能的话，少于 80 个字符。

主题应该是对所发生事情的简要总结。

这里有一个小提示，如果你写的东西短小精悍有困难，那么这可能表明你在提交中放了太多不同的主题，对吧。

因此，让我们转到命令行。

如果我现在输入，那么在下一次提交时，我会对 stage 做一些修改。

如果我输入 git commit，我将得到一个编辑器窗口，可以在其中输入提交消息。

我们将为电子邮件注册编写一些简单的广告捕获。

如果我们在主题后添加一个空行，get 知道我们正在编写消息的主体，并且有空间进行更详细的解释。

这里有几个你今年可能想用提交消息正文回答的问题，现在与以前有什么不同，变化的原因是什么？关于这个提交有什么需要注意的或者特别值得注意的吗？

所以我将在文本编辑器中写下我的版本。

瞧，让我们保存并关闭它。

并且提交完成。

让我们快速查看一下 git log，我们可以看到，这是我们刚刚做的最后一次提交。

这是主题，这是信息的主体。

因此，通过回答这些问题，你帮了你的同事和你未来的自己一个大忙，因为它有助于理解这次修订中到底发生了什么，以及需要注意什么。

让我们谈一谈分支策略。

这是一个重要的话题，因为 Git 让您完全决定如何处理分支。

它只提供工具，但你和你的团队有责任以最佳方式使用它。

这就把我们带到了我们的第一个主题会议。

如果你在一个团队中工作，你需要想出一个关于如何与分支机构合作的清晰约定。

你需要把它写在每个人都能拿到的地方。

你问为什么你的团队需要一个书面约定，因为 Git 允许你创建分支，但是它没有告诉你如何使用，你需要一个书面的最佳实践，关于如何工作或者如何在你的团队中理想地组织工作以避免错误和冲突。

这在很大程度上取决于你的团队和项目团队的规模，以及你如何处理软件的发布。

最后，同样重要的是，它有助于接纳新的团队成员。

当新人加入你的团队时，你可以向他们指出你记录的意愿惯例，他们会很快理解你的团队是如何处理分支的。

当您考虑如何使用分支时，您会自动考虑如何集成变更和结构化发布。

这些话题紧密相连。

帮助你更好地理解你的选择。

让我们稍微简化一下。

我将向您展示如何设计分支工作流的极端版本。

第一个的座右铭是永远集成主线开发。

始终将自己的工作与团队的工作结合起来。

这是这里的座右铭。

这是它看起来的样子。

在这个例子中，我们只有一个分支，每个人都提交他们的提交。

这是一个非常简单的例子，我怀疑现实世界中的任何团队会有如此简单的分支结构。

但是为了说明，这个极端简化的例子有助于我们理解这个模型的优缺点。

因此，在一个总是集成的模型中，你只有很少的分支。

这使得跟踪项目中的事情变得更加容易。

当然，这个模型中的提交也必须相对较小。

这是一个自然的需求，因为在这样一个不断将东西集成到产品代码中的环境中，您不能冒险进行大的臃肿的提交。

这也意味着您必须有一个高质量的测试环境设置。

同样，这个模型的前提是，代码可以很快地集成到你的主线产品代码中。

这意味着你团队中的测试和 QA 标准必须是顶尖的。

如果你没有这个，这个模式就不适合你。

另一个极端是多个不同类型的分支进入舞台。

所以这里树枝被用来完成不同的工作。

新的特性和实验被保存在它们自己的分支中。

发布可以在他们自己的分支中被计划和管理。

甚至开发流程中的不同状态，比如生产开发，也可以用分支来表示。

请记住，这完全取决于您的团队和项目的需要和要求，很难说一种方法比另一种更好。

虽然像这样的模型看起来很复杂，但这主要是一个实践和习惯的问题。

正如我已经说过的，在现实中，大多数团队都在这两个极端之间工作。

现在让我们仔细看看两种主要类型的分支以及它们是如何使用的。

这两种类型的分支是长期运行和短期运行的分支。

所以长期运行的分支和短期运行的分支之间的区别是最广泛的，也是非常有用的。

因此，让我们首先开始讨论长时间运行的分支。

每个 Git 存储库包含至少一个长期运行的分支，通常称为 main 或 master。

但是在你的项目中也可能有其他长期运行的分支，比如开发或生产或登台。

例如，这些分支都有一些共同点，它们存在于项目的整个生命周期中。

我已经提到了这种长时间运行的分支的一个典型例子。

每个项目都有一个主线分支，如 master 或 main。

另一种类型的长期运行分支被称为集成分支，通常被称为开发分支或阶段分支。

通常，这些分支代表项目发布或部署过程中的状态。

如果您的代码经历不同的状态，例如，从开发到登台再到生产，那么将分支中的结构镜像到。

最后，许多团队有一个与长期运行的分支相联系的惯例。

通常提交永远不会直接添加到这些分支中。

提交应该只通过集成进入长期运行的分支。

换句话说，通过合并或重定基数。

这样的规则有几个原因。

一个与质量有关。

例如，您不希望将未经测试和审查的代码添加到您的生产环境中。

这就是为什么代码在最终进入生产之前应该经过不同状态的测试和审查。

另一个原因可能是发布捆绑和计划，你可能想要批量发布新的代码，甚至是完全计划好的。

如果没有这样的规则。

当代码被直接提交到像 main 这样的长时间运行的分支时，监视发布的内容变得非常困难。

另一种分支是短命分支。

与长时间运行的分支相反，它们是为某些目的而创建的，然后在集成后被删除。

有许多不同的原因来创建短的活分支。

例如，当你开始着手一项新功能、一个错误修复或重构或一个实验时。

并且通常短期分支将基于长期运行的分支。

例如，当您开始一个新的特性时，您可能会将新的特性基于您长期运行的 main 分支，并且在提交和完成您的工作之后，您可能希望将它重新集成到 main 中。

在你安全地合并或重置它之后，你的特征分支可以被删除。

我已经说过，分支策略对于每个团队和项目都是不同的。

这很大程度上取决于你的偏好、团队规模或项目类型。

但是我想给你介绍两种非常流行的分支策略，并把它们作为你个人分支策略的灵感。

先说 GitHub 流量。

GitHub 提倡一种极其精简和简单的工作流程。

它只有一个长时间运行的分支，默认的主分支，你正在积极工作的任何事情都是在一个单独的分支，一个短的左分支中完成的，不管那是一个功能，一个 bug 修复，还是一个分解。

这是一个非常简单、非常精简的设置。

另一个非常流行的模型叫做 Git flow。

这提供了更多的结构，但也有更多的规则可循。

所以主分支是当前生产状态的反映。

另一个长期运行的分支通常被称为“开发”,从这个分支开始，将被合并回这个分支。

开发也是任何新版本的起点，你将打开一个新的发布分支，你的测试将任何错误修正提交到那个发布分支。

一旦您确信它已经准备好投入生产，您将它合并回 main，然后您将为该发布添加一个标记，在 Main 上提交，并关闭发布分支。

正如您所看到的，好的流程定义了流程中相当多的任务和步骤。

在我们制作的优秀桌面 GUI tower 中，我们通过在应用程序中提供这些任务作为快捷方式来支持用户。

这样我就可以在这里展示给你，这样你就拥有了 Git flow 带给你的所有最重要的动作。

所以你不需要记住所有的细节，你要做什么，接下来要做什么，化妆，这些不同的步骤。

所以如果你问不同的团队，他们是如何使用分支的，你会得到很多不同的答案。

没有人人都应该采用的完美分支模型。

它更多的是关于理解你的项目，你的发布工作流和你的团队，然后建模一个分支工作流，以最好的方式支持你。

我们来谈谈拉取请求。

首先，你需要明白拉请求并不是一个核心的好特性。

它们是由你的 Git 托管平台提供的，这意味着它们在 GitHub、git lab、Bitbucket、Azure DevOps 或你正在使用的任何东西上的工作和外观都有所不同。

但是基本原理和思路都是一样的。

让我们从谈论你为什么想要使用拉请求开始。

本质上，它们是一种交流代码和审查代码的方式。

最完美的例子是，当你完成了一个特性的工作，没有一个拉请求，你可以简单地将你的代码合并到 main master 或者其他分支中。

在某些情况下，这可能完全没问题。

但是特别是当您的更改稍微复杂一点或者稍微重要一点的时候，您可能希望有第二双眼睛来检查您的代码。

这正是提出拉取请求的目的。

通过拉式请求，您可以邀请其他人来检查您的工作并向您提供反馈。

在关于代码的一些对话之后，您的评审者可能会批准拉请求，并将其合并到另一个分支中。

除此之外，拉请求还有另一个重要的用例。

这是一种向存储库贡献代码的方式，你没有权利去想一个流行的开源存储库，你可能有一个改进的想法，但你不是主要贡献者之一，你不允许向他们的存储库提交代码。

这是拉请求的另一个用例。

我们还必须讨论一下 fork，在这个连接中，fork 是你的 git 库的个人副本。

回到我们的开源例子，你可以派生出原始的库。

在您的分叉版本中进行更改，并打开一个 pull 请求，将这些更改包含到原始存储库中。

主要贡献者之一可以检查您的更改并决定是否包含它们。

我已经提过了。

每个好的平台都有自己的设计和对拉请求应该如何工作的理解。

它们在 GitHub、git lab Bitbucket 或 Azure DevOps 上看起来有点不同，或者你正在使用的任何东西。

这是一个我们将使用 GitHub 接口的例子。

对于这个测试用例，让我们使用 Ruby on Rails 开源库。

好了，现在我们在 GitHub 上，在 Ruby on Rails 的主存储库上。

在右上角，我可以分支这个存储库，这样我就可以创建我自己的个人版本的存储库。

它是基于代码的。

再次提醒一下我们为什么要这么做，我没有权限将代码放入 Ruby on Rails，放入 Ruby on Rails 库。

当然，这是有充分理由的，因为我不是 Ruby on Rails 专家。

但是在我自己的 fork 存储库中，我可以进行更改，我可以进行任何我想要的更改。

所以我就这样做了，我分叉了存储库。

我现在可以简单地克隆，我将获得克隆 URL，然后在命令行上，git 克隆和远程 URL。

克隆完成后，我们将立即创建一个分支并进行一些更改。

因此，理解拉请求总是基于分支，而不是基于单个提交也很重要。

因此，我们正在创建一个新的分支，稍后我们会请求将其包含在内。

让我们进入 rails，在我的编辑器中打开它。

我将创建一个简短的分支 git 分支测试和 git 检验测试。

好了，我现在在一个新的分支上，可以做一个愚蠢的小改变，让我们在自述文件中做些改变。

这是一个，一个很棒的网络应用框架，关闭它。

好吧，让我们看看我们的变化。

git 添加 README 和 git 提交 dash m 愚蠢的小变化。

所以我们现在在一个单独的分支上做了一些小的改变，我们可以把这个分支推到我们自己的远程仓库，我们的分支，所以 git push set upstream origin tests test。

一旦有了这个，好的，这就成功了。

因此，我们现在已经创建了我们可以请求包含的变更。

一旦我将它们推送到我在 GitHub 上的远程存储库，我就可以在浏览器中再次查看存储库，看看发生了什么。

瞧，GitHub 已经注意到我刚刚在这里推了一些东西。

由于它是分叉库的一个分支，GitHub 检测到了我的更改，并自动询问我是否要用这些更改创建一个 pull 请求。

因为在分叉的环境里，这多半是你想做的。

如果我这样做了，我可以建议他们应该整合到哪个分支。

因此，我将在这里启动拉请求流程。

所以现在，我打算将我在 fork 中的小分支的更改集成回 Rails 中的主分支，假设这没问题。

我可以补充一些意见。

然后我可以创建 pull 请求，原始存储库的维护者会得到通知，他们可以检查我的更改，并可能集成它们。

合并冲突，没有人喜欢它们，但是当你使用 Git 时，它们是生活中的事实。

而且在大多数情况下，它们并没有我们通常认为的那么悲惨。

哦，我们将讨论它们何时发生，它们实际上是什么以及如何解决它们。

好吧，名字已经说明了这一点。

合并。

当您的合并更改来自不同的源时，集成时可能会发生冲突。

但是请记住，集成不仅限于合并分支。

冲突也可能发生在重定基础交互式重定基础时，在执行精选或拉取时，甚至在重新应用存储时，所有这些操作都执行了某种集成，这时，冲突可能发生。

当然，感谢上帝，这些行为并不会每次都导致合并冲突。

但是当冲突发生时，合并功能是它最大的特点和优势之一。

合并分支在大多数时候毫不费力，因为 Git 通常能够自己解决问题。

但是也有矛盾的变化。

这就是技术无法决定什么是对什么是错的时候。

这些情况需要人类做出决定。

真正经典的情况是，完全相同的代码行被更改为两个不同分支上的提交。

Git 无法知道您更喜欢哪种变化。

还有一些不太常见的类似情况，例如，当一个文件在一个分支中被修改，而在另一个分支中被删除。

但同样的，但问题是总是同样的变化，当你使用桌面 GUI 工作时，像 tower forget，这可以使事情变得更容易，特别是因为它更直观，我可以在这里选择东西。

这有助于我了解实际发生了什么，我可以看到这两个变化之间的冲突，我可以选择一个或两个，或者就在今年，很容易地解决冲突。

你如何知道冲突何时发生？不要担心，当发生冲突时，get 会非常清楚地告诉您。

首先，它会让您立即了解情况，例如，当合并或重置因冲突而失败时。

所以让我们试试这个。

其实我们这里有事，来挑起合并冲突吧。

我会试着将开发人员合并到我的主分支中。

瞧，我自然而然地发现这里有问题。

冲突冲突冲突，自动合并失败。

所以你可以看到，当我试图执行合并时，我遇到了冲突，get 立即告诉了我这个问题。

但是即使我忽略了这些警告消息，我也会在下次运行 git status 时发现这个冲突。

让我们开始吧。

很快，你就有了这个未合并的路径类别。

换句话说，不要担心没有注意到，合并冲突确保你不能忽略它们。

好吧，嗯，虽然你不能忽视合并冲突，但你真的必须在继续工作之前解决它。

处理合并冲突并不意味着你必须解决它，你也可以撤销它。

这有时很有帮助。

因此，请始终记住这一点，您总是可以撤消合并冲突并返回到之前的状态。

这是真的，即使你已经开始解决一些冲突的文件，你注意到哦，上帝，我，我在错误的轨道上。

即使这样，当你发现自己走进了死胡同，你仍然可以撤销合并。

有些命令带有中止选项，可以让您这样做。

所以最突出的例子是 Git 合并、优步中止和 Git rebase 中止。

在我们的例子中，当我发现为什么我现在没有时间处理这个问题，或者我用错误的方式解决了一些问题，我总是可以在这里输入 Git merge dash dash abort，然后状态显示我又恢复正常了。

因此，这应该给你信心，你真的不能搞砸，你可以随时上船，回到干净的状态，并再次尝试重新开始。

所以让我们看看什么是真正的冲突，我们将揭开这些小家伙的神秘面纱。

并且，同时，帮你失去对他们的尊重，获得一点点自信。

作为一个例子，让我们看看其中一个冲突文件的内容。

我将再次引发合并冲突，我可以看到在我的索引 HTML 文件中，我有一个冲突。

让我们来看看这个。

不，不是这个。

但是这个。

所以 get 很友好地标记了文件中有问题的区域。

所以它们被这些符号包围着。

这是问题区域的开始，这是问题区域的结束。

因此，在第一个标记之后出现的内容，最初来自我们当前的工作分支，然后与一些等号线对齐，将两个冲突的更改分开。

最后，今年来自另一个展示的分支。

所以在这种情况下，很简单。

在我做了一些更改的 develop 分支中，我删除了这个列表项，这些列表项，在我的 head 分支中，我更改了它们。

所以 Git 不确定，你想改变它们吗？像这样吗？还是你想删除它们？像这里吗？我必须告诉 git，什么是正确的，什么是错误的。

好，那么你如何解决冲突，解决冲突实际上很简单，我们需要清理这些线。

在我们完成之后，文件应该看起来和我们想要的完全一样。

因此，可能有必要与编写其他更改的队友交流，并决定哪个代码实际上是正确的，也许是我们的，也许是他们的，也许是两者的混合。

这个清理文件的过程，确保它包含我们真正想要的东西。

这不需要任何魔法，你只需要打开你的文本编辑器或者 ID，做一些修改就可以了。

不过，有时你会发现这不是最有效的方法，这时专用工具可以节省你一点时间和精力。

因此，一方面，有好的桌面 gooeys。

一些图形用户界面在解决冲突时会很有帮助，你已经看到过一个了。

这是一座塔，在这里你可以看到在冲突中发生了什么。

这就把问题形象化了。

另一方面，有专门的合并工具。

对于更复杂的冲突，手边有一个专用的不同的合并工具是很好的，您可以使用 Git config 命令配置一个工具。

如果发生冲突，你可以简单地输入 Git 合并工具，让它打开冲突，我在 Mac 上安装了一个万花筒应用程序。

所以让我们试试这个 Git 合并工具。

我配置的。

所以第一个，如你所见，很简单，或者第二个，错误 HTML 被删除了。

所以我不需要看到我只需要决定，我要保留它还是删除它。

所以我还是坚持删除。

对于第二个，文件中确实有内容，打开我配置的合并工具是有意义的，我可以看到，这是我所做的更改。

这是来自另一个人或不同分支的变化。

我想看起来像什么，我想看起来像什么，我可以选择这些变化，或者这些年，或者我可以在这里做我自己的改变。

因此，在清理完文件后，无论是手动还是在桌面上，使用 GUI 或合并工具，我们都必须像其他任何更改一样提交它。

所以我可以把它保存在这里，说这个问题已经解决了。

如果我键入 git status，我可以看到这些更改将被提交，我在 index HTML 中做了一些更改，这只是一个安全副本，您也可以配置它。

因此，您可以随时返回到原始文件。

但实际上我会在这里提交。

简单地通过提交已解决的文件，我发出信号表示冲突已完成。

我可以继续我的工作。

大多数开发人员都明白在 git 中使用分支的重要性，因为为您的工作使用单独的容器非常有帮助。

让我们谈一谈关于集成分支，关于把你的新代码放回一个现有的分支。

有不同的方法可以做到这一点，两个最常见的是合并和 rebase。

让我们从谈论合并和它实际上是如何工作的开始。

当 Git 执行合并时，它会寻找三次提交。

首先是共同祖先提交。

如果您跟踪一个项目中两个分支的历史，它们总是至少有一个共同的提交。

此时，两个分支有相同的内容。

从那以后，它们进化得不同了。

其他有趣的提交是每个分支的端点。

记住，集成的目标是合并两个分支的当前状态。

所以最新的修订当然很重要。

结合这三个提交，将执行我们的目标集成。

我在这里选择了一个非常简单的例子，因为两个分支中的一个是分支 a，它在分支发生后没有接收到任何新的提交。

所以它的最新提交也是共同的祖先。

在这种情况下，集成非常简单，只需在公共祖先提交的基础上添加来自分支 B 的所有新提交即可。

最简单的整合形式叫做快速向前合并。

两个分支共享完全相同的历史。

然而，在大多数情况下，这两个分支的前进方向当然是不同的。

为了进行集成，很好，我们必须创建一个包含它们之间差异的新提交。

这就是我们所说的合并提交。

通常，提交是由人在某个有意义的单元仔细创建的，该单元只包装提交消息中的相关更改，提供上下文和注释。

现在，合并提交有点不同。

它不是由开发人员创建的，而是由 Git 自动创建的。

并且它也没有包装一组相关的变更。

它的目的是像一个结一样连接两个分支。

如果您想在事后理解合并操作，您需要查看两个分支的历史和它们的提交历史。

现在我们来谈谈 rebase。

但是在我们开始之前，让我强调一下 rebase 并不比 merge 更好或更差。

最重要的是，不一样。

只要用 merge 就能过上幸福美好的生活。

但是 rebase 有它的优点和缺点。

所以知道它做什么，什么时候会有帮助是很好的。

好的，记住我们刚刚谈到的自动合并提交，有些人更喜欢没有这些，他们希望项目历史看起来像一条直线，没有任何科学证明它已经在某个点被分成多个分支，甚至在分支被集成之后。

这就是 rebase 的情况。

让我们一步一步地走一遍 rebase 操作。

场景与前面的例子相同，我们希望将分支 B 中的变更集成到分支 a 中。

但是现在通过使用 rebase。

启动这个的实际 Git 命令非常简单。

只是 Git rebase 和分支。

类似于 git 合并，我们只是告诉 Git，我们要整合哪个分支。

但是让我们来看看幕后。

首先，git 将删除分支 a 上在公共祖先提交之后发生的所有提交。

但是不要担心，我不会扔掉它们，你可以把这些提交看作是暂时保存在某个地方。

然后 get 应用于来自分支 b 的新提交。

暂时来说，这两个分支看起来完全一样。

但在最后一步，需要包含那些暂停的提交，来自分支 a 的新提交，它们位于来自分支 B 的集成提交之上，正如您所看到的，它们被重新调整，结果看起来像是以直线方式进行开发，没有包含所有组合更改的合并提交，我们保留了原始提交结构。

关于 rebase，还有一件重要的事情需要理解，它重写了提交历史。

所以仔细看看最后这张图。

提交 C3 有一个星号，它和 C3 有相同的内容，但是它实际上是一个不同的提交。

因为它现在在重定基础之前有了一个新的父对象。

看，一个是它的父母。

在重定基础之后，它被重定基础到提交的 C 只有少数重要属性，比如作者日期变更集和它的父提交是谁。

并且如果有效地创建了全新的提交并且具有新的提交散列，则改变该信息的任何内容。

所以我们写历史，就像这对于还没有发布或推送的提交来说不是问题。

但是如果您正在重写已经被推送到远程存储库的提交，您可能会有麻烦。

因为另一个开发人员可能将他们的工作建立在最初的 c 提交的基础上，现在已经不存在了。

所以让我们用一个简单的规则来结束这个话题。

不要重写已经推送到共享存储库的提交。

像 rebase 这样的工具，你应该只使用它们来清理你的本地提交历史。

例如，对于一个你已经工作了一段时间的特性分支，在你把它集成回一个团队分支之前，那么你就要在此基础上使用 re，这就是 rebase 中这些工具的用途。

好了，今天就到这里。

一定要看看我的小高级 Git 工具包。

完全免费。

这是一个关于很多高级 Git 主题的小视频集，从交互式 rebase，一直到分支策略，合并冲突，子模块等等。

如果你想用 Git 和版本控制变得更有效率，这真的很有帮助。

再说一次，这是免费的。

更右？玩得开心点，我们很快会在免费代码营 YouTube 频道上再见。