# 为什么编译器是你最好的朋友

> 原文：<https://www.freecodecamp.org/news/why-the-compiler-is-your-best-friend-f165329cb20a/>

在项目之间，我花时间研究大型游戏团队中高成本 bug 的根本原因。这些发现让我们质疑基本的 C++语言特性和模式。这篇文章从技术领导的角度讲述了混淆问题。这些想法的背景研究在[“如何编写更少的 bug”](https://medium.freecodecamp.org/how-to-write-fewer-bugs-tips-for-game-developers-82e3d742f6f7)中有所涉及。

### 编码原则

你的团队的编码标准是什么样的？也许他们是基于一个共同的或开放的标准？也许他们定义 camelCase 变量名是为了可读性？也许他们为了维护而定义了源代码去格式化？也许这些都不重要？它们真的有帮助吗？你是 bug 少还是误会少？你的编码标准可能勾选了你所有的 OCD 编码框，但是它们真的能以一种明显更好的方式帮助团队运作吗？

当我为 Onrush 编写编码标准时，我们有一张白纸。无需担心之前的代码。该标准没有包括任何关于我们的括号应该在哪里的内容。没有关于 camelCase 或下划线命名约定。没有关于文档格式的内容。事实上，我们甚至没有称之为编码标准。我们坐下来讨论我们在代码中真正关心的是什么。我们想要更高的质量。对我们和我们的游戏来说，这意味着更多的迭代时间，更少的修正时间。更高的性能和更低的错误数。

> 我们写了我们的**编码原则**。*我们最关心的编码原则。*

编码原则包含这样的陈述:编译时间和链接时间是代码质量的函数。写断言的代码，而不是防御的代码。超载是混淆。命名函数和类，使高级代码读起来像伪代码。给定的可读代码文档在很大程度上是无用的。记录概念、想法和推理，不记录代码。编译器是验证假设的工具。

我们允许人们拥有自己的编码风格，只要它不违背任何编码原则。这就产生了一个在功能上高度统一，在风格上非常灵活的代码库。这种灵活的造型并不重要。这不会影响可读性或理解，因为核心原则支撑着一切。

如果没试过，就别写物理::模拟了。Update(dt)并开始编写 updatethephysicsimulationforthistimestep(dt)。当我开始编写描述性的函数名时，我开始考虑数据和应用的转换。前者是笨拙的面向对象的。后者是选择描述操作的函数名和描述信息的数据名。以清晰描述功能操作的高级代码为目标。这清楚地显示了数据依赖性。以不需要文档的高级代码为目标。

### 编译器是验证假设的工具

在编写 C++代码时，编译器是我最好的朋友。她仔细检查每一行代码。她把我的想法编码成可执行代码。她向我展示了我的假设和误解。她展示了我人性的缺点。但是，编译器不是读心术。她没有特异功能。只有不懈的努力才能产生正确的代码。

编译器应用 C++语言的严格规则来验证我的代码的正确性。虽然在这方面 C++语言并不精确。C++有很多不精确的地方。很多方法要求编译器做假设。如果说这些年来我学到了一件事，那就是:做假设总是会给你带来麻烦。

随着 C++继续成长，膨胀到矮星的大小，很容易忽略基本原理。这些基本的编程概念对你的团队有利还是不利？下面的例子和注释是专门针对 C++的，但也适用于许多现代语言。

### <true>多态性的成本</true>

所以让我们从多态性开始说起。1983 年引入，当时“带类的 C”被重命名为 C++。多态性允许许多函数或方法具有相同的名称。编译器将使用参数类型选择正确的函数。然而，这里有一个基本问题。什么时候不同的东西有相同的名字是好的？

考虑这个典型的 C++ 101 例子，其中我们有 FileWrite 函数或方法的变体。

```
// Simple polymorphic file write functions for int, short and char 

bool FileWrite(int i);
bool FileWrite(short f);
bool FileWrite(char c);
```

这似乎很方便。我只要用任何类型调用 FileWrite，编译器就会把它整理出来。编译器对代码有很好的了解，会选择编译所需的函数而不会出错。该过程是确定性的和万无一失的。

可惜没有。编译器可能对代码了如指掌，但对意图却一无所知。我告诉编译器，假设我输入的代码正确地实现了我的意图。现在我知道了一个事实，我并不总是正确的，20 年的编程生涯教会了我这一点。由于这种便利，我失去了一个让编译器在我的代码中发现错误的重要机会，这将最终导致一个难以发现的运行时错误。

作为技术总监或技术负责人，我主要关心的是让编程团队高效地合作。团队越大，这个问题就越难解决。下面是使用上面简单代码的典型开发情况。

```
// Simple example structure with three int members.

struct Brain 
{
 int humor;
 int intelligence;
 int empathy;
}
```

ai_brain.cpp:

```
 // Example usecase using polymorphic file functions 

void SaveGame(Brain& brain) 
{
  FileWrite(brain.humor);
  FileWrite(brain.intelligence);
  FileWrite(brain.empathy);
}

void LoadGame(Brain& brain) 
{
  FileRead(brain.humor);
  FileRead(brain.intelligence);
  FileRead(brain.empathy);
}
```

好吧还是 C++ 101。在编程团队中，汤姆致力于人工智能，杰里致力于拯救游戏。团队中的每个人都在忙于下一个里程碑的构建。在加载阶段，游戏突然崩溃，团队 a 被阻塞。里程碑即将到来，每个人都期待杰里修复崩溃。

问题是 Jerry 今天没有提交代码。杰瑞开始调查这个问题。源代码管理显示，今天没有对保存的游戏模块文件进行任何更改。调试器在拾取代码中显示崩溃。对 SCM 的另一次搜索显示，拾取模块今天没有变化。保存的游戏数据的输入文件流似乎已损坏。杰里叹了口气，喝了一口咖啡，继续调查。

过了一段时间，杰瑞发现了导致人工智能代码出现问题的变化，并去找汤姆谈话。

```
// Breaking changes causing **action at a distance**

struct Brain 
{
<< old
  int humor;
  int intelligence;
  int empathy;
>>> new
  short humor;
  short intelligence;
  short empathy;
=====
}
```

杰里向汤姆解释说，上述变化导致游戏崩溃创建皮卡！成员大小的更改导致输入流不对齐。由于坏数据导致致命错误的第一个代码是拾取模块。

事实证明，汤姆确实在加载阶段遇到过一次崩溃。汤姆删除了保存游戏和离开时的错误。由于 Tom 没有在加载代码附近工作，他认为这是一个预先存在的错误，并继续工作。Tom 在提交之前全面测试了他的代码，所有测试都通过了。

### 如何避免这种情况？

> 多态支持代码中的“远距离操作”。

在上面的简单例子中，编译器开始在 LoadGame 和 SaveGame 函数中生成不同的可执行代码。LoadGame 和 SaveGame 函数中的代码没有改变。保存游戏模块中的代码没有任何改变。AI 模块中的代码更改导致 LoadGame 函数中的代码具有不同的含义。然后编译器悄悄地编译新的 LoadGame 并保存游戏代码，没有错误。代码在技术上是正确的，但不再满足最初的意图。

考虑这个选择。

```
// Strong naming and type safe file write functions

bool FileWriteInt(int i);
bool FileWriteShort(float s);
bool FileWriteChar(char c);
```

```
// Example usecase using strong name and typesafe functions

void SaveGame(Brain& brain) 
{
  FileWriteInt(brain.humor);
  FileWriteInt(brain.intelligence);
  FileWriteInt(brain.empathy);
}
```

在本例中，要写入的数据由代码明确定义。编译器不需要填写任何假设。如果传递给函数的类型不正确，编译器将生成一个错误。

> 我们已经将一个间歇性的数据相关运行时错误变成了一个 100%可重复的编译时错误。

现在让我们用新代码重新评估我们的场景。Tom 对 ai/brain.h 进行了更改，但代码无法编译。汤姆很快就意识到是他的修改导致了这个错误。Tom 能够在提交更改之前修复代码。编译器现在在编译时发现错误，而不是 QA 或团队在以后发现错误。

你可能会问为什么这是一个问题？这值得一个解释。

### 规模

作为我自己项目中的一个单独的开发人员，我对我的代码有着彻底而深入的了解。我可以低成本测试迭代。这个简单的多态例子显示了很低的错误成本带来的便利。

我的游戏开发职业生涯是在大型团队中度过的。当我在大学时，我的讲师教授面向对象程序设计、多态性和其他聪明的编程技巧。

当我还是初级程序员的时候，我会写一个像上面这样的重载方法。这些技巧对我很有用，我将在我的代码中使用它们。作为一名高级程序员，我开始对代码中的错误负责。我更清楚维护代码的时间成本。

作为技术负责人，我要对别人代码中的 bug 负责。我参与规划其他人的工作和时间估计，以使我的团队做到最好。作为技术总监，我要对整个编程团队的效率负责。我希望团队生产功能，而不是修复错误。

在一个由 25、50、100 或更多程序员组成的大型游戏开发团队中，对整个代码库的了解会有所不同。我对我的代码了如指掌。我对代码的其余部分有不同程度的了解，或者更确切地说，是不确定性。在一个大型的编程团队中，我必须尽我所知编写假设的代码。在一个更大的项目中，我会犯比我个人项目更多的错误，这些错误的代价也会更高。

在汤姆和杰瑞的例子中，杰瑞选择多态重载使得汤姆很容易引入 bug。这个 bug 让一半以上的开发团队无法工作近 4 个小时。在一个 100 名开发人员的团队中，这大约是 200 小时的工作损失。相当于一个人全职工作 5 周！多态性节省少量开发人员工作的便利性与远处*动作的影响完全不成比例*可能引入的错误。

很明显，错误在于 Jerry 制作了一个很有可能被错误使用的界面。当汤姆提交他的修改时，所有的测试都通过了。Tom 已经完成了一定量的测试，并有其他任务要继续。汤姆掉进了洞里，他没有挖洞。

### 范围和命名空间

名称空间是在 1990 年出版的《带注释的 C++参考手册》中引入的。尽管直到 1995 年左右才被广泛实施。

以前，程序中所有命名的对象都是全局唯一的。这导致了在不同项目之间共享代码的问题。如果共享代码中的名称与宿主应用程序冲突，那么必须对某些内容进行重命名。在大型项目中，这可能会对时间产生重大影响。

从外部库限定应用程序范围的名称空间是完全有效的，也是明智的开发选择。

然而，程序员倾向于在项目代码库中使用过多的命名空间。

> 在项目中，命名空间支持这两种功能

> —同一对象的多个名称。

> —多个同名的对象。

我所说的项目代码库具体指的是团队为项目输入的代码。没有任何第三方库或来自同一公司其他不同团队的代码。

同一个对象有多个别名会增加代码的可读性。多个同名对象会增加假设。我们再次要求编译器假设意图并选择“正确的”函数或变量。同样，随着团队规模的增长，假设导致错误的概率也会增加，在大型团队中，失败的成本可能会很高。

过多名称空间的模式很容易陷入。STL 和 Boot 等流行库的命名空间很大。这些项目的命名空间很大，因为实际上它们是单个库中的微型项目的集合。在这些情况下，名称空间被用来隔离来自不同贡献者的代码，重构全局名称会不必要地难以协调。

然而，这种模式非常普遍，以至于开发人员经常在自己的代码中复制它。当编写新代码时，确保惟一的名字很容易，编译器会立即告诉你有问题。在团队的代码库中，独特的命名是好的，因为它避免了假设。在团队自己的代码中使用名称空间会产生可避免的假设。这使得编译器能够选择*正确的*类、函数或变量，但是具有错误的意图/结果。

> math::fast::fpow(2，10)

> math::emulation::fpow(2，10)

当使用名称空间时，有多种方法引用函数，并且可能有几个函数具有相同的名称。

> fpow(2，10)

在读取代码时，程序员需要假设作者打算调用哪个特定的 fpow()函数，编译器实际上会选择哪个特定的 fpow()函数。如果生成的代码与意图不符，将不会出现编译时错误。这些错误需要在运行时被发现。

这就增加了认知负荷。我现在需要在头脑中跟踪应用于任何给定代码块的当前名称空间。对于大型团队和大型代码库来说，这是一个不能很好扩展的问题。

> MathEmuFpow(2，10)

> MathFastFpow(2，10)

只有一种方法来引用这些 Fpow 函数。无论我在代码中的什么位置，这些函数总是有相同的惟一名称。通过减少程序员的认知负担，这使得代码更容易阅读和理解。我知道作者的意图，也知道编译器将生成的代码。

名称空间有有效的*用例*来包含外部代码，您不需要修改这些代码，而且在许多情况下也不能修改。因此，我将总是把我的项目放在一个包含名称空间。这是对将来可能需要使用这些代码的其他团队和程序员的一种礼遇。在项目中，命名空间支持糟糕的命名和假设，应该谨慎使用。

### 汽车

C++11 标准引入了 auto 以及许多其他方便的特性。不幸的是，auto 是另一个编译器假设特性，它告诉编译器假设我写的代码是正确的。编译器现在必须选择允许代码编译的任何类型。问题是，我还是会犯错。

Auto 解决了多态函数的上述问题，并将其应用于变量。对于多态函数，编译器只能在名称匹配的函数之间进行选择。使用 auto 会要求编译器选择任何类型来编译代码！

> Auto 允许您在不理解数据类型的情况下编写代码。

> 自动启用变量的远距离操作。

我听到的在 C++中使用 auto 的最常见原因是为了使代码更简单、更易读。长而复杂的 STL 类型名通常被作为使用 auto 的理由。将 typedef 长 STL 类型名转换成方便的简写名称是很常见的。为什么不跳过这一步，使用自动呢？

简化代码作为一个支持论点是有缺陷的。复杂总是导致更多的复杂。如果另一个系统很复杂，很难理解，那么使用 auto 并不能消除这种复杂性。使用 auto 是通过简单的假设来掩盖复杂性。(解决 API 泄漏复杂性的唯一方法是重构 API。)

如果我**不**知道汽车将解决的类型，那么我没有考虑所有可能的故障情况。如果我**确实**知道 auto 将解析的类型，那么我应该使用那个类型。使用特定类型可以更好地编码我的意图。如果编译器给我一个错误，那么我就知道我对所用类型的假设是不正确的。使用特定类型还可以保护代码免受以后的重构和远程操作的影响。

在个人项目中使用 auto 的成本大概是零。在大型开发团队中使用 auto 的成本可能很大，并且与收益不成比例。

### 编译器是我的朋友

编译器是我的朋友和盟友，在开发过程中维护我的假设。根据定义，编译器发现的错误必须在提交更改之前修复。

> 通过将我的代码设计成在使用不当时产生编译器错误，我正在帮助我团队中的其他程序员。

这符合我们程序员的工作方式。我键入一些代码，然后在一个短而快的迭代循环中点击 compile。我甚至可能会使用一个 IDE，它会在我打字的时候不断地在后台编译。如果编译器在输入后很快发现了我的错误，那么修复的成本几乎为零。

大型游戏开发团队扩大了 bug 的影响。如果一个数百人的团队无法工作，那么开发时间就会以一种非常可怕的速度流失。大型游戏开发项目通常会有大型 QA 团队来寻找 bug。一旦缺陷被提交到构建中，这就给缺陷发现、修复和验证带来了显著的时间延迟和成本。

作为一名技术总监，我必须为多态函数、名称空间、auto 和其他基本语言便利功能的简写便利性付出代价。将此与未经检查的假设产生的额外错误的影响和成本进行比较。

在大学里，我被告知编译器是一种将源代码翻译成可执行机器代码的工具。在我的编程生涯中，很长一段时间我都专注于技术和优化。我以为我知道如何使用编译器生成最好的代码，但是我忽略了更大的画面。

编写使用编译器来验证作者意图的源代码与生成最佳可执行代码一样重要。

> 编译器实际上是一个将意图转化为可执行的机器代码的工具。

![1*C9CScad4P6wtLj8H_3AhqA](img/5330504218aa477c4302e7a7c172c604.png)