# 理解数据库伸缩模式的指南

> 原文：<https://www.freecodecamp.org/news/understanding-database-scaling-patterns/>

网上有很多描述数据库可伸缩性模式的文章，但它们大多是零散的文章——只是随意定义的技术，没有太多的上下文。我发现它们不是以一步一步的方式定义的，也没有讨论什么时候选择哪个缩放选项，哪些缩放选项在实践中是可行的，以及为什么。

因此，我打算在以后的文章中详细讨论一些技术。首先，我觉得如果我以自己的方式讨论一步一步的技术，并结合一些背景会更好。本文是一篇高水平的文章——我不会在这里详细讨论缩放技术，但会提供一个概述。所以让我们开始吧。

### 案例研究

假设你已经建立了一家提供廉价拼车服务的初创公司。最初，当你开始时，你的目标是一个城市，在你最初的广告后，几乎没有几十个客户。

您将所有客户、旅行、位置、预订数据和客户旅行历史记录保存在同一个数据库中，或者很可能保存在一台物理机器中。由于您的应用程序非常新，因此没有花哨的缓存或大数据管道来解决问题。这对于您目前的用例来说是完美的，因为很少有客户，例如，您的系统很难在 5 分钟内预订一次行程。

但随着时间的推移，越来越多的人开始在你的系统中注册，因为你是市场上最便宜的服务，这要归功于你的推广和广告。你开始预订，比方说，每分钟 10 个，慢慢地这个数字增加到每分钟 20，30 个。

此时，您意识到系统开始表现不佳:API 延迟增加了很多，一些事务死锁或饥饿并最终失败。您的应用程序需要更多时间来响应，导致客户不满。你能做什么来解决这个问题？

## 模式 1 -查询优化和连接池实现:

想到的第一个解决方案是缓存经常使用非动态数据，如预订历史、支付历史、用户配置文件等。但是在这种应用层缓存之后，您无法解决 API 公开动态数据的延迟问题，例如给定客户的当前司机位置或最近的出租车，或者旅行开始后某个时刻的当前旅行成本。

您发现您的数据库很可能是高度规范化的，因此为了反规范化，您在频繁使用的表中引入了一些冗余列(这些列经常出现在查询的`WHERE`或`JOIN ON`子句中)。这减少了连接查询，将一个大查询分解成多个小查询，并在应用层将它们的结果相加。

您可以做的另一个并行优化是调整数据库连接。几乎所有的编程语言都提供数据库客户端库和外部库。您可以使用连接池库来缓存数据库连接，或者可以在数据库管理系统本身中配置连接池大小。

创建任何网络连接都是昂贵的，因为它需要客户机和服务器之间的一些来回通信。连接池可以帮助您优化连接数。连接池库可以帮助您多路复用连接—多个应用程序线程可以使用同一个数据库连接。我将在以后的单独文章中详细解释连接池。

您测量了 API 的延迟&发现延迟可能减少了 20–50%或更多。在这个时间点上，这是很好的优化。

现在，你已经将业务扩展到了一个城市，有更多的客户注册，你开始慢慢地做到每分钟 80-100 个预订。您的系统无法处理这种规模。您再次看到 API 延迟增加了，数据库层放弃了，但是这一次，查询优化没有给您带来任何显著的性能提升。您检查系统指标，发现磁盘空间几乎已满，CPU 80%的时间都很忙，RAM 很快就填满了。

## 模式 2 -垂直扩展或向上扩展:

在检查了所有系统指标之后，您知道除了升级系统的硬件之外，没有其他简单的解决方案。您将 RAM 大小升级 2 倍，将磁盘空间升级 3 倍或更多。这被称为垂直扩展或纵向扩展您的系统。您通知您的基础架构团队或 devops 团队或第三方数据中心代理升级您的机器。

****但是如何设置机器进行垂直缩放呢？****

你分配一台更大的机器。一种方法是不从旧机器手动迁移数据，而是将新机器设置为现有机器的`replica`(`primary`)——进行临时的`primary replica`配置。让复制自然发生。一旦复制完成，[将新机器提升为主机器](https://blog.pythian.com/mysql-recipes-promoting-a-slave-to-master-or-changing-masters/?source=post_page---------------------------)使旧机器离线。因为预计较大的机器将服务于所有请求，所以所有读/写都将在该机器上进行。

酷毙了。您的系统再次启动并运行，性能得到提升。

你的业务做得非常好&你决定扩展到另外 3 个城市——你现在总共在 5 个城市运营。流量是以前的 3 倍，预计每分钟约有 300 个预订。甚至在达到这个预定目标之前，您又遇到了性能危机，数据库索引大小在内存中大量增加，它需要不断维护，使用索引的表扫描比以往任何时候都慢。您计算了进一步扩大机器规模的成本，但对成本并不信服。你现在做什么？

## 模式 3 -命令查询责任分离(CQRS):

您发现大型机器无法处理所有的`read/write`请求。此外，在大多数情况下，任何公司都需要在`write`上的交易能力，而不是在`read`操作上的交易能力。你也可以接受一点点不一致或延迟的`read`操作&你的业务对此也没有问题。你发现了一个机会，将`read` & `write`运营从物理机器角度分离出来可能是一个不错的选择。这将为单个机器处理更多的`read/write`操作创造空间。

你现在有两台更大的机器&将它们设置为当前机器的`replica`。数据库复制将负责将数据从`primary`机器分发到`replica`机器。您将所有读取查询(`CQRS`中的查询(`Q`)导航到副本—任何`replica`都可以服务于任何读取请求，您将所有写入查询(`CQRS`中的命令(`C`)导航到`primary`)。复制中可能会有一点延迟，但是根据您的业务用例，这没什么问题。

大多数每天为几十万个请求提供服务的中等规模的创业公司，只要他们定期归档旧数据，就可以通过设置主副本生存下来。

现在你扩展到另外两个城市，你会发现你的`primary`无法处理所有的`write`请求。许多`write`请求都有延迟。此外，`primary` & `replica`之间的延迟有时会影响客户&司机，例如，当旅行结束时，客户成功地向司机付款，但司机看不到付款，因为客户的活动是发送到`primary`的`write`请求，而司机的活动是发送到其中一个副本的`read`请求。你的整个系统太慢了，司机至少有半分钟看不到付款，这让两个司机&客户都很沮丧。你是怎么解决的？

## 模式 4 -多主复制

您使用`primary-replica`配置进行了很好的扩展，但是现在您需要更高的写入性能。您可能准备在`read`请求性能上做一点妥协。为什么不把写请求也分发给一个`replica`？

在`multi-primary`配置中，所有机器都可以作为`primary` & `replica`工作。你可以把`multi-primary`想象成一圈机器说`A->B->C->D->A`。`B`可以从`A`复制数据，`C`可以从`B`复制数据，`D`可以从`C`复制数据，`A`可以从`D`复制数据。您可以向任何节点写入数据，同时读取数据，您可以向所有节点广播查询，无论谁回复都将返回该查询。所有节点将有相同的数据库模式，相同的表，索引等。所以你必须确保在同一个表中的节点之间`id`没有冲突，否则在广播期间，多个节点将为同一个`id`返回不同的数据。

一般最好用`UUID`或`GUID`来标识。这种技术的另一个缺点是——`read`查询可能是低效的，因为它涉及广播查询&以获得正确的结果——基本上是分散收集的方法。

现在你扩展到另外 5 个城市&你的系统再次陷入困境。你应该每秒处理大约 50 个请求。您迫切需要处理大量并发请求。你是怎么做到的？

## 模式 5 -分区:

你知道你的`location`数据库的`write` & `read`流量越来越高。大概`write:read`的比例是`7:3`。这给现有的数据库带来了很大的压力。`location`表包含少量的原始数据，如`longitude`、`latitude`、`timestamp`、`driver id`、`trip id`等。它与用户行程、用户数据、支付数据等没有太大关系。在一个单独的数据库模式中分离`location`表怎么样？将数据库放在具有适当的`primary-replica`或`multi-primary`配置的不同机器上怎么样？

这被称为按功能划分数据。不同的数据库可以托管按不同功能分类的数据，如果需要，结果可以在后端层汇总。使用这种技术，您可以专注于扩展那些要求高`read/write`请求的功能。尽管后端或应用层必须负责在必要时加入结果，这可能会导致更多的代码更改。

现在，假设您已经将业务扩展到了您所在国家的 20 个城市，并计划很快扩展到澳大利亚。您不断增长的应用需求需要越来越快的响应。以上方法现在都不能帮你做到极致。您必须以这样一种方式扩展您的系统，即扩展到其他国家/地区并不总是需要您频繁地进行工程或架构更改。你是怎么做到的？

## 模式 6 -水平缩放:

你做了大量的谷歌搜索，阅读了大量关于其他公司如何解决这个问题的资料，并得出结论，你需要横向扩展。假设您分配了 50 台机器，它们都有相同的数据库模式，而数据库模式又包含相同的表集。所有的机器只保存一部分数据。

因为所有的数据库都包含相同的一组表，所以你可以以这样一种方式设计系统，即数据的局部性在那里；所有相关数据都存放在同一台机器上。每台机器都可以有自己的副本，副本可以用于故障恢复。每个数据库被称为`shard`。一台物理机器可以有一个或多个`shards`——这取决于您的设计。你需要以这样一种方式来决定`sharding key`，即一个`sharding key`总是指同一台机器。因此，您可以想象许多机器都在同一组表中保存相关数据，`read/write`请求同一数据库机器中的同一行或同一组资源。

分片通常很难——至少不同公司的工程师是这么说的。但是当你服务于数百万或数十亿的请求时，你必须做出如此艰难的决定。

我将在我的下一篇文章中更详细地讨论`sharding`，所以抑制住我在这篇文章中讨论更多的诱惑。

现在，既然您已经有了分片，您有信心可以扩展到许多国家。你的业务增长如此之快，以至于投资者都在推动你将业务扩展到各个大洲。您再次看到了一些问题。又是 API 延迟。你的服务托管在美国&来自越南的人有困难的时间图书乘车。为什么？你会怎么做？

## 模式 7 -数据中心式分区:

你的业务在美国、南亚和欧洲的几个国家都在增长。您每天都在做数百万的预订，有数十亿的请求访问您的服务器。恭喜，这是你事业的巅峰时刻。

但由于应用程序的请求必须通过互联网上成百上千的服务器在各大洲之间传递，因此出现了延迟。如何在数据中心之间分配流量？您可以在新加坡建立一个数据中心来处理来自南亚的所有请求，在德国建立一个数据中心来处理来自欧洲国家的所有请求，在加利福尼亚建立一个数据中心来处理来自美国的所有请求。

此外，您还可以实现跨数据中心复制，这有助于灾难恢复。因此，如果加州数据中心复制到新加坡数据中心，万一加州数据中心由于电力问题或自然灾害而崩溃，所有美国请求都可以回退到新加坡数据中心，等等。

当您有数以百万计的客户需要跨国家服务，并且您不能容忍任何数据丢失，您必须始终保持系统的可用性时，这种扩展技术非常有用。

这些是一些通用的数据库扩展逐步技术。虽然大多数工程师没有足够的机会来实现这些技术，但总的来说，最好对这样的系统有一个更广泛的了解，这可能有助于你将来做更好的系统和架构设计。

在我的下一篇文章中，我将尝试详细讨论一些概念。如果有任何问题，请随时给我们适当的反馈。

文章原载于作者的 medium 账号:[https://medium . com/@ kousiknath/understanding-database-scaling-patterns-ac24e 5223522](https://medium.com/@kousiknath/understanding-database-scaling-patterns-ac24e5223522)