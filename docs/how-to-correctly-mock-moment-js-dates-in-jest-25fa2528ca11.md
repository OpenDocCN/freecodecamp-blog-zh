# 如何正确地用笑话嘲弄 Moment.js/dates

> 原文：<https://www.freecodecamp.org/news/how-to-correctly-mock-moment-js-dates-in-jest-25fa2528ca11/>

伊恩·纳什

# 如何正确地用笑话嘲弄 Moment.js/dates

![1*W26Jdk8ZEo4QDC797b7smA](img/fb56f7bb2966d6d266da1636448b2cec.png)

众所周知，时间和日期[很难](https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time)在代码中正确实现。这使得正确测试日期和时间代码变得非常重要。测试允许围绕代码中的逻辑进行推理，也允许在影响用户之前捕捉边缘情况或错误。

测试日期和时间代码时的一个常见错误是没有将当前时间设置为静态时间。如果 UI 中的代码呈现了今天的日期，并且测试正确，那么该测试只在当前时间变化太大之前有效。Javascript 公开了内置的`Date`对象，该对象允许在没有参数或调用`now()` 属性的情况下通过构造来检索当前时间。

[Moment.js](https://momentjs.com/) 是一个流行的前端日期操作库，通常用于操作、加载、格式化和转换时间。它使用一个空的构造函数来获取当前时间。Jest 通常与 Moment 和 React 应用程序结合使用。此外，Jest 快照测试引入了对日期和时间的新依赖性，这是需要考虑的重要因素。下面是一个呈现当天的有问题的组件示例:

对`TodayIntro` 组件的初始测试可能如下所示:

但是，该测试将在 1 月 23 日以外的任何一天失败。一个解决方案是覆盖 Javascript 的 date 函数，返回一个已知的日期，以便在编写测试时使用。

这段代码重写 Date 构造函数来设置一个静态的“当前”日期:

一个无效的解决方案是根据测试运行的当前时间自己计算日期。这是一个无效的测试，因为您正在运行与测试返回值相同的代码。例如，如果通过用 moment 比较格式化的日期进行测试，人们将无法捕捉到 moment 格式化代码是否从`Jan`更改为`MMM`到`JAN`。

#### 为 Jest/JS 设置静态时间和时区的方法

1.  使用一个库模拟 Date 对象来返回一个静态日期和时区(对于简单的情况，我们推荐使用 [MockDate](https://github.com/boblauer/MockDate) ，但是请继续阅读备选方案的详细说明)
2.  模仿`moment().format()`返回一个静态字符串
3.  模仿`Date`构造函数和`now()`函数来返回一个静态时间

在这种情况下使用一个库是更好的选择，因为这些库经过了很好的测试，不会引入样板代码，并且可以透明地处理两种情况日期都可以被创建(`Date.now()`对`new Date()`等等)。).此外，使用库可以很容易地跟踪测试代码，并为每个测试设置一个特定的时间，这允许更好的测试实践。

*   `[MockDate](https://github.com/boblauer/MockDate)`为时区提供更多功能，并且易于使用
*   `[sinon](https://sinonjs.org/releases/v7.2.4/fake-timers/)`提供日期和计时器(`setTimeout`等)。)模仿
*   手动设置 mock 在有限的环境中很有用，但是会变得相当复杂
*   `[jasmine](https://jasmine.github.io/)`(不包含在 jest 中)，附带一个 [jasmine.clock()](https://jasmine.github.io/api/2.6/Clock.html)

下面的例子使用了 [MockDate](https://github.com/boblauer/MockDate) ，它只关注于简单地模拟 Date 对象，并处理测试时区偏移量以及测试本地时区转换。

一个[快照测试](https://jestjs.io/docs/en/snapshot-testing)也很容易用模拟日期来测试:

既然[酵素](https://airbnb.io/enzyme/)是一个牛逼的库，一个酵素浅显的例子:

### 如何(更好地)测试日期逻辑

日期背后有很多边缘案例和逻辑。测试日期时，确保涵盖边缘案例，而不只是设置一个特定的日期来测试和继续。日期也可能因地区和时区的不同而不同。

正确测试日期需要围绕可能发生的边缘情况进行推理，并编写测试来确保这些边缘情况的行为符合预期，并且未来对应用程序中使用的代码或库的更改不会破坏这些假设。此外，添加代码将所有测试代码的当前日期和时间设置为静态日期和时间可能更容易，但是会妨碍对测试日期的良好推理，并在库代码中隐藏测试假设。

以下是一些关于日期的不正确且通常隐含的假设:

1.  所有客户端都位于同一个时区和夏令时内
2.  所有客户端都存在于开发人员所在的时区内
3.  月份名称的长度相对相似
4.  服务器时钟总是正确的
5.  服务器知道客户端的时区/时间设置

该测试假设服务器始终处于正确的时区，并且该时区设置正确。相反，请设置时区，并确保日期与当地时区正确匹配。

确保当测试访问当前时间时,“当前时间”被设置为静态值是很重要的。如果值是动态的，要么测试最终中断，要么测试是针对动态值进行的。动态值在测试行为时并不有效，因为通过比较两个相同函数的返回值，而不是与不随代码修改而改变的静态值进行比较，不会暴露 bug。

### 展望未来:日期时间存储和设计

向代码库添加测试的需求不一定提供任何价值，除非像运行代码一样严格地审查、运行和推理这些测试。

日期和时间逻辑在行为和输出方面引入了大量的可能性，这是有效测试日期和时间的强大动力。除了测试之外，确认和保存相关数据以及在早期跨系统一致地同步和存储日期时间的策略既有助于测试，也有助于更好的用户体验。

这些技巧和方法不仅仅适用于日期和时间的 Javascript & Jest 测试。他们还在 NodeJS 上下文中工作，并且在一般意义上围绕处理日期和时间的系统中要测试的关键内容工作。在许多情况下，在服务器上以 UTC(通用协调时间)存储时间，然后根据客户端/浏览器设置转换为本地时区是理想的。如果客户端不可访问，存储 UTC 时间和用户的实际时区是一致处理日期和时间的有效方法。