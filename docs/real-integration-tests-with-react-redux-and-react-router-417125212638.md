# React、Redux 和路由器的真实集成测试

> 原文：<https://www.freecodecamp.org/news/real-integration-tests-with-react-redux-and-react-router-417125212638/>

作者:马塞洛·洛蒂夫

# React、Redux 和路由器的真实集成测试

![1*Vv0HNvRhU0ihKVaBIpDUww](img/c0598823c2c438edd41fb79b56bf9710.png)

在被糟糕的重构和坏的应用咬了几次之后——即使我所有的测试都是绿色的——我开始研究 React 中的集成测试。可能还有 Redux 和 React 路由器。

令我绝对震惊的是，我在那里找不到任何好的素材。我发现的那些人要么是在做不完整的集成测试，要么就是做错了。

因此，这里我们将构建一个集成测试，它初始化一个 React 组件，激发一个模拟的用户交互，并断言我们的组件按照我们期望的方式改变。

这是**而不是**关于:单元测试。我现在不打算深入讨论这个问题，但是我们在[波](http://waveapps.com) ( [我们正在招聘](https://www.waveapps.com/about-us/jobs/))有一个很好的理由。)正在放慢我们的单元测试，并转向集成测试。如果你对此感兴趣，请滚动到底部。

披露:如果不是 Wave 的优秀前端人员，尤其是知道如何连接路由器的了不起的[Tommy Li](https://github.com/tommyzli)，我不会有现在这样顺利的测试，所以谢谢你们！

### 安装

对于这个项目，我们将使用 [React](https://facebook.github.io/react/) 、 [Redux](https://github.com/reactjs/react-redux) 、[React](https://github.com/ReactTraining/react-router)/[Redux Router](https://github.com/acdlite/redux-router)(可选)和 [Thunk](https://github.com/gaearon/redux-thunk) (可选)运行 app、 [Jest](https://facebook.github.io/jest/) 和 [Enzyme](https://github.com/airbnb/enzyme) 进行测试。

我将跳过所有这些设置，因为有很多很好的教程。

为了建立我的集成测试的基础，我将稍微欺骗一下，用一些样板代码创建一个 util 函数:

### 测试

在您的测试文件中，您将首先需要导入一些依赖项、您的 reducer 和您的组件:

然后，在每个函数之前的*上，使用 util 函数设置您的集成测试变量:*

(如果您不使用 React Router 或 Thunk，您可以在这里和 util 函数上删除它们的引用，工作方式是一样的。)

现在，您已经准备好安装组件并测试它了。让我们想象这个组件呈现一个 *div* ，它显示来自 reducer 的文本。当点击它时，文本应该变成另一个字符串，比如说“新文本”。要测试这种交互，您只需:

就是这样，☺，用这个非常简单的代码，你正在测试的 *div* 点击调用一个动作生成器，它将一个动作分派给缩减器，改变数据，触发组件的重新呈现，这将改变你希望它改变的方式。如果这些步骤中的任何一个失败了，你的测试就会变红，你就知道你的应用程序的功能没有工作。

您可以尝试在这个链中更深入一些，并断言一些其他的事情:

### 测试 API 调用

在现实世界中，您可能需要调用一些 API 来为您的应用程序获取数据，这是您需要模拟的部分，以便有效地进行测试。我们将在这里使用 Jest，这不是模仿 http 请求的最佳方式，但是为了方便起见，我将这样做。

假设您使用一个假设的 http 客户端，当您单击 *div* 时，通过其 *get* 函数调用一个端点，然后将该调用的返回设置到 reducer 中，该 reducer 显示在 *div* 中:

在一个更真实应用程序中， *get* 函数将返回一个承诺对象。从这里开始，事情变得有点复杂，因为模拟的点击功能不知道这个承诺，并且没有办法执行它的*然后*功能。对该对象的引用已丢失。

在执行断言之前，我们需要以某种方式等待该承诺得到解决。我们通过在一个实用函数中做一点修改来解决这个问题:

我们的测试现在看起来像这样:

使用从 ES7 开始可用的 *async … await* 语句，我们的测试将一直等待，直到所有承诺都被解析，这样它就可以做出断言。Jest 目前对此没有解决方案，但这种方法在现实生活中效果很好。

如果你有更复杂的动作生产者，在第一个承诺的 *resolve* 或 *reject* 中调用其他承诺，我建议你对这些调用进行单元测试，并在集成测试中测试所有案例的最终结果。

### 更多测试

如果需要为组件设置初始状态，可以手动调度操作，直到达到所需的状态:

```
store.dispatch({ payload: 'data', type: 'SOME_ACTION' });
```

你也可以疯狂地断言并测试每一件小事，或者保持简单，知道测试覆盖范围将是相同的，就好像你已经在这个应用的每一层上添加了单元测试，但代码少得多。此外，您还将测试这些层如何相互连接，以及您的应用程序如何响应用户输入和数据存储更改。

请在评论区留下你的意见，这里有很多需要改进的地方，我很乐意根据你的建议来修改。谢谢！

### 你没有单元测试吗？！？

我们在[波](http://waveapps.com)(我有没有提到[我们正在招聘](https://www.waveapps.com/about-us/jobs/)？)以前做过大量的前端单元测试，老实说，大多数测试都没什么用。当然，它们是 TDD 的核心，但是一些 reducers 和 action producers 单元测试只是样板代码，并没有给代码或 TDD 过程增加多少价值。

实际上，只有集成测试才能做好 TDD，在未来，它们将有助于发现应用程序层之间断开的链接，并最终检查应用程序是否按预期运行，这就是自动化测试的目的。

不要误解我的意思，我们仍然有单元测试边缘案例，这些案例太复杂或者太烦人，以至于无法在集成测试中重现，但是一旦我们像上面那样添加了集成测试，我们的大多数单元测试就变得毫无用处了。最后，这意味着我们现在花在思考、开发和修复测试上的时间比以前少了很多，而且它们在发现应用程序中的问题方面也更加有效。所以，赢赢☺

你可能会发现的一个问题是深安装，而不是浅渲染。您可能认为有些组件树太复杂而无法挂载，但是我要说挂载根组件的另一个好处是测试子组件是否被正确实例化。如果您已经连接了子组件，如果您愿意，可以单独测试它们。我还没有尝试浅层呈现一个连接的组件，以查看这个集成测试设置是否仍然有效，但您可以尝试。如果你不喜欢挂载，也没有连接的子组件，另一个我没有探索的可能性是浅渲染，然后手动连接。这里重要的是对你所写的测试的数量和质量感到满意，确保它们确实有助于自动进行一些回归测试，并为你发现隐藏的问题。