# 让我向您介绍 Swift networking with Siesta——我的新宠图书馆。

> 原文：<https://www.freecodecamp.org/news/swift-networking-with-siesta-5b5e7089bd8f/>

尼古拉·德卡什

# 让我向您介绍 Swift networking with Siesta——我的新宠图书馆。

![1*YAavX2qseMIP_llujYfguA](img/fd15667c8e163e7429cfbf120c34e8ec.png)

今天我想告诉你我最喜欢的 iOS 网络库，名为 [Siesta](https://github.com/bustoutsolutions/siesta) 。“它有什么了不起的，为什么我不能直接用 Alamofire？”你可能会问。其实午睡可以用 Alamofire！因为它是 HTTP 客户端之上的一个网络抽象层。

但是不像 [Moya](https://github.com/Moya/Moya) 这样的库，这个库不会对你隐藏 HTTP。这为您提供了一个很好的中间地带，这正是我喜欢使用 REST APIs 的方式。

通过采用以资源为中心的方法，而不是以请求为中心的方法，Siesta 提供了 RESTful 资源状态的**应用级可观察模型。**

这是什么意思？这意味着避免不必要的网络请求和冗余的响应反序列化。它将视图控制器与网络请求生命周期分离。它提供了开箱即用的透明响应解析。[还有更多。](https://github.com/bustoutsolutions/siesta)

在本教程中，我将向你展示如何快速地从这种神奇的事物开始，让你的人际网络再次变得伟大？

### 设置

从 Cocoapods 安装它:

```
pod 'Siesta', '~> 1.0'
```

出于本教程的目的，我用 REST API 和基于 JWT 的认证构建了一个简单的 CRUD 应用程序，并由 T2 部署到 Heroku T3。

首先，为您的 API 创建一个单独的类。姑且称之为`AwesomeAPI.swift`

让我们在这里定义一个基本的 API 配置:

这里我们为我们的 API 定义了一个全局单例。我们用 API 和`standardTransformers`的 URL 配置服务，它们是文本和图像响应的默认解析器。我们还在调试模式下启用日志记录，这对于针对您的 API 调试请求非常有用。最后，我们定义了我们的第一个*资源访问器，*，这是我们的 API 类的一个公共方法，返回一个我们现在将在视图控制器中使用的资源。

为了从新定义的资源中获取数据，我们需要在视图控制器中创建一个*资源观察者*:

这里我们添加了一个*资源观察者*到我们的`ping`资源中，并且定义了一个委托方法，当资源的状态改变时调用这个方法。例如，当添加了一个观察者或者有了一些新数据时，状态可能会改变。

因为 Siesta 允许您将请求配置从请求初始化中分离出来，所以您可以请求一个资源，而不必担心如何请求它的细节。

例如，你不必过于担心，因为午睡可以让你避免多余的请求。资源的默认过期时间是 30 秒，并且是可配置的。

现在，如果您运行您的应用程序，您应该会看到类似这样的内容:

```
Siesta:network        │ GET https://jwt-api-siesta.herokuapp.com/ping
```

```
Siesta:network        │ Response:  200 ← GET https://jwt-api-siesta.herokuapp.com/ping
```

```
pong
```

### 变形金刚(电影名)

让我们做一些更有趣的事情。让我们定义一些能够自动将原始 JSON 响应解码成数据模型的*转换器*。

在我们的 API 中，我们有一个端点`/status`,它返回

```
{  "text": "ok"}
```

为了在后端解码 JSON，我们将使用最近添加到 Swift 4 中的 [JSONDecoder](https://developer.apple.com/documentation/foundation/jsondecoder) 。

首先，我们要像这样添加一个变压器:

`[String: String]`意味着我们期望 JSON 响应中有一个字符串到字符串的映射字典。

然后，我们需要用资源观察者更新我们的视图控制器。

正如您在这里注意到的，为了解码 JSON，我们在打开可选的。在这种情况下，我们需要显式地提供一个数据类型(`[String: String]`)，否则无法推断出数据类型。同样，我们可以像这样重写以前的`/ping`端点的资源观察者:

### 证明

在我们的 API 中，我们有几个经过认证的端点:`/incomes`和`/expenses`。要访问它们，我们需要先获得一个 JWT 令牌。让我们定义一种方法来验证请求。这一次，我们不是创建一个返回*资源*的函数，而是创建一个返回`Request.`的函数。这将是一种处理 API 上除了 *GET* 请求之外的所有请求的方法。

首先，我们将添加一个类属性，它将存储 JWT 身份验证令牌:

每次设置该属性时，我们都希望使我们的服务配置无效，以便下次获取资源时，请求头会被刷新。这是必要的，因为您可能会在 cookie 或 *Authorization* 报头中发送您的认证令牌。

还可以考虑将您的认证令牌存储在钥匙串中，而不是存储在`NSUserDefaults`或其他不安全的存储器中。我们在这里使用 JWTDecode 库来解码一个 JWT 令牌并获得它的到期日期。

之后，我们还想在令牌过期时自动刷新它。在一个更复杂的 JWT 实现中，我们会同时得到一个*刷新令牌*，稍后我们会用它来刷新我们的认证令牌。在我们的例子中，我们有一个简单的 JWT 实现，我们将再次发送登录响应。

下面是如何在您的 *AwesomeAPI* 类中实现登录请求以获得认证令牌:

在这里，我们用 JSON 有效负载中的用户凭证向`/login`发送一个 POST。我们还定义了两个闭包:`onSuccess`和`OnFailure`，并在成功认证时存储一个认证令牌。

最后，我们希望在过期之前自动更新我们的认证令牌*。为此，我们可以使用单次计时器:*

是的，我们测试 API 的实际登录凭证是*测试*和*测试。*通过从负责登录的视图控制器获取凭证，您可以轻松地将`AwesomeAPI.login()`调用集成到您的登录流程中。为了成功解码来自登录请求的响应，您还需要为它定义一个转换器:

API 要求我们在*授权*头中传递 JWT 令牌。为此，我们可以将以下内容添加到我们的服务配置中(`init()`):

既然我们已经验证了我们的请求，让我们试着向经过验证的资源发出一些请求，比如`/expenses.`这个端点返回以下字典的列表:

```
{    "amount": -50.0,    "created_at": "2017-12-07T16:00:52.988245",    "description": "pizza",    "type": "TransactionType.EXPENSE"}
```

我们的目标是创建一个模型来存储这种格式的响应。让我们创建一个名为 *Expense 的类。*因为我们在这里使用了 *JSONDecoder* ，我们只需要从 *Codable:* 继承我们的类

*CodingKeys* 枚举允许我们将 JSON 响应中的字段名映射到结构的属性名。注意我们在这里也是解码日期(`createdAt`)。由于我们的日期有一个自定义格式，我们需要通过 *JSONDecoder* 的`dateDecodingStrategy`进行配置:

最后，让我们为这个类创建一个转换器:

我们在这里使用`[Expense]`,因为我们期待一个*费用*对象的数组。

在以与前面相同的方式定义了一个`expenses()`资源访问器之后，我们可以像这样获取经过身份验证的资源:

### 最后一件事…

我想向您展示的最后一件事是，当您的身份验证令牌过期时该做什么。例如，我们可以使用 Siesta 来自动验证和重试失败的请求。

首先，我们需要在配置中添加以下内容:

然后我们链接我们的请求并用一个新的令牌重复它！

如果你想看看最终的项目，可以在 [Github](https://github.com/nderkach/AwesomeAPI) 上找到。

黑客快乐！