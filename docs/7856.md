# 想更好的理解 Node.js 中的 Buffer 吗？看看这个。

> 原文：<https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/>

由大法官 Mba

在Node.js 中，每当遇到 **Buffer、Stream、**和**二进制数据**这样的词时，你是不是总是和我一样迷惑不解？这种感觉是否让你害怕理解它们，认为它们不是给你看的，而只是给 Node.js 专家和包开发人员看的？

事实上，这些话可能非常吓人，尤其是当你在没有任何 CS 学位的情况下开始使用 Node.js 进行 web 开发的时候。

可悲的是，许多教程和书籍会直接跳到如何使用 Node.js 包开发 web 应用程序，而不会让您了解 Node.js 的核心特性以及它们存在的原因。有些人会厚颜无耻地告诉你，你不需要理解他们，因为你**可能永远不会直接与他们**共事。

是的，如果您选择继续做一名普通的 Node.js 开发人员，您可能永远不会直接与他们一起工作。

然而，如果神秘让你非常好奇，你会不择手段地满足你的好奇心，如果你想让你对 Node.js 的理解更上一层楼，那么你真的想更深入地了解 Node.js 的许多核心特性，例如 **Buffer** 。这正是我写这篇文章的原因——帮助我们揭开这些特性的神秘面纱，并将 Node.js 的学习提升到一个新的水平。

在介绍**缓冲**、[官方 Node.js 文档](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buffer)部分声明…

> …读取或操作二进制数据流的机制。`Buffer`类是作为 Node.js API 的一部分引入的，它使得在 TCP 流和文件系统操作的上下文中与 octet 流交互成为可能。

嗯，除非你事先知道以上句子中的所有单词，否则它们很可能只是一堆术语。让我们试着通过重新措辞来简化一下，这样我们就可以有一个清晰的焦点，而不会被那里的许多花里胡哨分散注意力。从这段引言中，我们可以有把握地说:

`Buffer`类是作为 Node.js API 的一部分引入的，它使得操纵二进制数据流或与之交互成为可能。

现在简单多了，对吧？但是…缓冲区，流，二进制数据…还是很多大词。好吧，让我们试着从最后一个到第一个来解决这些大单词。

### 二进制数据，那是什么？

你可能已经知道计算机用二进制存储和表示数据。二进制只是 1 和 0 的集合。例如，下面是五个不同的二进制文件，五组不同的 1 和 0:

`10`、`01`、`001`、`1110`、`00101011`

二进制中的每个数，集合中的每个`1`和`0`称为一个**位**，是**二进制数字的简称。**

为了存储或表示一段数据，计算机需要将该数据转换成二进制表示。例如，为了存储数字 12，计算机需要将 12 转换成它的二进制表示形式`1100`。

计算机如何知道如何进行这种转换？嗯，这是纯数学。这是我们在基础数学中学到的简单的二进制数字系统——用基数为 2 的数字系统表示一个数字。计算机理解数学。

但是数字并不是我们唯一使用的数据类型。我们也有字符串，图像，甚至视频。计算机知道如何用二进制表示所有类型的数据。就拿琴弦来说吧。计算机将如何在二进制中表示字符串“L”？为了在二进制中存储任何字符，计算机将首先把字符转换成数字，然后再把数字转换成二进制表示。所以对于字符串“L”，电脑会先把 **L** 转换成代表 **L** 的数字。让我们看看怎么做。

打开浏览器控制台，粘贴以下代码片段，然后按 enter 键:`"L".charCodeAt(0)`。你看到了什么？76 这个数字？那就是字符 **L** 的数字表示或**字符码**或**码点**。但是，计算机如何知道每个字符的确切数字呢？它怎么知道用数字 76 来代表 **L** ？

#### **字符集**

字符集是已经定义好的规则，规定了每个字符的确切数字。我们对这些规则有不同的定义。非常流行的有 **Unicode** 和 **ASCII** 。JavaScript 非常适合 Unicode 字符集。事实上，是浏览器中的 Unicode 表示 76 应该代表 **L** 。

我们已经看到了计算机是如何用数字来表示字符的。现在，计算机将依次用二进制表示法表示数字 76。你可能会想，好吧，就把 76 转换成以 2 为基数的数字系统。没那么快！

#### **字符编码**

正如有规则定义什么数字应该代表一个字符，也有规则定义**如何**在二进制中表示那个数字。具体来说，**要用多少位**来表示这个数。这叫做**字符编码**。

字符编码的定义之一是 **UTF-8** 。UTF-8 规定字符应该用**字节编码。**一个字节是一组八个比特——八个 1 和 0。所以应该用八个 1 和 0 来表示二进制中任何字符的码位。

为了理解这一点，正如我们前面提到的，数字 12 的二进制表示是`1100`。因此，当 UTF-8 说 12 应该是 8 位时，UTF-8 是说计算机需要在 12 的实际基数-2 表示的左边增加更多的位，使它成为一个字节。所以 12 应该存储为`00001100`。有道理？

所以 76 应该存储为`01001100`。

朋友们，这就是计算机在二进制文件中存储字符串或字符的方式。同样，计算机也有关于图像和视频应该如何转换或编码并以二进制形式存储的特定规则。这里的要点是，计算机以二进制存储所有数据类型，这就是所谓的二进制数据。

如果你对字符编码的本质非常感兴趣，你可能会喜欢这个温和而详细的介绍。

现在我们明白了什么是二进制数据，但是从我们对缓冲区的介绍来看什么是**二进制数据流** ？

### 溪流

Node.js 中的 Stream 简单地表示一段时间内从一点移动到另一点的数据序列。整个概念是，你有大量的数据要处理，但你不需要等到所有的数据都可用了才开始处理。

基本上，这些大数据被分解并以块的形式发送。因此，从缓冲区的原始定义(“二进制数据流…在…文件系统的上下文中”)来看，这仅仅意味着在文件系统中移动二进制数据。例如，将存储在 file1.txt 中的文本移动到 file2.txt。

但是 buffer 到底是如何帮助我们在流式传输时与二进制数据进行交互或操作的呢？这个缓冲 btw 到底是什么？

### 缓冲器

我们已经知道数据流是数据从一点到另一点的移动，但是它们到底是如何移动的呢？

通常情况下，移动数据通常是为了处理或读取数据，并根据数据做出决策。但是随着时间的推移，一个进程可以占用的数据量有一个最小值和一个最大值。因此，如果数据到达的速度比进程消耗数据的速度快，那么多余的数据需要在某个地方等待处理。

另一方面，如果进程消耗数据的速度比数据到达的速度快，那么较早到达的少量数据需要等待一定量的数据到达后才能被发送出去进行处理。

那个“等待区*”*就是缓冲区！它是计算机中的一个小的物理位置，通常在 RAM 中，在这里数据被临时收集、等待，并最终在流式传输过程中被发送出去进行处理。

我们可以把整个流和缓冲过程想象成一个汽车站。在一些公共汽车站，直到一定数量的乘客到达或直到特定的发车时间，公共汽车才被允许发车。此外，乘客可能在不同的时间以不同的速度到达。乘客和汽车站都不能控制乘客到达车站。

在任何情况下，先到的乘客都需要**等待**,直到公交车站决定让公交车上路。而当公交车已经在装货或已经发车时到达的乘客需要在**等待**下一辆公交车。

无论在什么情况下，总有一个等待的地方。那就是 Node.js 的**缓冲区**！Node.js 无法控制数据到达的速度或时间，流的速度。它只能决定何时发送数据。如果时间未到，Node.js 会将它们放入缓冲区——“等待区”RAM 中的一个小位置，直到发送它们进行处理的时候。

一个可以看到 buffer 运行的典型例子是当你在网上播放视频的时候。如果你的互联网连接足够快，数据流的速度会足够快，可以立即填满缓冲区并发送出去进行处理，然后填满另一个，并发送出去，然后再一个，再一个…直到数据流结束。

但是如果你的连接很慢，在处理完到达的第一组数据后，视频播放器会显示一个加载图标，或者显示文本“缓冲”，这意味着收集更多的数据，或者等待更多的数据到达。当缓冲区被填满并被处理时，播放器显示数据，视频。播放时，更多的数据将继续到达并在缓冲区中等待。

如果播放器已经处理完或播放完之前的数据，而缓冲区尚未填满，将再次显示文本“缓冲”，等待收集更多数据进行处理。

那就是**缓冲区！**

从缓冲区的原始定义来看，它表明在缓冲区中，我们可以操作正在传输的二进制数据或与之交互。对于这些原始的二进制数据，我们能有什么样的互动呢？Node.js 中的 Buffer 实现为我们提供了一个完整的列表。让我们看看其中的一些。

#### 与缓冲区交互

甚至可以创建自己的缓冲区！除了 Node.js 在流中自动创建的一个缓冲区之外，还可以创建和操作自己的缓冲区。有趣吧？让我们创造一个！

根据您想要实现的目标，有不同的方法来创建缓冲区。让我们看一些。

```
// Create an empty buffer of size 10\. // A buffer that only can accommodate 10 bytes.
```

```
const buf1 = Buffer.alloc(10);
```

```
// Create a buffer with content
```

```
const buf2 = Buffer.from("hello buffer");
```

一旦创建了缓冲区，就可以开始与它交互了

```
// Examine the structure of a buffer
```

```
buf1.toJSON()// { type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] }// an empty buffer
```

```
buf2.toJSON()// { type: 'Buffer',     data: [        104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114      ]    }
```

```
// the toJSON() method presents the data as the Unicode Code Points of the characters
```

```
// Examine the size of a buffer
```

```
buf1.length // 10
```

```
buf2.length // 12\. Auto-assigned based on the initial content when created.
```

```
// Write to a bufferbuf1.write("Buffer really rocks!") 
```

```
// Decode a buffer
```

```
buf1.toString() // 'Buffer rea'
```

```
//oops, because buf1 is created to contain only 10 bytes, it couldn't accommodate the rest of the characters
```

```
// Compare two buffers
```

我们可以和缓冲区有很多交互作用。前往[官方文档](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html)更多地使用这些方法。

最后，我留给你一个小小的挑战:通读 Node.js 的核心库之一 **zlib.js** 的源代码[，看看它是如何利用 buffer 的能力来操作二进制数据流的。这些原来是压缩文件。当你阅读时，记录下你所学到的，并在评论中与我们分享。](https://github.com/nodejs/node/blob/master/lib/zlib.js)

希望这篇介绍能帮助你更好地理解 Node.js Buffer。

如果您认为我做得很好，并且其他人也应该有机会看到这一点，请为这篇文章鼓掌，以帮助在我们的 Node.js 社区中传播对 Buffer 的更好理解。

如果你有一个问题没有得到回答，或者你对这里的一些观点有不同的理解，请随时在这里或通过 [Twitter](https://twitter.com/Daajust) 发表评论。