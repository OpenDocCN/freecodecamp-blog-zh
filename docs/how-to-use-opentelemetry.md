# 如何使用 OpenTelemetry 了解软件性能

> 原文：<https://www.freecodecamp.org/news/how-to-use-opentelemetry/>

如果您希望您的应用程序具有良好的性能，您需要收集数据来确定哪里需要改进。这就是 OpenTelemetry 的用武之地。

OpenTelemetry 提供了一套 API 和库，用于标准化收集和传输遥测数据的方式。OpenTelemetry 为仪器提供了一个规范，因此您可以将数据发送到您选择的不同后端。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了完整的开放式遥测课程。

这门课程是由一个帮助开发者监控和调试他们的应用程序的可观察性平台 [New Relic](https://www.newrelic.com) 资助的。

ania ku bow 创建了该课程。Ania 是一位受欢迎的软件教育家，她将帮助您全面了解如何在您的项目中使用 OpenTelemetry。

在本课程中，您将学习如何使用 OpenTelemetry 获得软件项目性能和行为的全栈可观察性。

以下是本课程涵盖的主题:

*   什么是 OpenTelemetry？
*   什么是微服务？
*   什么是可观测性？
*   米（meter 的缩写））电子学习技术
*   历史
*   设置我们的项目
*   什么是追踪？
*   语境与传播
*   设置我们的跟踪
*   什么是度量？
*   OpenTelemetry 的用例
*   设置分布式跟踪
*   使用其他分析工具-新遗迹
*   接下来去哪里

观看以下课程或 freeCodeCamp.org YouTube 频道上的[(1 小时观看)。](https://youtu.be/r8UvWSX3KA8)

[https://www.youtube.com/embed/r8UvWSX3KA8?feature=oembed](https://www.youtube.com/embed/r8UvWSX3KA8?feature=oembed)

## 视频抄本

(自动生成)

大家好，互联网，欢迎来到这门关于开放式遥测的课程。

在本课程中，我将向您展示如何通过使用开放式遥测技术和您选择的分析工具，获得软件项目行为的全栈可观测性。

如果你想知道为什么你的项目或应用程序运行太慢，坏了，或者你只是想提高它的代码质量。

这是给你的视频。

但是首先，我们所说的过度遥测到底是什么意思？好吧，让我们从名称本身开始，我们有开源和遥测，这是一个在远程点收集测量或其他数据的机构。

并自动传输到接收设备进行监控。

遥测一词实际上来自希腊语词根 Teller，或 remote，和 metron，表示测量。

这正是我们将要做的，我们将提供一种方法来远程测量我们在应用程序中使用的所有东西的性能。

对于任何应用程序，当您想要开始查看这种数据时，您需要将两个部分结合在一起。

首先是弄清楚如何生成和传输这些数据。

然后第二部分是决定你要用这些数据做什么。

换句话说，你打算如何分析它？开放式遥测处理总线部分。

到目前为止，还没有真正标准化的方法来描述你的系统在做什么。

这是因为我们都喜欢以不同的方式思考，使用不同的编程语言，不同的机器，以及不同方式的组合。

这是一个问题，尤其是对于那些想要构建可观察性工具的人来说。

开放遥测项目的核心正是这个，一个描述分布式系统正在做什么的标准化，不管你使用什么编程语言或计算机系统。

如今，开放式遥测项目可以被描述为工具、API 和 SDK 的集合，使用 it 仪器，生成、收集和导出遥测数据，以便我们可以在以后使用任何我们希望的平台来分析它，通过标准化我们的数据并意味着我们从长远来看不依赖于任何东西。

它使从一个分析工具转移到下一个工具变得非常容易，我不会影响你的历史数据。

正如我在开头提到的，这是一个开源项目。

它是由很多很多开发者和他们的投入组成的。

如果我们看看 GitHub 这个项目，你会发现它是超级透明的。

你可以看到治理委员会，你可以看到技术委员会。

如果你有兴趣参与，请加入他们的邮件列表并参加社区会议。

你甚至可以看到所有欢迎你参加的会议。

不过，在我们开始之前，我想简单介绍一下我们将在这门课中学到的东西。

所以我们来分解一下。

好的，在本课程中，首先我们将了解什么是微服务，其次是可观测性，然后我们将了解 melt，接着是开放式遥测技术的历史，最后我们将从建立一个项目开始。

然后，在将跟踪添加到我们的项目之前，我们将讨论跟踪、分布式跟踪以及上下文和传播。

然后，在最终结束我们的分布式项目之前，我们将继续查看度量标准。

我将以下一步的方向来结束本课程。

我们希望我们的网站、应用程序和在线服务能够几乎瞬间加载，对吗？想想当网站加载时间超过两秒钟时，我们中的一些人会有多沮丧。

在后端，需要一个工程壮举来保持一个全球系统的运行，以确保你可以访问网飞或 Instagram。

只需轻轻一点，让我们看一看网飞。

网飞在高峰期消耗了美国 37%的互联网带宽，同时有 1000 人点击播放，活动在晚上达到高峰。

不过，作为一个全球平台，这是一个持续的选择。

面临的挑战是如何在每天处理超过 4000 亿个事件的同时零损失地运行服务，并在高峰时每秒处理 17gb。

在今天的视频中，我们将深入探讨是什么类型的系统推动了这些令人惊叹的服务，以及我们如何利用数据来更深入地了解这些复杂系统。

从历史上看，开发人员考虑的是具有大型复杂代码库的单片应用程序，一个单片将包含所有业务活动和应用程序执行的所有代码。

如果你有一个小的应用程序，这一切都很好。

但是，如果你的应用程序证明是成功的，用户会喜欢它，并开始依赖它流量急剧增加，总是不可避免地使用请求改进和附加功能。

因此，越来越多的开发人员被吸引到日益增长的应用程序中来。

过不了多久，你的应用程序就会变成一团泥巴。

在这种情况下，没有一个开发人员了解整个应用程序。

您曾经简单的应用程序现在变得更加复杂。

多个独立的开发团队同时。

在相同的代码基础上工作，同时更改相同的代码部分，那么几乎不可能知道谁在做什么，代码质量受到影响，单个开发团队在不计算对其他团队的影响的情况下进行更改变得越来越困难，团队可能看不到该代码可能如何与其他代码不兼容，以及其他问题。

这通常会导致更慢、更不可靠的应用程序，更不用说越来越长的开发时间表了。

在 come 微服务中，微服务架构背后的主要原则是，当应用程序被分解为更小的部分时，构建和维护更简单。

使用微服务时，您将软件功能隔离到多个独立的模块中，这些模块分别负责执行精确定义的独立任务。

这些模块通过简单的 API 相互通信。

微服务架构允许您将应用程序拆分为不同的独立服务，每个服务由不同的团队管理。

它自然地将构建高度可伸缩的应用程序的责任委托给其他人，允许独立地在单个服务上完成工作，而不会影响其他团队中其他开发人员在同一个整体应用程序上的工作。

然而，试图了解这个系统是非常困难的。

当您有数百个服务和应用程序时，您的请求经过调试和故障排除可能是一场噩梦。

这就是开放式遥测技术的用武之地。

正如我们已经提到的，遥测被定义为收集远处物体的信息并将信息以电子方式发送到某个地方的科学或过程。

现在。

可观察性意味着你能在多大程度上根据系统的输出来理解系统内部正在发生的事情。

尤其是当系统变得更加分散和复杂的时候。

很难看出应用程序内部发生了什么，以及为什么会出错。

当谈到可观察性时，我们需要定义必要的数据类型，以广泛理解我们的应用程序的性能和健康状况，度量、事件、日志和跟踪。

Met，metrics 是定期收集的测量值，必须有时间戳和名称、一个或多个数值以及表示多少事件的计数。

这些包括错误率、响应时间或输出。

事件是在任何时刻发生的离散动作。

以自动售货机为例。

例如，一个事件可以是用户从机器上购物的时刻。

向事件添加元数据会使它们更加强大。

对于自动售货机的例子，我们可以添加额外的属性，如商品类别和支付类型。

这允许提出问题，例如每个项目类别赚了多少钱，或者最常见的支付类型是什么。

日志直接来自您的应用程序，导出事件的详细数据和详细背景。

因此工程师们可以一毫秒一毫秒地重现当时的情况。

当您使用 system out print 或控制台日志跟踪从初始请求到返回输出的请求时，您可能已经记录了一些内容。

它需要偶然的事件链来确定不同实体之间的关系。

跟踪对于突出用户体验中的低效、瓶颈和障碍非常有价值，因为它们可以用于显示单个内核和分布式架构的端到端延迟。

然而，获取这些数据非常困难。

您将不得不一层一层地手工检测每一个服务。

这将花费与编写代码本身一样多的时间，这很烦人。

幸运的是，有一些很棒的开源项目和公司使这变得容易得多，在今天的 16 open tracing 中，它作为一个 cn CF 项目发布，只关注分布式跟踪。

因为这些库是轻量级的和简单的，所以它可以适用于任何用例。

虽然它使检测数据变得容易，但如果没有大量的手工工程工作，检测作为二进制文件发布的软件就很困难。

2018 年，一个名为 Open census 的类似项目在谷歌开源，支持捕捉追溯权限和指标。

虽然它使得从作为二进制文件(如 Kubernetes)和数据库提供的软件中获取遥测数据变得更加容易，但它使得很难使用 API 来检测定制实现，而不是默认用例的一部分。

这两个项目都使现代应用程序的可观察性变得容易，并加速了软件行业对分布式跟踪的广泛采用。

然而，开发人员不得不在两个各有利弊的选项之间做出选择。

事实证明，这两个项目的方法是互补的，而不是矛盾的。

我们没有理由不能同时拥有抽象的厂商中立的 API 和良好支持的默认实现。

2019 年末，这两个项目合并成立了 opentelemetry。

这就提出了用一个单一的可观测性标准代替两个相互竞争的标准的想法。

好吧，首先，让我们先来一点元，并确切地了解将会发生什么。

以便我们查看应用程序中发生的事情。

这是我们的项目。

把 project 想象成一个我们用自己选择的代码编辑器制作的项目。

例如，如果我们运行它，它就在我们的机器上本地运行。

让我们也假设这个项目是为了倾听请求而构建的。

例如，就像监听 get 请求一样，我们决定根据应用程序发出的请求来衡量应用程序的性能。

要做到这一点，正如我们在开始时提到的，第一步是在项目中实现开放式遥测。

我们这样做是为了帮助我们标准化数据。

一旦我们实现了开放式遥测并使数据标准化，我们就需要考虑如何处理数据，如何查看数据等等。

为此，我们可以使用分析工具。

对于分析工具，我的意思是，任何类型的给你可观察性的工具，我们将看一些这样的工具，一个专门关注跟踪，一个专门关注度量，一个关注一个平台中的所有东西。

然后，我们将数据发送到我们选择的分析工具。

这里我们有一个例子，展示了我们的数据在 zipkin 等追踪应用程序、permittees 等指标应用程序和 New Relic 等可观察性工具中的表现，这些工具将在一个平台中为我们提供一切以及其他更多定制见解的概览。

我们将在专门的章节中讨论这些问题。

我们先从实现开放式遥测开始。

好了，在我们开始之前，我要问你的唯一先决条件是你已经把 Docker 下载到你的机器上了。

Docker 是一个容器平台，用于快速开发和交付微服务。

如果你对容器和微服务了解不多，现在就跟着我吧。

在本节之后，我将有一节专门讨论这两个主题。

对于那些没有的人，请浏览 Docker 网站并按照说明进行操作。

为了被安置好。

我个人会选择下载 Docker 桌面。

因为我在 Mac 上工作，所以我选择了 Mac 选项。

一旦你完成了，确保你的 Docker 桌面在 Mac 上运行，我会像这样简单地将鼠标悬停在图标上。

如果你打开这个平台，你会发现我目前没有运行任何容器。

当我们开始使用分析工具时，拥有一个容器将变得很重要，比如像 zipkin 这样的跟踪后端。

一旦我们都启动并运行了 Docker，让我们开始吧。

让我们竖起我们的终端。

现在，我将导航到一个文件夹，我喜欢在那里存储我的所有项目。

这叫发展。

请继续选择您想要工作的任何目录。

现在，使用 Mk dir 命令后，我将为即将开始的新项目创建一个文件夹。

我称之为开放式遥测开始。

请注意，如果您使用不同的终端，可能需要使用其他命令。

现在，让我们使用命令 cd 进入项目。

我要做的第一件事是启动我们的容器。

所以它为下一部分做好了准备。

因此，如前所述，在开始收集跟踪之前，您需要的第一件事是像 zipkin 这样的跟踪后端，您可以将跟踪导出到该后端，为了尽快设置 zipkin，请运行最新的 Docker zipkin 容器，公开端口 9411。

如果你不能或者不想运行 Docker 容器，你也可以选择直接下载 zipkin。

如你所知，这也是一种选择。

如果你想进一步探索这个选项，我建议你访问 zipkin 网站。

这是运行我们的容器的命令。

好了，我们现在有了这个容器 ID，它工作了。

接下来，我们需要在我们的项目中获得一个包 JSON 文件，我们可以通过键入 NPM 来完成。

在其中，拥有一个包 JSON 文件将使其他人更容易管理和安装项目所需的所有包。

如果你得到错误，这可能是因为你没有安装 js 和 NPM。

如果是这样的话，请访问节点 j s.org。

以便按照下载说明进行设置。

好了，我们已经初始化了该实用程序，我将对所有这些字段按 enter 键，它会提示我回答。

所以输入和，和，和，然后输入。

好了，我们现在已经完成了包 JSON 文件的创建。

如果我们使用 ls 命令列出项目中的所有文件，您将在那里看到该文件。

最后，我需要创建一个应用 js 文件。

所以一个 JavaScript 文件，并把它放到项目中，你们中的一些人可能有不同的方法来把文件添加到项目中。

因此，这完全取决于您，无论您希望创建什么样的文件。

但是一旦我们完成了，我们现在需要打开我们的项目。

因为我使用的是 VS 代码，所以我将使用命令代码来打开我们的项目。

我们开始吧。

有一个文件夹，里面有 app js 文件和包 JSON 文件。

您将看到 JSON 文件包中有我们被询问的所有提示，因为我跳过了所有提示，只是标准的缺省条目根本没有条目。

如果你转到应用 js 文件，你也会看到它目前是空的，里面什么也没有。

好的，所以我需要做的第一件事是把它改为指向我们创建的 app j s 文件，而不是索引 js，因为没有索引 js 文件。

只是为了好玩，这是不必要的，我将填写我的项目的描述。

所以公开遥测成本。

接下来我想做的就是添加一个启动脚本。

对于这个脚本，我将运行 node app j s。

好了，现在是有趣的部分，让我们开始添加一些包。

要开始使用开放式遥测技术，我们需要安装它的一些软件包。

使用 NPM II 或简称 install。

我准备存储开放遥测核心包，开放遥测节点包 open telemetry 插件 http opentelemetry。

插件 HTTP s，开放遥测出口商 zipkin 让我们准备好下一节关于开放遥测跟踪下一节到一个快递唯一的非开放遥测之一。

好的，我们需要安装所有这些。

好的，很好。

所以这些看起来不错。

如果我们回头看这里，这是我们刚刚安装的软件包。

他们已经自动填充了我们的包 JSON 文件。

所以这看起来不错。

我们刚刚错过了一个。

因此，让我们回到使用 NPM 二或安装的简称，并在快速安装开放遥测插头。

我们结束了。

好了，现在让我们继续我们的应用程序 js 文件。

我要做的第一件事是为我们定义一个端口。

接下来，我们将需要 Express。

所以 const Express。

Express 是我们安装的软件包之一。

所以这里的这个。

所以我们需要告诉我们的文件这个常量需要 Express。

然后我们将调用 Express 并存储为 const 应用程序。

我想做的第一件事就是在我们的控制台日志中获得一条消息，让我们知道一切都很好，我们正在监听以及在哪个端口上。

因此，只是作为一个重述，我在这里做的是让应用程序启动服务器。

然后用这段代码，我让它监听我们定义的端口的任何请求。

好了，接下来，我要粘贴这段超级基本的代码。

这个代码是一个非常基本的路线的例子。

路由指的是应用程序端点如何响应客户端请求。

我们已经使用对应于 http 方法的 Express app 对象的方法定义了路由。

例如，app get 处理 get 请求。

这些路由方法指定了一个回调函数，当应用程序接收到对指定路由 HTTP 方法的请求时调用该函数。

换句话说，它监听指定路由和方法的请求。

在这种情况下，根是我们的主页，我们本质上想要跟踪对主页的每一次 get 请求。

我们将在下一节中完成这项工作。

既然我们已经完成了基本的安装，现在是时候讨论跟踪了。

如你所知，开放式遥测技术使我们能够将数据标准化。

下一部分实际上是以一种我们可以分析幕后发生的事情的方式查看数据，我们将使用跟踪系统来完成这一工作。

在软件工程中，跟踪包括专门使用日志来记录关于程序执行的信息。

程序员通常使用此信息进行调试，通过使用跟踪日志中包含的信息来诊断特定软件或应用程序可能出现的任何问题。

然而，分布式跟踪，也称为分布式请求跟踪，是一种用于调试和监控使用微服务架构构建的应用程序的方法。

分布式跟踪有助于查明故障发生的位置，以及导致低性能的原因。

因此，正如我们现在所看到的，能够获得跟踪数据遥测对应用程序的整体性能非常重要。

然而，正如我们在引言中所讨论的，由于系统使用各种不同的语言、框架和基础设施，如果没有某种通用的方法，这是很难做到的。

这就是为什么 Evans limitary 在分布式跟踪方面能提供如此大的帮助。

通过提供一组通用的 API、SDK 和有线协议。

它为组织提供了一个支持良好的端到端分布式跟踪遥测集成服务。

在本课程中，我们将使用的示踪剂称为 zipkin。

zipkin 是一个分布式跟踪系统，帮助他们收集解决延迟问题和服务架构所需的时间数据。

Circuit 最初是由 Twitter 创建的。

它目前由开放的 zipkin 志愿者组织运营。

我使用 zipkin 的原因就是我不得不选择一个。

但是请随意选择任何你想要的后端追踪系统，这个选择完全取决于你。

一般来说，一旦跟踪被实现到应用程序中，它们实际上记录了发生的操作的时间和元数据。

这方面的一个例子是，web 服务器记录下它收到请求的确切时间。

当它发出回应时。

这些数据通常用一个条形表示，就像这样，官方名称为垃圾邮件。

因此，在本例中，我们有两个服务和一组跨度。

为了解释这一点，想象这代表了你最喜欢的食品交付应用程序。

想象一下你做了一个正确的订单。

现在将会发生几件事情，每一件都用一个跨度来表示。

您在服务中心来回发送信息以便付款，找到离您最近的送货司机，并通知该司机您的订单。

这些操作中的每一个都会生成一个垃圾邮件，向您显示为此所做的工作。

在这种情况下，跨度具有隐式关系，因此父和子也来自单个服务和跟踪。

如您所见，每个跨度从不同的点开始，花费的时间也不同。

我们称之为延迟和网络延迟。

简而言之，延迟是动作和对动作响应之间的延迟。

网络延迟是指网络中发生的特定延迟。

延迟通常以毫秒计，由于网络之间的通信方式，这是不可避免的。

它取决于网络的几个方面，如果其中任何一个方面发生变化，它就会发生变化。

大多数系统上的错误通常很容易发现。

例如，如果您的柱线以红色或类似颜色结束，您就知道发生了错误。

现在我们该看看语境和传播了。

这两个概念将让我们更好地理解追踪这个主题。

正如我们所知，分布式跟踪允许我们跨服务边界关联事件。

但是，我们如何在我们的分布式系统中找到这些组件之间的关联，以便能够收集、存储和传输元数据呢？我们将这种元数据称为上下文。

语境分为两种类型，跨度语境和关联语境。

span context 表示跨边界移动跟踪信息所需的数据。

它包含以下元数据。

我们有这个绑定上下文的跟踪 ID、span ID、跟踪标志和跟踪状态。

然后我们有了关联上下文。

关联联系人携带用户定义的属性。

这通常是指客户 ID、提供商、灵车名称、数据区域和其他遥测数据，可为您提供特定应用的性能洞察。

不需要相关上下文，组件可以选择不携带或存储该信息。

上下文通常包含信息，因此我们可以识别当前范围，跟踪和传播是我们用来捆绑上下文并跨服务传输的机制，这样我们就有了上下文和传播。

一起。

这两个概念代表了分布式跟踪背后的引擎。

如果您想进一步了解这两个主题，请访问城市遥测网站。

然而，对于本教程来说，上面的基本知识就足够了。

因此，作为下一节的一点提示，我们将首先介绍如何初始化一个全局跟踪器，然后初始化并注册一个跟踪导出器。

好了，我们又回到了上次停下的地方。

在最后一部分，我们运行了最新的 Docker zipkin 容器，公开了端口 9411。

如果我们真的访问 localhost 9411，我们将会看到 zipkin UI，它是这样做的一部分。

这就是我们，这就是我们要用来查看我们的痕迹。

好吧，我们继续。

接下来，让我们创建一个名为 tracing 和 j s 的文件，并添加以下代码。

这只是 opentelemetry 提供给我们的样本代码。

如果你访问他们的网站，你可以看到我只是把这段代码复制到这里，然后粘贴到我的项目中。

您还会看到这个文件使用了我们在初始设置中安装的两个包。

粘贴后，我们需要初始化并注册一个跟踪导出器。

我们已经完成了其中的一部分，因为我们安装了这一部分和初始设置部分所需的两个包。

这就是开放遥测跟踪和开放遥测导出到 zipkin 包。

首先，让我们创建一个新的 zipkin exporter。

所以提供新增跨度处理器，新的简单跨度处理器。

这是从打开的遥测追踪包中，可以看到已经显示在顶端的消息可以导出来了。

这也来自另一个包。

因此，开放的遥测导出器可以打包显示在顶部，这可能不会自动显示。

这只是我用的代码编辑器。

因此，您可能需要输入这两个名称，然后输入正确的服务名称并选择一个服务。

我将放入入门，但您可以用自己的服务名替换它。

好吧，看起来不错。

app js 文件也是。

好极了。

文明中的所有跟踪都应该发生在应用程序代码运行之前。

最简单的方法是初始化跟踪和一个单独的文件，这需要在应用程序代码运行之前使用 node r 选项，我将向您展示我的意思。

所以，现在，如果你用 node、我们的 tracing j s 和 app j s 运行你的应用程序，你的应用程序将通过 HTTP 创建和传播跟踪。

让我们运行它。

现在让我们通过 HTTP 向应用程序发送请求。

我们可以简单地通过刷新 localhost 8080 页面来做到这一点，您会看到跟踪导出到我们的跟踪后端，如下所示。

因此，他将看到我们正在向主页发出 get 请求，而主页则以 hello world 作为响应。

现在我们已经开始了。

因为这就是我们对服务名称的称呼。

我们还得到一个开始时间和一个持续时间作为跨度。

现在，随着您越来越频繁地使用它，一些跨度可能看起来是重复的，但它们不是。

这是因为有些应用程序既可以是这些请求的客户端，也可以是服务器。

如果是这种情况，您将看到一个跨度是客户端请求时间，一个跨度是服务器端请求时间，它们不重叠的地方是网络时间。

好，现在我再给你们看一个例子。

为了进行区分，我将更改我的服务名以获取日期。

现在，我将进入我的应用程序 js 文件。

我要把这段代码复制到这里。

和粘贴。

现在，我想从本质上监听任何对 park date 发出 get 请求的时间。

换句话说，如果有人现在转到 localhost 8080 正斜杠 date，即我们发出 get 请求，我们也将能够看到用实际日期响应。

所以，让我们继续，让我们回到我们的本地主机 8080，并键入正斜杠日期。

哎呀，我停止了我的应用程序运行，让我们确保它正在运行。

所以我要重新开始。

好的，刷新我们的页面。

很好，这是我们今天的对象。

太神奇了。

现在，如果我们访问 localhost 9411，也就是我们公开的端口，并单击 run a query，我们将看到所有已发出的请求。

好了，我们现在可以看到我们的约会服务了。

目前，它监听的唯一请求是 get 请求。

现在，我实际上已经重命名了该服务，请记住，如果我访问主页，您会看到请求也存储在 get date 服务名称下，您可以通过时间戳来判断它是哪一个。

好吧，我们继续。

好了，我们现在完成了跟踪的基本实现。

然而，我们实际上只是触及了表面。

在课程的专题部分，我将向你展示如何使用开放式遥测技术来装备分布式系统。

我的意思是，我将向您展示如何跟踪多个服务以及它们之间的交互(如果存在的话)。

在下一节中，我们将了解如何使用开放式遥测技术收集指标，并将 Prometheus 修复为一个监视平台，该平台通过收集这些目标上的指标 HTTP 端点来从监视目标收集指标。

在本节中，我将向您展示如何使用 Prometheus 和 open telemetry 安装、配置和监控我们的 fast 应用程序。

我们将下载、安装并运行 Prometheus，以在主机和服务上公开时间序列数据。

与在跨度中工作的跟踪不同，指标是在时间间隔上测量的数据的数字表示。

度量可以利用数学建模和预测的能力来获取系统在现在和未来的时间间隔内的行为知识。

由于 numbers 针对存储、处理、压缩和检索进行了优化，因此指标可以延长数据的保留时间并简化查询。

这使得指标非常适合构建反映历史趋势的仪表板。

度量还允许数据分辨率的逐渐降低。

经过一段时间后，数据可以按每天或每周的频率进行汇总。

让我们来看看它的运行情况。

在这一部分，我将使用 promethium 作为我的指标后端。

现在我们已经建立了端到端的跟踪，我们可以收集和导出一些基本的指标。

首先，我要让它停止运行。

让我们去普罗米修斯下载页面下载最新版本。

您的操作系统的许可证。

因为我用的是 Mac，所以我要点击这里的这个。

下载完成后，打开命令行，使用 cd 或命令 CD 进入您下载 promethease tarball 的目录。

在我的例子中，它将是下载目录。

现在我需要将它恢复到新创建的目录中，确保用下载的 harbor 替换文件名。

所以不一定用这个。

现在让我们进入目录。

如果我列出所有的文件和文件夹，您会看到一个名为 permit this 莫亚的文件，这是用于配置 permit 的文件是的，现在，只需确保 permit 是通过运行点四斜杠 promethease 二进制文件和文件夹启动的，并浏览到 localhost 9090。

好极了。

这是我们的普罗米修斯用户界面。

因此，当服务器准备好接收 web 请求时，您会看到这一点。

所以这应该是好的。

我将在这里打开一个新选项卡，这样我就可以继续运行了。

我将使用 VS 代码快捷方式打开我们的目录。

一旦我们确认允许用户已经开始，我们需要用下面的内容替换莫亚文件的内容。

所以直接删除所有内容，放入这段更短的代码。

这将把刮擦间隔设置为每 15 秒。

我们现在准备好监控我们的节点 JS 应用程序。

在下一节中，我们需要初始化所需的开放式遥测指标库，初始化一个仪表并收集指标，初始化并注册一个指标导出器。

为此，我们将不得不安装一些库，我们将需要开放的遥测指标包。

因此，让我们继续安装它。

让我们先回到我们的项目。

所以不要在我们刚刚下载的目录中这样做。

在这里，键入 NPM II 或安装开放式遥测指标。

很好，我们现在准备初始化一个计量器并收集指标。

我们首先需要一个仪表来创建和监控指标，仪表和开放式遥测是用于创建和管理指标、标签、未计量导出器的机制，创建一个名为 monitoring j s 的文件。

所以一个 JavaScript 文件和你的文件夹的根目录，然后添加下面的代码。

因此，我们需要这个康德式的开放式遥测指标包。

我们将从它那里获得仪表提供商并购买它，我的意思是，开放式遥测指标包，然后我们将制作一个新的控制台常量仪表。

我们将使用计量表提供程序，我们将创建一个新的计量表提供程序，并使用 get meter，现在我将输入您的计量表名称，我们可以随时更改它。

现在，我们可以从您的应用程序代码中获取这个文件，并使用度量工具来创建和管理指标。

这些指标中最简单的是计数器。

在下一部分中，我们将从我们的监控 js 文件中创建一个导出，这是一个中间件函数，express 可以用它来统计 route 发出的所有请求。

所以首先，我们需要修改 IO 监控 j s 文件。

因此，我将再次从 open telemetry 开源项目中复制这个示例代码，以帮助我们统计请求，并将其粘贴到我的 monitoring j s 文件中。

接下来，我们需要在应用程序代码中导入并使用这个中间件。

所以我们的 app js 文件。

因此，我们需要从我们的监控 js 文件中获取所有请求的计数。

所以模块导出时，我们通过键入 const count 来完成所有要求监视的请求。

从字面上看，我们就在这里使用它。

现在让我们开始使用它。

键入 app use count all requests 并立即调用它当您发出请求时，您将计量的服务将对所有请求进行计数。

完美。

接下来，让我们看一下初始化和注册指标导出器计数器指标只有在您可以将它们导出到您可以看到的地方时才有用。

为此，我们将使用 Prometheus is 创建并注册一个度量导出器，这与上面的跟踪导出器非常相似。

因此，我将使用 npm 安装并打开遥测导出器许可证。下一步，我们需要向我们的监控 js 文件添加更多代码。

因此，我将再次复制 opentelemetry 提供给我们的代码，并将其粘贴到我的监控 js 文件中。

别担心，我会和你们分享这个回购，这样如果你遇到困难，你可以参考我完成的项目。

现在，在一个单独的选项卡中，让它保持运行，通过运行前面的 Prometheus 二进制文件来显示 Prometheus 正在运行，然后启动您的应用程序。

我们通过使用自己编写的脚本来实现这一点。

因此，NPM 启动时，您应该看到 promethease scrape 端点和 HTTP localhost 94644 斜杠指标，以及侦听 localhost 8080 上的请求。

现在，每次浏览到 localhost 8080 时，您应该会在浏览器和指标中看到 Hello，Prometheus 应该会更新，您可以通过浏览到 localhost 9464 来验证当前指标，正斜杠指标应该是这样的，您还应该能够在 Prometheus web UI 中看到收集的指标，我们还可以在应用程序 js 文件中添加更多路由。

让我们继续这样做，看看会是什么样子。

所以我要在这里添加一些预先写好的代码。

这是一条中间层路线，另一条路线有大麻后端。

所以现在我们有了我们的日期，前一部分的主页，我们现在的后端路线，中间层路线，以及新的主页路线。

为此，我还需要 axios。

因此，另一个包将有助于我提出这些要求。

因此，让我们继续将它导入到我的项目中。

很好，完成了。

让我们从 NPM 开始。

好的，现在让我们检查一下一切是否如预期的那样工作。

主页现在以 Hello backend 响应。

这其实是因为我们有两条首页路线。

所以我一会儿就把另一个去掉。

后端路由用 Hello back end 响应，日期路由用今天的日期响应。

所以看起来不错。

因此，我将删除最初的主页路径，该路径以 hello world 作为响应，并保留新的路径。

好的，现在我们来看看中间层。

我们得到 Hello 后端的响应。

最后，让我们访问 matrix，在这里我们可以获得我们访问过的所有路由的请求计数器。

好吧。

看起来一切正常，我们访问了所有路线，我的计数器看起来工作正常。

现在，让我们继续在 permittees 用户界面中查看。

所以我们必须选择要执行的东西。

我们开始吧。

现在，在我们继续我们的项目之前，我想让我们花一点时间来了解到底什么问题可以被检测到。

打开遥测系统。

这是我要和你一起看的一份清单。

从后端开始。

在具有开放式遥测的后端，您可能会发现错误的逻辑或用户输入，导致抛出异常、执行不佳的下游调用。

例如数据库或下游 API 等基础设施，导致异常长的响应时间。

或者，您可以在单个 API 上获得性能较差的代码，从而导致异常的响应时间。

在前端，通过开放式遥测，您可以检测到导致 JavaScript 错误的错误逻辑或用户输入。

您还可以使用它来查找实现不佳的 JavaScript，这使得您的 UI 非常慢，尽管有高性能的 API。

您甚至可以使用它来定位需要地理分布的特定地理慢度。

最后，对于基础设施，您可以使用它来识别在主机上运行的高噪声邻居，这些邻居会从其他应用中消耗资源，配置更改会导致性能下降版本审计。

所以零日漏洞检查，确保罪犯的变化通过，或只是错过配置与您的 DNS 使您的应用程序无法访问。

这是一个列表，列出了你们认为可以通过开放式遥测检测到的问题。

现在我们已经讨论过了，让我们继续我们的项目。

在课程的这一部分，我想向大家展示当你构建一个具有更复杂的后端处理两种服务的应用程序时会发生什么。

这是一个假设的项目，你可以适应任何你想要的东西，这是一个为你的数据库获取电影的应用程序。

到项目结束时，你将能够准确地追踪我们是如何得到这些电影的，以及每一步花了多长时间。

好的，这是我预先做的一个项目，感谢开源社区，灵感来自一个开放的遥测贡献者，艾伦·斯托姆。

这是一个包含两个服务的项目，其中一个服务依赖于另一个服务，而不是相反。

在这个项目中，我有一个主要的仪表板服务，以及电影服务，这将返回我们的应用程序的所有电影。

这个项目的布局类似于我们在跟踪设置中所做的。

然而，代码直接在每个文件中，而不是有一个单独的跟踪 js 文件来跟踪每个服务。

如你所见，每个服务都在我们项目的根中。

我们将把它最小化，这样我们就可以更好地看到代码了。

所以从我们的课程开始，这应该看起来很熟悉。

提醒一下，开放式遥测要求我们实例化一个跟踪提供者，用导出器配置该跟踪提供者，并安装开放式遥测插件来装备特定的节点模块。

让我们通过代码来讨论。

因此，我们可以将此视为复习，特别是因为它的组织方式与我们在基本实现中看到的不同。

首先，我们将从开放式遥测节点包中获取节点跟踪提供程序。

跟踪提供程序将帮助我们在 no Jess 上创建跟踪。

接下来，我们将从开放的遥测跟踪包中获得控制台跨度导出器和简单的跨度处理器。

然后我们需要从开放遥测导出器 zipkin 包中获取 zipkin 导出器。

既然我们有了必要的东西，让我们继续。

所以目前我们做了一个寻人程序。

如果你还记得的话，为了实际生成跨度，我们安装了一个名为 Open telemetry plugin dash HTTP 的插件，node a trace provider 对象足够智能，可以注意到插件的存在并加载它。

这段代码创建了一个跟踪提供程序，并向其中添加了一系列处理器。

跟踪处理器需要导出程序。

所以我们也实例化了它。

两者都负责将遥测数据从您的服务中取出并放入另一个系统。

使用这段代码，我们创建了一个导出器，然后在创建 span 处理器时使用该导出器，然后将该垃圾邮件处理器添加到我们的跟踪提供程序中。

这就是这段代码的作用。

让我们实际命名我们的服务。

现在，我把这个留白了。

所以让我们继续填写。

因为这个服务将处理主服务，所以我将把它称为仪表板服务。

这里我们实例化了一个 zipkin。

导出器，然后将其添加到跟踪提供程序中。

我们当然需要从包裹快递中得到快递。

一台服务器，监听一个四端口连接上的端口 3000。

该应用程序目前不会对任何部分的请求作出任何回应，因为我们还没有写任何东西。

我想用仪表板本身和电影服务中的电影来响应。

但在此之前，我们需要构建我们的电影 js 文件。

因此，这个文件与另一个文件完全相同，只是可能在不同的地方有一些代码。

使用不同的端口。

在这个文件中，我想处理电影。

因此，我将把这个服务名称重命名为 movies service。

如果我运行这个服务，我们将监听端口 3000。

现在，我将确定我们的应用程序如何响应对电影端点的 get 请求。

所以我只需要向上写，得到，然后我只需要把电影路径。

所以我编了这个。

这是一个异步函数，我将传递一个请求和响应。

好了，我们开始吧。

然后我将把 rest 类型 Jason 作为一个字符串。

回应是，派杰森·史特林吉菲去。

我将发送一个电影对象，比如说，一个电影数组。

让我们在数组中放一些对象，我要让数组包含电影对象。

每个电影对象都有一个名字。

所以像大白鲨这样的名字，一个流派。

例如，《大白鲨》是一部惊悚片，这是我的第一个目标。

然后我会快速制作另一个物体。

这一次，让我们放一个不同类型的电影。

所以我就把 Ani 的字符串，再一次，我们放一个流派。

所以我只是用不同的名字和类型制作了同一个电影对象。

我要把家庭放进去，再做一个对象。

我将在这之后停止，因为这仅仅是为了说明的目的。

让我们把侏罗纪公园作为名字，让我们把动作作为类型。

好吧，就这样。

这是由三个电影对象组成的数组。

好了，现在让我们运行我们的应用程序。

因此，让我们实际上去本地主机 3000，并把电影的路径。

所以我现在要做的是请求 URL。

当然，我们的应用程序会监听它并进行追踪。

现在让我们转到 zipkin UI 并搜索最近的跟踪，我们将看到我们记录了一个服务跟踪。

但是，如果我们仔细查看跟踪细节，我们会发现这些跟踪看起来不像我们以前看到的跟踪。

在我们前面的例子中，一个 span 相当于一个服务。

然而，跨度只是与其他时间跨度相关的时间跨度，我们也可以使用跨度来度量我们服务的任何单独部分。

Express auto instrumentation 插件创建了测量 Express 框架中的动作的跨度，我们可以使用它来找出每个中间件执行了多长时间，您的 Express 处理程序执行了多长时间，等等。

它不仅能让你了解整个服务的情况，还能让你了解快递系统的各个部分。

这是大多数合同插件在开放遥测项目中扮演的角色。

核心插件关心的是确保每个请求都绑定到一个单独的跟踪。

但是契约插件将创建特定于特定框架行为的跨度。

好极了。

让我们继续。

现在，我们已经完成了这项工作，我想向大家展示如何使用开放式遥测技术来为分布式系统提供仪器。

这就是我们的 dashboard js 文件的用途，本质上是希望我的 dashboard js 文件也调用电影服务。

所以让我们开始写代码吧。

我要做的第一件事实际上是使用我们还没有安装的节点获取库。

所以这个服务，使用节点获取库来调用我们的电影服务。

让我们继续安装它。

因此，我将使用我的终端，键入 NPM I 进行安装和节点批处理。

好的，现在，我要再次键入 apt get，然后使用 dashboard 的路径，然后写入异步函数，这是一个病态函数，并传递请求和响应。

现在我要在这里写，我需要从第二个服务获取数据。

这就是电影服务。

我会写一些伪代码来提醒我们，从第二个服务获取数据，我的第二个服务是电影服务。

好了，现在，我要写一个函数，它将帮助我们从电影服务中获取所有的 URL 联系。

所以本质上我们的对象在一个数组中有三个电影或者电影对象在一个数组中。

让我们开始写这个函数，我要写这个函数并传递两个参数。

所以每当我把一个 URL 传递给这个函数和一个 fetch，fetch 实际上会使用我们的节点 fetch 库，然后我会使用这两个参数来获取这个 URL 的主体。

所以我要用一个承诺来做这个新的承诺，我要通过 resolve 和 reject。

然后我将使用 fetch 来获取 URL。

然后不管正文里是什么，我都要用，获取 URL，解析 reject，然后是 Russ，Russ text，然后是 body。

这就是我获取 URL 内容的函数。

让我们开始使用它。

好吧，我要把它改一下。

我不喜欢这样写。

我想让它和底部保持一致。

所以我要改变一下。

所以看起来更整洁一点只是编写函数的不同方式。

所以这是一致的。

好吧。

所以再一次，让我们回到我之前写的代码。

在这里，我将从第二个服务中获取数据。

因此，电影服务，我将实际上保存的内容作为电影的网址。

所以 const movies，等待并使用我们预先写好的函数来通过 URL。

所以我们要获取内容的 URL 是 HTTP localhost 3004 斜杠电影。

所以我们走吧，这是 ju L。

这是我在这里写的相同的网址。

所以 URL U，r，l，这就是我们所做的。

然后我将需要请求节点获取。

因此，我将浏览 right require 和包节点 fetch，我将放置 rest 类型 Jason，rez 发送 Jason stringify。

现在我要写 dashboard 这个词。

好的，我正在制作一个对象，我将编写 dashboard，然后我们保存为电影的任何内容都应该显示在这里。

所以本质上，URL 的内容会显示在这里。

好了，现在我不能运行这个文件了。

所以我可以运行这个文件，但是我们会看到一个错误。

这是因为我们的文件依赖于正在运行的电影服务。

我现在要展示给你们看，我要输入节点仪表板，j。

南

所以它在本地主机 3001 监听。

但是，如果我访问 slash dashboard 的 localhost 3001，我会得到一个错误。

这是因为我们需要我们的电影服务运行。

所以让我们继续前进，让这成为现实。

我将打开一个新选项卡，键入 node movies j s。

好吧，这不是运行和监听端口本地主机 3000。

现在，这是我们的电影。

让我们刷新或重新运行控制面板。

所以再一次，节点仪表板，j . s。

然后刷新我们的页面。

令人惊奇的是，我们将看到我们的 dashboard 对象，其中包含来自 Ford slash movies 路径的 URL 的内容。

太神奇了。

所以这很好。

我们的代码工作正常。

现在，让我们看看这在我们的 zipkin UI 中是什么样子。

所以我将重新运行查询并查看我们最新的。

我们开始吧。

因此，再次重申，简而言之，仪表板服务依赖于电影服务来填充它。

对于今天你所接触的许多应用程序来说都是如此，这也是为什么我想在我们的项目中向你展示这个例子的原因。

现在，我们可以看到，服务的每个跨度都连接在一起。

opentelemetry HTTP 插件为我们解决了这个问题，节点获取插件使用节点 j、s、HTTP 和 HTTPS 的底层功能来发出请求。

这就是如何使用开放式遥测技术对应用进行检测。

这很酷，因为很明显，你可以看到我们的仪表板服务，然后你可以看到它的确切时间去获取电影，服务，然后回来。

好了，我们的项目到此结束。

我希望你喜欢这一部分。

当然，这只是你所能做的表面工作。

还有很多事情要做。

但是，在您掌握基础知识之前，我真诚地希望您能够一遍又一遍地学习这门课程，直到您能够更轻松地构建自己的项目。

到目前为止，在这个项目中，我们直接从一个应用程序中获取数据，并将数据发送到 zipkin。

但是，如果我们想尝试将它发送到另一个后端来处理我们的遥测数据，会发生什么呢？这是否意味着我们必须重新测试整个应用程序？好吧，开放遥测技术的惊人贡献者们已经想出了解决这个问题的办法。

开放式遥测收集器是开发人员接收过程并将遥测数据导出到多个后端的一种方式。

它支持像 zipkin、Jaeger permittees 或 flume bit 这样的开源可观测性数据格式，将其发送到一个或多个开源或商业后端。

在下一节中，我将向您展示如何使用它。

好的，在这一节，我们将使用新遗迹作为我们的观测工具。

我要做的就是去新遗迹注册。

接下来，你会看到一些问题，请尽你所能回答这些问题。

举个例子，在你储存数据的地方，只要点击保存，你的账户就会建立起来。

一旦你到了这一页，我会要求你现在不要和任何东西互动，直接去新 relic.com 的一个点。

在这里，我将要求您进入您的个人资料下拉菜单，然后单击 API 密钥。

在这里，我将要求您创建一个新队列，并选择“摄取许可证”。

我将把这个例子命名为 otol。

我会给它一些注释，这样我们就可以跟踪我们的 API 键了。

太好了，我们的 API 密匙现在已经创建好了。

让我们复制它，然后继续前进。

接下来我们要做的是打开遥测采集器。

为此，我将前往 New Relic GitHub 帐户，在那里我可以获得公开的遥测示例。

因此，我将要求您将此回购克隆到您的本地计算机中。

我已经这样做了。

所以我现在就去那个回购处。

这就是了。

在这里，我将要求你导航到收藏家和我们的出口商 Docker otol 配置莫亚文件，因为我们将不得不改变这一点。

所以请马上过来。

我会让你添加一小段代码。

这一行代码将添加 zipkin 作为接收器，接收器知道数据进入开放的遥测收集器。

因此，因为我们已经将我们的应用程序配置为使用 zipkin，我们将告诉开放式遥测收集器嘿，我们将以 zipkin 的形式向您发送数据。

这就是正在发生的事情，我们将 zipkin 添加为接收者，然后给它一个端点，在本例中是 0.0 点 09411。

现在，因为 zipkin 报告跟踪数据，我们将在服务下添加 zipkin 作为跟踪接收者。

仅此而已。

我们需要做的下一件事是转到 Docker compose 莫亚文件，并确保运行这个开放式遥测收集器的 Docker 容器实际上能够通过与 zipkin 相同的端口接收数据。

因此，我们将添加端口 9411，就像这样并保存它。

现在，根据 readme 来运行它，我们需要使用我们刚刚创建的 API 键。

因此，在我的终端中，我将使用这个命令导出我刚刚创建的新 Relic API 密钥。

接下来，我们需要用这个命令启动 Docker 容器，当然要确保我们在正确的目录中。

所以那是我的错。

让我们进入目录。

所以 nr 出口商码头工人。

我们再次运行 Docker 容器。

很棒。

现在让我们回到我们在本课程中一直致力于的电影仪表板项目。

因此，现在我只需要修改我们的应用程序，第三，与开放的遥测收集器。

要做到这一点，我们需要改变两件事，我们需要改变报告的 URL。

这里的这个，我就这样简单地使用它。

所以我们需要做的是仪表板和电影服务。

仅此而已。

现在，我将为那些刚刚加入我们的人重新安装所有的依赖项，我已经从下面的描述中选择了这个项目。

然后让我们运行这两个服务，就像我们之前在本教程中所做的那样。

太棒了。

好了，现在我将通过访问仪表板服务来调用服务。

提醒一下，dashboard 服务依赖于 movies 服务，我将多次调用它，这样我们就可以获得大量的数据。

所以也许再多几天。

好了，搞定。

我们继续吧。

现在，我们已经有了我们的应用程序，并成功地装备了开放式遥测收集器，该收集器将我们的数据转发到 New Relic，我们现在应该能够可视化我们的数据。

为此，我们需要去新遗迹的浏览器标签。

在这里，我们将看到两个服务，仪表板服务和电影服务，就像前面的分布式跟踪部分一样。

让我们继续深入。

正如您在仪表板服务中看到的，这是一个峰值。

让我们看看发生了什么事。

因此，看起来仪表板服务有 18 个跟踪，9 个跨度和两个实体。

听起来没错。

太好了。

如果我们深入挖掘，您将看到我们的仪表板服务正在与之通信的微服务，以实际解决最终结果。

太棒了。

正如你所看到的，我们可以获得大量令人惊叹的数据来做一些事情，例如分析应用程序中可能出现问题的根本原因，检查微服务的性能，等等。

好了，我们知道了。

这是我们的开放式遥测课程，在结束之前，我想花点时间回顾一下我们在本课程中学到的内容。

概括地说，在本课程中，我们学习了如何为项目设置后端。

然后我们学习了如何在我们的项目中实现跟踪，如果需要的话，还有度量标准。

然后我们还看了两种服务以及它们如何通信。

多亏了分布式跟踪。

我希望您现在已经了解了使用开放式遥测技术的好处，并且很好地理解了如何在 Node JS 项目中实现它。

如果你想知道下一步该何去何从，我建议你学习一下基础设施监控和数字体验监控。

这是另外两种对整个软件体系进行可视化、分析和故障排除的方法。

我会留给你这个和一个链接到新的遗物，以了解更多，并获得一个没有到期日的免费帐户。

再次感谢您的收看，我们稍后再见