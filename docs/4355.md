# 代码如何变成垃圾场(以及如何修复它！)

> 原文：<https://www.freecodecamp.org/news/fixing-code-dumping-grounds/>

在我职业生涯的早期，我面临着某种职业危机。

我是在汽车行业创建大型分析平台的团队的一员。该应用程序具有您所期望的典型的“企业 y”分层架构(“业务层”、“数据访问层”、“核心”等)。).

您可能会期望在这些层的代码中找到嵌入的业务逻辑——真正重要的业务逻辑。但是，通常，真正重要的业务规则被编码到存储过程中。

**存储过程**，如果你不知道的话，就像你在数据库内部创建的一个函数，使用类似 SQL 的语法来处理数据，存储数据，等等。

我想知道这些层的目的是什么。除了向存储过程传递数据或显示存储过程返回的数据之外，他们没有任何代码。

我开始学习更多关于面向对象编程、行业最佳实践、SOLID、其他编程范例、应用程序架构等的知识。

从这次职业危机中，我发现这些问题早就解决了！只需要研究、时间和实践来学习和熟练掌握它们。

## 面向对象？

我发现的一件事是，我参与的所有进行“面向对象”编程的项目都不是真正的面向对象。你使用类并不意味着你在做 OOP。尤其是当您使用存储过程对所有业务规则进行编码时。

### 简短的旁白:大辩论

需要提出来:面向对象编程好还是函数式编程好？

首先，大多数人不明白 OOP 最初的目的是什么。类似于当今敏捷通常被误解的方式(例如，仅仅因为你每天都有脱口秀，使用故事点，看板等等。不代表你在做敏捷)。

艾伦·凯被认为是 OOP 之父之一。在一封电子邮件中，他坦率地解释了 OOP 应该是什么。

> “我认为对象就像生物细胞和/或网络上的单个计算机，只能与消息进行通信(所以消息传递从一开始就出现了——花了一段时间才明白如何用编程语言足够有效地进行消息传递)...

> 对我来说，OOP 只意味着消息传递、本地保留、保护和隐藏状态流程，以及所有东西的极端后期绑定...

> 但是，为了说明一个想法是多么顽固，在整个七八十年代，有许多人试图通过“远程过程调用”来解决问题，而不是考虑对象和消息。"

对于那些熟悉微服务、actor 模型和其他高级编程范例的人来说，你的蜘蛛侠感觉很兴奋。这些其实和真正的 OOP 更紧密相关。

那么，FP 比真正的 OOP 好吗？

我不这么认为。我觉得两者都有可取之处。今天，许多语言都包含这两种范式，并允许开发人员使用最适合给定问题的工具和方法！

您通常会发现公开了所有属性或内部数据成员的类。一个 HTTP 请求或数据库查询将填充所有属性，然后，可能会有其他东西对该对象的数据起作用。

Alan Kay 并不打算将对象作为互相传递消息的小“包”(见上文)，大多数开发人员只是将对象作为“数据持有者”。可以说是美化了的变量。

你还会在许多代码库中发现非常通用的类，如`User`、`Customer`或`Order`。

很糟糕吗？嗯，**是的**。

让我问你一个问题:

在你的应用中,`User`是否被用在许多不同的不相关的地方？

例如，您的`User`类是否用于代码的计费部分、用户配置文件部分、运输部分等。？

大多数系统都在做类似的事情。

最终会发生的是，因为这些类是如此的通用，它们成为了我们不知道它属于哪里的代码的垃圾场。

我们没有花时间去考虑我们编写的新代码的业务需求，而是经常觉得把它放入我们的泛型类更容易。都是可以分享的吧？我们都是关于代码重用的，对吗？

## 连接

因此...如果我更改了`User`类以符合一些计费逻辑会怎么样？通过改变这个类，我破坏了运输特性的可能性有多大？不知道，但是高于 0%的**。**

这个`User`类将你所有的特性结合在一起。这导致了许多问题。

理想情况下，我们希望我们的代码是正交的(这只是一个花哨的词，意思是在一个地方更改代码不会影响其他不相关的地方)。

例如，我们希望能够改变运输特性，并且**不必再次测试我们的整个应用程序。**但是，如果我们到处共享我们的`User`类，为了确信我们没有破坏东西，我们需要重新测试**所有东西。**

这导致了对改变代码的恐惧。害怕让我们的代码变得更好。也导致了很多 bug。

如果你正在为你的应用程序构建支付功能，你不应该考虑你是否同时破坏了运输功能！这造成了不需要的巨大认知负荷。

### 另一个旁白:警告标志

总的来说，我发现通过不同的物理文件夹甚至完全不同的项目来分割你的业务特性/功能的想法是最好的。[我在](https://dev.to/jamesmh/the-life-changing-and-time-saving-magic-of-feature-focused-code-organization-1708)之前写过这个。

但是，当涉及到更深层次的代码时，我们仍然倾向于以一种过于一般化的方式来设计我们的类和对象，从而导致更多的耦合。

每当我发现名字简单的类，比如`User`或`Customer`，就会发出警告信号。我更希望看到为特定上下文创建的类。

例如，如果我看到一个名为`UserForAuthentication`或`PaymentsCustomer`的类，那么我会更加确信这些类不会在太多的上下文中被丢弃和重用。

这里有一个基本的方法可以帮助你开始分析你的类。取你的班级名并回答这些问题:

有主题吗？(用户、客户、订单等。)

这个主题有背景吗？(运输、订单、仪表板等。)

甚至有可能对这个主题采取行动吗？(我们很快会看到更多细节)

如果你不能回答其中的两个问题，那么我会说你的课程很有可能因为过于一般化而做得太多了。

## 这些东西中的一个和其他的不一样

有一个编程原则叫做单一责任原则。

当查看做得太多的类或方法时，使用 SRP 作为指路明灯可以帮助我们使代码更容易维护，耦合更少，从而导致更少的错误。

让我们来看一个通用的`User`类，它可能类似于您以前见过的代码:

```
class User {
    public firstName: string;
    public lastName: string;
    public id: number;
    public jwtToken: string;
    public homeAddress: string;
    public creditCardNo: string;

    public getFullName(): string {
        return this.firstName + " " + this.lastName;
    }

    public decodeJwtToken(): string {
        return decode(this.jwtToken);
    }
} 
```

眼熟吗？

给定这个类的名字，我们应该开始怀疑它是不是太通用了。

## 你有邮件

您的任务是添加一项新的业务需求。我们需要用户能够使用贝宝支付他们的产品。

这个`User`类已经在很多地方使用，比如用户资料、运输和支付功能。

我们需要做的只是将用户的 PayPal 电子邮件地址添加到用户中。对吗？

## 分开它

通常，你会得到新的业务需求，需要对你的代码进行比这更多的修改。但这是一个简单的例子。

如果我们开始改变这个`User`类，使其与支付功能一起工作，那么我们就冒着影响用户档案或运输功能的风险(因为他们也使用这个类)。

我们做什么呢

这里最好的做法是*创建一个不同的用户类，在每个特定的上下文中使用。*

由此应该会产生像`UserForAuthentication`、`UserProfileUser`、`ShippingUser`和`PaymentUser`这样的类。

那些模型/类会包含所有模型/类都需要的相似的数据吗？当然可以。

他们是否也有只在一种环境中使用的数据？当然可以。

比如到处都需要用户的`id`。

但是，用户的家庭地址只在运输时需要。那么，为什么支付功能需要访问这些数据呢？并没有。

这些类可能是这样的:

```
class UserProfileUser {
    public firstName: string;
    public lastName: string;
    public id: number;
    public homeAddress: string;

    public getFullName(): string {
        return this.firstName + " " + this.lastName;
    }
}

class ShippingUser {
    public id: number;
    public homeAddress: string;
}

class UserForAuthentication {
    public id: number;
    public jwtToken: string;

    public decodeJwtToken(): string {
        return decode(this.jwtToken);
    }
}

class PaymentUser {
    public id: number;
    public creditCardNo: string;
} 
```

## 把不同的东西分开

请注意，`UserProfileUser`和`ShippingUser`需要家庭地址。很糟糕吗？

我们已经被灌输了太多，复制代码是一件坏事。以至于，正是这种想法导致了我们现在正在谈论的问题！

有时，最好“复制”代码和/或数据——如果它们在不同的上下文中。同样，我们希望避免将我们的特性和类耦合在一起。

让我问你一个问题:

*用户个人资料中家庭住址的行为是否可能不同于配送功能中的行为？*

答案:**是的。**

那么，我们在谈论两件不同的事情。同样的原始数据，但**不一样的业务功能或概念** *。*

运输需要家庭地址，这样它就知道把产品送到哪里。

用户配置文件需要家庭地址**,这样用户就可以从 UI 中更新它的值。**

*不一样的东西。*

此外，考虑向`PaymentUser`类添加一个地址也是有意义的。但是，这个上下文应该与 shipping 共享同一个地址吗？

嗯，有没有可能你的送货地址和你的收单地址不一样？当然可以！这种事经常发生！

使用单一责任原则，我们看到这两个概念/责任应该分开。

此外，请注意，我们的大多数数据片段都是被共享的，而不是被共享的。例如，JWT 令牌仅在认证用户时需要。为什么我们需要在我们的运输特性代码中包含这些数据呢？

现在，这些信息是孤立的。

此外，任何作用于该数据的方法也将被移动，不会被另一个特性的代码不恰当地调用。

这是一个简单的例子，在大多数情况下，这可能比我们想要的要复杂一些。不过，最终，将不同的业务概念彼此分开会使您的代码在特定的上下文中更容易理解，更容易维护，并且更不容易出错！

这是摘自我的书[“重构类型脚本:保持你的代码健康”](https://leanpub.com/refactoringtypescript)。本书的这一部分有**更多的**技巧来帮助你处理这类垃圾场。如果你喜欢这篇文章，那么[看看这本书，了解更多类似的内容！](https://leanpub.com/refactoringtypescript)

你也可以在推特上和我联系。