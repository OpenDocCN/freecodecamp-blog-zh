# 可靠软件系统的设计方法:学术文章摘要

> 原文：<https://www.freecodecamp.org/news/a-design-methodology-for-reliable-software-systems-a-summary-394dfd0dcbc2/>

让我们深入研究芭芭拉·利斯科夫在 1972 年发表的可靠软件系统的设计方法。

本文的重点是如何开发可靠的软件系统以及帮助我们实现这一目标的技术。

这里的可靠性意味着系统在给定的一组条件下按预期工作。

> 不幸的事实是，构建
> 系统的标准方法，包括大量的调试，在生产可靠的软件方面还没有被证明是成功的，也没有理由认为它会成功。

> 尽管调试技术的改进可能会导致检测到更多的错误，但这并不意味着所有的错误都会被发现。

> 调试中当然不能保证这一点:正如 Dijkstra 所说，“程序测试可以用来显示错误的存在，但永远不能显示它们的不存在。”

为了确信我们的系统工作正常，我们需要满足以下条件的测试:

1.  我们可以生成相关测试用例的最小集合。
2.  可以生成集合中的所有测试用例。

> 这些问题的解决方案不在调试领域，因为调试无法控制问题的根源。

> 相反，因为是系统设计决定了有多少测试用例，以及它们有多容易被识别，所以问题可以在设计过程中被最有效地解决。彻底测试的需要必然会影响设计。

该论文进一步论证了可靠性是复杂系统的一个主要问题。它接着将复杂系统定义如下:

1.  系统有许多状态，很难组织程序逻辑来正确处理它们。
2.  它需要几个人以协调的方式一起工作。

### 优秀设计的标准:

为了驯服复杂系统的设计，我们需要使用模块化。

将程序分成几个模块(子程序，在本文中称为分区，以避免“模块”一词过载)，这些模块可以单独编译，但与其他模块相连。

Parnas 对连接的定义如下:

> 模块之间的连接是模块对彼此的假设。

尽管模块化的思想听起来像是构建大型复杂软件系统的一个很好的工具，但是如果做得不好，它会引入额外的复杂性。

> 模块化的成功直接取决于模块选择的好坏。

一些常见问题是:

1.  一个模块做了太多的事情。
2.  一个公共功能分布在许多不同的模块中。
3.  模块对公共数据的行为异常。

下一个问题是:什么是好的模块化？

我们使用两种技术来回答这个问题:处理系统固有复杂性的抽象层次，以及用软件表示设计的结构化编程。

#### 抽象层次:

> 抽象层次…为系统实现清晰的逻辑设计提供了一个概念框架。整个系统被认为是一个层次结构，最底层是那些最接近机器的层。

一组相关的功能构成了一个抽象层次。每个级别可以有以下两种类型的功能:

1.  外部:这些函数可以被其他级别的函数调用。
2.  内部:这些函数在该级别中执行一个共同的任务，不能被不同级别中的其他函数调用。

抽象级别由以下两条规则控制:

1.  每个级别都对某种资源拥有独占控制权。
2.  较低的级别不知道较高的级别，也不能以任何方式引用它们。但是，较高的级别可以要求较低的级别来执行某个操作。

#### 结构化编程:

结构化程序定义了控制在系统中不同分区之间传递的方式。

它由以下规则定义:

1.  该程序采用自上而下的格式开发，分为不同的级别。这里的层次概念不同于抽象层次的概念，因为第一条规则没有得到满足。
2.  只能使用以下控制结构:串联、基于条件测试的下一条语句的选择
    、
    和迭代。不允许使用`goto`跳跃。

回到之前提出的问题:**我们如何定义好的模块化**？

在同样可靠的模块化系统中，分区之间的连接受到如下限制:

1.  他们需要遵循抽象层次和结构化编程所强加的规则。
2.  应该使用显式参数在分区之间传递数据。参数被传递给另一个分区的外部函数。
3.  分区在逻辑上应该是独立的。分区内的函数应该只支持自己的抽象

*在我们弄清楚如何定义好的模块化之后，下一个问题是— **我们如何在设计中实现它**？*

> *传统的模块化技术是分析系统的执行时流程，并围绕每个主要的顺序任务组织系统结构。*

> *这种技术导致在控制中具有非常简单的连接的结构，但是在数据中的连接往往是复杂的。*

*分区支持抽象，系统设计人员在考虑系统时会发现这些抽象很有帮助。*

> *引入抽象是为了使系统正在做的事情更清晰、更容易理解；抽象是一种概念上的简化，因为它表达了正在做什么，而没有具体说明是如何做的。*

*然后，本文提出了一些在设计系统时识别不同类型抽象的指导方针:*

1.  *资源的抽象:对于系统上的每个硬件资源。我们可以将抽象资源的特征映射到底层资源。*
2.  *数据的抽象特征:它是如何存储的。*
3.  *通过限制分区需要知道或有权访问的信息进行简化。*
4.  *通过识别执行共同任务的功能，通过概括实现简化。这样的功能可以被组合在一个分区中。这种组的存在简化了其他分区，这些分区只需要调用较低分区的功能，而不需要自己执行任务*
5.  *系统维护和修改:执行某项任务的功能，其定义在将来很容易改变，应该是独立分区的一部分。例如，处理连接到特定类型的存储后端的功能，这样，如果将来使用不同的后端，只有该分区中的功能会受到影响。*

*既然我们对如何在设计系统时实现良好的模块化有了一些想法，**我们该如何继续呢**？*

*第一阶段是确定一组抽象，这些抽象以一种通用的方式表示系统的最终行为。下一阶段“建立分区之间的数据连接，并描述分区之间的控制流”。*

> *第二阶段与第一阶段同时发生；当抽象被提出时，它们的效用和实用性立即被研究。*

> *当一个分区与系统其余部分的连接是已知的，并且当设计者确信他们确切地理解了它对系统的影响时，这个分区就已经被充分地研究过了。*

*下一个问题是:**我们如何确定设计何时完成**？*

1.  *所有主要的抽象都已经被识别并链接到一个分区。系统资源已经被划分到不同的分区中，并且它们在层次结构中的位置已经被定义*
2.  *分区之间的接口和控制流被清晰地定义。每个分区的测试用例已经被识别*
3.  *可以编写系统的基本用户指南*