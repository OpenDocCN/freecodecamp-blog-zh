# 代码重构最佳实践 Python 示例

> 原文：<https://www.freecodecamp.org/news/best-practices-for-refactoring-code/>

在这篇文章中，我将讨论什么是代码重构。我们将回顾为什么需要重构代码，代码重构的优点，以及一些代码重构的最佳实践。

## 什么是代码重构？

重构意味着在不修改代码原有功能的情况下组织代码。重构是在不影响或改变代码在使用中的功能的情况下，对代码进行小的更改或调整的过程。

## 为什么需要重构代码？

### 它有助于改进您的代码/程序

重构有助于改进软件的设计，因为开发应用程序是一项艰巨的任务。当您添加额外的功能时，程序的相关性可能会受到影响。然后，抽象不再像以前那样纯粹。

您可以通过定期重构代码来改进工作，从而更好地理解您正在使用的程序或代码。

### 它让您更好地理解代码

如果你适当地重构，你的代码以后会更容易理解。你也可以通过改进设计让代码更容易理解。

众所周知，开发人员阅读代码的频率远远高于他们编写代码的频率。因此，尽可能保持简单最符合您的利益，这大大提高了可维护性。还有，以后看了的人会感恩。

### 重构拓宽了你的知识面

最后，重构是一种主动学习的方法。即使你没有写代码，重构它也能让你更好地理解它做了什么。

## 重构如何帮助你的团队

重构是软件开发团队的常见活动。如果做得正确，重构代码会让团队成员更容易理解您的代码和您所做的更改。

团队通常很难将重构阶段包含在他们的过程中。但是在我看来，重构是任何过程中必不可少的组成部分。对我来说，添加注释意味着让代码处于比我发现它时更好的状态。

无论您做什么，都要避免在技术价值和商业价值(创建特性)之间建立分离。你可以通过保持代码的可理解性来做到这一点。

## 重构最佳实践 Python 示例

如果您想从代码重组中获得最大的好处，您应该记住以下几点:

*   只重构测试过的代码。没有测试，重构代码，说白了就是赌博。如果您没有测试来验证 before 和 after 是否等价，您就不能确定您没有破坏代码。不管你有多自律，最终，你都会引入错误。
*   最小化重构。变化越剧烈，风险就越大。把它分成几个更紧凑的部分。你得到了灵活性和缓解。
*   循序渐进。在做了一个小的代码更改后，检查一下是否一切正常。
*   请遵守指南。重构还在进行时，不要开始添加功能。重构对系统的输出没有影响。在进入下一个挑战之前，完成这个挑战。

下面是一个代码重构的例子，使用 Python 中的 **Define 函数**来寻找移动一个质量为(m)的物体所需的力(F)，加速度(a)由公式“F = m x a”给出。

因为我们正在执行一个重复的任务，所以使用函数而不是只使用条件语句是一个好主意。因此，当我们将来需要时，我们只需调用该函数即可。

### 重构前的代码:

| #使用力公式 F = ma    whileTrue:  mass = int(input(【输入质量值: ))  如果>0  破  而 真    如果 加速度>0:  破打印( 【原力是】 |

请注意这两块积木看起来几乎一模一样。如果我们在计算一个人或一台机器所做的“功”呢？最有可能的是，我们复制并粘贴 while 循环，改变变量名和输入提示。现在让我们用一个函数来重构它。

### 重构后的代码:

| #重构代码    definput _ 正整数 (提示):  whileTrue:  input _ value |

现在我们的代码更容易理解了，我们可以开始保存一些代码行了。更重要的是，在未来，我们将能够毫不费力地将我们的函数插入到另一个脚本中，只需调用该函数，从而节省我们的时间。

以下是重构 Python 代码时需要记住的其他一些技巧:

### 使用列表理解代替 For 循环

最著名的 Python 构造之一是列表理解。与几个基本的 for 循环相比，列表理解提供了一个更干净、更快速的解决方案。

代码会运行得更快，现有的数据不会被改变，一旦你习惯了，列表理解会更容易理解。

下面是一个使用列表理解代替 For 循环的简单表达式:

初始代码:

| #列表理解代替 For 循环    numbers =【1，2，3，4，5，6，7，8】  odd _ numbers =  Foritemnumbers:  |

在上面的例子中，我们循环遍历一个整数(数字)列表，看看是否应该将每个整数输入到奇数列表中。

重构代码:

| 数字=1， 2 ， 3 ， 4 ， 5 ， 6 ， 7 ， 8 奇数 _ numbers =【itemforiteminnumbersifitem %2】= =1 |

在上面重构的代码中，列表理解是对奇数的赋值。然后我们迭代“数字”并设置返回(第一项)。然后，我们可以包含一个 if 语句来过滤。

### 对重复性任务使用 Def 函数

为重复性任务定义函数是我们可以执行的第一个，也可能是最重要的重构。

尽管函数提供了许多优势，但从重构的角度来看，我们将缩短代码并增加可读性。此外，您只需在函数声明中更新作业一次(如下例所示)。

初始代码:

| #利用做功完成表达式 W = f * d    whileTrue:  force = int(输入( 【输入力值: )  若 力>:  破  而 真:    如果 距离>0:  破打印( 《功成则》 |

重构代码:

| #重构代码    definput _ 正整数 (提示):  whileTrue:  input _ value  if0:  return force = input _ 正整数()输入力值:“” |

### 使用三元运算符代替 if-else 语句:

您可以使用一个简单的 if 语句来确定输入的整数是“偶数”还是“奇数”,而不是 if-else 语句:

| #使用三元运算符    to _ check = int(input()  msg =【偶数】ifto _ check %2= 【数字】)      【使用通常的 IF-ELSE    to _ check = int(input(【输入整数】:  msg = if【to _ check %=0:  msg = |

上面的代码中使用了三元运算符来确定一个整数是偶数还是奇数。

如果条件(to_check% 2 == 0)为真，则将为`msg`赋值`Even`。如果条件(检查% 2 == 0)不成立，`msg`也将被赋值`Odd`。

注意:您不能使用三元运算符来替换任何使用 if-else 表达式的代码。比如涉及两种以上情况的 if-else 语句。

### 使用 Enumerate 函数而不是 Range():

Python for loops 可能很复杂，尤其是如果您来自另一种编程语言。

最初，您可能会想到创建一个索引变量，并用它来遍历您的列表。因此，人们经常找到并利用 range()方法。但是使用这种方法并不是最佳实践。下面是一个例子:

重构前的代码:

| colors =【白色】【黑色】【棕色】 为在 范围内(len(colors)):  print(I+ |

在初始列表上使用索引会使理解变得更加困难，并鼓励像改变原始值这样的坏习惯。尤其是在复杂的嵌套数据结构中。

此外，我们需要手动将索引值更改为“计数”

重构后的代码:

| colors =【白色】【黑色】【棕色】 为 i，colors中的 枚举(colors，1):  |

enumerate()方法返回当前计数器值和 iterable 中的每一项，并需要两个参数:iterable 和初始计数值。

注意:在 for 循环中首先对临时计数变量排序，然后在函数调用中对初始计数值排序，这是一个典型的错误。

## 结论

希望您现在已经理解了什么是代码重构，以及重构代码的重要性和原因。

基于上面简单的 Python 代码，你应该明白重构并不一定意味着你的代码需要在重构后变得更短——只是某种程度上更简单和更容易理解。