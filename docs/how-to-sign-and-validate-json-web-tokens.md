# 如何签署和验证 JSON Web 令牌——JWT 教程

> 原文：<https://www.freecodecamp.org/news/how-to-sign-and-validate-json-web-tokens/>

自从我开始学习 JSON Web 令牌以来，我一直想知道我们如何验证它们。

我知道我们签署了令牌，并且我们使用签署的令牌来验证它的真实性。但是我仍然很想知道更多，想知道为什么我从来没有详细了解过这个过程。

我希望这篇文章能帮助您理解签名 JWT 是如何工作的，以及如何验证签名的令牌。

## 什么是 jwt？

在开始之前，让我们快速回顾一下什么是 JSON Web 令牌。

JSON Web 令牌(或 JWT)是一种在双方之间传输数据的紧凑、URL 安全的方式。

它们由开放标准(RFC 7519)定义，通常由三个部分组成:报头、有效载荷和加密部分。

JWT 在生成时被签名，同样的签名 JWT 在接收时被验证，以确保它没有在传输中被修改。

关于 JWT 的更详细的介绍，我推荐你阅读我在 [JSON Web Token (JWT)上的博客以及我们为什么使用它们](https://blog.rohitjmathew.space/json-web-token-jwt-and-why-we-use-them)。

## 为什么不需要知道签名和验证实际上是如何工作的呢？🤔

现在，为什么大多数 JWT 资源只是简单地说“然后你签字并确认”然后就不管了呢？答案是抽象。

例如，当你驾驶一辆汽车时，你不需要知道发动机是如何工作的，也不需要亲自调整发动机以获得汽车的最佳性能。

相反，你相信制造商利用他们的专业知识，尽职尽责地制造出对你有用的东西。

同样，为了有效地使用 jwt 来认证和授权您的应用程序和 API，您不需要知道签署和验证 jwt 的确切过程。

请注意，虽然**您通常不应该亲自签名和验证令牌**，但是了解它的工作原理有助于让您更轻松地使用 jwt。但总的来说，身份提供者和身份即服务平台(如 Auth0、Okta 和微软 Active Directory)确保了这一过程的简单性。

所以如果你仍然好奇(像我一样)它是如何工作的，那么请继续读下去。

## JSON Web 令牌是由什么组成的？🤔

我将在本教程中更详细地介绍这一点[，但让我们快速回顾一下。](https://blog.rohitjmathew.space/json-web-token-jwt-and-why-we-use-them)

JSON Web 令牌由三个 URL 安全的字符串段组成，这些字符串段用句点(`.`)连接在一起:

### JWT 的标题段

第一段是报头段。它通常看起来像这样:

```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9
```

头段是一个 JSON 对象，包含签名算法和令牌类型。它是 base64Url 编码的。

解码后，它看起来像这样:

```
{
  "alg": "RS256",
  "typ": "JWT"
} 
```

### JWT 的有效载荷部分

第二段是有效载荷段:

```
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0
```

这是一个包含数据声明的 JSON 对象，它包含关于用户的信息和其他与身份验证相关的信息。

这是 JWT 从一个实体传递给另一个实体的信息。也是 base64Url 编码的。数据声明可能如下所示:

```
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
} 
```

### JWT 的加密/签名段

最后一段是加密/签名段。jwt 是经过签名的，因此在传输过程中不能被修改。当授权服务器发布令牌时，它使用密钥对其进行签名。

当客户端收到 ID 令牌时，客户端也使用密钥验证签名。

根据签名算法的不同，使用的密钥可能会有所不同。如果使用的是非对称签名算法，则使用不同的密钥进行签名和验证。在这种情况下，只有授权服务器能够签署令牌。

## JWT 的签名和验证是如何进行的？🤔

### 如何签署 JWT

对于本文，我将使用 RS256 签名算法。RS256 是以其发明者 Rivest、Shamir 和 Adleman 命名的 [RSA 算法](https://en.wikipedia.org/wiki/RSA_(cryptosystem))和 [SHA-256 散列算法](https://dev.to/wagslane/how-sha-2-works-step-by-step-sha-256-11ci)的组合。

RS256 是非对称密钥加密算法，它使用一对密钥:一个私钥和一个公钥来加密和解密数据。

这里，授权服务器将使用私钥生成签名，接收令牌的应用程序将使用公钥验证签名。

#### 签名输入

首先，我们取 JWT 的前两个部分(报头和有效载荷)。它看起来像这样:

```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0
```

这基本上是 base64Url 编码的头和负载，用一个`.`连接

```
base64UrlEncode(header) + "." 
+ base64UrlEncode(payload) 
```

而以上是签约输入。

#### 散列签名输入

然后，我们使用 SHA-256 哈希算法对签名输入进行哈希处理。

哈希将一个值转换为不同的值。哈希函数使用数学算法从现有值生成新值。

注意:

*   哈希是不可逆的。一旦我们散列了一个输入，我们就不能再回到原来的输入。
*   对于相同的输入，散列总是产生相同的输出。
*   没有两个不同的散列输入会产生相同的输出。

```
SHA-256 (
    base64UrlEncode(header) + "." 
    + base64UrlEncode(payload)
) 
```

此时，我们有了报头和有效载荷段的散列。我们可以将其与其他哈希进行比较，但我们不能将哈希返回到原始签名输入。

#### 加密签名输入

接下来，我们加密散列签名输入。

与哈希不同，加密是可逆的。授权服务器使用私有加密密钥对散列签名输入进行加密，以产生输出。

这个最终输出(散列的、加密的、编码的报头和有效载荷)是 JWT 的加密/签名段。

```
RSA (
    SHA-256 (
        base64UrlEncode(header) + "." 
        + base64UrlEncode(payload)
    ),
    {RSA Private Key}
) 
```

这就是了。JSON Web 令牌的签名就是这样生成的。

### 如何验证 JWT

现在您已经知道了令牌是如何被签名的，我们可以继续了解接收令牌的人如何验证这个 JWT 包含没有被篡改的数据。

让我们看一个收到 JWT 并需要验证它的应用程序。应用程序还可以访问授权服务器的公钥。

JWT 的验证是关于到达一个点，在这个点上我们可以有效地比较我们收到的和我们期望的。

#### 解码索赔

应用程序可以解码报头和有效载荷以获得一些信息。

请记住，这两个片段是 base64Url 编码的，以使它们是 Url 安全的。这些数据段没有任何加密安全可言。

你可以用一个简单的在线 base64 解码工具来完成。一旦它们被解码，我们可以很容易地读取其中的信息。

例如，我们可以对报头段进行解码，以查看 JWT 声称它是用什么算法签名的。

从解码后的报头中，我们可以看到:

```
{
  "alg": "RS256",
  "typ": "JWT"
} 
```

当我们读取 JWT 报头中的算法时，我们应该验证它是否与我们配置的预期相匹配。如果不匹配，我们应该直接拒绝令牌。

#### 散列(再次)

如果令牌中的算法符合我们对 RS256 的期望，我们知道我们需要生成报头和有效载荷段的 SHA-256 散列。

记住散列是不可逆的，但是相同的输入将总是产生相同的输出。因此，我们将散列连接的 base64Url 编码的头和有效载荷。现在我们有了在应用程序端新计算的签名输入散列。

#### [通信]解密

散列签名输入也在 JWT 的签名中，但它是由授权服务器用私钥加密的。应用程序可以访问公钥，因此我们可以解密签名。

一旦完成，我们就可以访问原始散列:在首次生成令牌时由授权服务器生成的散列。

#### 比较哈希

现在，我们可以将解密的哈希与计算的哈希进行比较。如果它们相同，那么我们已经验证了在授权服务器创建令牌和我们的应用程序收到令牌之间，JWT 报头和有效负载数据段中的数据没有被修改。

#### 验证令牌声明

此外，一旦我们验证了签名，我们就可以验证 JSON Web 令牌的数据。有效负载段中的声明也可以被验证，因为它们包含有关令牌颁发者、令牌过期、令牌的预期受众、将令牌绑定到授权请求的信息等信息。

这些声明为应用程序提供了有关令牌的详细信息，而签名验证本身并没有提供这些信息。

例如，对声明的检查可以揭示技术上有效的令牌实际上是为不同的应用程序或用户准备的，它已经过期，它来自与应用程序没有关联的发行者，等等。

## 结论

我们现在已经介绍了如何签署 JWT 和验证 JWT 签名。我希望这有助于您更好地理解 jwt 并与它们一起工作。我仍然想重申的是**你不应该自己签署和验证令牌**。

有像 [Auth0](https://auth0.com/) 、 [Okta](https://www.okta.com/) 、 [Ping Identity](https://www.pingidentity.com/en.html) 等身份平台为你做这一切。它们还为应用程序或 API 端的验证和令牌管理提供了 SDK 和库。

如果您对使用 Auth0 保护您的应用程序感兴趣，您需要一个 Auth0 帐户。如果你还没有，你可以[注册一个免费的](https://a0.to/signup-for-auth0)。

感谢阅读！我真的希望这篇文章对你有用。我总是有兴趣知道你的想法，并乐意回答你脑海中的任何问题。如果你认为这篇文章有用，请分享给其他人。

感谢阅读！:)

页（page 的缩写）请随时在 LinkedIn 或 T2 Twitter 上与我联系

## 附录

以下是帮助我写这篇文章的很好的材料:

*   [由](https://dev.to/kimmaida/signing-and-validating-json-web-tokens-jwt-for-everyone-25fb)[金迈达](https://twitter.com/KimMaida)为所有人签名并验证 JSON Web 令牌(JWT)
*   [JSON Web Token (JWT)签名算法概述](https://auth0.com/blog/json-web-token-signing-algorithms-overview/)由 Auth0