# 什么是二分搜索法？

> 原文：<https://www.freecodecamp.org/news/what-is-binary-search/>

二分搜索法是编程语言和程序中常用的算法。对于程序员来说，理解它是如何工作的是非常有用的。

我们刚刚在 freeCodeCamp.org YouTube 频道上发布了一个二分搜索法课程。您将学习如何在 C 和 C++中实现二分搜索法，但是这些概念适用于任何编程语言。

二分搜索法是一种查找目标值在排序数组中的位置的搜索算法。二分搜索法将目标值与数组的中间元素进行比较。

这个课程是由我的母校的 Harsha 和 Animesh 开发的。MyCodeSchool 是 YouTube 上最古老的软件频道之一。Animesh 目前是谷歌搜索团队的一名工程师。Harsha 是顶级编码器竞争编程平台上排名最高的印度程序员。

我的学校有一个鼓舞人心又悲伤的故事。你可以在昆西·拉森写的这篇文章中读到它。

以下是本课程涵盖的主题:

*   什么是二分搜索法？
*   实施和常见错误
*   递归实现
*   查找数字的第一次或最后一次出现
*   计算一个数字在有重复项的排序数组中的出现次数
*   排序后的数组旋转了多少次？
*   循环排序数组中的搜索元素

观看以下全部课程或在 freeCodeCamp.org YouTube 频道观看[(1.5 小时观看)。](https://youtu.be/KsoUiNv1SZA)

[https://www.youtube.com/embed/KsoUiNv1SZA?feature=oembed](https://www.youtube.com/embed/KsoUiNv1SZA?feature=oembed)

## 副本

(自动生成)

在这一课中，我们将讨论计算机科学中最著名和最基本的算法之一二分搜索法，我们发现二分搜索法在计算机科学中的大量问题中的大量应用。

但是在这里，让我们试着用最简单的形式来学习它。

为此，我们先定义一个问题，问题是给定一个整数的有序数组，有序数组意味着数组中的元素按升序或降序排列，就像在这个数组中，元素按升序排列，假设这个数组的名字是 a，这个数组的大小是 9。

所以我们有从 0 到 8 的索引。

现在给定这样一个数组和一个数字或者一个整数 x，我们想知道 x 是否存在于这个数组中。

而如果 x 存在于这个数组中，那么我们要找出 x 存在于这个数组中的位置。

举个例子，如果 x 为 1，它在数组中存在吗？是的，它甚至存在于数组中，它存在于索引 7 处，25 存在于数组中吗不，25 不存在于数组中，21 存在于数组中吗？是的，21 存在于数组中索引 3 的位置 3。

那么，用什么逻辑来找出 x 是否存在于这个数组中呢？一个最简单的方法是我们可以扫描整个数组来找出想要的数字。

所以我们从索引 0 开始，把这个元素和 x 比较。

如果它等于 x，那么我们就完成了搜索，我们已经找到了数组中的元素。

如果没有，我们去下一个元素。

我们继续与下一个元素进行比较，直到我们完成了数组，或者找到了数字。

假设我们想在这个数组中找到 63，那么我们的搜索会在我们教索引 6 的时候结束，我们从索引 0 开始，我们的搜索会在索引 6 结束。

如果我们想找到 25，我们的搜索将在索引 8 处结束，结论是 25 在数组中不存在。

无论数组是否排序，这种方法都将有效。

如果我必须为此编写代码，这将非常简单。

假设我想写一个方法 search，它采用一个数组 A，大小为 N，要搜索的元素是 x，代码是，我们将运行一个循环，从 0 开始，直到 N 减 1。

所以对于 I 从 0 开始到 n 减 1，如果索引 I 处的元素等于 x，那么我们返回 I 这意味着返回我们已经找到元素 x 的位置，我们的搜索就结束了。

如果我们找不到这样的 AI，那么我们返回-1，假设返回-1 意味着我们找不到在数组中找不到 x 的元素。

现在用这个算法，如果我们幸运的话，我们会在第一个位置找到 x。

所以在最好的情况下，我们将只进行一次比较，我们将能够在最坏的情况下找到结果，当 x 不在数组中时，我们将扫描整个数组，我们将对数组中的所有元素进行 n 次比较，然后我们将能够返回一个结果，即 x 不在数组中。

所以在最坏的情况下，花费的时间肯定与数组的输入大小成正比，对不起，是数组的大小。

或者换句话说，我们说这在时间复杂度上是大 O/n，在最坏的情况下分析算法的运行时间，找出所用时间的上限总是好的。

在这种情况下，时间是 n 的线性函数。

所以，我们也称这种搜索为线性搜索。

再一次，如果我们使用线性搜索，我们不使用任何属性，比如数组排序，不管它是否排序，这都可以。

现在，让我们尝试使用数组的额外属性来改进这个算法，它是排序的，我将首先在这里腾出一些空间。

假设我们想知道数组中是否存在 13 这个数字。

所以 x 是 13。

我们想知道 x 是否存在于数组中。

现在我们将使用不同的方法，而不是像线性搜索一样，将 x 与第一个元素进行比较，我们将它与数组中的中间元素进行比较。

这个数组的大小是 9，所以中间的元素在索引 4 处，这里有三种情况。

情况一可以是 x 等于中间元素。

如果 x 等于中间的元素，我们已经在数组中找到了 x。

情况二可以是 x 小于中间元素，情况三可以是 x 大于中间元素。

显然，如果 x 等于中间元素，我们的搜索就结束了。

因为我们已经在数组中找到了 x，如果 x 小于中间的元素，那么因为数组是排序的，所以它位于中间的元素之前。

我们可以丢弃中间元素、中间元素以及中间元素之后的所有元素。

类似地，如果 x 大于中间元素，则它位于中间元素之后。

所以我们可以丢弃中间元素之前的所有元素，当然也可以丢弃中间元素。

因此，在第二种和第三种情况下，我们从搜索空间中丢弃一半的元素，并缩小搜索空间。

所以在这个例子中，当 X 是 13 时，最初，我们的搜索空间是整个数组，X 可以存在于数组中的任何地方。

现在我们把它和中间的元素 36 进行比较。

现在 x 小于 36。

所以它存在，应该存在于 36 年前的某个地方。

所以我们也丢弃了 36 和 36 之后的所有元素。

现在问题被重新定义了，我们只需要在索引 0 到 3 之间搜索 x。

那么我们如何跟踪搜索空间，我们使用两个索引 start 和 end 来跟踪搜索空间。

所以最初，开始是零，n 是数组中的最后一个元素，在这个例子中，索引是 8，因为最初整个数组是我们的搜索空间。

我们也是按照开始加 n 来计算的。

现在，一旦我们找到缩小的搜索空间，我们就相应地调整开始和结束。

所以在这种情况下，在比较 13 和 36，并丢弃数组的一半后，我们的末端现在变成了索引 3，它只比中间的元素少 1。

现在，我们再次在这个缩小的搜索空间中找到中间元素。

所以这里中间的元素是 3 加 0 乘 2，如果我们只取整数部分，3 加 0 乘 2 就是 1.5。

如果我们取整数部分，中间的元素将再次变成指数 1，它等于 x 吗？没有 6 不等于 13 x 小于中间元素吗？是案例二吗？不，不是 x 大于中间元素。

所以这一次，我们放弃了中间的元素和它左边的所有元素，这一次我们开始标记新的搜索空间。

现在，新的搜索空间从索引 2 开始，到索引 3 结束。

现在，什么是中间元素三加二是五五乘二是二点五，整数部分是二。

这是我们的中间元素。

所以 x 不等于中间的柠檬，我们找到元素了。

所以我们的搜索结束了。

这种每次比较都将搜索空间减半的搜索称为二分搜索法。

我们又一次将搜索空间减少了两个，换句话说，我们将搜索空间减少了一半，因为数组是有序的，而有序的数组是二分搜索法的先决条件。

好，现在让我们为这个算法写代码。

我会写一个方法二分搜索法，我们把它作为参数，数组 A，它的大小 N 和一个要在数组中搜索的数 x，我会初始化两个变量，从 0 开始，到 N 减 1 结束。

所以开始和结束定义了我们的搜索空间，最初整个区域就是搜索空间。

现在，我将在这里写一个条件，当 start 小于或等于时，我将回到为什么我要写这个条件。

因此，虽然这是真的，但 start 小于或等于，我们将找出搜索空间的中间索引，即 start 加 end 加 2。

现在我们将编写三个案例。

如果中间元素等于 x，那么我们的搜索就结束了。

我们返回存储在变量 made 中的索引并退出函数。

如果 x 小于中间的元素，那么我们需要丢弃所有索引大于或等于的元素。

所以我们搜索空间的终点现在变成了中减一。

在第三个条件中，它将比中间的元素大 x，这将是这两个 if 和 else 之后的默认条件，如果我们需要丢弃所有 index 小于或等于 mid 的元素，那么，我们的 start 变成 mid 加 1。

如果我们没有返回任何东西就退出这个 while 循环，那么我们会返回-1，这意味着我们无法在数组中找到元素 x。

现在，为什么这个条件 start 小于或等于 end 的 wild 语句，我们在算法中基本上做的是通过调整 start 和 end 指针递归地减少我们的搜索空间。

现在，我们的递归必须有一个退出条件，退出条件可以是我们找到数组中的元素，然后返回并退出，或者当 start 等于 end 或 start 小于 E 时，我们用尽整个搜索空间，然后我们还有这样的空间，当 start 等于 n 时，我们的空间只有一个元素。

所以，当这个条件为假时，我们已经耗尽了我们的搜索空间，我们需要退出循环，我们需要返回-1，告诉我们元素 x 不存在于数组中。

现在，再次在这种情况下，在最好的情况下，我们可以在一次比较中找到元素 x，当第一个中间元素本身将是最坏情况下的元素 x 时，我们将继续缩小搜索空间，直到搜索空间变成一个元素。

所以，我们从 n 减少到 n，从 n 减少到 2，从 n 减少到 n，直到我们的搜索空间变成 1。

现在，需要几个步骤？让我们在这里做一些数学。

假设需要 k 个步骤才能通过 keep 在每个步骤除以 2 将 n 减为 1。

所以，n 除以 K 等于 1，如果你解出这个，那么 K 等于 n 的对数，基数是 2。

因此，在最坏的情况下，二分搜索法将进行 log n 比较，因此，在最坏的情况下，所用的时间也与登录成正比，换句话说，在时间复杂度方面，它是 log n 的大 O，log n 的大 O 比 o n 算法要高效得多。

这就是二分搜索法，在接下来的课程中，我们将讨论更多关于二分搜索法的问题。

感谢观看。

在上一课中，我们学习了二分搜索法作为一种高效算法，在有序集合的有序数据中查找或搜索元素。

在这一课中，在一些真实的代码中，我们将看到如何实现二分搜索法。

我们还将了解在实施二分搜索法时会出现哪些常见错误。

但在此之前，快速回顾一下，假设我们有一个排序的整数数组，类似这样，元素按升序排列，数组的大小是 6。

所以指数从 0 到 5。

现在，让我们说，我们想找出数字 10 是否存在于这个数组中，或者没有使用二分搜索法编程。

现在，在二分搜索法中，我们做的是用两个指针指向变量，最初指向数组中的第一个和最后一个元素，我们可以称它们为开始和结束指针，我们可以称这个变量为开始和结束，或者我们也可以称它为低和高，来标记较低的索引和较高的索引。

现在开始和结束这两个变量，在我们算法的任何阶段，给我们元素可能存在的范围。

所以在算法的开始，元素可能存在于数组中的任何地方。

这就是为什么 Start 和 End 指向第一个和最后一个元素。

现在我们用等式来计算中点，中点等于 2 的低加高，或者 2 的开始加结束，我们只取整数部分。

所以这里 5 加 0.2 就是 2.5。

取整数部分会给我们这个指数 2 作为中间指数。

所以我们在寻找 10 个数字 10。

最初，我们处于低指数为 0，高指数为 5，中等指数为 2 的状态。

现在我们看到，中间索引处的元素是所需的元素。

如果这是我们想要的元素，我们的搜索就结束了。

所以中间索引的元素是 6 等于 10。

不，不是的。

现在我们看看这个元素是大于目标元素还是小于目标元素，现在 6 小于目标元素 10。

所以我们丢弃 6 和 6 之前的所有元素，因为它们也小于 10。

我们把起点移到索引 3 处。

所以我们到了这个状态，较低的索引 3，较高的索引 5，现在我们只在数组的这一部分搜索我们的数字。

现在如果我们计算 mid，mid 等于四五加三加二，是不是等于目标元素 10？是的，它等于，所以我们找到了我们的元素，我们的搜索结束了，我们在索引 4 找到了 10。

好的，如果我们在数组中寻找数字 9，如果我们在这卷带子之前寻找 9，结果会是一样的。

在这一步，中间的元素是 10，我们将它与 9 进行比较，我也将在这里修改它，现在 10 大于 9。

因此，9 肯定只能存在于 10 之前，我们需要丢弃数组的这一部分，我们需要进入一种状态，其中我们的搜索空间由低等于 3 和高等于 3 定义，现在 3 既是低又是高，这个范围的中间元素也将只有 3。

现在，这个中间元素也不等于我们想要的数字 9 不等于 8。

现在，一旦我们的搜索空间中只有一个元素，而我们仍然没有找到我们想要的元素，我们的搜索就结束了，我们无法找到该元素。

让我们现在实现二分搜索法，我现在要写一个 C 程序。

好吧。

所以，我在这里要做的是，首先写一个名为二分搜索法的方法，它接受一个整数数组，假设数组的大小是 n，假设要搜索的元素是 x，这个方法返回一个整数，如果在数组中找到它，它将是 x 的 L 索引。

现在，我们将声明两个变量 low 和 high，并将它们初始化为 0 和 n 减 1，在任意点分别为 low 和 high，给我们 x 所在的线段。

所以，现在我们声明另一个变量 made，它是以 2 为基数计算的低加高。

现在，我们将 x 与索引处的元素进行比较，这里有三个条件，第一个条件是当 x 等于中间元素时，索引处的元素，在这种情况下，我们的搜索结束了，我们将简单地返回索引，当我们从我们的方法返回时，我们现在退出它，第二种情况可以是当 x 小于 a 时，因为 x 小于中间元素，它将位于索引之前。

现在，我们重新定义我们的段，通过将 end 移动到 mid，将较高的索引移动到 mid 减 1，应该是 f 好的，第三个也是最后一个条件将是这里的默认条件，当 x 大于中间的元素时，在这种情况下，我们将通过调整 start 来重新定义段，这是较低的索引，较低的索引将等于 mid 加 1。

现在，我们需要不断重复这三个步骤。

我们怎么做呢，我们肯定需要一个循环。

所以我们在这里放一个 while 循环。

现在，当我们停止执行这些步骤时，我们也可以在找到元素时停止。

所以，要么我们回来，要么我们看完所有的元素。

因此，我将在这里设置一个条件，当下限小于或等于上限时，当下限大于上限时，则由下限和上限定义的段将不是有效段，Melo 等于 hi，则段中只有一个元素。

如果我们退出这个 while 循环，没有返回任何东西，那么我们可以说元素 x 不在数组中，假设我们返回-1，表示 x 不在数组中。

这就是二分搜索法方法。

现在让我们来写 main 方法，并尝试使用这个函数。

在 main 方法中，我将首先声明并初始化一个数组，假设这个数组的名字是 a，我们将一些元素按排序顺序填充到这个数组中。

记住，被排序的数组是二分搜索法的先决条件。

这是一个大小为 8 的数组。

现在让我们要求用户输入一个我们将在数组中搜索的数字。

所以我们在这里写一个 printf 语句，现在让我们输入这个数字。

现在我将调用二分搜索法来搜索这个数是否存在于数组中，或者大小为 8 的数组中，我们想找出 x，我宁愿把它命名为 x，因为我们一直把目标元素命名为 x。

所以，如果从二分搜索法方法返回的 index 不等于-1，那么我们在 a 中找到了元素 x

因此，在这一阶段，我们将打印类似数字 x 在索引处，索引索引是变量名，否则我们将打印在数组中找不到 x。

现在让我们运行这个程序，看看会发生什么。

我们被要求输入一个数字，假设我们想在数组中搜索数字 15。

这表示编号 15 位于索引 6 处，让我们现在尝试搜索一个数组中不存在的编号。假设我们要搜索 18，但没有找到输出编号 18。在二分搜索法实现中会出现一些常见错误。应该正确重置这些索引的高低值，并且我们应该始终小心循环中的这种退出条件。

一个更常见的错误是，当人们现在不把这个括号放在这里时，这里会发生的情况是，除法运算符的优先级更高，首先会计算高 2，然后将它添加到低 so， 这个括号很重要，我们需要把这个括号放在这里，有些人也计算 mid，而不是计算低加高除以 2，我们有时也计算低加高减去低除以 2，这是一个更好的方法，因为有时低加高会超过一个整数可以存储的最大值。

因此，像 32 位整数或 32 位有符号整数可以存储最大值 2 的 31 次方。

现在，如果 low 和 high 都很高，那么 high 加 low 将超过 2 的 31 次方，并在我们的程序执行中引起问题。很明显，这个表达式只在 2 上计算 high 加 low。

唯一的区别是，我们通过在这个表达式中不计算高低来避免溢出。

好吧。

这就是二分搜索法的实现。

在这个实现中，我们使用了循环，所以我们写了一个迭代的实现，你也可以用递归来写二分搜索法，我建议你自己试试。

在接下来的课程中，我们将看到二分搜索法的更多变体及其在其他场景中的应用。

感谢收看。

在上一课中，我们学习了二分搜索法，我们也实现了二分搜索法，但我们实现了二分搜索法的迭代版本，其中我们使用循环来编写程序。

在这一课中，我们将使用递归来编写二分搜索法。

让我们先快速写一个二分搜索法的迭代版本。

所以，我会写一个方法二分搜索法，它会把一个大小为 n 的排序数组和一个要搜索的元素 x 作为参数，然后我们初始化两个变量 low 和 high low 到 0，high 到 n-1。

我们说，虽然低小于或等于高，计算中间指数为低加高二。

更好的做法是将 mid 计算为 2 的低加高减低，这是一样的，只是我们不是在计算低加高，有时低和高各自在整数变量的范围内，但高加低超出了整数变量的范围或限制。

现在有三个条件，如果 x 等于中间的元素，我们已经在数组中找到了 x，所以我们的搜索结束了，我们返回索引 make 并退出，否则如果 x 小于中间的元素，我们就从高到中减去 1，2，也就是说我们丢弃了所有在 make 之上或之后的元素，因为 x 小于中间的元素，它的排序就好像 x 大于 make 一样，这里应该是隐含的。

对于第三个条件。

作为这种情况下的第三个条件，我们说低为制造加一。

如果我们从这个 while 循环中没有发现任何东西，我们将返回-1，表示 x 不存在。

在数组中，我们要做的是，如果我们有一个数组，数组中的元素按升序排列，那么我们首先比较 x 和中间的元素。

而如果 x 等于中间元素，就没问题。

如果 x 小于中间元素，则它必须存在于该突出显示部分中的该元素之前，如果 x 大于中间元素，则它必须存在于该特定突出显示部分中的中间元素之后。

我们在新的片段中不断重复这个过程。

直到我们找到 x，或者我们不能在低或高的地方进一步划分搜索空间，我们的搜索空间变得或者更确切地说减小到只有一个元素。

之后，我们不能再分了。

二分搜索法是分而治之算法的一个典型例子，在这个算法中，每一步我们都把问题分成两半。

现在让我们写递归实现。

所以我会再一次写一个方法二分搜索法，它会接受一个排序后的数组 A，这次参数会有一点变化我们会接受两个参数，低的和高的，来标记数组的段，在任何阶段 x 都可能位于其中，x 是要搜索的元素。

逻辑是这样的，我们将再次计算中间指数。

然后我们会有三个条件。

如果我们找到 x，那很好，我们返回找到它的索引。

如果 x 小于 a，我们就在低位递归调用二分搜索法。

我这里空间不够了。

所以我会在这里创造一些空间。

我们将运行，我们将递归调用二分搜索法指数，从低到中减去 1。

所以现在要在索引从低到中减去 1 之间搜索 x，如果 x 大于中，这是第三个条件，我们会把二分搜索法从中加 1 返回到高，所以我们做一个递归调用，从索引加一个尾开始搜索彩蛋，当我们写递归时，我们应该总是寻找一个基本情况，一个我们会停止递归的基本情况，在这种情况下，如果我们找到了元素，我们就会停止递归。

这种情况会返回一个 exit，我们不会再做任何递归调用，但是如果我们找不到元素呢，如果我们在数组中找不到 x 呢，我们有另一个基本条件，我们需要退出，如果 low 大于 high，那么我们在数组中没有有效的段。

在这种情况下，我们可以说我们已经耗尽了我们的搜索空间。

所以我们返回-1，说 x 不存在于这里缺少空间的 am 中。

所以我把这两个语句写在同一行。

所以，这两个是我们的基本条件，会导致递归停止或退出，这个条件低大于高，和我们在这里检查停止循环的条件一样。

现在让我们用一个例子来快速模拟这种递归。

假设我们有一个大小为 9 的排序数组，我们想在这个数组中搜索数字 63。

所以我们调用函数二分搜索法，我在这里写 b，s，这是二分搜索法的一个快捷方式，好的，我们传递给函数，数组和较低的索引应该是 0，较高的索引应该可以说，最初这个数可以存在于数组中从索引 0 到 8 的任何地方，要搜索的数是 63，现在我们进入函数，低的大于高的，不

我们继续计算 mid，mid 的计算方法是，对于索引为 4 的元素，索引为 36，63 大于 36。

所以，我们到了这个 else 条件，第三个条件，我们做了一个递归调用，在范围 mid 加 1 是 5 到 8 的范围内搜索 63。

对于这个函数来说，低大于高再次不成立。

所以我们计算 mid，如果我们只取整数部分，索引 6 的元素是 63。

我们已经找到了这个元素，我们将返回 made，所以我们在这里返回 6，这个方法结束，这个方法也返回 6 到它的颜色，可能是主方法。

现在让我们说，我们要搜索数字 25，所以我们从主方法调用二分搜索法。

现在，我们再次计算索引 436 处的“现在制造”元素大于 25。

所以我们进行递归调用，从索引 0 到 3 搜索 25。

好的，现在是低大于高，是零大于三，不，我们继续计算，是索引 1 的一个元素，是 625，大于 6。

因此，我们进行递归调用，在索引 2 和 3 之间搜索 25，现在的结果是 2，这一次，我们将进行递归调用，在 3 到 3 的范围内查找 25，这仍然是一个有效的范围，下限不大于上限，中间值是 3。

现在 25 大于 21。

因此，我们使用第三个条件对 mid 进行递归调用，加上 1 将是 4，较低的 high 仍然是 3，这次 low 大于 high。

所以我们到了这个条件，这个方法简单地返回-1，然后结束。

这个方法也返回-1，并且一直向上传播。

最后，这个方法返回-1 到它的颜色，在写递归的时候，我们必须非常小心基本条件，就像我们这里有两个基本条件。

如果我们没有得到我们的基本条件，我们的递归可能会无休止地继续下去，导致程序的内存溢出，导致程序崩溃。

该算法的时间复杂度为 log n 的大 O 倍，所用时间与登录次数成正比。

这是因为如果我们在每一步都将数组的大小除以 2，那么我们将需要 log n 步才能达到数组大小等于 1。

一个显而易见的问题是，递归实现，递归实现，还是迭代实现，哪一个更好？我们可以用递归来写任何东西，我们可以用迭代来写，我们可以用迭代来写任何东西，我们可以用递归来写，迭代是一种更高效的方法。

它在性能上更好，因为我们不必在内存中存储所有这些函数的所有状态，这些额外的函数。

但是写递归有时候可能很直观，很好写。

出于最实际的原因，你可以根据自己的舒适程度选择其中任何一种。

所以这不是问题。

好，这是二分搜索法的递归实现。

感谢观看。

在上一课中，我们看到了二分搜索法的基本形式，我们解决了一个问题，如果我们有一个排序的整数数组，就像这样，如果我们想知道一个数是否存在于这个数组中。

假设我们想知道数字 10 是否存在于这个数组中，那么我们的算法会返回 10 存在于索引 3 处。

如果我们想搜索一个数组中不存在的数，那么我们的算法会返回我们要找的数不在数组中。

所以如果我们想在这个数组中搜索 11，那么我们的算法说数组中不存在 11。

好，现在，我要修改这个数组。

现在，这个数组仍然是有序的，但是唯一的区别是数组中出现了三次数字 10。

现在，假设我们想用二分搜索法搜索数字 10，那么 10 的索引是什么，我们可以返回索引 3。

或者我们也可以返回索引 4，我们之前看到的正常的二分搜索法实现，一旦在数组中找到任何一个数字，它就退出，所以不能保证我们会找到第一个或最后一个数字。

在这一课中，我们将看到二分搜索法的两种不同的变体，一种变体总是给出数组中第一个出现的数字。

另一种变化总是给出我们在数组中搜索的数字的最后一次出现。

好的，让我们先写我们之前写的基本实现。

我将快速编写一个方法二分搜索法，它有三个参数数组，大小为 N，以及要搜索 x 的元素

我们将把两个变量 low 和 high 初始化为 0 和 n-1，来标记 x 可能所在的数组段。

当低小于或等于高时，我们计算中间的指数为低加高二，然后我们比较 x 和中间的元素。

而如果 x 等于中间元素，那么我们已经找到了 exe，我们的搜索就结束了。

我们通过返回这个索引来退出这个方法。

所以我们一找到 x 的任何一次出现，就退出，不一定是第一次或最后一次出现，而是任何一次出现。

如果 x 小于 mid 元素，我们将 high 加上 mid 减 1，表示 x 现在可能位于 mid 元素和第三个默认条件之前。

当 x 大于中间元素时，在这种情况下，我们只有低到中间加一。

如果我们在 while 循环中没有找到 x，那么我们返回-1，表示我们在数组中找不到 x。

好，让我们来看看这个特定例子的模拟，这个算法的模拟，这个特定例子，我会在这里画三列，低，高，中。

假设要搜索的数字是 10。

所以 x 是 10，数组的大小是 6，所以，最初 low 是 0，所以数组的大小是 7。

所以，最初低是零，高是六。

现在，我们已经开始执行这个 while 循环，我们计算出 low 加上 high 是 2，所以 mid 是 3。

让我们也拖动 a 柱，这样看起来更好。

三是十。

那么 x 等于 A 造吗？是的，它是。

所以我们返回三，我们返回三。

我们会说这场比赛结束了，因为我们发现了一个伤病，我们立即返回，我们不在乎在指数 2 上还有另外 10 个。

现在，如果我们想找出，如果我们想找出数组中第一次出现的 10，我们不应该说 gameover，我们应该说，好的，我在索引 3 处找到了 110，让我向左看，在任何更低的索引处是否还有 10。

如果它在那里，我会返回那个。

所以我会在这里稍微修改一下这个算法。

开始的时候，假设我们有一个变量结果，把它初始化为-1。

我会回到为什么我把它初始化为负一。

我这里空间不够。

所以我在同一行用逗号写两个语句。

现在，当条件是 x 等于中间元素时，我们不是返回并退出函数的执行，而是将 result 修改为 x。

抱歉，我们修改了结果来制作 x 所在的索引，我们把高调整到中间减一。

再说一次，我这里空间不够，所以我在同一行写两个语句。

因此，如果 x 等于中间的元素，这两条语句将在这个条件下执行。

现在，我真正的意思是，如果我们在数组中找到了 x，那么我们已经在找到 x 的变量结果中存储了索引，然后我们修改我们的段，我们不停止我们的搜索，我们通过将 high 调整到 mid 来修改我们的搜索空间。

所以，我们继续寻找中间元素之前的 x。

所以，如果我们现在看到模拟，那么我们不会在这里停下来，我们做最高的两个，然后继续我们的搜索，现在 mid 将会是一个，mid 将会是，因为我还会写下任何状态下的结果值。

到目前为止，我们的结果是，到目前为止，我们在索引 3 处找到了 10 个。

所以，我们的结果是 3，现在对于这种情况，低 0 高 2 和中 1，我们将进入条件这一个，当 x 大于中间元素时，那么低变成中加 1，那么低变成太高了，现在也变成了中也变成了 10，现在我们到了这个条件，我们又回到了 x 等于线段的中间元素。

现在，我们将结果修改为新的索引，在该索引处将找到 x，因此结果现在将为 2，高值变为中值减 1，低值将为 1，低值为 2，现在，小于或等于高值的条件不成立。

所以我们在这里退出 y 循环，我的代码应该还有一处修改，我会在这里返回结果。

我们在这里看到，在索引 2 处找到了 10。

这样，我们找到了数组中第一个出现的元素 10，我们在这里返回结果，一旦我们完成了 while 循环，我们没有在循环中返回结果，结果最初是-1。

所以如果我们找不到任何 x，它永远不会被修改。

我们返回-1，表示在数组中找不到 x。

如果我们在数组中找到任何 x，我在这里引用括号来标记这两个语句为 if 条件执行，我们把索引存储在这个变量中，意思是说，到目前为止，这是我最左边的结果。

然后我们继续向左搜索，这意味着向较低的索引。

所以我们把 high 修改为 mid 减 1，如果我们找到另一个 x，那么这个 x 就在前面索引的左边。

所以我们放弃之前的结果，修改我们的结果。

所以，这是二分搜索法找出数组中出现的第一个元素。

如果我们想找出数组中的最后一个事件，那么只需要对这段代码做一点小小的修改。

当我们找到 x 时，我们不会像现在这样停止搜索。

我们继续向右朝更高的索引搜索，方法是修改我们的窗口窗口或段，或者通过将较低的索引调整到中间加一，通过将较低的索引调整到中间加一，这是我们需要做的唯一更改，以找出数组中的最后一个事件。

那么，让我们也快速地看一下这个实现的模拟。

所以，我们再一次从低 0 高 6 开始，我们也从结果减 1 开始，减 1 意味着我们到目前为止还没有在数组中找到 x，所以现在应该是 3，中间的元素应该是 10，我们在这里执行 while 循环，现在，我们到了这个条件 x 等于一个中间值，所以，首先我们修改我们的结果，我们在索引 3 处找到一个 x，然后我们修改低到中间加 1，这将是 4。

之前我们的窗口是整个数组。

现在，我们的供应商把它隔开，我们已经有了到目前为止发生的最正确的 10 个信息，好的，现在 mid 是 5，现在 mid 是 18，我们到了这个条件 x 小于 a，现在 high 变成 mid 减 1，我们有这个范围我们的窗口或搜索空间现在是这个，到目前为止我们在索引 3 找到了 110，现在 mid 是 5 加 4 除以 2，如果我们只取整数部分，那么 mid 就是 10。

我们又一次遇到了 x 等于 image 的情况，因此我们将结果修改为新的索引 4，并将下限修改为中值加 1，因此，下限变为 5，上限变为 5。

因此，到目前为止，我们找到的 10 的最高索引是 4，我们的搜索窗口现在只有索引 5。

所以，mid 也是 5，mid 也是 18。

现在 80 大于 10。

所以，我们会再一次回到这个特殊的情况。

所以低的还是五，高的现在变成四。

现在这不是一个有效的搜索空间，这不是一个有效的段低小于或等于高条件失败，所以我们将退出循环，退出 while 循环，我们的游戏结束了，我们应该返回结果中的所有内容。

我们可以说在索引 4 找到了 10。

这是二分搜索法，找出一个排序数组中最后出现的元素。

该算法的时间复杂度为 log n 的大 O。

或者换句话说，我们可以说，花费的时间，和 n 的对数成正比。

在接下来的课程中，我们将会看到二分搜索法的更多变化，我们将会看到应用二分搜索法的其他场景。

感谢收看。

在这节课中，我们将解决一个非常著名的编程面试问题。

问题是，给定一个整数的排序列表，我们想要找出一个特定的元素在这个列表中出现了多少次。

假设我们得到了一个数组形式的列表。

这里我们有一个大小为 12 的数组。

元素的顺序是递增的。

现在数字 5 在这个数组中出现了多少次，5 出现了 5 次，数字 2 在这个数组中出现了多少次，2 没有出现在这个数组中。

所以我们会得到一个这样排序的数组和一个数字 x。

我们必须找出这个数 x 在这个数组中出现了多少次。

现在我们想通过编程来解决这个问题。

因此，让我们想一想我们可能想要遵循的不同方法。

最简单的方法是我们可以扫描整个数组并计算 x 在数组中的出现次数。

所以如果我要写一个函数 find count，它会把数组，数组大小 N，和要搜索的元素 x 作为参数，来查找元素 x 的计数。

逻辑很简单，我们先取一个变量，假设这个变量的名字是 count，我们把它初始化为零。

然后我们运行一个循环，从 0 开始，直到 n-1。

如果 a I 或索引 I 处的元素等于元素 x，我们增加 count。

所以 count 变成 count 加 1，最后当我们从这个循环中出来时，我们返回 count。

所以我们执行线性搜索，扫描整个数组来搜索元素 x。

我们可以稍微优化一下这个算法，就像这样，因为一旦我们到达一个阶段，数组就会被排序，当 AI 大于 x 时，我们就可以停止计数了。

但还是在最坏的情况下，这个循环会运行 n 次。

当数组中的所有元素都相同时，这个循环将运行 n 次。

所以在最坏的情况下，这个算法，这个算法的运行时间和 n 成正比。

换句话说，时间复杂度是 n 的大 O。

对于这个问题，这是一个非常简单的解决方案。

如果你在编程面试中给出这个解决方案，面试官会说，我不喜欢这个，给我一个更好的。

那么，我们如何找到更好的解决方案呢？每当在一个问题中，我们被给予一个排序的数据或者一个排序的集合，我们应该试着考虑应用一个非常著名的算法，这个算法最好地利用了数据被排序的这个属性。

这个算法就是二分搜索法。

那么，在这个问题中，我们能不能利用二分搜索法，我们能做的一件事是，利用二分搜索法，我们能找出数字 x 在数组中的任何出现。

所以，在这个例子中，我们想知道数字 5 的计数。

假设我们用 log n 时间的二分搜索法发现，数字 5 存在于索引 6。

现在，因为数组已排序，所以所有出现的 5 将调整到这个值。

因此，我们可以从这个索引开始，向更高的索引前进，寻找所有的五个，然后我们可以向更低的索引前进，寻找所有出现的五个。

但是再一次，如果整个数组是 5，只有，所有的元素都是相同的，仍然是一个有序的数组，那么我们将扫描所有的元素，我们将访问数组中的所有元素，最终时间复杂度将是 N 的大 O，只有在最坏的情况下，花费的时间才会与 N 成正比。

所以，如果我们用二分搜索法的基本形式，用二分搜索法不会给我们带来太大的优势，因为要执行二分搜索法，我们需要用 log n 的时间。

然后为了找出 x 的所有相邻出现，我们将在最坏的情况下取 n 的大 O。

因此，对于较高的 n 值，log n 与相比可以忽略不计。

所以这最终是 n 的大 O，我们不会为这种方法写伪代码，我们会把它留给你做练习。

使用这两种方法，在最坏的情况下，我们仍然是大 O/n。

那我们该怎么办？如果你还记得我们之前关于二分搜索法的课，我们可以写一个二分搜索法，找出数组中第一个出现的元素。

类似地，我们可以写一个二分搜索法的变体来找出数组中最后一个出现的元素。

这是我们第三种方法的基础。

我会清理一些，腾出一些空间。

好的，我们可以用二分搜索法的一个变体，找出数组中一个元素的第一次出现。

我们可以用二分搜索法的另一种变体来找出最后一次出现的情况。

如果我们知道元素出现的最后一个和第一个索引，那么我们也知道它在数组中的个数。

因此，我们将再次编写一个方法 find count，它将接受一个大小为 N 的数组和元素 x。

假设我们使用 find first 方法找到数组中第一个出现的元素，这是二分搜索法的一种变体。

我们将使用另一个方法，调用二分搜索法的另一个变体，这将给出数组中元素的最后一次出现，然后我们可以返回 count 作为最后一个索引减第一个索引加 1。

这里我不处理元素不在数组中的情况。

假设我们会在实际实现中处理好它。

好的，如果我们使用二分搜索法，第一个方法调用将在 log n 的大 O 中工作，第二个方法调用查找最后一次出现也将在 login 的大 O 中工作。

所以总的来说，找出数组中一个元素的计数的时间复杂度是 log n 的大 O 倍。

这真的很棒。

我们已经描述了如何使用二分搜索法找出一个排序数组中的第一个或最后一个元素。

在上一课中，我们已经为算法编写了伪代码，在本课的描述中有一个到上一课的链接。

但是现在让我们去写一些真正的代码。

来解决这个问题。

我会写一个 C 程序。

让我们首先写一个简单的正常二分搜索法，然后我们将修改它找到第一个或最后一个出现。

假设我们有一个方法二分搜索法，它给我数组中元素 x 的索引。

在二分搜索法，我们首先定义两个指数低和高，两个变量低和高最初分别设置为零和 n-1。

然后我们找到中间元素和 as low 加上中间索引 as low 加上 high，然后我们比较中间元素和数字 x。

如果我们，如果中间元素等于 x，我们就找到了我们的元素。

所以我们简单地返回索引 mid else，如果 x 小于中间的元素，因为数组被排序了，记住数组被排序是二分搜索法的一个前提条件，我们设置 high 为 mid 减去一种说法，在中间元素左边的段中搜索。

如果 x 大于中间的元素，我们把它调低到中间加一。

我们一次又一次地重复这个过程，直到我们有了一个有效段，一个有效段，直到时间低小于或等于高。

如果我们从这个循环中出来却没有发现任何东西，那么我们返回-1，表示 x 在数组中不存在。

这个实现的问题是，一旦我们找到任何 x，我们就返回。

所以不能保证我们会找到第一个或者最后一个索引，如果在数组中 x 的副本中有重复的话。

所以我们要做的是，我们要做的是稍微修改一下算法，我们会有另一个变量，把它初始化为-1。

现在当我们找到 x 时，我们不返回 exit，我们更新结果变量，说，这是目前为止 x 的最低索引，然后我们继续搜索。

因此，如果我们想找出第一次出现，那么我们调整高到中间负一。

因此，我们更新结果并继续向较低索引较低段搜索。

最后，如果我们从这个循环中出来，那么我们返回结果。

所以如果我们找不到任何东西，任何 x 的出现，我们简单地返回-1，因为它被初始化为-1。

现在这个实现将给出 x 在数组中的第一次出现。

如果我们想要最后一次出现，唯一的区别是我们将继续向右边或更高的索引搜索，所以我们会说 low 等于 8 加 1，现在继续向更高的索引搜索。

现在我需要两个不同的函数来找出第一个或最后一个事件。

但是如果你看到这两个实现中只有一行有区别。

所以我要做的是，基于 flag 的另一个参数，使用相同的函数来检索第一个和最后一个索引。

假设我们有一个标志作为布尔参数。

先搜索，如果为真，我们要搜索第一个出现的，如果为假，我们要搜索最后一个出现的。

因此，如果我们想搜索第一次出现，那么我们想，在这种情况下，当一个 mid 等于 x 时，我们想把高调整到 mid 减一，否则我们想把低调整到 mid 加一。

好的，让我们知道写 main 方法。

我要做的是首先初始化一个数组。

我会让用户输入一个数字 x。

现在我们想知道 x 的计数。

所以我们将首先调用二分搜索法方法来找出数组中的第一个索引。

所以我们将传递数组，数组中元素的个数，是 12。

我们还将使用这个特定的等式来计算元素的数量，大小为 0，整个数组中的字节数，每个元素中的字节数。

我们想搜索 x，我们将传递 true，因为在我们的方法声明中，如果这个标志作为 true 传递，那么我们搜索第一个索引，否则我们搜索最后一个索引。

现在，如果第一个索引返回-1，那么元素不在数组中。

所以不需要找到最后一个索引，我们可以简单地打印计数为零。

否则，我们找出最后一个索引，这次我们调用同一个函数二分搜索法，唯一不同的是，这次我们将把标志作为 false 传递。

所以我们会说，嘿，给我最后一个索引。

我们将打印计数为最后一个索引减第一个索引加 1。

这是我们的代码。

这是我们的方法，二分搜索法。

我们两次调用二分搜索法来找出第一个和最后一个索引，我们用这个标志来决定第一个或最后一个索引。

现在让我们运行这段代码，看看会发生什么。

假设我们想知道数字 3 的计数，那么这给了我们数字 3 出现了两次，这是正确的。

现在让我们试试五号，数到五就是五。

假设 x 等于 2，2 不在数组中，那么计数将为零。

所以这是一个优化的算法来找出一个排序数组中的元素的数量。

这是二分搜索法的经典实现。

在接下来的课程中，我们将会看到更多关于二分搜索法的问题。

感谢收看。

在这节课中，我们将解决另一个编程面试问题。

问题是我们得到了一个已经旋转过的排序数组。

假设我们得到了一个包含这些元素的有序数组，数组的大小是 6，所以我们有从 0 到 5 的索引。

假设我们想逆时针旋转这个数组，向右旋转这个数组。

因此，每个元素都将向右移动一位，除了最后一个元素，它将移动到数组中的第一个位置，得到的数组将是这个，这个旋转一次，如果我们旋转数组两次，得到的数组将是这个，这个当然也旋转了两次。

这种数组通常也称为循环排序数组。

我们得到了这样一个循环排序的数组，还有一个条件，数组中没有重复，数组中的所有元素都是不同的。

所以给定这样一个数组，我们必须找出这个数组旋转了多少次。

那么我们如何解决这个问题呢？很明显，如果我们知道数组中排序序列的第一个元素或最小元素，那么我们就知道数组旋转了多少次。

对于这个问题，当我们说旋转了 30 次时，我们指的是逆时针方向的旋转或向右旋转，数组的旋转次数将是数组中最小元素或最小元素之前的元素数。

所以在这种情况下，只有一个元素在两个元素之前，这是最小值。

很明显这个数组旋转了一次，在最小元素之前有两个元素。

所以这个旋转了两次。

事实上，如果我们看到旋转数等于最小元素的指数。

所以我们的问题基本上是找出数组中的最小元素，数组中最小元素的索引。

我们结束了。

我们知道数组旋转了多少次。

那么我们如何找出最小元素的索引呢，最简单的方法是扫描整个数组，执行我们所说的线性搜索。

伪代码是这样的，我们有两个变量，一个存储最小元素，另一个存储最小索引。

假设最初，第一个元素是最小元素，然后我们运行一个从 1 到 n 减 1 的循环，其中 n 是数组的大小。

如果 if 索引处的元素小于最小值，则更新最小值和最小索引。

最后，当我们从这个循环中出来时，我们将清楚地知道最小元素的索引，这个算法的运行时间将是 n 的大 O，运行时间将与 n 成正比。

现在，这会给我们正确的答案，这是一个正确的解。

但是在这个方案中，我们没有利用数组循环排序的性质，我们能不能利用数组的这个性质来改进这个算法，提高这个算法的时间复杂度？让我想想。

现在，我们将利用数组是循环排序的性质，我们将使用二分搜索法算法的一个变体或修改来解决这个问题。

现在，我们在一个正常的二分搜索法算法中做什么？假设我们有一个这样排序的数组，我们首先找出数组中索引的中间元素。

然后我们看看这是不是我们要找的元素。

如果它不是我们要寻找的元素，我们要么向左搜索，要么向右搜索，这取决于我们要寻找的元素是大于还是小于中间的元素。

所以在每一步，我们把问题分成在一半数组中搜索一些东西。

在每一步，我们放弃一半的元素，我们放弃一半的搜索空间，我们继续前进，直到找到元素。

在这样的循环排序列表中，我们的问题是找出排序序列的第一个元素。

这个特殊的元素是循环排序数组中的枢纽或连接点。

所以现在我们将使用二分搜索法的一个变体来找出这个枢纽元素，它也是数组中的最小元素。

在二分搜索法中，我们主要做的是重新定义一个搜索空间或段，在该搜索空间或段中，我们想要的元素可能存在于两个变量 low 和 high 中，即较低索引和较高索引，并且在每一步中，我们要么找到一个元素，要么通过丢弃段中的一半元素并创建一个新段来将搜索空间减半。

现在，我们来看看新的部分，我们把每一步的问题分成两半。

现在，在这个问题中，对于每个段，我们将考虑几件事情，可能会有这样的情况，即较低索引处的较低元素小于或等于较高索引处的元素。

现在，只有当段已经排序了，段已经排序了，段中的最小元素，这就是我们在数组中找到的最小元素，如果我们能找到段中的最小元素，它也将是数组中的最小元素，这才有可能。

因此，我们将简单地返回索引低，因为数组已经排序。

因此，在较低索引处的元素是最小的。如果段没有被排序，我们计算中间索引。

现在，我们试着看看我们的中间指数是否是支点。

现在，如果我们以循环方式看到 pivot 元素的下一个和前一个元素，我们如何找到 pivot，如果你看到 pivot 或数组中的最小元素有一个特殊的属性。

因此，如果它是最后一个元素，下一个元素将是第一个元素，那么对于 pivot 元素，数组中的下一个和前一个元素都大于它，就像这里的 18 和 5 都大于 2。

除了 pivot 元素之外，数组中的其他元素都不具有此属性。

我们把这个属性定义为 pivot 属性。

所以，这里我们计算下一步，因为如果 mid 是数组中的最后一个索引，我们需要去第一个元素。

所以，模运算是这样做的，之前是 mid 减 1 模 n，我们也在这里加上 n，所以 mid 减 1 不会变成负数。

所以，我们的情况也是，一个 made 小于或等于下一个，它也小于或等于循环排序数组中循环数组的前一个元素。

如果是这种情况，我们再次拥有数组中的轴心或最小元素。

所以，我们将返回索引。

到目前为止，在这两种情况下，我们已经直接找到了我们的元素，我们没有感觉到需要划分数组，划分搜索空间段。

如果中间的元素不是主元，那么我们可以使用一个属性，我们可以说我们可以丢弃右半部分，或者我们可以丢弃左半部分，然后我们可以去其中的一个部分搜索主元元素。

是的，这样做是可能的，如果中间元素(在中间索引处的元素)小于或等于在高索引处的最高元素，那么从中间索引开始并向右延伸直到高索引的段，整个段被排序，并且中枢不能存在于右段中。

所以，在这种情况下，我们会说，我们需要在左半部分寻找支点。

因此，我们将 high 调整为 mid 减 1，情况四是当 mid 元素大于或等于最低索引的元素时。

在这种情况下，支点不可能在左边。

因此，我们将在右侧进行搜索，我们将向下调整到 mid。

所以，我们在每一步都不断缩小我们的分段，努力找出答案。

现在，让我们模拟这个方法，这个算法，这个特殊的例子。

所以，对于这个例子，第一种情况显然不是真的。

所以，我们找出中间的指标。

现在，中间索引的 pivot 属性不为真。

所以，我们看第三种情况，当我们看第三种情况时，我们基本上是在看这部分序列是否排序，是否包括 18 和所有向右的元素。

所以，18 不小于等于 8。

现在，我们寻找第四种情况。

当我们寻找第四种情况时，我们要检查这个完整的序列是否被排序。

嗯，这是排序。

事实上，如果数组没有排序，那么这两个序列中的一个将总是被排序。

你可以拿起一些例子，试着看看，这就是我们分而治之方法的基础。

这就是我们抛弃一半元素的基础。

所以现在我们需要调整低到中加一。

所以我们从搜索空间中丢弃了这些元素，不是从 2 开始的新搜索空间。

现在这个数组已经排序了。

案例一对于这个段位是真的，不好意思，这个段位是排序的。

所以我们简单地返回 2 的索引，也就是 0123，和 4，所以我们在这里返回 4，现在我们的搜索结束了，我们已经找到了 pivot 元素。

所以，我们知道数组旋转了四次，旋转的次数等于这个算法的 pivot 元素的索引，这个算法只有在数组中没有重复元素的情况下才有效。

这也是我们在问题中的初始条件，如果有重复项，搜索空间减半是不可能的。

现在让我们为这个算法写代码，看看它是否可行。

所以，我会写一个方法来寻找旋转计数，它会给我一个循环排序的数组 A 旋转了多少次，是数组中元素的数量。

所以，我们先定义下低和高。

然后，当我们的搜索空间有效时，我们首先查看片段是否已经排序。

如果它被排序，我们返回较低的索引。

这是我们的例子，另外一个例子，我们计算中值为 2 的低加高，然后我们也计算下一个和上一个相遇。

如果 make 满足 pivot 属性，我们返回 make。

否则，如果中间的元素小于或等于较高的元素，那么我们丢弃右半部分，并且我们将较高的索引调整为中间减去一，如果 a 大于或等于低，那么我们丢弃左半部分的前一半。

如果数组没有排序，这两个条件中的一个总是为真。

这些条件中只有一个是真的，而不是两个都是真的。

假设我们不能返回任何东西，如果我们不能在 while 循环中返回任何东西，那么我们返回-1，它将是-1，只有在无效的情况下才会返回，当数组没有循环排序时，它的属性不为真。

现在，在 main 方法中，我已经初始化了一个大小为 11 的数组。

我调用了这个函数寻找旋转次数。

我在试着打印计数。

让我们看看如果我运行这个程序会发生什么。

这上面说数组旋转了六次，好像是对的。

现在让我们修改这个数组。

让我们在元素已经排序的情况下运行这个测试用例。

好吧，这个看起来也不错。

所以我们没事了。

现在我用了四个案例来解决这个问题。

还有几种不同的其他实现方法，使用二分搜索法的基本思想是相同的。

但是我们可以用一些不同的条件来实现。

我鼓励你自己尝试一下，或者快速谷歌搜索代码片段。

这是一个使用二分搜索法求解的有趣问题，在接下来的课程中，我们会看到更多这样有趣的问题。

感谢观看。

第二课我们将解决另一个非常著名的编程面试问题。

问题是我们得到了一个循环排序的数组，这意味着一个排序的数组被旋转了。

在上一课中，我们还解决了一个问题，我们想找出循环排序数组的旋转数。

这是一个循环排序数组的例子，排序序列中的第一个元素在索引 4 处，然后我们向右移动。

最后一个元素之后，我们进入第一个元素。

这是排序序列的开始。

这是排序序列的结尾。

排序后的序列中的每个元素都向前移动了四个位置，数组逆时针或向右旋转了四次。

现在给定这样一个数组，我们必须找出这个数组中是否存在一个数 x。

那么我们如何解决这个问题呢？最简单的方法是执行线性搜索，扫描整个数组来寻找 x。

但是在这种方法中，我们不会利用数组循环排序的特性。

这种方法的时间复杂度是 n 的大 O 倍，其中 n 是数组中元素的数量。

那么我们还能做什么呢？每当我们有一个分类的数据，我们必须搜索的东西，我们应该总是认为二分搜索法广告作为一种可能的方法。

我们所知道的二分搜索法是在 log n 的大 O 中执行的

我们最多进行 log n 次比较来找出数组中的元素。

log n 的大 O 是解决方案的最佳时间复杂度。

所以让我们看看我们是否能以某种形式应用二分搜索法。

为了解决这个问题，让我们拿起这个循环排序的数组，我们在左边的例子，现在我们将使用二分搜索法的一个变体来找出数组中的元素 x，就像我们在正常的二分搜索法中所做的那样，我们将首先分别为数组中的第一个和最后一个元素定义两个索引 low 和 high。

然后我们找到了中间元素，在中间索引的下方加上上方。

到目前为止，逻辑是一样的。

现在，第一种情况是在中间索引 a 处的元素等于 x。

正如我们在普通二分搜索法中所做的那样，我们将比较中间的元素和我们要寻找的 x 的数字，如果它等于 x，我们的搜索就结束了，我们将返回 made，告诉 x 存在于索引 mid 处，如果 mid 不等于 x，那么如果该数组是一个普通的排序数组，那么我们将根据 x 是大于还是小于中间的元素而进入左半部分或右半部分。

但是在这种情况下，我们不能应用这种简单的逻辑来丢弃一半中的一个，但是有一个属性，我们可以探索它并丢弃一半的元素。

如果你看到，数组中的元素总是在增加，除了这个特殊的点，即连接点或支点，在这里我们有排序序列中的第一个元素或最小元素。

现在，如果我们选择任何线段或任何子数组，那么如果它不包含这个枢轴点，如果它不包含这两个元素，这两个元素形成了边界，断点，那么该线段中的所有元素都将被排序。

并且如果该段包含形成断点的这两个元素，那么该段将不会被排序。

现在，mid 元素将线段分成两半，这个断点或枢轴点将只位于其中的一半。

因此，这些一半中的至少一个将总是被排序，我们将利用这个属性，并且在二分搜索法的每次迭代中，我们将在搜索空间的一半处丢弃数组的一半。

我们的第二种情况是，如果一个 made 小于或等于一个 high，基本上我们会查看数组的这个特定部分，我们包括中间的元素，并查找延伸到最高元素的段。

如果这个条件为真，那么这整个段被排序。

在这个例子中，这个段没有被排序。

但是如果段被排序了，右边的段被排序了，那么会有两个条件假设这两个条件是到 A 和到 B，我们知道 x 不等于 A，但是如果 x 大于 A，并且 x 小于或等于 A，那么它肯定在排序后的一半。

因此，我们将下限调整到 mid 加 1，继续在右半部分搜索，如果不是这样，我们将有一个条件，当我们在未排序的半部分中在左半部分中搜索时，这将是这种情况，当数组的右半部分排序时，情况三将是当序列中的下限或第一个元素小于或等于中间元素小于或等于 mid 时。

现在，在这种情况下，我们将查看这个特定的段是否从低索引开始一直到中间索引排序。

现在，当我们知道这一半已排序时，我们将不得不再次对条件进行调整，这很容易验证 x 是否可能位于此段内或不在此子段内，如果 x 大于或等于 low 且 x 小于 a，则 x 不能等于 mid 元素，因为这样我们将不会到达情况 3，那么 x 可能位于此条件的左半部分。

因此，在这种情况下，我们将把高调整到中间减一，否则我们将通过把低调整到中间加一来搜索未排序的一半。

这就是我们对二分搜索法的分而治之策略。

让我们现在写代码，看看它是否工作，我将写一个循环数组搜索函数，它将在一个大小为 n 的数组中搜索一个数 x，如果在数组中找到它，它将返回 x 的索引。

就像我们在正常的二分搜索法中做的一样，我们将首先定义两个变量，低到零，高到 n-1。

当低小于或等于高时，当我们的搜索空间有效时，当我们的段有效时，有效的段段将具有至少一个元素当低等于高时，我们计算中间指数为低加高二。

现在，如果 x 等于中间的元素，那么我们已经找到了 x，我们返回索引中间的单元格，我们需要决定是去左半部分还是右半部分，是去搜索更高的索引还是更低的索引。

我们首先找出数组的哪一部分是搜索空间的哪一部分被排序了。

如果 made 小于或等于 high，即索引高的元素，则右半部分被排序。

右半部分已经排序，那么我们可以很容易地检查 x 是否有可能存在于排序后的这一半中。

因此，如果 x 大于中间的元素，并且 x 小于或等于索引高的元素，我们通过将 low 调整到 mid 加 1 来搜索右边排序的一半。

否则，我们知道元素不在右半部分，那么它肯定在左半部分。

所以我们将把 high 调整到 mid 减一，去左半部。

现在，右半部分已经排序了，我们知道，但是左半部分，它可以排序也可以不排序，这不重要。

对于某些特殊情况，当片段本身被排序时，左半部分也可以被排序。

但是不管怎样，利用这两个条件，我们丢弃一半，我们选择一个子段。

好，现在如果右半部分没有排序，那么左半部分肯定会排序。

所以要么我们把这个条件写成 A 大于或等于 A。

或者我应该写一个小于或等于 emit 的 low，就像我们之前写的那样。

这是第三种情况，即使我们不写这个条件，只写一个 else，我们也没问题，因为在这一点上，这都是真的。

所以现在左半部分排序了。

这样我们就可以知道 x 是否有可能位于左半部分。

如果 x 在低点和中点之间，小于或等于，大于或等于低点和小于中点，那么它很可能在这一半。

所以我们会把高调到中减一。

否则，如果 x 不太可能位于左半部分，那么我们通过将 low 调整到 mid 加 1 来向右搜索。

最后，如果我们从这个 while 循环中出来，没有找到 x，没有返回任何东西，我们返回-1，表示我们在数组中找不到 x。

现在让我们写 main 方法，我们将首先初始化一个数组，这是同一个数组。

这些元素与我们在整个示例中使用的相同。

现在让我们要求用户从控制台输入一个数字 x。

现在我们调用方法来搜索 x，数组的大小是 8。

所以我们将八作为第二个参数传递。

如果这个方法返回-1，我们会说我们找不到数组中的元素，数组中的数字。

如果不是-1，我们打印索引。

这是我们的 C 程序。

现在让我们运行它，看看会发生什么。

让我们在数组中搜索数字 8。

这似乎是正确的。

元素 8 在索引 6 处。

让我们再运行一次，在数组中搜索数字 12。

这也是正确的。

这似乎也适用于其他情况。

让我们修改这个数组。

假设我们想获得一个元素已经排序的数组。

我们再来拿起八个元素。

让我们搜索数组中的第四个元素，好的，这也很好。

所以我们似乎对所有的测试用例都很好。

事实上，我们并不适合所有的测试案例。

如果我们有一个重复的数组，像这样，这个数组仍然是循环排序的。

这是排序序列零中的第一个元素。

但是如果在循环排序的数组中有重复项，就不可能决定是左半部分排序还是右半部分排序。

利用上面我们用过的条件，利用这个条件。

因此，数组必须严格地以循环方式递增，并且所有元素都必须是不同的。

如果我们运行这个函数，假设我们要搜索一个数字 0，那么这个 0 在数组中没有找到，这是不正确的。

如果有重复，我们不能做得比 n 的大 O 更好，我们将不得不执行线性搜索只有当元素是不同的，我们可以执行二分搜索法。

好，这是在一个循环排序的数组中，用二分搜索法搜索一个元素，没有重复。

感谢观看。