# 简洁的代码并不总是干净的代码——原因如下

> 原文：<https://www.freecodecamp.org/news/concise-code-isnt-always-clean-code/>

作为开发人员，我们希望编写有效、可读、高效、简洁的代码，并且如果可能的话，可以重用。

当我们很多人想到干净的代码时，我们可能会陷入这样一个陷阱，认为代码越少越好。虽然这是常有的事，但也不总是如此。

如果我能以一种其他开发人员可以跟随我的方式完成工作，并立即(或至少容易地)理解我所做的事情，那就是我要做的事情。

## 那么，什么是干净的代码？

如今，你和我能比设备更有效地阅读代码要重要得多(在大多数情况下*)*。**

*当我写代码时，我的第一个目标总是完成工作。接下来，我写代码是为了人类的可读性，然后是运行时的复杂性，然后是简洁性。最后，如果可以的话，我会让代码易于重用。*

*如果为了满足复杂性/时间或可重用性的需求，我必须以一种人类不再容易阅读的方式编写代码，你可以肯定它将被很好地记录。*

## *我认为干净代码的一个例子*

*我最近接受了一项挑战，要在一组偶数中找出唯一的奇数，反之亦然。给了我一个整数数组作为输入，我不知道它包含的是奇数还是偶数。数组中肯定至少有 3 个值，其中只有一个是奇数/偶数。*

### *这是我的解决方案:*

```
*`func findOutlier(_ array: [Int]) -> Int {
  //since we're guaranteed to have 3 values, grab the first 3
  let parityArr = [
      array[0],
      array[1],
      array[2]
  ]
  //track any odd or even numbers found in parityArr || O(1) - (technically O(n) but we know the input won't grow)
  var odd = 0
  var even = 0
  for num in parityArr {
     //number is even
     if num % 2 == 0 {
         even += 1
     //number is odd
     } else {
         odd += 1
     } 
  }
  //track and test whether there were more odd or even numbers in the array
  var isEven = false
  if even > odd {
      isEven = true
  }  
  //return the first match that's an outlier based on the array containing more even or more odd numbers || O(n) - we don't know the input size 
  if isEven {
      return array.first(where: ({ $0 % 2 != 0 }))!
  } else {
      return array.first(where: ({ $0 % 2 == 0 }))!
  }
}`*
```

*如果你会注意到，我留下了包括运行时复杂性或算法扩展效率的笔记——即使如果你关心这类事情，这可能是非常明显的。我还记下了给定操作的输入大小(尽管这也很明显)。*

## *什么时候要简洁，什么时候要“写出来”*

*在某些情况下，简洁的代码可以减少编译时间、运行时执行时间或许多其他事情。尽管如此，我主要关心的是下一个开发人员是否能阅读它，容易地跟随它，并使用它。*

### *过于简洁怎么会影响可读性？*

*例如，在我的返回中，我可以将这一行`return array.first(where: ({ $0 % 2 != 0 }))!`变成一个 for 循环，在那里我返回第一个匹配。但是它会做完全相同的事情，因为它的命名方式，我认为它是可读的。*

*但是也许你不理解闭包语法，或者你的同事不理解。没关系，把它拼出来。我选择不这样做，因为这对我来说同样易读，但更简洁。*

*`return array.first(where: { ...`“写出来”是:*

```
*`for num in array {
    if num %2 !=0 {
        return num
    }
}`*
```

*有一些机会可以使这个例子中的代码更加简洁，并且对于大多数开发人员来说仍然是可读的。*

*因此，我也可以做这个积木:*

```
*`var isEven = false
if even > odd {
    isEven = true
}`*
```

*看起来更像这样:*

*`var isEven = even > odd`*

*上面提到的返回块可以用三元运算符做成一行检查，但是似乎有越来越多的开发人员不熟悉三元运算符。我认为 if/else 块在大多数情况下也更具可读性:*

```
*`if isEven {
    return array.first(where: ({ $0 % 2 != 0 }))!
} else {
    return array.first(where: ({ $0 % 2 == 0 }))!
}`*
```

*`return isEven ? array.first(where: {$0 %2 != 0}) : array.first(where: {$0 %2 == 0})`*

*就我个人而言，我只是觉得这两个简洁的单行语句有点不容易阅读——尤其是在涉及三元运算符的地方。*

*无论如何，我对我的解决方案非常满意——它通过了所有的单元测试，非常高效，并且易于阅读。但是当我看到别人的解决方案时，一开始我有点为自己的简陋感到羞愧…*

*他们中的许多人使用了过滤器，他们中的许多人使用了三元运算符。大多数都更简洁。*

### *过于简洁的例子*

*排名第一的答案是两行代码，我一开始很难读懂，但这些代码肯定能完成任务。在某些情况下，它可能比我的解决方案更有效，而且显然非常简洁:*

```
*`func findOutlier(_ array: [Int]) -> Int {
    let odd = array.filter{$0 % 2 != 0}
    return odd.count > 1 ? array.filter{$0 % 2 == 0}[0] : odd[0]
}`*
```

*这两个例子都满足了编写干净(或者真的，任何)代码的第一个标准——它们起作用了。它们都很简洁，尽管我的解决方案可以更简洁。乍一看，我认为更简洁的解决方案很棒。它优雅、高效，而且……简洁。*

*然后，我开始将回报分解成 if/else，并意识到我的解决方案在大多数情况下可能更有效。我只对整个数组迭代一次，并且只有当奇偶异常值是数组中的最后一个数时。*

*这仍然是一个很好的解决方案，但我不会说它*很棒*(或者像网站上很多人提到的那样——一个最佳实践)。*

*在简明解中的多数偶数阵列的情况下，它将被过滤两次。一次是创建名为 odd 的数组(也可以更好地命名)，这是被迭代的整个数组。如果它不是一个多数奇数组。*

*如果只有 3 个数字，这没什么大不了的。但是给定一个包含 10，000 个数字的数组，你会看到你的用户有一大段时间在等待计算一些不需要计算的东西。*

*关于我的解决方案与简洁解决方案的另一个需要注意的事情是，我的答案一在数组中找到就被返回。*

*假设输入数组是奇数，偶数是数组中的第一个数字。在我的解决方案中，它将被计算并立即返回，而在简洁的解决方案中，我们将在返回答案之前等待整个数组被过滤。*

### *关于可重用性的说明*

*我在前面提到了可重用性，但是我们并没有谈论太多。可重用的代码意味着你可以在不止一种情况下使用它。*

*这是编写干净代码的主要关注点之一，但只有当它适用时。我们可以通过在函数中使用参数来做到这一点，这些函数对于不同的用例是灵活的，并且其他事情也可以在其他地方使用我们的代码，而不需要任何或太多的修改。*

*但是编写可重用的代码怎么会影响可读性呢？
我本可以将整个函数通用化。它仍然符合标准，并使其更易于重用。例如，我们可以检查任何数字类型，但这不在这个项目的范围内，如果你不熟悉泛型语法，这样做会降低可读性。*

## *保持清洁可以避免陷阱*

*编写有点过于简洁的代码的一个缺陷是很难考虑到边缘情况。这是因为它使得很难一眼就看到“移动的棋子”。*

*我绝对不是说我的解决方案是完美的。我已经找到了一种方法，可以使它更有效(在某些情况下，我们可以跳过最后的 O(n)运算)，并且仍然保持可读性。*

*但关键是，我可以在近期或远期的任何时候回到这段代码，轻松地看到它是如何工作的，以及我如何能使它变得更好。*

*请记住，编写干净的代码需要做很多工作。干净并不是**只是**简洁的意思！编写您的代码，以便其他开发人员可以使用它——每个使用它的人都会感谢您。*