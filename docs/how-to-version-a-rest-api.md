# 如何对 REST API 进行版本控制

> 原文：<https://www.freecodecamp.org/news/how-to-version-a-rest-api/>

如果您不太熟悉 API，您可能会想知道...为什么对 API 版本如此大惊小怪？

如果你被 API 的变化搞得焦头烂额，你可能就是那个大惊小怪的人。如果你是一个 API 的维护者，你可能也会为尝试回答像下面这样的挑战性问题而烦恼:

```
# Is this version 2 of just products or of the entire API?
/v2/products

# What catalyzed the change between v1 and v2? How are they different?
/v1/products
/v2/products
```

这些关于版本的问题不容易回答。并不总是清楚`v1`或`v2`指的是什么。当第一个版本不再满足*需求时，我们不应该仅仅制造第二个版本的端点。*

有明确的理由*为什么*你的 API 需要版本控制，也有明确的策略*如何*有效地导航 API 变化。

然而，我发现大多数开发人员——包括我自己，直到我吸取了一些教训——都没有意识到这些原因和策略。

本文试图强调版本化的原因和实现它的策略。我们将假设一个 [REST](https://restfulapi.net/) API 上下文，因为它是许多 API 的标准，并将重点放在*版本控制*方面。

## 什么是版本控制？

我们应该从术语“API 版本控制”的含义开始。这是我们的工作定义:

> API 版本化是透明地管理 API 变更的实践。

版本控制是围绕 API 变化的有效沟通，因此消费者知道对它有什么期望。你以某种方式向公众传递数据，当你改变传递数据的方式时，你需要进行沟通。

归根结底，这是管理数据契约和打破变化。前者是 API 的主要构件，后者揭示了为什么需要版本控制。

### 数据契约

API 是应用编程**接口**，接口是交换信息的*共享*边界。数据契约是这个接口的核心。

> 数据契约是关于请求和/或响应数据的形式和一般内容的协议。

为了说明数据契约，下面是一个基本的 JSON 响应体:

```
{
  "data": [
    {
      "id": 1,
      "name": "Product 1"
    },
    {
      "id": 2,
      "name": "Product 2"
    }
  ]
}
```

它是一个具有`data`属性的对象，是一个产品数组(列表),每个产品都有一个`id`和`name`属性。但是`data`属性可以很容易地被称为`body`，每个产品的`id`属性可以是 GUID 而不是整数。如果返回一个产品，`data`可能是一个对象而不是一个数组。

这些看似细微的变化会导致关于数据“形状”的不同协议、不同合同。数据形状可以应用于属性名、数据类型，甚至是预期的格式(JSON vs. XML)。

## 为什么需要版本控制？

有了 API，像将属性名从`productId`改为`productID`这样简单的事情就可能会给消费者带来麻烦。上周我们队也发生了同样的事情。

谢天谢地，我们有测试来捕捉 API 契约的变化。然而，我们不应该需要那些测试，因为 API 的维护者应该知道这将是一个突破性的改变。

### 重大变化

这是对已达成一致的数据契约的重大改变，因为他们的改变迫使我们也改变我们的应用程序。

> 什么构成了 API 端点的“突破性变更”?对 API 合同的任何变更，迫使消费者也做出变更。

重大变更主要分为以下几类:

1.  更改请求/响应格式(例如，从 XML 到 JSON)
2.  更改属性名称(如从`name`更改为`productName`)或属性的数据类型(如从整数更改为浮点数)
3.  在请求中添加必填字段(例如，请求正文中新的必填标题或属性)
4.  删除响应的属性(例如，从产品中删除`description`)

### API 变更管理

强迫 API 的消费者做出改变是不明智的。如果您必须做出突破性的改变，这就是版本化的目的，我们将讨论对您的应用程序和端点进行版本化的最有效的方法。

但是首先让我们简单地讨论一下如何在第一时间避免破坏性的改变。我们可以称之为 API 变更管理。

API 环境中的有效变更管理可以概括为以下原则:

*   继续支持现有属性/端点
*   添加新的属性/端点，而不是更改现有的属性/端点
*   深思熟虑地淘汰过时的属性/端点

这里有一个例子，在请求用户数据的响应的上下文中演示了所有这三个原则:

```
{
  "data": {
    "id": 1,
    "name": "Carlos Ray Norris",     // original property
    "firstName": "Carlos",           // new property
    "lastName": "Norris",            // new property
    "alias": "Chuck",                // obsolete property
    "aliases": ["Chuck", "Walker"]   // new property
  },
  "meta": {
    "fieldNotes": [
      {
        "field": "alias",
        "note": "Sunsetting on [future date]. Please use aliases."
      }
    ]
  }
}
```

在这个例子中，`name`是一个原始属性。正在实现的`firstName`和`lastName`字段提供了一个更细粒度的选项，以防消费者希望显示“Mr. Norris ”,但不需要解析`name`字段。然而，`name`财产将得到持续的支持。

另一方面，`alias`将被弃用，取而代之的是`aliases`数组——因为 Chuck 有太多别名——并且在响应中有一个注释来指示日落时间框架。

## 你如何给一个 API 版本化？

这些原则将需要很长的时间来导航对 API 的更改，而不需要推出新版本。然而，有时这是可以避免的，如果您需要一个全新的数据契约，您将需要一个新版本的端点。所以你需要以某种方式向公众传达这一点。

作为题外话，请注意我们不是在谈论底层代码库的版本。因此，如果你正在为你的应用程序使用语义版本化,并且它也支持一个公共 API，你可能会想要分离那些版本化系统。

如何创建 API 的新版本？这样做有哪些不同的方法？你需要确定一般情况下你想采取什么样的*类型*版本控制策略，然后当你开发和维护你的 API 时，你需要确定每个版本变化的*范围*。

### 范围

让我们先解决范围问题。正如我们上面所探讨的，有时数据契约会被一个突破性的改变所损害，这意味着我们需要提供一个新版本的数据契约。这可能意味着一个端点的新版本，也可能意味着一个更全球化的应用范围的改变。

我们可以在一个树形类比中考虑范围变化的级别:

*   **叶** -与其他端点无关的孤立端点的变化
*   **分支** -一组端点或通过几个端点访问的资源的变化
*   **Trunk** -应用程序级别的变更，保证在大多数或所有端点上进行版本变更
*   **Root** -影响访问所有版本的所有 API 资源的变更

正如您所看到的，从叶到根，变化在范围上变得越来越有影响力和全球性。

*叶*范围通常可以通过有效的 API 变更管理来处理。如果没有，只需用新的资源数据契约创建一个新的端点。

一个*分支*稍微复杂一点，这取决于有多少端点受到所讨论的资源上的数据契约变化的影响。如果更改相对局限于一组明确的相关端点，您可以通过为资源引入一个新名称并相应地更新您的文档来导航。

```
# variants, which has a breaking change, is accessed on multiple routes
/variants
/products/:id/variants

# we introduce product-variants instead
/product-variants
/products/:id/product-variants
```

*主干*是指应用程序级别的变更，通常是以下类别之一的变更的结果:

*   格式(例如从 [XML](https://www.w3schools.com/xml/xml_whatis.asp) 到 [JSON](https://www.w3schools.com/js/js_json_intro.asp)
*   规范(例如，从内部规范到 [JSON API](https://www.freecodecamp.org/news/p/ccead735-3d4a-4304-b4e2-57b78ce59156/jsonapi.org) 或[开放 API](https://www.openapis.org/)
*   必需的报头(例如，用于认证/授权)

这将需要对您的整个 API 版本进行更改，因此您应该仔细计划并很好地执行转换。

一个*根*的改变将迫使你更进一步，确保你的 API 的所有版本的所有消费者都知道这个改变。

## API 版本控制的类型

当我们转向不同类型的 API 版本控制时，我们将希望使用这些对 API 变化范围的洞察来评估这些类型。每种方法在处理基于其范围的变更时都有自己的优点和缺点。

有几种方法可以管理 API 的版本。URI 路径版本控制是最常见的。

### URI 路径

```
http://www.example.com/api/v1/products
http://api.example.com/v1/products
```

这种策略包括将版本号放在 URI 的路径中，通常使用前缀“v”来实现。API 设计者通常用它来指代他们的应用程序版本(即“主干”)，而不是端点版本(即“叶子”或“分支”)，但这并不总是一个安全的假设。

URI 路径版本化意味着需要两种方法之一的应用程序版本的协调发布:在开发新版本的同时维护一个版本，或者迫使消费者等待新资源，直到新版本发布。这也意味着您需要将任何未更改的端点从一个版本延续到另一个版本。然而，对于易失性相对较低的 API，这仍然是一个不错的选择。

您可能不希望将您的版本号与端点或资源的版本号相关联，因为这很容易导致类似于`products`的`v4`而`variants`的`v1`的情况，这将非常令人困惑。

### 查询参数

```
http://www.example.com/api/products?version=1
```

这种类型的版本控制将查询参数添加到请求中，以指示版本。在“叶”级请求您想要的资源版本方面非常灵活，但是它没有总体 API 版本的概念，并且导致了上面关于 URI 路径的端点级版本控制的评论中提到的相同的不同步问题。

### 页眉

```
Accept: version=1.0
```

header 方法在提供任何给定资源的请求版本时提供了更多的粒度。

然而，它隐藏在请求对象中，不像 URI 路径选项那样透明。也很难判断`1.0`是指端点的版本还是 API 本身。

### 集成类型

这些方法中的每一种似乎都有弱点，要么支持“叶子”范围，要么支持“主干”范围，但不支持两者。

如果您需要维护整个 API 版本，并且还需要支持多个版本的资源，那么可以考虑混合使用 URI 路径和查询参数类型，或者使用更高级的头文件方法。

```
# URI path and query params combo
http://api.example.com/v1/products?version=1
http://api.example.com/v1/products?version=2

# Extended headers, for http://api.example.com/products
Accept: api-version=1; resource-version=1
Accept: api-version=1; resource-version=2
```

## 结论

我们已经讨论了很多内容，现在让我们回顾一下:

*   API 版本化是透明地管理 API 变更的实践。
*   管理一个 API 可以归结为定义和发展数据契约以及处理突发的变化。
*   在不破坏变更的情况下，改进 API 的最有效方法是遵循有效的 API 变更管理原则。
*   对于大多数 API，URI 路径中的版本控制是最直接的解决方案。
*   对于更复杂或更易变的 API，您可以通过集成 URI 路径和查询参数方法来管理变化的范围。

尽管这些原则应该为如何有效地管理 API 的变更提供明确的方向，但是发展 API 可能更像是一门艺术而不是科学。创建和维护一个可靠的 API 需要思考和远见。