# 回顾如何帮助我们前进:软件宝石和时尚回顾

> 原文：<https://www.freecodecamp.org/news/software-fads-and-gems/>

也许一个开发人员最重要的品质之一就是能够为正确的工作选择正确的工具，而不需要赶时髦或者重新发明轮子。这可能需要一点技术分析，但更多的是一点批判性思维。

以下是对计算机科学奇妙世界不同领域中一些被夸大的趋势和被低估的细节的回顾:**数据库、异步性、加密货币和数据格式**。我不会触及 REST webservices 这个话题，我已经[长篇大论地谈论过这个话题了](https://www.freecodecamp.org/news/rest-is-the-new-soap-97ff6c09896d/)。

像往常一样，如果这篇文章中有任何事实错误，我们非常欢迎你的反馈。

## 数据库:NoSQL 和 ZODB

在计算机科学的历史上，很少有时刻像 2009 年左右非 SQL 数据库的出现那样具有讽刺意味。一股浪潮冲击了后端开发和系统管理的海岸:SQL 数据库太死板、太慢、太难复制。

因此，新项目大量抛弃了它们，转而支持 Redis 这样的键值存储、MongoDB/CouchDB 这样的面向文档的数据库或 Neo4j 这样的面向图形的数据库。我们必须承认一件事:这些新数据库在基准测试中大放异彩；他们照得差不多了....任何 SQL 数据库都可以摆脱所有的 ACID 约束和查询语言的灵活性。

但是对于许多程序员来说，前景是暗淡的。他们艰难地认识到，数据持久性不是一个小问题。例如，他们需要明确激活 MongoDB 中的“写入问题”,以确保数据不会在到达磁盘氧化物之前丢失。

他们了解到“最终一致性”是“暂时不一致”的一个好词，为生产中讨厌的、无声的、难以复制的错误打开了大门。事务和它们的隐式锁定是珍贵的特性，手工模仿它们，把笨拙的标志塞进文档，几乎是简单而健壮的。

他们还了解到，数据模式和参照完整性非常受欢迎，可以防止数据库变成一堆不一致的对象。键值存储中缺乏高级索引功能(对多个键、深层文档字段)会变得非常尴尬。

因此，人们开始在 NoSQL 数据库的基础上重新发明 SQL 特性，在特定语言的“ORM”库中模仿数据模式、外键、高级聚合(mongoengine、mongoid、mongomapper...).在这种情况下，这个“对象关系映射器”的首字母缩略词本身就应该是某种疯狂的暗示。

观看 NoSQL 数据库有一种超现实的感觉，这些数据库是为特定用例(高度复制或异构数据、[上限大小集合](https://docs.mongodb.com/manual/core/capped-collections/)或 [TTLs](https://docs.mongodb.com/manual/tutorial/expire-data/) 、发布/订阅系统)而精心打造的...)，仅用于在单个服务器实例中存储一堆形状相同的对象。

一个标准的 SQL 数据库完全可以完成这项工作，并提供更多的工具选项和插件(不同的存储引擎、Percona 工具包脚本、HeidiSql 或 Mysql Workbench 等 ide、集成到 web 框架中的 DB 模式迁移流程...).即使这意味着将额外的非结构化数据填充到序列化的文本字段中(或者，现在，专用的 [PostgreSQL Json 字段](https://www.postgresql.org/docs/current/datatype-json.html))。

随着时间的推移，NoSQL 数据库本身也有了很大的改进，尤其是通过借鉴 SQL 世界的特性。但是重新发明 SQL 并不是一件容易的事情。关系数据库处理查询语言解析、字符集和排序规则、数据聚合和转换、事务和隔离级别、视图和查询缓存、触发器、嵌入式过程、 [GIS](http://wiki.gis.com/wiki/index.php/Geographic_information_system) 、细粒度权限、复制和集群...复杂而敏感的特性，由分布在多个级别(每个数据库、每个表、每个连接)的数百个设置驱动。

因此，尽管取得了巨大的进步(多文档事务、更好的数据聚合、存储的 JavaScript 函数、可插拔存储、MongoDB 中基于角色的访问控制)，NoSQL 数据库在挑战主要的 SQL 数据库方面仍然有困难，纯粹是功能方面的。

幸运的是，大多数项目只需要这些 SQL 数据库特性的很小一部分:一些模式验证、一些适当的索引，业务就可以运转起来；因此，对于缺乏 SQL 专业知识的团队来说，老实说，许多 NoSQL 数据库的相对简单性确实是一个相关因素。

现在浪潮似乎已经消退，项目似乎更倾向于根据实际需要组合不同的数据库。因此，它们将用户帐户、作业队列和类似的缓存、日志和统计数据分开...每个都放入最相关的存储器中。

所有这些引用的 NoSQL 数据库，以及它们无数的替代品，都在它们的预期用例中闪闪发光。但是我想提一下 Python 生态系统中一个鲜为人知、很少使用的瑰宝。你是否已经想用一种非常非常简单的方式来保存你的数据？然后我把你转发到 [ZODB](http://www.zodb.org/en/latest/) 。你像打开字典一样打开它，把你想要的任何数据放入其中，提交事务，你就可以开始了。

*简单的本地 ZODB 实例示例:*

```
from ZODB import FileStorage, DB
import transaction

storage = FileStorage.FileStorage('mydatabase.fs')
root = DB(storage).open().root()
print("ROOT:", root)
root['employees'] = ['Mary', 'Jo', 'Bob']
transaction.commit() 
```

数据图表得到了优雅的处理(没有递归错误)，对象在访问时被延迟加载，提供了特殊的“桶树”类型来浏览大量数据，同时保持低内存，并且存在几个存储后端，包括利用 SQL 数据库功能的 [relstorage](https://relstorage.readthedocs.io/en/latest/install.html) 。很完美，不是吗？

好吧，我在撒谎，有几个陷阱。没有内置的索引系统(必须使用 Zcatalog 或类似的系统)。强烈建议使用专用的“持久”类型来自动检测和持久化对象的突变。与主流数据库相比，整个工具相当有限。基于“乐观锁定”的并发模型可能会迫使您在高负载下多次重试操作，直到成功应用为止。

与 Python 语言的极度集成还有一个额外的缺点:如果您在数据模型中引入了破坏性的更改，您的数据库可能不再加载，因此您必须小心处理模式迁移。

但是上下文就是一切:ZODB 并不意味着长期和可互操作的数据持久性，而是用于轻松存储(可能非常异构)python 对象。它可以使长时间运行的脚本能够在中断后恢复，它可以存储在线游戏会话的玩家数据...如果您真的想在 ZODB 中存储博客文章或个人帐户，您最好将自己限制在原生 python 类型，并实现自己的健全性检查。但是不管发生什么，如果你能有一个漂亮的 ZODB 来存储你正在进行的数据，不要使用一个非常有限的 stdlib 库。

## 异步性:Asyncio、Trio 和绿色线程

在所有 IO 绑定的程序中，同步和异步编程模型之间存在着一个由来已久的挑战。内核为磁盘操作提供了异步模式，或多或少获得了成功(Windows 上的*重叠*非阻塞 IO，Linux 上的有限 *io_submit* () API)...).

网络代码使得这个问题更加尖锐，因为需要大量的长期连接，每个连接只执行少量的 CPU 操作。

一些语言，比如 Erland，从一开始就通过异步来解决这个问题，让不同的任务通过消息传递进行通信(也称为 [Actor Model](https://en.wikipedia.org/wiki/Actor_model) )。

在其他语言中，出现了几种设计模式来解决这个问题:

*   回收
*   异步/等待语法
*   轻质螺纹

回调以前是主流框架中的主要解决方案。例如，在 jQuery 或 Twisted 中，开发人员会以参数或实例方法的形式提供可调用程序，这些程序会在 IO 完成/取消时被调用，这种模式称为[控制反转](https://en.wikipedia.org/wiki/Inversion_of_control)。这当然是可行的，但是它使得程序流很难预测和调试，因此在这种情况下经常使用术语“回调汤”。

在过去的几年中， [async/await](https://docs.python.org/3/library/asyncio-task.html) 语法变得非常流行，尤其是在 Python 世界中。但有一个问题:像控制反转一样，这是一种全新的编程方式，几乎是一种新的语言。目前可用的大量由模块、类和方法组成的包都不能与 async/await 一起工作。

隐藏在从属关系深处的任何 IO、任何昂贵的操作都可能毁掉你的一天。因此，我们目前正注视着数以千计的伟大模块被愉快地重新实现，拥有一个充满错误和缺失功能的全新世界。

这一切值得吗？Python 开发者已经大规模地跳上了 asyncio 包的列车，它已经成为 stdlib 的一部分。但是这种技术有可怕的问题，比如套接字背压的困难、异常和 ctrl-C 的脆弱处理、不安全的任务取消(泄露),以及充满陷阱和冗余概念的 API 的陡峭学习曲线。像 Trio/Curio 这样的其他框架，在这些问题上似乎[更加小心。](https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/)

如果我们必须重新编码大量现有的库，为什么要将新版本建立在一些开发人员称之为糟糕设计的垃圾箱火灾的引擎上呢？但是在这种情况下，[网络效应](https://en.wikipedia.org/wiki/Network_effect)是巨大的，替代的基于 async/await 的框架将很难挑战这个标准。

那么上面引用的第三种模式，轻量级线程呢？早在这种 async/await 趋势之前，Python 开发人员就想:我们已经有了一些非常好的同步业务代码，所以让我们改变它的运行方式，而不是编写方式。因此出现了轻量级线程，或“greenlets”。它们就像一堆安排在几个本机线程上的小任务，这些任务只有在阻塞 IO 或显式阻塞 IO 时才会相互控制；并且在内存使用和切换延迟方面比本机线程具有更高的性能。

最终，该系统可以快速提升任何现有的代码库，从而支持数千个长期并发任务。这并不是一个孤立的 mad 实验:Python 轻量级线程最初用于 Eve 在线游戏(通过无堆栈 Python ),后来成功移植到 CPython (Gevent，Eventlet...)和 PyPy。实际上，它们已经在许多编程语言中存在了很长时间(T1 ),只是名字不同(绿色进程、绿色线程、纤程...).

这个系统的弊端？

*   库必须很好地处理绿色线程，在 IOs 上放弃控制而不是阻塞，启动绿色线程而不是本地线程。在 python 中，主库(socket、time.sleep()、threading)通过猴子补丁被强制变成绿色友好的；但是必须特别检查编译的扩展，因为它们可以绕过这些补丁并阻塞自己的系统调用。
*   不得执行繁重的计算或耗时的任务，否则所有其他任务都会受到延迟的影响。对于这样的需求，只需将工作委托给一个由[个本机线程](http://www.gevent.org/api/gevent.threadpool.html)组成的池(或者一个类似[芹菜](http://www.celeryproject.org/)的工作队列)。

正如我们所见，这些缺点类似于 async/await 的缺点，只是您几乎不必接触原始的同步代码。一个“例外”,这可能意味着几个月或几年的工作可以避免；你的首席技术官和首席执行官应该对此感到非常高兴。

现在，你有时会听到一些人奇怪的合理化建议，他们抛弃了轻量级线程，转而支持整个异步/等待重新实现。“ *Explicit 比 implicit 好，所有这些都向我展示了我的代码可以在哪里切换上下文，而如果第三方函数执行任何类型的 IO 或显式切换*，绿色线程可能会谨慎地切换。

但问题是...

首先，为什么你需要知道程序会在什么时候切换到另一个任务？在过去的几年里，使用本机(抢占式)线程，切换可以在任何地方、任何时间发生，甚至就在简单增量的中间。

但是我们学会了通过用锁和其他同步原语(递归锁、事件、条件、信号量)来保护关键部分，从而正确地处理这种看不见的威胁...)，在嵌套锁时保持适当的顺序，并使用线程安全的数据结构(队列之类的)为我们处理并发性。

绿色线程是介于(隐式)抢占式线程和(显式)异步/等待之间的中间地带，但是所有这些技术最好都坚持保护并发操作的老方法。

当锁被误用时可能是危险的(特别是因为大多数实现都停滞了，而不是检测死锁并报告它们为异常)，但是它们是廉价且健壮的。当您可以随时在精心制作的无锁序列中添加新操作(甚至是简单的日志输出),从而破坏其安全性时，通过检查每个潜在的开关触发调用的位置来尝试无锁并发有什么意义呢？

这段简单的代码展示了最近添加的对 log_counter_value()的调用是如何破坏一段原本安全的异步代码的。

```
 async def increment_counter(counter):
     current = counter.current_value
     await log_counter_value(current)  # Unwanted context switch happens here
     counter.current_value = current + 1 
```

第二，真的要处理同步吗？特别是在 web 世界，HTTP 请求不应该交互，我们希望并行化，而不是并发性。持久数据(和事务)应该由外部数据库和缓存处理，而不是在进程内存堆中。

因此，通常的线程安全良好实践(通过锁使用线程安全的进程初始化、全局数据的只读结构和只对堆栈帧本地的读写数据)足以使整个系统“线程/greenlet/asynctask 安全”。

如果有一天你需要在一个流程中实现高度并发的算法，你会为此选择最好的工具，但是如果你所要做的只是钉一颗钉子，就不需要建造工厂了。

## 货币:比特币和替代品

让我们思考一下。我们 21 世纪面临的最大挑战是什么？气候变化？逃税？国家权力的合法性？如此坦率的头脑会认为精力充沛的清醒、财务可追溯性和(真正的)民主组织将是追求的目标。

但一群聪明的黑客认为当前的货币是一个主要问题，并提出了比特币:耗能的“工作证明”系统，货币持有者容易匿名，以及模糊(至少)治理。

有了这样的需求和需求之间的平衡，难怪比特币会成为他们现在的样子:一个(几乎)纯粹投机的产物，受到[勒索软件](https://cointelegraph.com/news/research-suggests-russian-based-hackers-behind-ryuk-ransomwares-25-million-gains)和各种黑手党的称赞，由显卡工厂大量开采，对[被盗](https://cryptosec.info/exchange-hacks/)(或丢失)有着特别高的胃口。

这笔钱，以及它很快出现的兄弟姐妹，有一段已经充满了令人困惑的历史，有意外的连锁分裂，[软叉](https://en.bitcoin.it/wiki/Softfork)因[政治原因](https://en.bitcoin.it/wiki/Segregated_Witness)，[硬叉](https://en.wikipedia.org/wiki/List_of_bitcoin_forks)由各种各样的人相当随意地决定(或被[网络攻击](https://news.bitcoin.com/verge-is-forced-to-fork-after-suffering-a-51-attack/))以及不同货币之间无休止的战斗，或同一货币的不同版本(比特币核心、现金、黄金、SV...).算法(密码术、共识、交易代码...)被称赞为防弹和自治系统的基础，但一些参与者不得不[黑掉自己的用户](https://www.coindesk.com/crypto-developer-komodo-hacks-wallet-users-to-foil-13-million-hack)以保护他们免遭盗窃，而即使是如此美化的“智能合同”也显示出大量[可怕的安全弱点](https://blog.sigmaprime.io/solidity-security.html#)，并且[没有一些人预期的那么多用例](https://www.coindesk.com/three-smart-contract-misconceptions)。

让我们明确一点:区块链，一个基于 Merkle 树的公共账本，绝对不是一个坏主意。但是，当决策不是基于社会的需求和对错误的谨慎，而是基于意识形态和贪婪时，结果是可以预测的。炒作的减少与过度投资的希望成正比。

比特币、以太坊之类的“更好”的对应物是什么？存在许多替代的加密货币，授权形式更简单，加密算法不同，隐私设置不同，采用率也不同...但是如果你问我，我们真正需要的是"**一笔易于追踪的国家财政和非政府组织资金**"；这是一个公共账本，旨在让任何公民都可以轻松审计公共资金的使用情况，从通过税收和捐款筹集到通过支付商品或员工工资回到私人回路的那一刻。*有人知道这样的东西存在吗？找不到...*

人们也可以提到非加密的但是本地的货币。里昂的“ [Gonette](https://translate.google.com/translate?sl=fr&tl=en&u=http%3A%2F%2Fwww.lagonette.org%2F) ”)，与国家货币保持平价，这有利于当地企业，从而降低国际贸易的附带损害。

## 数据格式:文本和二进制

一位机智的路人曾将 XML 定义为“*二进制数据的可读性与文本的效率*”。事实上，与二进制数据加载器相比，XML 解析器往往很慢，而且会造成内存混乱(当处于 DOM 模式时);手动编辑 XML 配置和文档并不是最好的用户体验。

我们很容易理解为什么 XML 作为一种允许为各种用途创建新标签和属性的元语言，需要如此冗长。但是，当目标是使用定义良好的数据类型在服务器之间传输信息时，为什么对基于文本的格式如此热衷呢？

将 HTTP 有效负载解析为内部表示，然后解析(例如)它的 JSON 主体，最终会给 webservice 请求增加大量开销。为了什么利益？像 [Bson](http://bsonspec.org/) 这样的二进制格式会使序列化/反序列化更高效；语义上等价的文本格式可以用于调试(由 web 浏览器开发工具、Wireshark、CURL 等自动转换)，也可以用于手工制作测试负载。

当然，处理这些相同数据的双重表示会给系统增加一点复杂性，但是在一个创业公司喜欢向成千上万个并发客户端公开 web 服务的时代，性能提升是真实的，不需要太多努力。

## 结论

这一切的寓意是什么？总是一样的，“*用正确的工具做正确的工作，提防不合理的时尚*”。在一个人对一个特定的问题有足够的深度去做出明智的决定之前，可能需要大量的阅读；但是这项投资很快就有了回报。

猜测一个框架将在多大程度上被长期支持，或者哪种协议/格式将赢得标准化战争，是一个不同的问题，但至少当涉及到纯技术方面时，我们可以有坚定的观点，这是黄金。