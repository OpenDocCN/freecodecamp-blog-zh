# 用简单的现实类比解释硬编码概念

> 原文：<https://www.freecodecamp.org/news/hard-coding-concepts-explained-with-simple-real-life-analogies-280635e98e37/>

#### 如何向一个 5 岁的孩子解释像流、承诺、林挺和声明式编程这样的编码概念

我喜欢通过将编码概念与我们生活中熟悉的事物进行比较来思考它们。关于编码概念有很多相似之处。其中一些是好的，而另一些是令人困惑的，主要是因为他们专注于一个概念的部分方面，而忽略了许多其他方面。本文将总结一些我认为最适合一些完整编码概念的类比。

![1*_vKRQ66IBIliuqjqkQBLUQ](img/eeacee2740ade56fa318bdf8c6f8b365.png)

Warning: do not read this article on an empty stomach

> **更新:**这篇文章现在是我的书《职业程序员》的一部分。

> 阅读本内容更新版本，更多编程建议在[**【jscomplete.com/pro-programmer】**](https://jscomplete.com/g/coding-analogies)。

我将从简单的概念开始，然后转向较难的概念。先说编码本身。编码可以比作写烹饪食谱。这个比喻中的食谱是程序，厨师是计算机。菜谱是厨师遵循的一系列指令，程序是计算机执行的一系列指令。

这是一个非常简单的类比，因为一个食谱是用人类语言编写的，而一个程序是用计算机语言编写的，这两种语言非常不同(除非你的食谱有闭包和承诺！).食谱中也没有太多意想不到的事情需要计划，而计算机程序会有很多。尽管这很简单，但它是展示计算机如何按顺序执行一系列指令的好方法。它还显示了一条指令行可以在哪里使用执行前面指令行的任何结果。

有些食谱甚至会有 [if 语句](https://medium.com/@samerbuna/coding-tip-try-to-code-without-if-statements-d06799eed231) : if 烹饪 2 人、4 人或 8 人！有些食谱会有[循环](https://medium.com/@samerbuna/coding-tip-try-to-code-without-loops-18694cf06428):不断搅拌混合物，直到…

我也喜欢这个比喻，因为你可以在你的食谱中使用所有现成的物品和工具——比如你可以用来制作纸杯蛋糕的蛋糕混合料，以及使制作纸杯蛋糕更加容易的特殊形状的平底锅。

使用现成的项目和工具就像在自己的代码中包含和使用他人编写的代码包。

```
// The making of a cupcake// First steps:
```

```
$ npm install cake-mix$ npm install cupcake-pan
```

[](https://www.npmjs.com/)*是 [*Node.js*](https://nodejs.org/en/) 的包管理器，这是一个非常流行的用于编写 JavaScript 应用程序的*框架*。在这个类比中，Node.js 就像是厨房本身。它允许您通过使用内置模块(如烤箱和水槽)来执行食谱中的内容。*

*说到不健康的食物，下一个类比是为了学习如何编码，是和饮食习惯相比较的。我特别喜欢这个类比和它所传达的东西，因为它帮助我在代码学习的旅程中保持正轨。对我来说，这从高中就开始了，并将持续到我的大脑到达它的最后一个指令:die()；*

#### *学习编码*

*学习编码就像减肥一样。这个类比适用于学习任何东西，但是学习编码在这里是一个特殊的匹配。*

*“减肥”是一个负面的术语。我们应该称之为“获得健康”从这个意义上说，它非常类似于“获取知识”你可以利用的教育资源就像你的食物选择。有些还可以，有些很棒，有些对你完全不好。健康饮食和锻炼是帮助你获得健康的两个主要活动。同样，消耗好的教育资源和手工练习编码是帮助你获得好的编码知识的两个主要活动。*

*那么如何学习「健康」？当你承诺健康饮食时，你会使用像有机食品、T2 本地食品、T4 减脂食品、草食食品和非转基因食品这样的过滤器。健康教育资源也是如此，只不过这些标签还不那么清晰。我希望教育资源有一天也会有可验证的和相关的标签。也许像“非赞助”、“非营销”、“专家认可”、“严格编辑”和“龙在前方”这样的标签*

*然而，你可以很容易地根据好品牌进行过滤，而不是根据内容进行过滤。我对食物也是这样。我知道并信任一些品牌，并且我主要使用这些品牌。这更容易。有了教育资源，有一些品牌(出版物和人物)你应该一直关注。*

*将你的知识摄入过滤到只有好的资源后，你只需要运动！练习你所学的一切，但不仅仅是重复你所学的。也挑战自己，围绕你所学的主题做一些稍微不同的事情。运气好的话会被卡住！那么当你摆脱困境时，你会永久地学到其他东西。*

*锻炼对身体和大脑都有好处。*

#### *变量*

**计算机程序中使用变量来保存数据*。这是一个非常简单的说法，从很多方面来看都是错误的。*

*变量不保存数据。他们只是指着它。数据保存在计算机的内存中。您可以将变量与您在电子邮件消息(或注释或文件)上放置的标签进行比较。*

*本文中的所有代码示例都是用 JavaScript 编写的。 [JavaScript 是一种非常容易学习的计算机语言](https://medium.com/@samerbuna/lets-learn-coding-introduction-and-basics-65e31414a197)。*

*在 Gmail 中，标签是指向电子邮件或电子邮件列表的指针。许多标签可以指向同一个电子邮件。这类似于将另一个变量赋给现有变量:*

```
*`let work = [email1, email2, email3];let important = work;`*
```

*工作和重要现在都是指向完全相同的电子邮件列表的标签。*

*一些变量代表*常量引用*。它们不能被改变。这就像 Gmail 中的“*发送的*标签。虽然我们可以更改上面的工作标签，使其指向不同的电子邮件列表，但我们不能更改发送的标签。您不能将【T4 发送】标签指向不同的电子邮件列表。你只能让它指向更多的邮件。*

```
*`const sent = [];`*
```

```
*`// You cannot change the meaning of sent now// But you can add more values to it:`*
```

```
*`sent.push(new Email());`*
```

#### *错误和异常*

*一个程序员的专长很大程度上是关于如何处理错误。专业程序员喜欢错误，因为对他们来说，错误意味着进步。*

*有时我们期望看到这些美妙的红色信息，如果我们没有看到，我们知道代码是完全错误的！*

*我喜欢短语“*倾听*你的代码”，因为我认为代码通过使用错误与我们交流而进化。*

*这就像抚养孩子一样。*

*通过实践，我认识到最重要的育儿理念是孩子如何通过不当行为进行交流。这是因为他们还没有逻辑大脑。我认为程序做完全相同的事情。他们还通过行为不当(产生错误)进行交流，因为程序不是完全符合逻辑的。作为程序员，你的任务是在代码中添加更多的逻辑来处理最初产生错误的情况。这就像父母的任务是如何教导行为不端的孩子这种不良行为是错的，以及下次该如何做不同。*

*有些错误是不可恢复的，遇到这些错误的程序应该退出(并重新启动)。这就像如果你的心脏停止跳动。除了用电击重启之外，没有太多办法。这就是为什么我们监控我们的程序，并在它们达到那个状态时重启它们。幸运的是，重启程序的过程并不那么戏剧化。*

*在程序早期开发过程中发生的大多数错误有助于改进这些程序，使错误永远不会发生。好孩子就是这样被培养出来的。他们不会重复错误的行为，因为现在他们有良好的逻辑来引导他们向好的方向发展。*

*一些错误演变成例外。异常是预期的错误。我们可以计划和恢复的错误。这里最好的编码例子是当我们制作一个程序，例如，下载一些数据时的网络连接错误。这是意料之中的，因为我们知道网络连接可能不可靠，所以我们为这种错误做了准备。当错误发生时，让我们将下载数据的任务标记为未完成。将它放在某个地方排队，稍后再试(参见下面关于排队的类比)。*

*我们对这个计划异常所做的是，当错误发生时，给计算机一组不同的指令(不同的方法)去做。我们对我们的孩子也是这样。我们会给他们一些指示，告诉他们在我们预期的(或者在这种情况下是害怕的)某些未来场景中应该做什么。*

```
*`// Hey kidsif (stranger.offersYou(chocolate)) {  doNotAccept();  doNotTalkTo(stranger);  walkAway();}`*
```

```
*`if (stranger.triesToForceYouToDoSomething()) {  screamFor(help);  runAway();  call(911);}`*
```

#### *反应式编程和流*

*反应式编程是一种流行的基于*对变化*做出反应来编写代码的方法。它的灵感来自我们的日常生活，以及我们如何采取行动和与他人沟通。当进行日常生活活动时，我们尽可能地尝试多任务处理，但无论我们如何努力，大脑都无法多任务处理。我们人类能够同时处理多项任务的唯一方法是*切换任务*，并在他们的一生中有效地分割它们。当我们需要做的任务需要一定量的*等待*时，这就更有意义了，几乎总是这样。事实上，我们总是转换任务，即使我们没有意识到这一点。*

*反应式编程简单来说就是使用并依赖*事件*而不是代码中的行顺序来编程。通常，这涉及到不止一个事件，而且这些事件是按时间顺序发生的。我们称这一系列事件为“T2”流。*

*把事件想象成未来可能发生的任何事情。例如，你知道 Jane(一个商店老板)总是在 Twitter 上发布有趣的事情。每次她发微博，我们都称之为“事件”。如果你查看 Jane 的 Twitter feed，你会看到一系列随着时间推移而发生的“事件”(一系列事件)。反应式编程之所以如此命名，是因为我们要对那些事件做出“反应”。例如，假设您正在等待 Jane 在 tweet 上发布一条促销代码，介绍她店里卖的很酷的东西。你想对那条推文做出“反应”,用促销代码买最酷的东西。简单来说，这就是反应式编程的全部内容。*

*为了能够对事件做出反应，我们必须*监控*它。如果我们不跟踪事件，我们将永远不知道何时应对。在推特上，为了监控简推特的事件，我们跟踪简，并设置手机在她每次推特时通知我们。当她这样做的时候，我们会看一下这条微博，然后决定是否需要对此做出进一步的反应。*

*在反应式编程中，监控事件的过程被称为监听或*订阅*事件。事实上，这与订阅时事通讯非常相似。当你在网上订阅时事通讯时，你提供你的电子邮件地址。每次有新一期的时事通讯，您的电子邮件地址将被用作获取该期的途径。类似地，我们用函数订阅事件流。每次有新事件时，流将使用函数使我们的代码能够对事件做出反应。在这个类比中，简讯平台就是事件流。每期时事通讯都是一个事件，您的电子邮件是您用来订阅事件流的功能。*

*现在想象一个动态的时事通讯，它允许您选择主题，并且只向您发送与您的主题相匹配的新闻条目。你基本上是根据自己的喜好过滤时事通讯，这也是我们可以在事件流上做的事情。此外，假设您使用不同的电子邮件地址订阅了几份时事通讯。后来，您决定将所有时事通讯发送到一个新的电子邮件地址。你可以做的一件简单的事情是设置一个电子邮件规则，将任何时事通讯中的任何问题转发到新的电子邮件地址。您基本上是将多个时事通讯合并到一个电子邮件地址中，这是我们可以对事件流做的另一件事。*

*考虑事件流的另一种方式是将它们与常规数组进行比较。他们其实很像。数组是空间中的值序列，而事件流是时间上的值序列。在反应式编程中，我们可以在一个数组上进行的所有功能操作。过滤、减少、映射、组合、管道都可以在事件流上完成。我们可以过滤一个事件流，减少一个事件流的值，将一个事件流映射到另一个事件流，合并事件流，并将一个事件流作为另一个事件流的输入。随着时间的推移，这些选项都会产生新的价值流。*

#### *回访和承诺*

*想象一下，你要求某人给你一些需要时间准备的东西。他们记下你点的菜和你的名字，并告诉你等你点的菜好了就叫你。过了一会儿，他们叫你的名字，给你你想要的东西。*

*你最初给它们起的名字就是这里的*回调*函数。他们用被请求的对象调用它。*

*这就像你在星巴克点了一杯拿铁咖啡(在商店里，而不是在汽车餐厅)。他们同步记录你的订单和名字，然后你等待，直到你的名字被叫到。当这发生时，你会收到你的拿铁:*

```
*`starbucks.makeMeALatte({ type: 'Vanilla', size: 'Grande' }, Samer);`*
```

```
*`// "Samer" here is the callback function.// When the Latte is ready, the barista will call Samer // with the ready object// We define a function Samer to process the ready object`*
```

```
*`function Samer(readyLatte) {  // drink readyLatte}`*
```

*现在想象一下，你让某人给你一些东西，但是他们给了你一些别的东西。姑且称之为神秘物体吧。他们向你保证这个神秘的物体最终会变成你最初想要的东西。*

*这个有希望神秘物体可以变成两种可能的形式之一。一种形式与成功有关，另一种与失败有关。*

*这就像我们向一只鸡要一只小鸡，而小鸡给了我们一个鸡蛋。那个蛋可能会成功地变成小鸡，也可能会死去，变得毫无用处。*

```
*`const egg = chicken.makeChick();   // It's a promise!`*
```

```
*`egg.then(chick => raiseChick())    // Success outcome   .catch(badEgg => throwBadEgg()) // Fail outcome`*
```

#### *队列和堆栈*

*当我们处理数据元素时，有两种流行的数据结构来存储和使用这些元素:LIFO *栈*和 FIFO *队列*。*

*LIFO 代表*后进先出*，FIFO 代表*先进先出*。*

*数据堆栈最简单的类比就是水槽中的一堆脏盘子。当你用完一个盘子，你把它叠放在现有的脏盘子上，直到你准备好清洗它们。*

*当你准备洗它们的时候，你拿起你叠放的最后一个脏盘子，然后洗它。在计算机术语中，我们说你“弹出”了一个盘子。*

*你叠的最后一个盘子就是你洗的第一个盘子*。这是 LIFO。**

*数据队列最简单的类比就是在收银台或订餐站前排队的人群。当你准备好为你的杂货付款并带回家时，你可能需要排队直到轮到你。*

*第一个到达队列的人将是第一个完成队列的人。这是先进先出。*

#### *结对编程*

*当你去熟悉的地方时，你可以自己开车，但是当你第一次去很远的地方时，你就要使用 GPS 了。如果车里有其他人和你在一起，更好的选择是让他们给你指引下一个转弯的方向。如果你不按照指示做，结果转得不好，他们会立即让你知道，并建议你如何纠正。*

*当你开车的时候，身边有一个导航员就像有一对程序员。你不是一个人在开车。你们是一个目标一致的团队:安全到达目的地，没有任何问题，用最少的时间和精力。*

*你或许可以不用人工导航器或花哨的全球定位系统，用老派的方法，在出发前查看地图，自己完成这项工作。如果需要，您可以再次查看地图。如果你在开车的时候查看地图，你可能会不小心撞到路边或者在车上留下凹痕。如果你停下来查看地图，你会失去时间。没有配对导航器，你就不安全，而且/或者旅程会更长。*

*你的配对导航器的经验也可以教你新的东西。他们可能知道一条你不知道的新捷径，一条地图上没有的捷径。你从他们的相关经验中学习，这是非常宝贵的。*

*如果你需要去两个目的地，而你有两辆车。你可能会忍不住想，独自开车，并行到达目的地会更快。这在短期内可能会更快，但综合考虑，时间可能不是最重要的因素。就计算机程序而言，使用一辆车并确保它在两次旅程结束时都没有凹痕可能是一个重要得多的因素。这就是为什么我们喜欢结对编程。*

#### *林挺和任务自动化*

*如果你不得不一个人开车去长途旅行，你仍然可以依靠工具让你的旅程更安全。地图是一种工具。全球定位系统是更好的工具。巡航控制是另一个工具。*

*如果你在开车时做错了什么，自动警告你的工具类似于*林挺*编码工具。在 JavaScript 中，今天最好的林挺工具是 ESLint。它会警告你在编码时不应该做这么多错误的事情。最棒的是，它甚至可以在你运行你的程序之前就做到这一点。*

*在现代汽车中，当你驾驶时警告你的工具的例子正在发展。现在，当你意外穿越车道线时，或者当你试图转弯或改变车道而没有看到盲点中隐藏的汽车时，汽车可以向你发出警告。此外，当你超速行驶时，或者当你试图将车停在一个狭窄的地方时，它们会警告你。*

*林挺工具也在发展，以提供更准确、更有用的警告。ESlint 总是用非常准确的警告给我惊喜。此外，它的默认建议随着每次升级而变得越来越好。*

*我喜欢的现代汽车的另一个类比是自动化。一旦明确了目标和价值，你经常重复的任何任务都应该自动化。不要每次保存文件时都重新启动程序，而要有一个监控程序来自动执行。与其在与他人共享代码之前对代码运行格式化命令，不如让一个命令在每次将代码提交到源代码控制时自动执行格式化。*

*现代汽车也自动化了许多事情。这里明显的例子是自适应巡航控制，但其他微妙的例子包括自动挡风玻璃雨刷和夜间自动远光灯(我的最爱！).*

#### *命令式编程与声明式编程*

*当你需要做某件事时，总会有*什么*和*如何*的方面。到底需要做什么，我们怎么做。*

*命令式编程是关于*如何*的。声明式编程是关于*什么*的。*

**什么？怎么会？你为什么要在乎？**

*命令式方法代表一系列步骤。先做这个，再做那个，之后再做别的。例如:*一个接一个地检查一列数字，对每一个数字都加上一个累加值。**

*声明式方法代表了我们拥有的和我们需要的。例如:*我们有一个数字列表，我们需要这些数字的总和。命令式语言更接近今天的计算机，因为它们只知道如何执行指令。声明性语言更接近于我们思考和指挥的方式。请把它做完。不知何故！**

*好消息是计算机语言已经进化了。计算机语言提供了声明性的方法来执行必要的命令性计算机指令。就像汽车从手动挡发展到自动和自动驾驶一样！*

*命令式编程就像驾驶手动档汽车。你需要手动操作(踩下离合器，慢慢踩下，逐渐换挡，等等)。声明式编程就像驾驶一辆自动汽车——您只需指定“什么”:停车还是开车。*

*除非有工具支持，否则不能进行声明式编程。虽然你可以强制驾驶自动挡汽车(通过切换到手动模式)，但你不能强制驾驶手动挡汽车。如果你只有一辆手动挡汽车，命令式编程是你唯一显而易见的选择。除非你花时间安装一个自动换挡装置，从长远来看这是值得的。如果你买得起新车，你可能会选择自动档的，除非你是那种喜欢用汇编语言编程的书呆子！*

*[*汇编*](https://en.wikipedia.org/wiki/Assembly_language) *是原始的真正命令式的低级计算机语言，带有直接翻译成机器代码的纯指令。**

*注意命令式编程可能会产生更快的程序。此外，声明式编程需要您付出更少的努力。一般来说，维护它也需要更少的努力。编码不一定非要这样或那样。任何有价值的计算机程序都很可能两种方法都有一点。此外，知道如何以声明方式编码是很好的，但这并不意味着你不需要学习命令方式。你应该自信地使用两者。*

*使您能够进行声明式编程的工具发展成更好、更快的方式，让您到达目的地。现代汽车的终极宣告体验是自动驾驶。“是什么”成为目的地，汽车会做剩下的事情。这可能也是编程的未来。我们将拥有理解所有目标的程序，它们可以施展魔法来生成逻辑，让我们实现这些目标。*

*你最喜欢的比喻是什么？请在下面的回复部分告诉我。*

*感谢阅读！*