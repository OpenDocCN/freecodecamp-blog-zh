# 如何编写更少的 bug:给游戏开发者的提示

> 原文：<https://www.freecodecamp.org/news/how-to-write-fewer-bugs-tips-for-game-developers-82e3d742f6f7/>

### **前言**

我做过很多游戏。游戏开发的最后阶段通常是艰难的。可怕的危机，额外的修复错误和添加润色对所有参与者来说都是非常艰巨的。

如果你幸运的话，危机是由激情和实现集体愿景的愿望驱动的。如果你运气不好，那是因为过度的承诺和不可能的截止日期。在现实中，运气与此无关，但这是另一次讨论的话题。)

我们开发人员在谈论 bug 时使用的语言很能说明问题。通常类似于“QA 在我的代码中发现了一个 bug！”这意味着 bug 和代码是独立的实体，就像在你要吃的莴苣中发现一条毛虫一样。

当然，这远非事实——因为没有代码就没有臭虫。莴苣可以去掉留下毛虫，代码不能去掉留下臭虫。没有代码就没有臭虫。事实是没有错误，只有或多或少满足必要要求的代码。

当试图谈论创建更少错误的方法时，这种莫名其妙的语言可能是非常无益的，“你是什么意思，错误只是发生，调试是软件周期的一部分。”

根据我的经验，大多数游戏开发项目在整个项目中花费大量的资源来修复 bug，并在项目结束时进行大规模修复。这基本上是浪费时间和精力，如果这些工程师不修复错误，他们可以增加波兰和提高质量。

答案很清楚:少写 bug！

鉴于所有的 bug 都只是代码，那么任何 bug 都是开发团队添加的。也许你应该要求你的开发团队“少写 bug”？

如果你嘲笑这个建议，我并不感到惊讶。根据我的经验，这是工程师的典型反应:没有人会故意写 bug，对吗？然而，从项目的角度来看，这是一个完全合理的要求。想象一下，如果花在修复 bug 上的时间可以简单地从时间表中删除，那么质量会提高，加班时间会减少。

代码和 bug 的划分使它成为一个很难认真对待的请求。我们已经习惯了这种思维方式，这似乎是一个毫无意义的问题。那么，我们如何将“编写更少的 bug”变成一个合理的要求，让你的工程团队能够接受呢？

### 开始新项目。第一步，不要重复以前的错误。

我们的团队已经在几个 AAA 项目上合作过，我们刚刚结束驾驶俱乐部。我们都知道，我们不想在下一个项目的最后几个月里无所事事。现在是做点什么的时候了。我们想花时间打磨游戏，而不是修复错误。在开始一个新项目的时候，我们坐下来，研究编写更少 bug 的想法。

我们必须发展语言和推理能力，让团队对问题负责。必须明确目标是可以实现的，责任在于具体的个人。

第一步是定义“为什么”。我们有最重要的原因:减少修复错误的时间，花更多的时间来提高质量。每个人都可以少加班，但为什么我要让“你”来解决问题？

这不仅仅是浪费了更少的时间，而是你可以花更多的时间在有趣的事情上，让你早上起床。更多的 RnD，更多的优化，更多的游戏性，更多的视觉保真度，更多的卓越。这个愿景解释了为什么我们都是游戏开发者。花更多时间在酷的东西上。

即使有一个清晰的愿景，“编写更少的 bug”也是一个非常笼统的说法，实际上毫无用处。这是一份意向声明，但它没有给出任何我们可能如何做这样一件事的指示。更重要的是，如何将花在“编写更少的错误”上的时间转化为净收益。

将“编写更少的 bug”转化为工程团队可以采用的某种技术方向将会花费大量的时间和精力。在这一点上，很容易看到项目的截止日期，并决定保持现状。毕竟，错误是不可避免的，我们有一个项目要运送。

为了发现“如何”，我们遵循基本的科学方法:**观察、假设、测试、重复。**

### **观察结果**

#### **分类—法医分析**

打开你上一个完成的项目的 bug 数据库，看一看。有许多不同类型的 bug，所以仅仅说 bug 少本质上是没有意义的。

为了能够讨论这个问题，我们首先需要更好地定义细节。在这种情况下，我们对占用大量工程时间的 bug 特别感兴趣。我们分析了 bug 数据库，并确定了我们想要解决的两个重要群组:

*   花了很长时间修复的错误，以及
*   不断退化的臭虫。

bug 基本上有两个 KPI 值:“接受修复的天数”和“bug 状态转换的次数”。

需要长时间修复的错误通常是难以重现或诊断的错误。具有许多状态转换的 bug 经常在“无法恢复”或“修复/重新打开”循环中反复出现。

使用这些 KPI，我们确定了一个较小的 bug 集，这些 bug 占用了不成比例的大量工程时间。我们在这些队列中有一些假阳性，在下一步中被丢弃。我们终于解决了这个问题。

#### **分析**

确定了特定的 bug 组后，下一步是尝试确定共性和根本原因。这需要结合编程经验和对 bug 描述的解释。最重要的是，这需要时间和毅力。

我们在 bug 数据库和 SCM 之间进行了整合。这允许与源代码有一些直接的关联，尽管噪声比很高，并且仍然需要有经验的解释。

#### **根本原因**

最终，在足够长的时间后，一些模式确实出现了，我们可以看到一部分错误确实占用了大量的工程时间。鉴于这些错误，我们决心找到根本原因，找到源代码。

通过与工程师合作，我们找到了“修复变更”。然后，我们编制了更多与重要问题相关的系统、文件和代码行的列表。最终，我们与工程团队讨论了一系列具体的代码变更。

#### **早就告诉你了**

然后，我们能够与更广泛的工程团队坐下来讨论我们的发现(他们几乎肯定知道代码中的所有问题！！！).那么，如果团队已经知道代码中的问题，我们已经完成了什么？答案是非常重要的事情。

我们已经在“损失的开发时间”和“代码的特定区域”之间建立了一个映射。这给了我们一种客观地对任何被提议的重构和维护的价值进行排序的方法。

它还可以突出那些已经变得“可接受的糟糕”的代码区域。这是我们最大的惊喜。我发现自己在说‘我们显然需要重构这个系统’，而工程团队已经排除了这个可能性，因为它是一个‘太大的工作’或者‘T2’不可行。

事实上，许多根本原因问题都是系统性的。特别是，许多“看不见的”问题涉及到普遍接受的编程模式。这意味着解决这些问题需要挑战当前的编程趋势、时尚和咒语。

(最终，这些根本原因在代码架构中是如此系统化，以至于我们不得不从头开始。但这是另一篇博文的主题。)

最后，我们有了足够的观察来做一个假设，整个团队都参与了这个旅程。

### **假设**

> 假设 1 —从统计上看，特定的编程模式更有可能导致大型软件项目中的错误。

> 假设 2 —如果我们避免使用由(1)确定的编程模式，那么在整个项目中修复 bug 所花费的时间将会减少。

出于本文的目的，让我们将一个大型项目定义为 25 个以上的程序员和 12 个月以上的开发。一个足够大的项目，满足以下条件:

a)任何代码都将存在足够长的时间，以至于维护成本将超过开发成本。

b)系统之间的粘合所产生的复杂性大于任何单个系统的复杂性。

为什么这很重要？在小型软件项目中，你可以做任何事情，软件工程基本上无关紧要。密码都是你的了。

在大型项目中，代码不是你的。您将使用您不理解的代码工作，并将工程决策建立在不完善的知识和假设的基础上。现在，当我们与团队的其他成员交谈时，信息是非常不同的。

“在分析了我们之前的项目后，我们做出了以下假设……”

“数据显示，这些特定的编程模式是这些问题中的一个常见因素。我们相信避免这些模式将减少修复错误所花费的时间，并提高质量。”

接下来我们需要把假设变成有用的东西。

### **测试**

下一个项目的技术方向和系统架构的一个重要部分将基于避免已识别的高风险代码模式。

*   将内存分配生存期与对象构造和生存期耦合起来。
*   重载操作符和非规范化的命名约定。
*   ' auto '，多态函数和类型安全的移除。([https://medium . freecodecamp . org/why-the-compiler-is-your-best-friend-f 165329 cb20a](https://medium.freecodecamp.org/why-the-compiler-is-your-best-friend-f165329cb20a))
*   依赖注入、回调、lamdbas，
*   在高级代码中使用互斥、信号量和其他线程原语。

关于它如何改变我们的系统和 API 设计方法，每一点都值得进行技术讨论。由于这次技术讨论的受众略有不同，我将在单独的技术后续文章中讨论这些问题。

#### 接下来发生了什么？

正如我上面提到的，我们非常幸运，有机会用新的方法开始一个新的游戏。我们能够在 24 个月内从零开始构建一个新的游戏引擎，并通过一个小型编程团队按时交付游戏。尽管在我们达到相对较少的错误和很少的高成本错误的高水平之前，代码从未发布过。QA 部门独立证实了这一点，他们记录了游戏在 QA 过程中的轻松时光。

要求团队避免上述模式是不够的。编码指南很容易被忘记，团队可能很快又回到了旧习惯。一个关键的决定是设计代码、系统和接口，使得上述模式不能被使用。这很快发展成一句口头禅“让做错事变得困难”,指导团队完成整个项目。

重要的是，团队更开心了。我们已经定义了一种方法，可以在第一时间产生更多的代码。团队知道使用系统的简单明了的方法可能是正确的，API 可以防止不良模式。bug 更少了，花在特性、修饰和迭代上的时间更多了。

### 延伸阅读。

您可以查看这些带注释的幻灯片，其中包含了从编写更少的 bug 方法中得出的特定技术方向。

[https://www . slide share . net/richardtaylor 172/c-游戏编程限制](https://www.slideshare.net/RichardTaylor172/c-restrictions-for-game-programming)

![PEiGLDLWyj93R8M4ot-OpdUjsmbjxjTwmD1o](img/aa89e5420f6555b2f3fb0829394fbcb6.png)